
class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    proxyAuthorModel->setColumnToFilter(0);
    proxyAuthorModel->setColumnToFilter(1);
    ui->tblAuthors->setModel(proxyAuthorModel);
    ui->tblAuthors->setRootIsDecorated(false);
    ui->pte_Authors->clear();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    proxyAuthorModel->setColumnToFilter(0);
    proxyAuthorModel->setColumnToFilter(1);
    ui->tblAuthors->setModel(proxyAuthorModel);
    ui->tblAuthors->setRootIsDecorated(false);
    ui->pte_Authors->clear();
}
void Singleton::f2();{
    }
    return QDialog::event(event);
void AboutDialog::showEvent(QShowEvent * event)
    int one_em = fontMetrics().height();
    // Authors: Names slightly narrower than emails.
}
void Singleton::f3();{
        showInFolderAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
        connect(showInFolderAction, SIGNAL(triggered()), this, SLOT(showInFolderActionTriggered()));
    }
    QAction * copyColumnAction = menu->addAction(tr("Copy"));
    copyColumnAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
}
void Singleton::f4();{
    UrlLinkDelegate *plugin_delegate = new UrlLinkDelegate(this);
    script_pattern = QString("\\.(lua|py)$");
    plugin_delegate->setColCheck(3, script_pattern);
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
}
void Singleton::f5();{
    return QStringList() << tr("Shortcut") << tr("Name") << tr("Description");
FolderListModel::FolderListModel(QObject * parent):
        AStringListListModel(parent)
    /* "file open" */
    appendRow(QStringList() << tr("\"File\" dialogs") << get_last_open_dir() << tr("capture files"));
}
void Singleton::f6();{
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
    ui->tblPlugins->setContextMenuPolicy(Qt::CustomContextMenu);
    ui->tblPlugins->setTextElideMode(Qt::ElideMiddle);
    connect(ui->tblPlugins, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(handleCopyMenu(QPoint)));
}
void Singleton::f7();{
    AStringListListSortFilterProxyModel * pluginTypeModel = new AStringListListSortFilterProxyModel(this);
    pluginTypeModel->setSourceModel(pluginFilterModel);
    pluginTypeModel->setColumnToFilter(2);
    ui->tblPlugins->setModel(pluginTypeModel);
    ui->tblPlugins->setRootIsDecorated(false);
}
void Singleton::f8();{
    appendRow(QStringList() << tr("Global Plugins") << get_plugins_dir_with_version() << tr("binary plugins"));
    /* pers plugins */
    appendRow(QStringList() << tr("Personal Lua Plugins") << get_plugins_pers_dir() << tr("lua scripts"));
    /* global plugins */
    appendRow(QStringList() << tr("Global Lua Plugins") << get_plugins_dir() << tr("lua scripts"));
}
void Singleton::f9();{
    {
        QString cf_path = tree->model()->index(index.row(), 3).data().toString();
        desktop_show_in_folder(cf_path);
    }
void AboutDialog::copyRowActionTriggered()
}
void Singleton::f10();{
    setAttribute(Qt::WA_DeleteOnClose, true);
    QFile f_license;
    AuthorListModel * authorModel = new AuthorListModel(this);
    AStringListListSortFilterProxyModel * proxyAuthorModel = new AStringListListSortFilterProxyModel(this);
    proxyAuthorModel->setSourceModel(authorModel);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    proxyAuthorModel->setColumnToFilter(0);
    proxyAuthorModel->setColumnToFilter(1);
    ui->tblAuthors->setModel(proxyAuthorModel);
    ui->tblAuthors->setRootIsDecorated(false);
    ui->pte_Authors->clear();
}
void Singleton::f2();{
    }
    return QDialog::event(event);
void AboutDialog::showEvent(QShowEvent * event)
    int one_em = fontMetrics().height();
    // Authors: Names slightly narrower than emails.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    proxyAuthorModel->setColumnToFilter(0);
    proxyAuthorModel->setColumnToFilter(1);
    ui->tblAuthors->setModel(proxyAuthorModel);
    ui->tblAuthors->setRootIsDecorated(false);
    ui->pte_Authors->clear();
}
void Singleton::f2();{
    }
    return QDialog::event(event);
void AboutDialog::showEvent(QShowEvent * event)
    int one_em = fontMetrics().height();
    // Authors: Names slightly narrower than emails.
}
void Singleton::f3();{
        showInFolderAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
        connect(showInFolderAction, SIGNAL(triggered()), this, SLOT(showInFolderActionTriggered()));
    }
    QAction * copyColumnAction = menu->addAction(tr("Copy"));
    copyColumnAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    proxyAuthorModel->setColumnToFilter(0);
    proxyAuthorModel->setColumnToFilter(1);
    ui->tblAuthors->setModel(proxyAuthorModel);
    ui->tblAuthors->setRootIsDecorated(false);
    ui->pte_Authors->clear();
}
void Singleton::f2();{
    }
    return QDialog::event(event);
void AboutDialog::showEvent(QShowEvent * event)
    int one_em = fontMetrics().height();
    // Authors: Names slightly narrower than emails.
}
void Singleton::f3();{
        showInFolderAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
        connect(showInFolderAction, SIGNAL(triggered()), this, SLOT(showInFolderActionTriggered()));
    }
    QAction * copyColumnAction = menu->addAction(tr("Copy"));
    copyColumnAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
}
void Singleton::f4();{
    UrlLinkDelegate *plugin_delegate = new UrlLinkDelegate(this);
    script_pattern = QString("\\.(lua|py)$");
    plugin_delegate->setColCheck(3, script_pattern);
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    proxyAuthorModel->setColumnToFilter(0);
    proxyAuthorModel->setColumnToFilter(1);
    ui->tblAuthors->setModel(proxyAuthorModel);
    ui->tblAuthors->setRootIsDecorated(false);
    ui->pte_Authors->clear();
}
void Singleton::f2();{
    }
    return QDialog::event(event);
void AboutDialog::showEvent(QShowEvent * event)
    int one_em = fontMetrics().height();
    // Authors: Names slightly narrower than emails.
}
void Singleton::f3();{
        showInFolderAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
        connect(showInFolderAction, SIGNAL(triggered()), this, SLOT(showInFolderActionTriggered()));
    }
    QAction * copyColumnAction = menu->addAction(tr("Copy"));
    copyColumnAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
}
void Singleton::f4();{
    UrlLinkDelegate *plugin_delegate = new UrlLinkDelegate(this);
    script_pattern = QString("\\.(lua|py)$");
    plugin_delegate->setColCheck(3, script_pattern);
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
}
void Singleton::f5();{
    return QStringList() << tr("Shortcut") << tr("Name") << tr("Description");
FolderListModel::FolderListModel(QObject * parent):
        AStringListListModel(parent)
    /* "file open" */
    appendRow(QStringList() << tr("\"File\" dialogs") << get_last_open_dir() << tr("capture files"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    proxyAuthorModel->setColumnToFilter(0);
    proxyAuthorModel->setColumnToFilter(1);
    ui->tblAuthors->setModel(proxyAuthorModel);
    ui->tblAuthors->setRootIsDecorated(false);
    ui->pte_Authors->clear();
}
void Singleton::f2();{
    }
    return QDialog::event(event);
void AboutDialog::showEvent(QShowEvent * event)
    int one_em = fontMetrics().height();
    // Authors: Names slightly narrower than emails.
}
void Singleton::f3();{
        showInFolderAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
        connect(showInFolderAction, SIGNAL(triggered()), this, SLOT(showInFolderActionTriggered()));
    }
    QAction * copyColumnAction = menu->addAction(tr("Copy"));
    copyColumnAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
}
void Singleton::f4();{
    UrlLinkDelegate *plugin_delegate = new UrlLinkDelegate(this);
    script_pattern = QString("\\.(lua|py)$");
    plugin_delegate->setColCheck(3, script_pattern);
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
}
void Singleton::f5();{
    return QStringList() << tr("Shortcut") << tr("Name") << tr("Description");
FolderListModel::FolderListModel(QObject * parent):
        AStringListListModel(parent)
    /* "file open" */
    appendRow(QStringList() << tr("\"File\" dialogs") << get_last_open_dir() << tr("capture files"));
}
void Singleton::f6();{
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
    ui->tblPlugins->setContextMenuPolicy(Qt::CustomContextMenu);
    ui->tblPlugins->setTextElideMode(Qt::ElideMiddle);
    connect(ui->tblPlugins, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(handleCopyMenu(QPoint)));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    proxyAuthorModel->setColumnToFilter(0);
    proxyAuthorModel->setColumnToFilter(1);
    ui->tblAuthors->setModel(proxyAuthorModel);
    ui->tblAuthors->setRootIsDecorated(false);
    ui->pte_Authors->clear();
}
void Singleton::f2();{
    }
    return QDialog::event(event);
void AboutDialog::showEvent(QShowEvent * event)
    int one_em = fontMetrics().height();
    // Authors: Names slightly narrower than emails.
}
void Singleton::f3();{
        showInFolderAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
        connect(showInFolderAction, SIGNAL(triggered()), this, SLOT(showInFolderActionTriggered()));
    }
    QAction * copyColumnAction = menu->addAction(tr("Copy"));
    copyColumnAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
}
void Singleton::f4();{
    UrlLinkDelegate *plugin_delegate = new UrlLinkDelegate(this);
    script_pattern = QString("\\.(lua|py)$");
    plugin_delegate->setColCheck(3, script_pattern);
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
}
void Singleton::f5();{
    return QStringList() << tr("Shortcut") << tr("Name") << tr("Description");
FolderListModel::FolderListModel(QObject * parent):
        AStringListListModel(parent)
    /* "file open" */
    appendRow(QStringList() << tr("\"File\" dialogs") << get_last_open_dir() << tr("capture files"));
}
void Singleton::f6();{
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
    ui->tblPlugins->setContextMenuPolicy(Qt::CustomContextMenu);
    ui->tblPlugins->setTextElideMode(Qt::ElideMiddle);
    connect(ui->tblPlugins, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(handleCopyMenu(QPoint)));
}
void Singleton::f7();{
    AStringListListSortFilterProxyModel * pluginTypeModel = new AStringListListSortFilterProxyModel(this);
    pluginTypeModel->setSourceModel(pluginFilterModel);
    pluginTypeModel->setColumnToFilter(2);
    ui->tblPlugins->setModel(pluginTypeModel);
    ui->tblPlugins->setRootIsDecorated(false);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    proxyAuthorModel->setColumnToFilter(0);
    proxyAuthorModel->setColumnToFilter(1);
    ui->tblAuthors->setModel(proxyAuthorModel);
    ui->tblAuthors->setRootIsDecorated(false);
    ui->pte_Authors->clear();
}
void Singleton::f2();{
    }
    return QDialog::event(event);
void AboutDialog::showEvent(QShowEvent * event)
    int one_em = fontMetrics().height();
    // Authors: Names slightly narrower than emails.
}
void Singleton::f3();{
        showInFolderAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
        connect(showInFolderAction, SIGNAL(triggered()), this, SLOT(showInFolderActionTriggered()));
    }
    QAction * copyColumnAction = menu->addAction(tr("Copy"));
    copyColumnAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
}
void Singleton::f4();{
    UrlLinkDelegate *plugin_delegate = new UrlLinkDelegate(this);
    script_pattern = QString("\\.(lua|py)$");
    plugin_delegate->setColCheck(3, script_pattern);
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
}
void Singleton::f5();{
    return QStringList() << tr("Shortcut") << tr("Name") << tr("Description");
FolderListModel::FolderListModel(QObject * parent):
        AStringListListModel(parent)
    /* "file open" */
    appendRow(QStringList() << tr("\"File\" dialogs") << get_last_open_dir() << tr("capture files"));
}
void Singleton::f6();{
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
    ui->tblPlugins->setContextMenuPolicy(Qt::CustomContextMenu);
    ui->tblPlugins->setTextElideMode(Qt::ElideMiddle);
    connect(ui->tblPlugins, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(handleCopyMenu(QPoint)));
}
void Singleton::f7();{
    AStringListListSortFilterProxyModel * pluginTypeModel = new AStringListListSortFilterProxyModel(this);
    pluginTypeModel->setSourceModel(pluginFilterModel);
    pluginTypeModel->setColumnToFilter(2);
    ui->tblPlugins->setModel(pluginTypeModel);
    ui->tblPlugins->setRootIsDecorated(false);
}
void Singleton::f8();{
    appendRow(QStringList() << tr("Global Plugins") << get_plugins_dir_with_version() << tr("binary plugins"));
    /* pers plugins */
    appendRow(QStringList() << tr("Personal Lua Plugins") << get_plugins_pers_dir() << tr("lua scripts"));
    /* global plugins */
    appendRow(QStringList() << tr("Global Lua Plugins") << get_plugins_dir() << tr("lua scripts"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    proxyAuthorModel->setColumnToFilter(0);
    proxyAuthorModel->setColumnToFilter(1);
    ui->tblAuthors->setModel(proxyAuthorModel);
    ui->tblAuthors->setRootIsDecorated(false);
    ui->pte_Authors->clear();
}
void Singleton::f2();{
    }
    return QDialog::event(event);
void AboutDialog::showEvent(QShowEvent * event)
    int one_em = fontMetrics().height();
    // Authors: Names slightly narrower than emails.
}
void Singleton::f3();{
        showInFolderAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
        connect(showInFolderAction, SIGNAL(triggered()), this, SLOT(showInFolderActionTriggered()));
    }
    QAction * copyColumnAction = menu->addAction(tr("Copy"));
    copyColumnAction->setData(VariantPointer<QTreeView>::asQVariant(tree));
}
void Singleton::f4();{
    UrlLinkDelegate *plugin_delegate = new UrlLinkDelegate(this);
    script_pattern = QString("\\.(lua|py)$");
    plugin_delegate->setColCheck(3, script_pattern);
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
}
void Singleton::f5();{
    return QStringList() << tr("Shortcut") << tr("Name") << tr("Description");
FolderListModel::FolderListModel(QObject * parent):
        AStringListListModel(parent)
    /* "file open" */
    appendRow(QStringList() << tr("\"File\" dialogs") << get_last_open_dir() << tr("capture files"));
}
void Singleton::f6();{
    ui->tblPlugins->setItemDelegateForColumn(3, plugin_delegate);
    ui->cmbType->addItems(pluginModel->typeNames());
    ui->tblPlugins->setContextMenuPolicy(Qt::CustomContextMenu);
    ui->tblPlugins->setTextElideMode(Qt::ElideMiddle);
    connect(ui->tblPlugins, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(handleCopyMenu(QPoint)));
}
void Singleton::f7();{
    AStringListListSortFilterProxyModel * pluginTypeModel = new AStringListListSortFilterProxyModel(this);
    pluginTypeModel->setSourceModel(pluginFilterModel);
    pluginTypeModel->setColumnToFilter(2);
    ui->tblPlugins->setModel(pluginTypeModel);
    ui->tblPlugins->setRootIsDecorated(false);
}
void Singleton::f8();{
    appendRow(QStringList() << tr("Global Plugins") << get_plugins_dir_with_version() << tr("binary plugins"));
    /* pers plugins */
    appendRow(QStringList() << tr("Personal Lua Plugins") << get_plugins_pers_dir() << tr("lua scripts"));
    /* global plugins */
    appendRow(QStringList() << tr("Global Lua Plugins") << get_plugins_dir() << tr("lua scripts"));
}
void Singleton::f9();{
    {
        QString cf_path = tree->model()->index(index.row(), 3).data().toString();
        desktop_show_in_folder(cf_path);
    }
void AboutDialog::copyRowActionTriggered()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    QString subframe_style(
//                ".QFrame {"
//                "  background: palette(window);"
//                "  padding-top: 0.1em;"
//                "  padding-bottom: 0.1em;"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    QString subframe_style(
//                ".QFrame {"
//                "  background: palette(window);"
//                "  padding-top: 0.1em;"
//                "  padding-bottom: 0.1em;"
}
void Singleton::f2();{
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
    if (isVisible()) {
}
void Singleton::f3();{
        if (parent && parent->layout()) {
            // Force our parent layout to update its geometry. There are a number
            // of ways of doing this. Calling invalidate + activate seems to
            // be the best.
            show();
}
void Singleton::f4();{
    animation_ = new QPropertyAnimation(this, "maximumHeight", this);
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
}
void Singleton::f5();{
    }
void AccordionFrame::animationFinished()
    if (animation_->currentValue().toInt() < 1) {
        hide();
        setMaximumHeight(frame_height_);
}
void Singleton::f6();{
void AccordionFrame::animatedHide()
    if (!isVisible()) {
        hide();
        return;
    }
}
void Singleton::f7();{
            // be the best.
            show();
            parent->layout()->invalidate(); // Calls parent->layout()->update()
            parent->layout()->activate(); // Calculates sizes then calls parent->updateGeometry()
            frame_height_ = height();
}
void Singleton::f8();{
    }
    if (!display_is_remote()) {
        QWidget *parent = parentWidget();
        if (parent && parent->layout()) {
            // Force our parent layout to update its geometry. There are a number
}
void Singleton::f9();{
        if (frame_height_ > 0) {
            animation_->setStartValue(0);
            animation_->setEndValue(frame_height_);
            animation_->start();
        }
}
void Singleton::f10();{
    QFrame(parent),
    frame_height_(0)
    QString subframe_style(
//                ".QFrame {"
//                "  background: palette(window);"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    QString subframe_style(
//                ".QFrame {"
//                "  background: palette(window);"
//                "  padding-top: 0.1em;"
//                "  padding-bottom: 0.1em;"
}
void Singleton::f2();{
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
    if (isVisible()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    QString subframe_style(
//                ".QFrame {"
//                "  background: palette(window);"
//                "  padding-top: 0.1em;"
//                "  padding-bottom: 0.1em;"
}
void Singleton::f2();{
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
    if (isVisible()) {
}
void Singleton::f3();{
        if (parent && parent->layout()) {
            // Force our parent layout to update its geometry. There are a number
            // of ways of doing this. Calling invalidate + activate seems to
            // be the best.
            show();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    QString subframe_style(
//                ".QFrame {"
//                "  background: palette(window);"
//                "  padding-top: 0.1em;"
//                "  padding-bottom: 0.1em;"
}
void Singleton::f2();{
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
    if (isVisible()) {
}
void Singleton::f3();{
        if (parent && parent->layout()) {
            // Force our parent layout to update its geometry. There are a number
            // of ways of doing this. Calling invalidate + activate seems to
            // be the best.
            show();
}
void Singleton::f4();{
    animation_ = new QPropertyAnimation(this, "maximumHeight", this);
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    QString subframe_style(
//                ".QFrame {"
//                "  background: palette(window);"
//                "  padding-top: 0.1em;"
//                "  padding-bottom: 0.1em;"
}
void Singleton::f2();{
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
    if (isVisible()) {
}
void Singleton::f3();{
        if (parent && parent->layout()) {
            // Force our parent layout to update its geometry. There are a number
            // of ways of doing this. Calling invalidate + activate seems to
            // be the best.
            show();
}
void Singleton::f4();{
    animation_ = new QPropertyAnimation(this, "maximumHeight", this);
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
}
void Singleton::f5();{
    }
void AccordionFrame::animationFinished()
    if (animation_->currentValue().toInt() < 1) {
        hide();
        setMaximumHeight(frame_height_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    QString subframe_style(
//                ".QFrame {"
//                "  background: palette(window);"
//                "  padding-top: 0.1em;"
//                "  padding-bottom: 0.1em;"
}
void Singleton::f2();{
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
    if (isVisible()) {
}
void Singleton::f3();{
        if (parent && parent->layout()) {
            // Force our parent layout to update its geometry. There are a number
            // of ways of doing this. Calling invalidate + activate seems to
            // be the best.
            show();
}
void Singleton::f4();{
    animation_ = new QPropertyAnimation(this, "maximumHeight", this);
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
}
void Singleton::f5();{
    }
void AccordionFrame::animationFinished()
    if (animation_->currentValue().toInt() < 1) {
        hide();
        setMaximumHeight(frame_height_);
}
void Singleton::f6();{
void AccordionFrame::animatedHide()
    if (!isVisible()) {
        hide();
        return;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    QString subframe_style(
//                ".QFrame {"
//                "  background: palette(window);"
//                "  padding-top: 0.1em;"
//                "  padding-bottom: 0.1em;"
}
void Singleton::f2();{
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
    if (isVisible()) {
}
void Singleton::f3();{
        if (parent && parent->layout()) {
            // Force our parent layout to update its geometry. There are a number
            // of ways of doing this. Calling invalidate + activate seems to
            // be the best.
            show();
}
void Singleton::f4();{
    animation_ = new QPropertyAnimation(this, "maximumHeight", this);
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
}
void Singleton::f5();{
    }
void AccordionFrame::animationFinished()
    if (animation_->currentValue().toInt() < 1) {
        hide();
        setMaximumHeight(frame_height_);
}
void Singleton::f6();{
void AccordionFrame::animatedHide()
    if (!isVisible()) {
        hide();
        return;
    }
}
void Singleton::f7();{
            // be the best.
            show();
            parent->layout()->invalidate(); // Calls parent->layout()->update()
            parent->layout()->activate(); // Calculates sizes then calls parent->updateGeometry()
            frame_height_ = height();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    QString subframe_style(
//                ".QFrame {"
//                "  background: palette(window);"
//                "  padding-top: 0.1em;"
//                "  padding-bottom: 0.1em;"
}
void Singleton::f2();{
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
    if (isVisible()) {
}
void Singleton::f3();{
        if (parent && parent->layout()) {
            // Force our parent layout to update its geometry. There are a number
            // of ways of doing this. Calling invalidate + activate seems to
            // be the best.
            show();
}
void Singleton::f4();{
    animation_ = new QPropertyAnimation(this, "maximumHeight", this);
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
}
void Singleton::f5();{
    }
void AccordionFrame::animationFinished()
    if (animation_->currentValue().toInt() < 1) {
        hide();
        setMaximumHeight(frame_height_);
}
void Singleton::f6();{
void AccordionFrame::animatedHide()
    if (!isVisible()) {
        hide();
        return;
    }
}
void Singleton::f7();{
            // be the best.
            show();
            parent->layout()->invalidate(); // Calls parent->layout()->update()
            parent->layout()->activate(); // Calculates sizes then calls parent->updateGeometry()
            frame_height_ = height();
}
void Singleton::f8();{
    }
    if (!display_is_remote()) {
        QWidget *parent = parentWidget();
        if (parent && parent->layout()) {
            // Force our parent layout to update its geometry. There are a number
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    QString subframe_style(
//                ".QFrame {"
//                "  background: palette(window);"
//                "  padding-top: 0.1em;"
//                "  padding-bottom: 0.1em;"
}
void Singleton::f2();{
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
    if (isVisible()) {
}
void Singleton::f3();{
        if (parent && parent->layout()) {
            // Force our parent layout to update its geometry. There are a number
            // of ways of doing this. Calling invalidate + activate seems to
            // be the best.
            show();
}
void Singleton::f4();{
    animation_ = new QPropertyAnimation(this, "maximumHeight", this);
    animation_->setDuration(duration_);
    animation_->setEasingCurve(QEasingCurve::InOutQuad);
    connect(animation_, SIGNAL(finished()), this, SLOT(animationFinished()));
void AccordionFrame::animatedShow()
}
void Singleton::f5();{
    }
void AccordionFrame::animationFinished()
    if (animation_->currentValue().toInt() < 1) {
        hide();
        setMaximumHeight(frame_height_);
}
void Singleton::f6();{
void AccordionFrame::animatedHide()
    if (!isVisible()) {
        hide();
        return;
    }
}
void Singleton::f7();{
            // be the best.
            show();
            parent->layout()->invalidate(); // Calls parent->layout()->update()
            parent->layout()->activate(); // Calculates sizes then calls parent->updateGeometry()
            frame_height_ = height();
}
void Singleton::f8();{
    }
    if (!display_is_remote()) {
        QWidget *parent = parentWidget();
        if (parent && parent->layout()) {
            // Force our parent layout to update its geometry. There are a number
}
void Singleton::f9();{
        if (frame_height_ > 0) {
            animation_->setStartValue(0);
            animation_->setEndValue(frame_height_);
            animation_->start();
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    barItem->setAttribute(Qt::WA_MacSmallSize, true);
    return barItem;
static void
toolbar_button_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    barItem->setAttribute(Qt::WA_MacSmallSize, true);
    return barItem;
static void
toolbar_button_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
}
void Singleton::f2();{
QWidget * AdditionalToolbarWidgetAction::createWidget(QWidget * parent)
    QWidget * barItem = 0;
    if (toolbar_item->type != EXT_TOOLBAR_ITEM)
        return barItem;
    switch (toolbar_item->item_type)
}
void Singleton::f3();{
static void
toolbar_selector_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
        return;
    QComboBox * comboBox = (QComboBox *)(item_data);
}
void Singleton::f4();{
        }
        else if (update_entry->type == EXT_TOOLBAR_UPDATE_DATA_REMOVE)
        {
            QList<QStandardItem *> entryList = sourceModel->findItems(display);
            /* Search for index if display did not find anything */
}
void Singleton::f5();{
                editor = children.at(0);
        }
    }
    if (editor)
        item->callback(item, qstring_strdup(editor->text()), item->user_data);
}
void Singleton::f6();{
    if (! item || ! item_data || ! user_data)
        return;
    QCheckBox * widget = (QCheckBox *)(item_data);
    ext_toolbar_update_t * update_entry = (ext_toolbar_update_t *)user_data;
    if (update_entry->type == EXT_TOOLBAR_UPDATE_VALUE)
}
void Singleton::f7();{
                    g_free(entry->display);
                    entry->display = g_strdup(display);
                    dataValue->setData(VariantPointer<ext_toolbar_value_t>::asQVariant(entry), Qt::UserRole);
                    dataValue->setText(display);
                    break;
}
void Singleton::f8();{
    }
    if (update_entry->silent)
        comboBox->blockSignals(oldState);
QWidget * AdditionalToolbarWidgetAction::createSelector(ext_toolbar_t * item, QWidget * parent)
    if (! item || item->type != EXT_TOOLBAR_ITEM || item->item_type != EXT_TOOLBAR_SELECTOR)
}
void Singleton::f9();{
        return;
    gboolean value = checkState == Qt::Checked ? true : false;
    item->callback(item, &value, item->user_data);
void AdditionalToolbarWidgetAction::sendTextToCallback()
    ext_toolbar_t * item = extractToolbarItemFromObject(sender());
}
void Singleton::f10();{
    if (! item || item->type != EXT_TOOLBAR_ITEM || item->item_type != EXT_TOOLBAR_STRING)
        return 0;
    QWidget * frame = createLabelFrame(toolbar_item, parent);
    ApplyLineEdit * strEdit = new ApplyLineEdit(toolbar_item->defvalue, frame);
    strEdit->setToolTip(toolbar_item->tooltip);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    barItem->setAttribute(Qt::WA_MacSmallSize, true);
    return barItem;
static void
toolbar_button_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
}
void Singleton::f2();{
QWidget * AdditionalToolbarWidgetAction::createWidget(QWidget * parent)
    QWidget * barItem = 0;
    if (toolbar_item->type != EXT_TOOLBAR_ITEM)
        return barItem;
    switch (toolbar_item->item_type)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    barItem->setAttribute(Qt::WA_MacSmallSize, true);
    return barItem;
static void
toolbar_button_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
}
void Singleton::f2();{
QWidget * AdditionalToolbarWidgetAction::createWidget(QWidget * parent)
    QWidget * barItem = 0;
    if (toolbar_item->type != EXT_TOOLBAR_ITEM)
        return barItem;
    switch (toolbar_item->item_type)
}
void Singleton::f3();{
static void
toolbar_selector_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
        return;
    QComboBox * comboBox = (QComboBox *)(item_data);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    barItem->setAttribute(Qt::WA_MacSmallSize, true);
    return barItem;
static void
toolbar_button_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
}
void Singleton::f2();{
QWidget * AdditionalToolbarWidgetAction::createWidget(QWidget * parent)
    QWidget * barItem = 0;
    if (toolbar_item->type != EXT_TOOLBAR_ITEM)
        return barItem;
    switch (toolbar_item->item_type)
}
void Singleton::f3();{
static void
toolbar_selector_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
        return;
    QComboBox * comboBox = (QComboBox *)(item_data);
}
void Singleton::f4();{
        }
        else if (update_entry->type == EXT_TOOLBAR_UPDATE_DATA_REMOVE)
        {
            QList<QStandardItem *> entryList = sourceModel->findItems(display);
            /* Search for index if display did not find anything */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    barItem->setAttribute(Qt::WA_MacSmallSize, true);
    return barItem;
static void
toolbar_button_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
}
void Singleton::f2();{
QWidget * AdditionalToolbarWidgetAction::createWidget(QWidget * parent)
    QWidget * barItem = 0;
    if (toolbar_item->type != EXT_TOOLBAR_ITEM)
        return barItem;
    switch (toolbar_item->item_type)
}
void Singleton::f3();{
static void
toolbar_selector_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
        return;
    QComboBox * comboBox = (QComboBox *)(item_data);
}
void Singleton::f4();{
        }
        else if (update_entry->type == EXT_TOOLBAR_UPDATE_DATA_REMOVE)
        {
            QList<QStandardItem *> entryList = sourceModel->findItems(display);
            /* Search for index if display did not find anything */
}
void Singleton::f5();{
                editor = children.at(0);
        }
    }
    if (editor)
        item->callback(item, qstring_strdup(editor->text()), item->user_data);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    barItem->setAttribute(Qt::WA_MacSmallSize, true);
    return barItem;
static void
toolbar_button_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
}
void Singleton::f2();{
QWidget * AdditionalToolbarWidgetAction::createWidget(QWidget * parent)
    QWidget * barItem = 0;
    if (toolbar_item->type != EXT_TOOLBAR_ITEM)
        return barItem;
    switch (toolbar_item->item_type)
}
void Singleton::f3();{
static void
toolbar_selector_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
        return;
    QComboBox * comboBox = (QComboBox *)(item_data);
}
void Singleton::f4();{
        }
        else if (update_entry->type == EXT_TOOLBAR_UPDATE_DATA_REMOVE)
        {
            QList<QStandardItem *> entryList = sourceModel->findItems(display);
            /* Search for index if display did not find anything */
}
void Singleton::f5();{
                editor = children.at(0);
        }
    }
    if (editor)
        item->callback(item, qstring_strdup(editor->text()), item->user_data);
}
void Singleton::f6();{
    if (! item || ! item_data || ! user_data)
        return;
    QCheckBox * widget = (QCheckBox *)(item_data);
    ext_toolbar_update_t * update_entry = (ext_toolbar_update_t *)user_data;
    if (update_entry->type == EXT_TOOLBAR_UPDATE_VALUE)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    barItem->setAttribute(Qt::WA_MacSmallSize, true);
    return barItem;
static void
toolbar_button_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
}
void Singleton::f2();{
QWidget * AdditionalToolbarWidgetAction::createWidget(QWidget * parent)
    QWidget * barItem = 0;
    if (toolbar_item->type != EXT_TOOLBAR_ITEM)
        return barItem;
    switch (toolbar_item->item_type)
}
void Singleton::f3();{
static void
toolbar_selector_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
        return;
    QComboBox * comboBox = (QComboBox *)(item_data);
}
void Singleton::f4();{
        }
        else if (update_entry->type == EXT_TOOLBAR_UPDATE_DATA_REMOVE)
        {
            QList<QStandardItem *> entryList = sourceModel->findItems(display);
            /* Search for index if display did not find anything */
}
void Singleton::f5();{
                editor = children.at(0);
        }
    }
    if (editor)
        item->callback(item, qstring_strdup(editor->text()), item->user_data);
}
void Singleton::f6();{
    if (! item || ! item_data || ! user_data)
        return;
    QCheckBox * widget = (QCheckBox *)(item_data);
    ext_toolbar_update_t * update_entry = (ext_toolbar_update_t *)user_data;
    if (update_entry->type == EXT_TOOLBAR_UPDATE_VALUE)
}
void Singleton::f7();{
                    g_free(entry->display);
                    entry->display = g_strdup(display);
                    dataValue->setData(VariantPointer<ext_toolbar_value_t>::asQVariant(entry), Qt::UserRole);
                    dataValue->setText(display);
                    break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    barItem->setAttribute(Qt::WA_MacSmallSize, true);
    return barItem;
static void
toolbar_button_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
}
void Singleton::f2();{
QWidget * AdditionalToolbarWidgetAction::createWidget(QWidget * parent)
    QWidget * barItem = 0;
    if (toolbar_item->type != EXT_TOOLBAR_ITEM)
        return barItem;
    switch (toolbar_item->item_type)
}
void Singleton::f3();{
static void
toolbar_selector_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
        return;
    QComboBox * comboBox = (QComboBox *)(item_data);
}
void Singleton::f4();{
        }
        else if (update_entry->type == EXT_TOOLBAR_UPDATE_DATA_REMOVE)
        {
            QList<QStandardItem *> entryList = sourceModel->findItems(display);
            /* Search for index if display did not find anything */
}
void Singleton::f5();{
                editor = children.at(0);
        }
    }
    if (editor)
        item->callback(item, qstring_strdup(editor->text()), item->user_data);
}
void Singleton::f6();{
    if (! item || ! item_data || ! user_data)
        return;
    QCheckBox * widget = (QCheckBox *)(item_data);
    ext_toolbar_update_t * update_entry = (ext_toolbar_update_t *)user_data;
    if (update_entry->type == EXT_TOOLBAR_UPDATE_VALUE)
}
void Singleton::f7();{
                    g_free(entry->display);
                    entry->display = g_strdup(display);
                    dataValue->setData(VariantPointer<ext_toolbar_value_t>::asQVariant(entry), Qt::UserRole);
                    dataValue->setText(display);
                    break;
}
void Singleton::f8();{
    }
    if (update_entry->silent)
        comboBox->blockSignals(oldState);
QWidget * AdditionalToolbarWidgetAction::createSelector(ext_toolbar_t * item, QWidget * parent)
    if (! item || item->type != EXT_TOOLBAR_ITEM || item->item_type != EXT_TOOLBAR_SELECTOR)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    barItem->setAttribute(Qt::WA_MacSmallSize, true);
    return barItem;
static void
toolbar_button_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
}
void Singleton::f2();{
QWidget * AdditionalToolbarWidgetAction::createWidget(QWidget * parent)
    QWidget * barItem = 0;
    if (toolbar_item->type != EXT_TOOLBAR_ITEM)
        return barItem;
    switch (toolbar_item->item_type)
}
void Singleton::f3();{
static void
toolbar_selector_cb(gpointer item, gpointer item_data, gpointer user_data)
    if (! item || ! item_data || ! user_data)
        return;
    QComboBox * comboBox = (QComboBox *)(item_data);
}
void Singleton::f4();{
        }
        else if (update_entry->type == EXT_TOOLBAR_UPDATE_DATA_REMOVE)
        {
            QList<QStandardItem *> entryList = sourceModel->findItems(display);
            /* Search for index if display did not find anything */
}
void Singleton::f5();{
                editor = children.at(0);
        }
    }
    if (editor)
        item->callback(item, qstring_strdup(editor->text()), item->user_data);
}
void Singleton::f6();{
    if (! item || ! item_data || ! user_data)
        return;
    QCheckBox * widget = (QCheckBox *)(item_data);
    ext_toolbar_update_t * update_entry = (ext_toolbar_update_t *)user_data;
    if (update_entry->type == EXT_TOOLBAR_UPDATE_VALUE)
}
void Singleton::f7();{
                    g_free(entry->display);
                    entry->display = g_strdup(display);
                    dataValue->setData(VariantPointer<ext_toolbar_value_t>::asQVariant(entry), Qt::UserRole);
                    dataValue->setText(display);
                    break;
}
void Singleton::f8();{
    }
    if (update_entry->silent)
        comboBox->blockSignals(oldState);
QWidget * AdditionalToolbarWidgetAction::createSelector(ext_toolbar_t * item, QWidget * parent)
    if (! item || item->type != EXT_TOOLBAR_ITEM || item->item_type != EXT_TOOLBAR_SELECTOR)
}
void Singleton::f9();{
        return;
    gboolean value = checkState == Qt::Checked ? true : false;
    item->callback(item, &value, item->user_data);
void AdditionalToolbarWidgetAction::sendTextToCallback()
    ext_toolbar_t * item = extractToolbarItemFromObject(sender());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
    epan_dissect_run(&edt, cap_file_->cd_t, &cap_file_->rec,
        frame_tvbuff_new_buffer(&cap_file_->provider, cap_file_->current_frame, &cap_file_->buf),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
    epan_dissect_run(&edt, cap_file_->cd_t, &cap_file_->rec,
        frame_tvbuff_new_buffer(&cap_file_->provider, cap_file_->current_frame, &cap_file_->buf),
}
void Singleton::f2();{
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
    animatedHide();
bool AddressEditorFrame::isAddressColumn(epan_column_info *cinfo, int column)
}
void Singleton::f3();{
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Fill in currently resolved address.
AddressEditorFrame::AddressEditorFrame(QWidget *parent) :
    AccordionFrame(parent),
}
void Singleton::f4();{
    on_buttonBox_rejected();
    emit redissectPackets();
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
}
void Singleton::f5();{
    for (int col = 0; col < cap_file_->cinfo.num_cols; col++) {
        /* Then check all columns except the selected */
        if ((col != column) && (isAddressColumn(&cap_file_->cinfo, col))) {
            addresses << cap_file_->cinfo.col_expr.col_expr_val[col];
        }
}
void Singleton::f6();{
void AddressEditorFrame::showEvent(QShowEvent *event)
    ui->nameLineEdit->setFocus();
    ui->nameLineEdit->selectAll();
    AccordionFrame::showEvent(event);
void AddressEditorFrame::keyPressEvent(QKeyEvent *event)
}
void Singleton::f7();{
        cap_file_->current_frame, &cap_file_->cinfo);
    epan_dissect_fill_in_columns(&edt, TRUE, TRUE);
    /* First check selected column */
    if (isAddressColumn(&cap_file_->cinfo, column)) {
        addresses << cap_file_->cinfo.col_expr.col_expr_val[column];
}
void Singleton::f8();{
    AccordionFrame(parent),
    ui(new Ui::AddressEditorFrame),
    cap_file_(NULL)
    ui->setupUi(this);
    foreach (QWidget *w, findChildren<QWidget *>()) {
}
void Singleton::f9();{
    epan_dissect_t edt;
    QStringList addresses;
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
}
void Singleton::f10();{
    {
        return true;
    }
    return false;
 * Editor modelines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
    epan_dissect_run(&edt, cap_file_->cd_t, &cap_file_->rec,
        frame_tvbuff_new_buffer(&cap_file_->provider, cap_file_->current_frame, &cap_file_->buf),
}
void Singleton::f2();{
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
    animatedHide();
bool AddressEditorFrame::isAddressColumn(epan_column_info *cinfo, int column)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
    epan_dissect_run(&edt, cap_file_->cd_t, &cap_file_->rec,
        frame_tvbuff_new_buffer(&cap_file_->provider, cap_file_->current_frame, &cap_file_->buf),
}
void Singleton::f2();{
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
    animatedHide();
bool AddressEditorFrame::isAddressColumn(epan_column_info *cinfo, int column)
}
void Singleton::f3();{
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Fill in currently resolved address.
AddressEditorFrame::AddressEditorFrame(QWidget *parent) :
    AccordionFrame(parent),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
    epan_dissect_run(&edt, cap_file_->cd_t, &cap_file_->rec,
        frame_tvbuff_new_buffer(&cap_file_->provider, cap_file_->current_frame, &cap_file_->buf),
}
void Singleton::f2();{
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
    animatedHide();
bool AddressEditorFrame::isAddressColumn(epan_column_info *cinfo, int column)
}
void Singleton::f3();{
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Fill in currently resolved address.
AddressEditorFrame::AddressEditorFrame(QWidget *parent) :
    AccordionFrame(parent),
}
void Singleton::f4();{
    on_buttonBox_rejected();
    emit redissectPackets();
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
    epan_dissect_run(&edt, cap_file_->cd_t, &cap_file_->rec,
        frame_tvbuff_new_buffer(&cap_file_->provider, cap_file_->current_frame, &cap_file_->buf),
}
void Singleton::f2();{
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
    animatedHide();
bool AddressEditorFrame::isAddressColumn(epan_column_info *cinfo, int column)
}
void Singleton::f3();{
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Fill in currently resolved address.
AddressEditorFrame::AddressEditorFrame(QWidget *parent) :
    AccordionFrame(parent),
}
void Singleton::f4();{
    on_buttonBox_rejected();
    emit redissectPackets();
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
}
void Singleton::f5();{
    for (int col = 0; col < cap_file_->cinfo.num_cols; col++) {
        /* Then check all columns except the selected */
        if ((col != column) && (isAddressColumn(&cap_file_->cinfo, col))) {
            addresses << cap_file_->cinfo.col_expr.col_expr_val[col];
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
    epan_dissect_run(&edt, cap_file_->cd_t, &cap_file_->rec,
        frame_tvbuff_new_buffer(&cap_file_->provider, cap_file_->current_frame, &cap_file_->buf),
}
void Singleton::f2();{
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
    animatedHide();
bool AddressEditorFrame::isAddressColumn(epan_column_info *cinfo, int column)
}
void Singleton::f3();{
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Fill in currently resolved address.
AddressEditorFrame::AddressEditorFrame(QWidget *parent) :
    AccordionFrame(parent),
}
void Singleton::f4();{
    on_buttonBox_rejected();
    emit redissectPackets();
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
}
void Singleton::f5();{
    for (int col = 0; col < cap_file_->cinfo.num_cols; col++) {
        /* Then check all columns except the selected */
        if ((col != column) && (isAddressColumn(&cap_file_->cinfo, col))) {
            addresses << cap_file_->cinfo.col_expr.col_expr_val[col];
        }
}
void Singleton::f6();{
void AddressEditorFrame::showEvent(QShowEvent *event)
    ui->nameLineEdit->setFocus();
    ui->nameLineEdit->selectAll();
    AccordionFrame::showEvent(event);
void AddressEditorFrame::keyPressEvent(QKeyEvent *event)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
    epan_dissect_run(&edt, cap_file_->cd_t, &cap_file_->rec,
        frame_tvbuff_new_buffer(&cap_file_->provider, cap_file_->current_frame, &cap_file_->buf),
}
void Singleton::f2();{
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
    animatedHide();
bool AddressEditorFrame::isAddressColumn(epan_column_info *cinfo, int column)
}
void Singleton::f3();{
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Fill in currently resolved address.
AddressEditorFrame::AddressEditorFrame(QWidget *parent) :
    AccordionFrame(parent),
}
void Singleton::f4();{
    on_buttonBox_rejected();
    emit redissectPackets();
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
}
void Singleton::f5();{
    for (int col = 0; col < cap_file_->cinfo.num_cols; col++) {
        /* Then check all columns except the selected */
        if ((col != column) && (isAddressColumn(&cap_file_->cinfo, col))) {
            addresses << cap_file_->cinfo.col_expr.col_expr_val[col];
        }
}
void Singleton::f6();{
void AddressEditorFrame::showEvent(QShowEvent *event)
    ui->nameLineEdit->setFocus();
    ui->nameLineEdit->selectAll();
    AccordionFrame::showEvent(event);
void AddressEditorFrame::keyPressEvent(QKeyEvent *event)
}
void Singleton::f7();{
        cap_file_->current_frame, &cap_file_->cinfo);
    epan_dissect_fill_in_columns(&edt, TRUE, TRUE);
    /* First check selected column */
    if (isAddressColumn(&cap_file_->cinfo, column)) {
        addresses << cap_file_->cinfo.col_expr.col_expr_val[column];
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
    epan_dissect_run(&edt, cap_file_->cd_t, &cap_file_->rec,
        frame_tvbuff_new_buffer(&cap_file_->provider, cap_file_->current_frame, &cap_file_->buf),
}
void Singleton::f2();{
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
    animatedHide();
bool AddressEditorFrame::isAddressColumn(epan_column_info *cinfo, int column)
}
void Singleton::f3();{
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Fill in currently resolved address.
AddressEditorFrame::AddressEditorFrame(QWidget *parent) :
    AccordionFrame(parent),
}
void Singleton::f4();{
    on_buttonBox_rejected();
    emit redissectPackets();
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
}
void Singleton::f5();{
    for (int col = 0; col < cap_file_->cinfo.num_cols; col++) {
        /* Then check all columns except the selected */
        if ((col != column) && (isAddressColumn(&cap_file_->cinfo, col))) {
            addresses << cap_file_->cinfo.col_expr.col_expr_val[col];
        }
}
void Singleton::f6();{
void AddressEditorFrame::showEvent(QShowEvent *event)
    ui->nameLineEdit->setFocus();
    ui->nameLineEdit->selectAll();
    AccordionFrame::showEvent(event);
void AddressEditorFrame::keyPressEvent(QKeyEvent *event)
}
void Singleton::f7();{
        cap_file_->current_frame, &cap_file_->cinfo);
    epan_dissect_fill_in_columns(&edt, TRUE, TRUE);
    /* First check selected column */
    if (isAddressColumn(&cap_file_->cinfo, column)) {
        addresses << cap_file_->cinfo.col_expr.col_expr_val[column];
}
void Singleton::f8();{
    AccordionFrame(parent),
    ui(new Ui::AddressEditorFrame),
    cap_file_(NULL)
    ui->setupUi(this);
    foreach (QWidget *w, findChildren<QWidget *>()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
    epan_dissect_run(&edt, cap_file_->cd_t, &cap_file_->rec,
        frame_tvbuff_new_buffer(&cap_file_->provider, cap_file_->current_frame, &cap_file_->buf),
}
void Singleton::f2();{
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
    animatedHide();
bool AddressEditorFrame::isAddressColumn(epan_column_info *cinfo, int column)
}
void Singleton::f3();{
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Fill in currently resolved address.
AddressEditorFrame::AddressEditorFrame(QWidget *parent) :
    AccordionFrame(parent),
}
void Singleton::f4();{
    on_buttonBox_rejected();
    emit redissectPackets();
void AddressEditorFrame::on_buttonBox_rejected()
    ui->addressComboBox->clear();
    ui->nameLineEdit->clear();
}
void Singleton::f5();{
    for (int col = 0; col < cap_file_->cinfo.num_cols; col++) {
        /* Then check all columns except the selected */
        if ((col != column) && (isAddressColumn(&cap_file_->cinfo, col))) {
            addresses << cap_file_->cinfo.col_expr.col_expr_val[col];
        }
}
void Singleton::f6();{
void AddressEditorFrame::showEvent(QShowEvent *event)
    ui->nameLineEdit->setFocus();
    ui->nameLineEdit->selectAll();
    AccordionFrame::showEvent(event);
void AddressEditorFrame::keyPressEvent(QKeyEvent *event)
}
void Singleton::f7();{
        cap_file_->current_frame, &cap_file_->cinfo);
    epan_dissect_fill_in_columns(&edt, TRUE, TRUE);
    /* First check selected column */
    if (isAddressColumn(&cap_file_->cinfo, column)) {
        addresses << cap_file_->cinfo.col_expr.col_expr_val[column];
}
void Singleton::f8();{
    AccordionFrame(parent),
    ui(new Ui::AddressEditorFrame),
    cap_file_(NULL)
    ui->setupUi(this);
    foreach (QWidget *w, findChildren<QWidget *>()) {
}
void Singleton::f9();{
    epan_dissect_t edt;
    QStringList addresses;
    ui->addressComboBox->clear();
    epan_dissect_init(&edt, cap_file_->epan, FALSE, FALSE);
    col_custom_prime_edt(&edt, &cap_file_->cinfo);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f2();{
    {
        QRegExp rx (regex_);
        QRegExpValidator v(rx, 0);
        int pos = 0;
        if (! rx.isValid() || v.validate(text, pos) != QValidator::Acceptable)
}
void Singleton::f3();{
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
  apply_button_(0)
    emptyAllowed_ = false;
    regex_ = QString();
}
void Singleton::f4();{
            return false;
    }
    return true;
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
}
void Singleton::f5();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
}
void Singleton::f6();{
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
    apply_button_->setEnabled(isValidText(newText));
    handleValidation(newText);
void ApplyLineEdit::onTextChanged(const QString & text)
}
void Singleton::f7();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f8();{
    return emptyAllowed_;
bool ApplyLineEdit::isValidText(QString & text, bool ignoreEmptyCheck)
    if (text.length() == 0)
    {
        if (! ignoreEmptyCheck && ! emptyAllowed_)
}
void Singleton::f9();{
            .arg(frameWidth + 1)
            .arg(apply_button_->sizeHint().width() + frameWidth)
            .arg(isValidText(newText, true) ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void ApplyLineEdit::resizeEvent(QResizeEvent *)
}
void Singleton::f10();{
        if (! rx.isValid() || v.validate(text, pos) != QValidator::Acceptable)
            return false;
    }
    return true;
void ApplyLineEdit::onTextEdited(const QString & text)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f2();{
    {
        QRegExp rx (regex_);
        QRegExpValidator v(rx, 0);
        int pos = 0;
        if (! rx.isValid() || v.validate(text, pos) != QValidator::Acceptable)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f2();{
    {
        QRegExp rx (regex_);
        QRegExpValidator v(rx, 0);
        int pos = 0;
        if (! rx.isValid() || v.validate(text, pos) != QValidator::Acceptable)
}
void Singleton::f3();{
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
  apply_button_(0)
    emptyAllowed_ = false;
    regex_ = QString();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f2();{
    {
        QRegExp rx (regex_);
        QRegExpValidator v(rx, 0);
        int pos = 0;
        if (! rx.isValid() || v.validate(text, pos) != QValidator::Acceptable)
}
void Singleton::f3();{
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
  apply_button_(0)
    emptyAllowed_ = false;
    regex_ = QString();
}
void Singleton::f4();{
            return false;
    }
    return true;
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f2();{
    {
        QRegExp rx (regex_);
        QRegExpValidator v(rx, 0);
        int pos = 0;
        if (! rx.isValid() || v.validate(text, pos) != QValidator::Acceptable)
}
void Singleton::f3();{
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
  apply_button_(0)
    emptyAllowed_ = false;
    regex_ = QString();
}
void Singleton::f4();{
            return false;
    }
    return true;
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
}
void Singleton::f5();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f2();{
    {
        QRegExp rx (regex_);
        QRegExpValidator v(rx, 0);
        int pos = 0;
        if (! rx.isValid() || v.validate(text, pos) != QValidator::Acceptable)
}
void Singleton::f3();{
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
  apply_button_(0)
    emptyAllowed_ = false;
    regex_ = QString();
}
void Singleton::f4();{
            return false;
    }
    return true;
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
}
void Singleton::f5();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
}
void Singleton::f6();{
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
    apply_button_->setEnabled(isValidText(newText));
    handleValidation(newText);
void ApplyLineEdit::onTextChanged(const QString & text)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f2();{
    {
        QRegExp rx (regex_);
        QRegExpValidator v(rx, 0);
        int pos = 0;
        if (! rx.isValid() || v.validate(text, pos) != QValidator::Acceptable)
}
void Singleton::f3();{
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
  apply_button_(0)
    emptyAllowed_ = false;
    regex_ = QString();
}
void Singleton::f4();{
            return false;
    }
    return true;
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
}
void Singleton::f5();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
}
void Singleton::f6();{
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
    apply_button_->setEnabled(isValidText(newText));
    handleValidation(newText);
void ApplyLineEdit::onTextChanged(const QString & text)
}
void Singleton::f7();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f2();{
    {
        QRegExp rx (regex_);
        QRegExpValidator v(rx, 0);
        int pos = 0;
        if (! rx.isValid() || v.validate(text, pos) != QValidator::Acceptable)
}
void Singleton::f3();{
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
  apply_button_(0)
    emptyAllowed_ = false;
    regex_ = QString();
}
void Singleton::f4();{
            return false;
    }
    return true;
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
}
void Singleton::f5();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
}
void Singleton::f6();{
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
    apply_button_->setEnabled(isValidText(newText));
    handleValidation(newText);
void ApplyLineEdit::onTextChanged(const QString & text)
}
void Singleton::f7();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f8();{
    return emptyAllowed_;
bool ApplyLineEdit::isValidText(QString & text, bool ignoreEmptyCheck)
    if (text.length() == 0)
    {
        if (! ignoreEmptyCheck && ! emptyAllowed_)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f2();{
    {
        QRegExp rx (regex_);
        QRegExpValidator v(rx, 0);
        int pos = 0;
        if (! rx.isValid() || v.validate(text, pos) != QValidator::Acceptable)
}
void Singleton::f3();{
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
  apply_button_(0)
    emptyAllowed_ = false;
    regex_ = QString();
}
void Singleton::f4();{
            return false;
    }
    return true;
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
}
void Singleton::f5();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ApplyLineEdit::ApplyLineEdit(QString linePlaceholderText, QWidget * parent)
: QLineEdit(parent),
}
void Singleton::f6();{
void ApplyLineEdit::onTextEdited(const QString & text)
    QString newText = QString(text);
    apply_button_->setEnabled(isValidText(newText));
    handleValidation(newText);
void ApplyLineEdit::onTextChanged(const QString & text)
}
void Singleton::f7();{
    regex_ = QString();
    apply_button_ = new StockIconToolButton(parent, "x-filter-apply");
    apply_button_->setCursor(Qt::ArrowCursor);
    apply_button_->setEnabled(false);
    apply_button_->setToolTip(tr("Apply changes"));
}
void Singleton::f8();{
    return emptyAllowed_;
bool ApplyLineEdit::isValidText(QString & text, bool ignoreEmptyCheck)
    if (text.length() == 0)
    {
        if (! ignoreEmptyCheck && ! emptyAllowed_)
}
void Singleton::f9();{
            .arg(frameWidth + 1)
            .arg(apply_button_->sizeHint().width() + frameWidth)
            .arg(isValidText(newText, true) ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void ApplyLineEdit::resizeEvent(QResizeEvent *)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            return QVariant::fromValue(data.at(index.column()));
    }
    else if (role == Qt::ToolTipRole)
    {
        QString tooltip = tooltip_data_.at(index.row());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            return QVariant::fromValue(data.at(index.column()));
    }
    else if (role == Qt::ToolTipRole)
    {
        QString tooltip = tooltip_data_.at(index.row());
}
void Singleton::f2();{
    return leftData.compare(rightData, sortCaseSensitivity()) < 0;
void AStringListListSortFilterProxyModel::setFilter(const QString & filter)
    filter_ = filter;
    invalidateFilter();
static bool AContainsB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
}
void Singleton::f3();{
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
    {
}
void Singleton::f4();{
    if (role == Qt::ForegroundRole && urls_.contains(index.column())
            && result.canConvert(QVariant::Brush))
    {
        QBrush selected = result.value<QBrush>();
        selected.setColor(ColorUtils::themeLinkBrush().color());
}
void Singleton::f5();{
        return false;
    return a.toString().contains(b.toString(), cs);
static bool AStartsWithB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
    if (! a.canConvert(QVariant::String) || ! b.canConvert(QVariant::String))
        return false;
}
void Singleton::f6();{
            invalidateFilter();
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
}
void Singleton::f7();{
        return false;
    return a.toString().contains(b.toString(), cs);
static bool AStartsWithB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
    if (! a.canConvert(QVariant::String) || ! b.canConvert(QVariant::String))
        return false;
}
void Singleton::f8();{
    return result;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f9();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
AStringListListModel::AStringListListModel(QObject * parent):
QAbstractTableModel(parent)
}
void Singleton::f10();{
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
    {
        columnsToFilter_.append(column);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            return QVariant::fromValue(data.at(index.column()));
    }
    else if (role == Qt::ToolTipRole)
    {
        QString tooltip = tooltip_data_.at(index.row());
}
void Singleton::f2();{
    return leftData.compare(rightData, sortCaseSensitivity()) < 0;
void AStringListListSortFilterProxyModel::setFilter(const QString & filter)
    filter_ = filter;
    invalidateFilter();
static bool AContainsB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            return QVariant::fromValue(data.at(index.column()));
    }
    else if (role == Qt::ToolTipRole)
    {
        QString tooltip = tooltip_data_.at(index.row());
}
void Singleton::f2();{
    return leftData.compare(rightData, sortCaseSensitivity()) < 0;
void AStringListListSortFilterProxyModel::setFilter(const QString & filter)
    filter_ = filter;
    invalidateFilter();
static bool AContainsB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
}
void Singleton::f3();{
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            return QVariant::fromValue(data.at(index.column()));
    }
    else if (role == Qt::ToolTipRole)
    {
        QString tooltip = tooltip_data_.at(index.row());
}
void Singleton::f2();{
    return leftData.compare(rightData, sortCaseSensitivity()) < 0;
void AStringListListSortFilterProxyModel::setFilter(const QString & filter)
    filter_ = filter;
    invalidateFilter();
static bool AContainsB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
}
void Singleton::f3();{
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
    {
}
void Singleton::f4();{
    if (role == Qt::ForegroundRole && urls_.contains(index.column())
            && result.canConvert(QVariant::Brush))
    {
        QBrush selected = result.value<QBrush>();
        selected.setColor(ColorUtils::themeLinkBrush().color());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            return QVariant::fromValue(data.at(index.column()));
    }
    else if (role == Qt::ToolTipRole)
    {
        QString tooltip = tooltip_data_.at(index.row());
}
void Singleton::f2();{
    return leftData.compare(rightData, sortCaseSensitivity()) < 0;
void AStringListListSortFilterProxyModel::setFilter(const QString & filter)
    filter_ = filter;
    invalidateFilter();
static bool AContainsB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
}
void Singleton::f3();{
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
    {
}
void Singleton::f4();{
    if (role == Qt::ForegroundRole && urls_.contains(index.column())
            && result.canConvert(QVariant::Brush))
    {
        QBrush selected = result.value<QBrush>();
        selected.setColor(ColorUtils::themeLinkBrush().color());
}
void Singleton::f5();{
        return false;
    return a.toString().contains(b.toString(), cs);
static bool AStartsWithB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
    if (! a.canConvert(QVariant::String) || ! b.canConvert(QVariant::String))
        return false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            return QVariant::fromValue(data.at(index.column()));
    }
    else if (role == Qt::ToolTipRole)
    {
        QString tooltip = tooltip_data_.at(index.row());
}
void Singleton::f2();{
    return leftData.compare(rightData, sortCaseSensitivity()) < 0;
void AStringListListSortFilterProxyModel::setFilter(const QString & filter)
    filter_ = filter;
    invalidateFilter();
static bool AContainsB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
}
void Singleton::f3();{
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
    {
}
void Singleton::f4();{
    if (role == Qt::ForegroundRole && urls_.contains(index.column())
            && result.canConvert(QVariant::Brush))
    {
        QBrush selected = result.value<QBrush>();
        selected.setColor(ColorUtils::themeLinkBrush().color());
}
void Singleton::f5();{
        return false;
    return a.toString().contains(b.toString(), cs);
static bool AStartsWithB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
    if (! a.canConvert(QVariant::String) || ! b.canConvert(QVariant::String))
        return false;
}
void Singleton::f6();{
            invalidateFilter();
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            return QVariant::fromValue(data.at(index.column()));
    }
    else if (role == Qt::ToolTipRole)
    {
        QString tooltip = tooltip_data_.at(index.row());
}
void Singleton::f2();{
    return leftData.compare(rightData, sortCaseSensitivity()) < 0;
void AStringListListSortFilterProxyModel::setFilter(const QString & filter)
    filter_ = filter;
    invalidateFilter();
static bool AContainsB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
}
void Singleton::f3();{
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
    {
}
void Singleton::f4();{
    if (role == Qt::ForegroundRole && urls_.contains(index.column())
            && result.canConvert(QVariant::Brush))
    {
        QBrush selected = result.value<QBrush>();
        selected.setColor(ColorUtils::themeLinkBrush().color());
}
void Singleton::f5();{
        return false;
    return a.toString().contains(b.toString(), cs);
static bool AStartsWithB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
    if (! a.canConvert(QVariant::String) || ! b.canConvert(QVariant::String))
        return false;
}
void Singleton::f6();{
            invalidateFilter();
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
}
void Singleton::f7();{
        return false;
    return a.toString().contains(b.toString(), cs);
static bool AStartsWithB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
    if (! a.canConvert(QVariant::String) || ! b.canConvert(QVariant::String))
        return false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            return QVariant::fromValue(data.at(index.column()));
    }
    else if (role == Qt::ToolTipRole)
    {
        QString tooltip = tooltip_data_.at(index.row());
}
void Singleton::f2();{
    return leftData.compare(rightData, sortCaseSensitivity()) < 0;
void AStringListListSortFilterProxyModel::setFilter(const QString & filter)
    filter_ = filter;
    invalidateFilter();
static bool AContainsB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
}
void Singleton::f3();{
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
    {
}
void Singleton::f4();{
    if (role == Qt::ForegroundRole && urls_.contains(index.column())
            && result.canConvert(QVariant::Brush))
    {
        QBrush selected = result.value<QBrush>();
        selected.setColor(ColorUtils::themeLinkBrush().color());
}
void Singleton::f5();{
        return false;
    return a.toString().contains(b.toString(), cs);
static bool AStartsWithB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
    if (! a.canConvert(QVariant::String) || ! b.canConvert(QVariant::String))
        return false;
}
void Singleton::f6();{
            invalidateFilter();
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
}
void Singleton::f7();{
        return false;
    return a.toString().contains(b.toString(), cs);
static bool AStartsWithB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
    if (! a.canConvert(QVariant::String) || ! b.canConvert(QVariant::String))
        return false;
}
void Singleton::f8();{
    return result;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            return QVariant::fromValue(data.at(index.column()));
    }
    else if (role == Qt::ToolTipRole)
    {
        QString tooltip = tooltip_data_.at(index.row());
}
void Singleton::f2();{
    return leftData.compare(rightData, sortCaseSensitivity()) < 0;
void AStringListListSortFilterProxyModel::setFilter(const QString & filter)
    filter_ = filter;
    invalidateFilter();
static bool AContainsB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
}
void Singleton::f3();{
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
    {
}
void Singleton::f4();{
    if (role == Qt::ForegroundRole && urls_.contains(index.column())
            && result.canConvert(QVariant::Brush))
    {
        QBrush selected = result.value<QBrush>();
        selected.setColor(ColorUtils::themeLinkBrush().color());
}
void Singleton::f5();{
        return false;
    return a.toString().contains(b.toString(), cs);
static bool AStartsWithB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
    if (! a.canConvert(QVariant::String) || ! b.canConvert(QVariant::String))
        return false;
}
void Singleton::f6();{
            invalidateFilter();
        }
    }
void AStringListListSortFilterProxyModel::setColumnToFilter(int column)
    if (column < columnCount() && ! columnsToFilter_.contains(column))
}
void Singleton::f7();{
        return false;
    return a.toString().contains(b.toString(), cs);
static bool AStartsWithB(const QVariant &a, const QVariant &b, Qt::CaseSensitivity cs)
    if (! a.canConvert(QVariant::String) || ! b.canConvert(QVariant::String))
        return false;
}
void Singleton::f8();{
    return result;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f9();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
AStringListListModel::AStringListListModel(QObject * parent):
QAbstractTableModel(parent)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
     **/
	int DoAttach(HMODULE module, bool isDebug, const char *command, bool showDebugInfo )
        auto isInit = reinterpret_cast<Py_IsInitialized*>(GetProcAddress(module, "Py_IsInitialized"));
        if (isInit == nullptr) {
            std::cerr << "Py_IsInitialized not found. " << std::endl << std::flush;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
     **/
	int DoAttach(HMODULE module, bool isDebug, const char *command, bool showDebugInfo )
        auto isInit = reinterpret_cast<Py_IsInitialized*>(GetProcAddress(module, "Py_IsInitialized"));
        if (isInit == nullptr) {
            std::cerr << "Py_IsInitialized not found. " << std::endl << std::flush;
}
void Singleton::f2();{
            }
        } else {
            if (showDebugInfo) {
                std::cout << "addPendingCall to initialize threads/import threading did NOT complete. " << std::endl << std::flush;
            }
}
void Singleton::f3();{
        }
        if (showDebugInfo) {
            std::cout << "Setting sys trace for existing threads failed with code: " << attached << "." << std::endl << std::flush;
        }
        return attached;
}
void Singleton::f4();{
std::wstring GetCurrentModuleFilename() {
    HMODULE hModule = nullptr;
    if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCTSTR)GetCurrentModuleFilename, &hModule) != 0) {
        wchar_t filename[MAX_PATH];
        GetModuleFileName(hModule, filename, MAX_PATH);
}
void Singleton::f5();{
                        initThreads();
                         if (version >= PythonVersion_32) {
                             // we will release the GIL here
                            gilRelease(gilState);
                         } else {
}
void Singleton::f6();{
        if (head == nullptr) {
            // this interpreter is loaded but not initialized.
            PRINT("Interpreter not initialized!");
            return 0;
        }
}
void Singleton::f7();{
        InitializeThreadingInfo *initializeThreadingInfo = new InitializeThreadingInfo();
        initializeThreadingInfo->pyImportMod = pyImportMod;
        initializeThreadingInfo->initThreads = initThreads;
        initializeThreadingInfo->initedEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
        // Add the call to initialize threading.
}
void Singleton::f8();{
            PRINT("Interpreter not initialized!");
            return 0;
        }
        auto version = GetPythonVersion(module);
        printf("Python version: %d\n", version);
}
void Singleton::f9();{
    std::mutex mutex;
    HANDLE initedEvent;  // Note: only access with mutex locked (and check if not already nullptr).
    bool completed; // Note: only access with mutex locked
int AttachCallback(void *voidInitializeThreadingInfo) {
    // initialize us for threading, this will acquire the GIL if not already created, and is a nop if the GIL is created.
}
void Singleton::f10();{
                        if (te.th32ThreadID != curThreadId && suspendedThreads.find(te.th32ThreadID) == suspendedThreads.end()) {
                            auto hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);
                            if (hThread != nullptr) {
                                SuspendThread(hThread);
                                bool addingPendingCall = false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
     **/
	int DoAttach(HMODULE module, bool isDebug, const char *command, bool showDebugInfo )
        auto isInit = reinterpret_cast<Py_IsInitialized*>(GetProcAddress(module, "Py_IsInitialized"));
        if (isInit == nullptr) {
            std::cerr << "Py_IsInitialized not found. " << std::endl << std::flush;
}
void Singleton::f2();{
            }
        } else {
            if (showDebugInfo) {
                std::cout << "addPendingCall to initialize threads/import threading did NOT complete. " << std::endl << std::flush;
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
     **/
	int DoAttach(HMODULE module, bool isDebug, const char *command, bool showDebugInfo )
        auto isInit = reinterpret_cast<Py_IsInitialized*>(GetProcAddress(module, "Py_IsInitialized"));
        if (isInit == nullptr) {
            std::cerr << "Py_IsInitialized not found. " << std::endl << std::flush;
}
void Singleton::f2();{
            }
        } else {
            if (showDebugInfo) {
                std::cout << "addPendingCall to initialize threads/import threading did NOT complete. " << std::endl << std::flush;
            }
}
void Singleton::f3();{
        }
        if (showDebugInfo) {
            std::cout << "Setting sys trace for existing threads failed with code: " << attached << "." << std::endl << std::flush;
        }
        return attached;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
     **/
	int DoAttach(HMODULE module, bool isDebug, const char *command, bool showDebugInfo )
        auto isInit = reinterpret_cast<Py_IsInitialized*>(GetProcAddress(module, "Py_IsInitialized"));
        if (isInit == nullptr) {
            std::cerr << "Py_IsInitialized not found. " << std::endl << std::flush;
}
void Singleton::f2();{
            }
        } else {
            if (showDebugInfo) {
                std::cout << "addPendingCall to initialize threads/import threading did NOT complete. " << std::endl << std::flush;
            }
}
void Singleton::f3();{
        }
        if (showDebugInfo) {
            std::cout << "Setting sys trace for existing threads failed with code: " << attached << "." << std::endl << std::flush;
        }
        return attached;
}
void Singleton::f4();{
std::wstring GetCurrentModuleFilename() {
    HMODULE hModule = nullptr;
    if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCTSTR)GetCurrentModuleFilename, &hModule) != 0) {
        wchar_t filename[MAX_PATH];
        GetModuleFileName(hModule, filename, MAX_PATH);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
     **/
	int DoAttach(HMODULE module, bool isDebug, const char *command, bool showDebugInfo )
        auto isInit = reinterpret_cast<Py_IsInitialized*>(GetProcAddress(module, "Py_IsInitialized"));
        if (isInit == nullptr) {
            std::cerr << "Py_IsInitialized not found. " << std::endl << std::flush;
}
void Singleton::f2();{
            }
        } else {
            if (showDebugInfo) {
                std::cout << "addPendingCall to initialize threads/import threading did NOT complete. " << std::endl << std::flush;
            }
}
void Singleton::f3();{
        }
        if (showDebugInfo) {
            std::cout << "Setting sys trace for existing threads failed with code: " << attached << "." << std::endl << std::flush;
        }
        return attached;
}
void Singleton::f4();{
std::wstring GetCurrentModuleFilename() {
    HMODULE hModule = nullptr;
    if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCTSTR)GetCurrentModuleFilename, &hModule) != 0) {
        wchar_t filename[MAX_PATH];
        GetModuleFileName(hModule, filename, MAX_PATH);
}
void Singleton::f5();{
                        initThreads();
                         if (version >= PythonVersion_32) {
                             // we will release the GIL here
                            gilRelease(gilState);
                         } else {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
     **/
	int DoAttach(HMODULE module, bool isDebug, const char *command, bool showDebugInfo )
        auto isInit = reinterpret_cast<Py_IsInitialized*>(GetProcAddress(module, "Py_IsInitialized"));
        if (isInit == nullptr) {
            std::cerr << "Py_IsInitialized not found. " << std::endl << std::flush;
}
void Singleton::f2();{
            }
        } else {
            if (showDebugInfo) {
                std::cout << "addPendingCall to initialize threads/import threading did NOT complete. " << std::endl << std::flush;
            }
}
void Singleton::f3();{
        }
        if (showDebugInfo) {
            std::cout << "Setting sys trace for existing threads failed with code: " << attached << "." << std::endl << std::flush;
        }
        return attached;
}
void Singleton::f4();{
std::wstring GetCurrentModuleFilename() {
    HMODULE hModule = nullptr;
    if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCTSTR)GetCurrentModuleFilename, &hModule) != 0) {
        wchar_t filename[MAX_PATH];
        GetModuleFileName(hModule, filename, MAX_PATH);
}
void Singleton::f5();{
                        initThreads();
                         if (version >= PythonVersion_32) {
                             // we will release the GIL here
                            gilRelease(gilState);
                         } else {
}
void Singleton::f6();{
        if (head == nullptr) {
            // this interpreter is loaded but not initialized.
            PRINT("Interpreter not initialized!");
            return 0;
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
     **/
	int DoAttach(HMODULE module, bool isDebug, const char *command, bool showDebugInfo )
        auto isInit = reinterpret_cast<Py_IsInitialized*>(GetProcAddress(module, "Py_IsInitialized"));
        if (isInit == nullptr) {
            std::cerr << "Py_IsInitialized not found. " << std::endl << std::flush;
}
void Singleton::f2();{
            }
        } else {
            if (showDebugInfo) {
                std::cout << "addPendingCall to initialize threads/import threading did NOT complete. " << std::endl << std::flush;
            }
}
void Singleton::f3();{
        }
        if (showDebugInfo) {
            std::cout << "Setting sys trace for existing threads failed with code: " << attached << "." << std::endl << std::flush;
        }
        return attached;
}
void Singleton::f4();{
std::wstring GetCurrentModuleFilename() {
    HMODULE hModule = nullptr;
    if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCTSTR)GetCurrentModuleFilename, &hModule) != 0) {
        wchar_t filename[MAX_PATH];
        GetModuleFileName(hModule, filename, MAX_PATH);
}
void Singleton::f5();{
                        initThreads();
                         if (version >= PythonVersion_32) {
                             // we will release the GIL here
                            gilRelease(gilState);
                         } else {
}
void Singleton::f6();{
        if (head == nullptr) {
            // this interpreter is loaded but not initialized.
            PRINT("Interpreter not initialized!");
            return 0;
        }
}
void Singleton::f7();{
        InitializeThreadingInfo *initializeThreadingInfo = new InitializeThreadingInfo();
        initializeThreadingInfo->pyImportMod = pyImportMod;
        initializeThreadingInfo->initThreads = initThreads;
        initializeThreadingInfo->initedEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
        // Add the call to initialize threading.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
     **/
	int DoAttach(HMODULE module, bool isDebug, const char *command, bool showDebugInfo )
        auto isInit = reinterpret_cast<Py_IsInitialized*>(GetProcAddress(module, "Py_IsInitialized"));
        if (isInit == nullptr) {
            std::cerr << "Py_IsInitialized not found. " << std::endl << std::flush;
}
void Singleton::f2();{
            }
        } else {
            if (showDebugInfo) {
                std::cout << "addPendingCall to initialize threads/import threading did NOT complete. " << std::endl << std::flush;
            }
}
void Singleton::f3();{
        }
        if (showDebugInfo) {
            std::cout << "Setting sys trace for existing threads failed with code: " << attached << "." << std::endl << std::flush;
        }
        return attached;
}
void Singleton::f4();{
std::wstring GetCurrentModuleFilename() {
    HMODULE hModule = nullptr;
    if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCTSTR)GetCurrentModuleFilename, &hModule) != 0) {
        wchar_t filename[MAX_PATH];
        GetModuleFileName(hModule, filename, MAX_PATH);
}
void Singleton::f5();{
                        initThreads();
                         if (version >= PythonVersion_32) {
                             // we will release the GIL here
                            gilRelease(gilState);
                         } else {
}
void Singleton::f6();{
        if (head == nullptr) {
            // this interpreter is loaded but not initialized.
            PRINT("Interpreter not initialized!");
            return 0;
        }
}
void Singleton::f7();{
        InitializeThreadingInfo *initializeThreadingInfo = new InitializeThreadingInfo();
        initializeThreadingInfo->pyImportMod = pyImportMod;
        initializeThreadingInfo->initThreads = initThreads;
        initializeThreadingInfo->initedEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
        // Add the call to initialize threading.
}
void Singleton::f8();{
            PRINT("Interpreter not initialized!");
            return 0;
        }
        auto version = GetPythonVersion(module);
        printf("Python version: %d\n", version);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
     **/
	int DoAttach(HMODULE module, bool isDebug, const char *command, bool showDebugInfo )
        auto isInit = reinterpret_cast<Py_IsInitialized*>(GetProcAddress(module, "Py_IsInitialized"));
        if (isInit == nullptr) {
            std::cerr << "Py_IsInitialized not found. " << std::endl << std::flush;
}
void Singleton::f2();{
            }
        } else {
            if (showDebugInfo) {
                std::cout << "addPendingCall to initialize threads/import threading did NOT complete. " << std::endl << std::flush;
            }
}
void Singleton::f3();{
        }
        if (showDebugInfo) {
            std::cout << "Setting sys trace for existing threads failed with code: " << attached << "." << std::endl << std::flush;
        }
        return attached;
}
void Singleton::f4();{
std::wstring GetCurrentModuleFilename() {
    HMODULE hModule = nullptr;
    if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (LPCTSTR)GetCurrentModuleFilename, &hModule) != 0) {
        wchar_t filename[MAX_PATH];
        GetModuleFileName(hModule, filename, MAX_PATH);
}
void Singleton::f5();{
                        initThreads();
                         if (version >= PythonVersion_32) {
                             // we will release the GIL here
                            gilRelease(gilState);
                         } else {
}
void Singleton::f6();{
        if (head == nullptr) {
            // this interpreter is loaded but not initialized.
            PRINT("Interpreter not initialized!");
            return 0;
        }
}
void Singleton::f7();{
        InitializeThreadingInfo *initializeThreadingInfo = new InitializeThreadingInfo();
        initializeThreadingInfo->pyImportMod = pyImportMod;
        initializeThreadingInfo->initThreads = initThreads;
        initializeThreadingInfo->initedEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
        // Add the call to initialize threading.
}
void Singleton::f8();{
            PRINT("Interpreter not initialized!");
            return 0;
        }
        auto version = GetPythonVersion(module);
        printf("Python version: %d\n", version);
}
void Singleton::f9();{
    std::mutex mutex;
    HANDLE initedEvent;  // Note: only access with mutex locked (and check if not already nullptr).
    bool completed; // Note: only access with mutex locked
int AttachCallback(void *voidInitializeThreadingInfo) {
    // initialize us for threading, this will acquire the GIL if not already created, and is a nop if the GIL is created.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->rec_type != REC_TYPE_PACKET)
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID) {
        gchar       *interface;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->rec_type != REC_TYPE_PACKET)
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID) {
        gchar       *interface;
}
void Singleton::f2();{
                           tr("PNG Image (*.png)"));
    if (fileName.isEmpty()) return;
    image = ui->tableTreeWidget->grab();
    image.save(fileName, "PNG");
void BluetoothAttServerAttributesDialog::on_buttonBox_clicked(QAbstractButton *)
}
void Singleton::f3();{
    QTreeWidgetItem *item = new QTreeWidgetItem(dialog->ui->tableTreeWidget);
    item->setText(column_number_handle, handle);
    item->setText(column_number_uuid, uuid);
    item->setText(column_number_uuid_name,  uuid_name);
    item->setData(0, Qt::UserRole, QVariant::fromValue(pinfo->num));
}
void Singleton::f4();{
    if (current_item->background(ui->tableTreeWidget->currentColumn()) == QBrush(ColorUtils::fromColorT(&prefs.gui_marked_bg))) {
        fg = QBrush();
        bg = QBrush();
    } else {
        fg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_fg));
}
void Singleton::f5();{
    if (0 != event)
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
}
void Singleton::f6();{
            return TAP_PACKET_REDRAW;
    }
    handle = QString("0x%1").arg(tap_handles->handle, 4, 16, QChar('0'));
    uuid = QString(print_numeric_uuid(&tap_handles->uuid));
    uuid_name = QString(print_uuid(&tap_handles->uuid));
}
void Singleton::f7();{
                .arg((*i_item)->text(column_number_handle), -6)
                .arg((*i_item)->text(column_number_uuid), -32)
                .arg((*i_item)->text(column_number_uuid_name));
    }
    clipboard->setText(copy);
}
void Singleton::f8();{
        fg = QBrush();
        bg = QBrush();
    } else {
        fg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_fg));
        bg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_bg));
}
void Singleton::f9();{
    image = ui->tableTreeWidget->grab();
    image.save(fileName, "PNG");
void BluetoothAttServerAttributesDialog::on_buttonBox_clicked(QAbstractButton *)
/*    if (button == foo_button_) */
 * Editor modelines
}
void Singleton::f10();{
    }
    if (addr && dialog->ui->deviceComboBox->currentIndex() > 0) {
        if (dialog->ui->deviceComboBox->currentText() != addr)
            return TAP_PACKET_REDRAW;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->rec_type != REC_TYPE_PACKET)
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID) {
        gchar       *interface;
}
void Singleton::f2();{
                           tr("PNG Image (*.png)"));
    if (fileName.isEmpty()) return;
    image = ui->tableTreeWidget->grab();
    image.save(fileName, "PNG");
void BluetoothAttServerAttributesDialog::on_buttonBox_clicked(QAbstractButton *)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->rec_type != REC_TYPE_PACKET)
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID) {
        gchar       *interface;
}
void Singleton::f2();{
                           tr("PNG Image (*.png)"));
    if (fileName.isEmpty()) return;
    image = ui->tableTreeWidget->grab();
    image.save(fileName, "PNG");
void BluetoothAttServerAttributesDialog::on_buttonBox_clicked(QAbstractButton *)
}
void Singleton::f3();{
    QTreeWidgetItem *item = new QTreeWidgetItem(dialog->ui->tableTreeWidget);
    item->setText(column_number_handle, handle);
    item->setText(column_number_uuid, uuid);
    item->setText(column_number_uuid_name,  uuid_name);
    item->setData(0, Qt::UserRole, QVariant::fromValue(pinfo->num));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->rec_type != REC_TYPE_PACKET)
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID) {
        gchar       *interface;
}
void Singleton::f2();{
                           tr("PNG Image (*.png)"));
    if (fileName.isEmpty()) return;
    image = ui->tableTreeWidget->grab();
    image.save(fileName, "PNG");
void BluetoothAttServerAttributesDialog::on_buttonBox_clicked(QAbstractButton *)
}
void Singleton::f3();{
    QTreeWidgetItem *item = new QTreeWidgetItem(dialog->ui->tableTreeWidget);
    item->setText(column_number_handle, handle);
    item->setText(column_number_uuid, uuid);
    item->setText(column_number_uuid_name,  uuid_name);
    item->setData(0, Qt::UserRole, QVariant::fromValue(pinfo->num));
}
void Singleton::f4();{
    if (current_item->background(ui->tableTreeWidget->currentColumn()) == QBrush(ColorUtils::fromColorT(&prefs.gui_marked_bg))) {
        fg = QBrush();
        bg = QBrush();
    } else {
        fg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_fg));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->rec_type != REC_TYPE_PACKET)
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID) {
        gchar       *interface;
}
void Singleton::f2();{
                           tr("PNG Image (*.png)"));
    if (fileName.isEmpty()) return;
    image = ui->tableTreeWidget->grab();
    image.save(fileName, "PNG");
void BluetoothAttServerAttributesDialog::on_buttonBox_clicked(QAbstractButton *)
}
void Singleton::f3();{
    QTreeWidgetItem *item = new QTreeWidgetItem(dialog->ui->tableTreeWidget);
    item->setText(column_number_handle, handle);
    item->setText(column_number_uuid, uuid);
    item->setText(column_number_uuid_name,  uuid_name);
    item->setData(0, Qt::UserRole, QVariant::fromValue(pinfo->num));
}
void Singleton::f4();{
    if (current_item->background(ui->tableTreeWidget->currentColumn()) == QBrush(ColorUtils::fromColorT(&prefs.gui_marked_bg))) {
        fg = QBrush();
        bg = QBrush();
    } else {
        fg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_fg));
}
void Singleton::f5();{
    if (0 != event)
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->rec_type != REC_TYPE_PACKET)
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID) {
        gchar       *interface;
}
void Singleton::f2();{
                           tr("PNG Image (*.png)"));
    if (fileName.isEmpty()) return;
    image = ui->tableTreeWidget->grab();
    image.save(fileName, "PNG");
void BluetoothAttServerAttributesDialog::on_buttonBox_clicked(QAbstractButton *)
}
void Singleton::f3();{
    QTreeWidgetItem *item = new QTreeWidgetItem(dialog->ui->tableTreeWidget);
    item->setText(column_number_handle, handle);
    item->setText(column_number_uuid, uuid);
    item->setText(column_number_uuid_name,  uuid_name);
    item->setData(0, Qt::UserRole, QVariant::fromValue(pinfo->num));
}
void Singleton::f4();{
    if (current_item->background(ui->tableTreeWidget->currentColumn()) == QBrush(ColorUtils::fromColorT(&prefs.gui_marked_bg))) {
        fg = QBrush();
        bg = QBrush();
    } else {
        fg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_fg));
}
void Singleton::f5();{
    if (0 != event)
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
}
void Singleton::f6();{
            return TAP_PACKET_REDRAW;
    }
    handle = QString("0x%1").arg(tap_handles->handle, 4, 16, QChar('0'));
    uuid = QString(print_numeric_uuid(&tap_handles->uuid));
    uuid_name = QString(print_uuid(&tap_handles->uuid));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->rec_type != REC_TYPE_PACKET)
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID) {
        gchar       *interface;
}
void Singleton::f2();{
                           tr("PNG Image (*.png)"));
    if (fileName.isEmpty()) return;
    image = ui->tableTreeWidget->grab();
    image.save(fileName, "PNG");
void BluetoothAttServerAttributesDialog::on_buttonBox_clicked(QAbstractButton *)
}
void Singleton::f3();{
    QTreeWidgetItem *item = new QTreeWidgetItem(dialog->ui->tableTreeWidget);
    item->setText(column_number_handle, handle);
    item->setText(column_number_uuid, uuid);
    item->setText(column_number_uuid_name,  uuid_name);
    item->setData(0, Qt::UserRole, QVariant::fromValue(pinfo->num));
}
void Singleton::f4();{
    if (current_item->background(ui->tableTreeWidget->currentColumn()) == QBrush(ColorUtils::fromColorT(&prefs.gui_marked_bg))) {
        fg = QBrush();
        bg = QBrush();
    } else {
        fg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_fg));
}
void Singleton::f5();{
    if (0 != event)
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
}
void Singleton::f6();{
            return TAP_PACKET_REDRAW;
    }
    handle = QString("0x%1").arg(tap_handles->handle, 4, 16, QChar('0'));
    uuid = QString(print_numeric_uuid(&tap_handles->uuid));
    uuid_name = QString(print_uuid(&tap_handles->uuid));
}
void Singleton::f7();{
                .arg((*i_item)->text(column_number_handle), -6)
                .arg((*i_item)->text(column_number_uuid), -32)
                .arg((*i_item)->text(column_number_uuid_name));
    }
    clipboard->setText(copy);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->rec_type != REC_TYPE_PACKET)
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID) {
        gchar       *interface;
}
void Singleton::f2();{
                           tr("PNG Image (*.png)"));
    if (fileName.isEmpty()) return;
    image = ui->tableTreeWidget->grab();
    image.save(fileName, "PNG");
void BluetoothAttServerAttributesDialog::on_buttonBox_clicked(QAbstractButton *)
}
void Singleton::f3();{
    QTreeWidgetItem *item = new QTreeWidgetItem(dialog->ui->tableTreeWidget);
    item->setText(column_number_handle, handle);
    item->setText(column_number_uuid, uuid);
    item->setText(column_number_uuid_name,  uuid_name);
    item->setData(0, Qt::UserRole, QVariant::fromValue(pinfo->num));
}
void Singleton::f4();{
    if (current_item->background(ui->tableTreeWidget->currentColumn()) == QBrush(ColorUtils::fromColorT(&prefs.gui_marked_bg))) {
        fg = QBrush();
        bg = QBrush();
    } else {
        fg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_fg));
}
void Singleton::f5();{
    if (0 != event)
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
}
void Singleton::f6();{
            return TAP_PACKET_REDRAW;
    }
    handle = QString("0x%1").arg(tap_handles->handle, 4, 16, QChar('0'));
    uuid = QString(print_numeric_uuid(&tap_handles->uuid));
    uuid_name = QString(print_uuid(&tap_handles->uuid));
}
void Singleton::f7();{
                .arg((*i_item)->text(column_number_handle), -6)
                .arg((*i_item)->text(column_number_uuid), -32)
                .arg((*i_item)->text(column_number_uuid_name));
    }
    clipboard->setText(copy);
}
void Singleton::f8();{
        fg = QBrush();
        bg = QBrush();
    } else {
        fg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_fg));
        bg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_bg));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->rec_type != REC_TYPE_PACKET)
        return TAP_PACKET_DONT_REDRAW;
    if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID) {
        gchar       *interface;
}
void Singleton::f2();{
                           tr("PNG Image (*.png)"));
    if (fileName.isEmpty()) return;
    image = ui->tableTreeWidget->grab();
    image.save(fileName, "PNG");
void BluetoothAttServerAttributesDialog::on_buttonBox_clicked(QAbstractButton *)
}
void Singleton::f3();{
    QTreeWidgetItem *item = new QTreeWidgetItem(dialog->ui->tableTreeWidget);
    item->setText(column_number_handle, handle);
    item->setText(column_number_uuid, uuid);
    item->setText(column_number_uuid_name,  uuid_name);
    item->setData(0, Qt::UserRole, QVariant::fromValue(pinfo->num));
}
void Singleton::f4();{
    if (current_item->background(ui->tableTreeWidget->currentColumn()) == QBrush(ColorUtils::fromColorT(&prefs.gui_marked_bg))) {
        fg = QBrush();
        bg = QBrush();
    } else {
        fg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_fg));
}
void Singleton::f5();{
    if (0 != event)
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
}
void Singleton::f6();{
            return TAP_PACKET_REDRAW;
    }
    handle = QString("0x%1").arg(tap_handles->handle, 4, 16, QChar('0'));
    uuid = QString(print_numeric_uuid(&tap_handles->uuid));
    uuid_name = QString(print_uuid(&tap_handles->uuid));
}
void Singleton::f7();{
                .arg((*i_item)->text(column_number_handle), -6)
                .arg((*i_item)->text(column_number_uuid), -32)
                .arg((*i_item)->text(column_number_uuid_name));
    }
    clipboard->setText(copy);
}
void Singleton::f8();{
        fg = QBrush();
        bg = QBrush();
    } else {
        fg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_fg));
        bg = QBrush(ColorUtils::fromColorT(&prefs.gui_marked_bg));
}
void Singleton::f9();{
    image = ui->tableTreeWidget->grab();
    image.save(fileName, "PNG");
void BluetoothAttServerAttributesDialog::on_buttonBox_clicked(QAbstractButton *)
/*    if (button == foo_button_) */
 * Editor modelines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        item->setText(column_number_manufacturer,   val_to_str_ext_const(tap_device->data.local_version.manufacturer, &bluetooth_company_id_vals_ext, "Unknown 0x%04x"));
    }
    if (tap_device->type == BLUETOOTH_DEVICE_REMOTE_VERSION) {
        item->setText(column_number_lmp_version,    val_to_str_const(tap_device->data.remote_version.lmp_version, bthci_evt_lmp_version, "Unknown 0x%02x"));
        item->setText(column_number_lmp_subversion, QString::number(tap_device->data.remote_version.lmp_subversion));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        item->setText(column_number_manufacturer,   val_to_str_ext_const(tap_device->data.local_version.manufacturer, &bluetooth_company_id_vals_ext, "Unknown 0x%04x"));
    }
    if (tap_device->type == BLUETOOTH_DEVICE_REMOTE_VERSION) {
        item->setText(column_number_lmp_version,    val_to_str_const(tap_device->data.remote_version.lmp_version, bthci_evt_lmp_version, "Unknown 0x%02x"));
        item->setText(column_number_lmp_subversion, QString::number(tap_device->data.remote_version.lmp_subversion));
}
void Singleton::f2();{
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
/* * - reimplement shortcuts from contex menu */
   if (event->modifiers() & Qt::ControlModifier && event->key()== Qt::Key_M)
}
void Singleton::f3();{
                .arg((*i_item)->text(column_number_name), -30)
                .arg((*i_item)->text(column_number_lmp_version), -20)
                .arg((*i_item)->text(column_number_lmp_subversion), -20)
                .arg((*i_item)->text(column_number_manufacturer), -30)
                .arg((*i_item)->text(column_number_hci_version), -20)
}
void Singleton::f4();{
    }
    QDialog::changeEvent(event);
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
}
void Singleton::f5();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f6();{
    QPixmap image;
    QString fileName = WiresharkFileDialog::getSaveFileName(this,
            tr("Save Table Image"),
            "bluetooth_devices_table.png",
            tr("PNG Image (*.png)"));
}
void Singleton::f7();{
                .arg(item->text(column_number_bd_addr_oui), -20)
                .arg(item->text(column_number_name), -30)
                .arg(item->text(column_number_lmp_version), -20)
                .arg(item->text(column_number_lmp_subversion), -20)
                .arg(item->text(column_number_manufacturer), -30)
}
void Singleton::f8();{
                .arg((*i_item)->text(column_number_bd_addr_oui), -20)
                .arg((*i_item)->text(column_number_name), -30)
                .arg((*i_item)->text(column_number_lmp_version), -20)
                .arg((*i_item)->text(column_number_lmp_subversion), -20)
                .arg((*i_item)->text(column_number_manufacturer), -30)
}
void Singleton::f9();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f10();{
    }
    if (tap_device->type == BLUETOOTH_DEVICE_BD_ADDR) {
        item->setText(column_number_bd_addr, bd_addr);
        item->setText(column_number_bd_addr_oui, bd_addr_oui);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        item->setText(column_number_manufacturer,   val_to_str_ext_const(tap_device->data.local_version.manufacturer, &bluetooth_company_id_vals_ext, "Unknown 0x%04x"));
    }
    if (tap_device->type == BLUETOOTH_DEVICE_REMOTE_VERSION) {
        item->setText(column_number_lmp_version,    val_to_str_const(tap_device->data.remote_version.lmp_version, bthci_evt_lmp_version, "Unknown 0x%02x"));
        item->setText(column_number_lmp_subversion, QString::number(tap_device->data.remote_version.lmp_subversion));
}
void Singleton::f2();{
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
/* * - reimplement shortcuts from contex menu */
   if (event->modifiers() & Qt::ControlModifier && event->key()== Qt::Key_M)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        item->setText(column_number_manufacturer,   val_to_str_ext_const(tap_device->data.local_version.manufacturer, &bluetooth_company_id_vals_ext, "Unknown 0x%04x"));
    }
    if (tap_device->type == BLUETOOTH_DEVICE_REMOTE_VERSION) {
        item->setText(column_number_lmp_version,    val_to_str_const(tap_device->data.remote_version.lmp_version, bthci_evt_lmp_version, "Unknown 0x%02x"));
        item->setText(column_number_lmp_subversion, QString::number(tap_device->data.remote_version.lmp_subversion));
}
void Singleton::f2();{
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
/* * - reimplement shortcuts from contex menu */
   if (event->modifiers() & Qt::ControlModifier && event->key()== Qt::Key_M)
}
void Singleton::f3();{
                .arg((*i_item)->text(column_number_name), -30)
                .arg((*i_item)->text(column_number_lmp_version), -20)
                .arg((*i_item)->text(column_number_lmp_subversion), -20)
                .arg((*i_item)->text(column_number_manufacturer), -30)
                .arg((*i_item)->text(column_number_hci_version), -20)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        item->setText(column_number_manufacturer,   val_to_str_ext_const(tap_device->data.local_version.manufacturer, &bluetooth_company_id_vals_ext, "Unknown 0x%04x"));
    }
    if (tap_device->type == BLUETOOTH_DEVICE_REMOTE_VERSION) {
        item->setText(column_number_lmp_version,    val_to_str_const(tap_device->data.remote_version.lmp_version, bthci_evt_lmp_version, "Unknown 0x%02x"));
        item->setText(column_number_lmp_subversion, QString::number(tap_device->data.remote_version.lmp_subversion));
}
void Singleton::f2();{
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
/* * - reimplement shortcuts from contex menu */
   if (event->modifiers() & Qt::ControlModifier && event->key()== Qt::Key_M)
}
void Singleton::f3();{
                .arg((*i_item)->text(column_number_name), -30)
                .arg((*i_item)->text(column_number_lmp_version), -20)
                .arg((*i_item)->text(column_number_lmp_subversion), -20)
                .arg((*i_item)->text(column_number_manufacturer), -30)
                .arg((*i_item)->text(column_number_hci_version), -20)
}
void Singleton::f4();{
    }
    QDialog::changeEvent(event);
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        item->setText(column_number_manufacturer,   val_to_str_ext_const(tap_device->data.local_version.manufacturer, &bluetooth_company_id_vals_ext, "Unknown 0x%04x"));
    }
    if (tap_device->type == BLUETOOTH_DEVICE_REMOTE_VERSION) {
        item->setText(column_number_lmp_version,    val_to_str_const(tap_device->data.remote_version.lmp_version, bthci_evt_lmp_version, "Unknown 0x%02x"));
        item->setText(column_number_lmp_subversion, QString::number(tap_device->data.remote_version.lmp_subversion));
}
void Singleton::f2();{
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
/* * - reimplement shortcuts from contex menu */
   if (event->modifiers() & Qt::ControlModifier && event->key()== Qt::Key_M)
}
void Singleton::f3();{
                .arg((*i_item)->text(column_number_name), -30)
                .arg((*i_item)->text(column_number_lmp_version), -20)
                .arg((*i_item)->text(column_number_lmp_subversion), -20)
                .arg((*i_item)->text(column_number_manufacturer), -30)
                .arg((*i_item)->text(column_number_hci_version), -20)
}
void Singleton::f4();{
    }
    QDialog::changeEvent(event);
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
}
void Singleton::f5();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        item->setText(column_number_manufacturer,   val_to_str_ext_const(tap_device->data.local_version.manufacturer, &bluetooth_company_id_vals_ext, "Unknown 0x%04x"));
    }
    if (tap_device->type == BLUETOOTH_DEVICE_REMOTE_VERSION) {
        item->setText(column_number_lmp_version,    val_to_str_const(tap_device->data.remote_version.lmp_version, bthci_evt_lmp_version, "Unknown 0x%02x"));
        item->setText(column_number_lmp_subversion, QString::number(tap_device->data.remote_version.lmp_subversion));
}
void Singleton::f2();{
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
/* * - reimplement shortcuts from contex menu */
   if (event->modifiers() & Qt::ControlModifier && event->key()== Qt::Key_M)
}
void Singleton::f3();{
                .arg((*i_item)->text(column_number_name), -30)
                .arg((*i_item)->text(column_number_lmp_version), -20)
                .arg((*i_item)->text(column_number_lmp_subversion), -20)
                .arg((*i_item)->text(column_number_manufacturer), -30)
                .arg((*i_item)->text(column_number_hci_version), -20)
}
void Singleton::f4();{
    }
    QDialog::changeEvent(event);
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
}
void Singleton::f5();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f6();{
    QPixmap image;
    QString fileName = WiresharkFileDialog::getSaveFileName(this,
            tr("Save Table Image"),
            "bluetooth_devices_table.png",
            tr("PNG Image (*.png)"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        item->setText(column_number_manufacturer,   val_to_str_ext_const(tap_device->data.local_version.manufacturer, &bluetooth_company_id_vals_ext, "Unknown 0x%04x"));
    }
    if (tap_device->type == BLUETOOTH_DEVICE_REMOTE_VERSION) {
        item->setText(column_number_lmp_version,    val_to_str_const(tap_device->data.remote_version.lmp_version, bthci_evt_lmp_version, "Unknown 0x%02x"));
        item->setText(column_number_lmp_subversion, QString::number(tap_device->data.remote_version.lmp_subversion));
}
void Singleton::f2();{
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
/* * - reimplement shortcuts from contex menu */
   if (event->modifiers() & Qt::ControlModifier && event->key()== Qt::Key_M)
}
void Singleton::f3();{
                .arg((*i_item)->text(column_number_name), -30)
                .arg((*i_item)->text(column_number_lmp_version), -20)
                .arg((*i_item)->text(column_number_lmp_subversion), -20)
                .arg((*i_item)->text(column_number_manufacturer), -30)
                .arg((*i_item)->text(column_number_hci_version), -20)
}
void Singleton::f4();{
    }
    QDialog::changeEvent(event);
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
}
void Singleton::f5();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f6();{
    QPixmap image;
    QString fileName = WiresharkFileDialog::getSaveFileName(this,
            tr("Save Table Image"),
            "bluetooth_devices_table.png",
            tr("PNG Image (*.png)"));
}
void Singleton::f7();{
                .arg(item->text(column_number_bd_addr_oui), -20)
                .arg(item->text(column_number_name), -30)
                .arg(item->text(column_number_lmp_version), -20)
                .arg(item->text(column_number_lmp_subversion), -20)
                .arg(item->text(column_number_manufacturer), -30)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        item->setText(column_number_manufacturer,   val_to_str_ext_const(tap_device->data.local_version.manufacturer, &bluetooth_company_id_vals_ext, "Unknown 0x%04x"));
    }
    if (tap_device->type == BLUETOOTH_DEVICE_REMOTE_VERSION) {
        item->setText(column_number_lmp_version,    val_to_str_const(tap_device->data.remote_version.lmp_version, bthci_evt_lmp_version, "Unknown 0x%02x"));
        item->setText(column_number_lmp_subversion, QString::number(tap_device->data.remote_version.lmp_subversion));
}
void Singleton::f2();{
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
/* * - reimplement shortcuts from contex menu */
   if (event->modifiers() & Qt::ControlModifier && event->key()== Qt::Key_M)
}
void Singleton::f3();{
                .arg((*i_item)->text(column_number_name), -30)
                .arg((*i_item)->text(column_number_lmp_version), -20)
                .arg((*i_item)->text(column_number_lmp_subversion), -20)
                .arg((*i_item)->text(column_number_manufacturer), -30)
                .arg((*i_item)->text(column_number_hci_version), -20)
}
void Singleton::f4();{
    }
    QDialog::changeEvent(event);
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
}
void Singleton::f5();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f6();{
    QPixmap image;
    QString fileName = WiresharkFileDialog::getSaveFileName(this,
            tr("Save Table Image"),
            "bluetooth_devices_table.png",
            tr("PNG Image (*.png)"));
}
void Singleton::f7();{
                .arg(item->text(column_number_bd_addr_oui), -20)
                .arg(item->text(column_number_name), -30)
                .arg(item->text(column_number_lmp_version), -20)
                .arg(item->text(column_number_lmp_subversion), -20)
                .arg(item->text(column_number_manufacturer), -30)
}
void Singleton::f8();{
                .arg((*i_item)->text(column_number_bd_addr_oui), -20)
                .arg((*i_item)->text(column_number_name), -30)
                .arg((*i_item)->text(column_number_lmp_version), -20)
                .arg((*i_item)->text(column_number_lmp_subversion), -20)
                .arg((*i_item)->text(column_number_manufacturer), -30)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        item->setText(column_number_manufacturer,   val_to_str_ext_const(tap_device->data.local_version.manufacturer, &bluetooth_company_id_vals_ext, "Unknown 0x%04x"));
    }
    if (tap_device->type == BLUETOOTH_DEVICE_REMOTE_VERSION) {
        item->setText(column_number_lmp_version,    val_to_str_const(tap_device->data.remote_version.lmp_version, bthci_evt_lmp_version, "Unknown 0x%02x"));
        item->setText(column_number_lmp_subversion, QString::number(tap_device->data.remote_version.lmp_subversion));
}
void Singleton::f2();{
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
/* * - reimplement shortcuts from contex menu */
   if (event->modifiers() & Qt::ControlModifier && event->key()== Qt::Key_M)
}
void Singleton::f3();{
                .arg((*i_item)->text(column_number_name), -30)
                .arg((*i_item)->text(column_number_lmp_version), -20)
                .arg((*i_item)->text(column_number_lmp_subversion), -20)
                .arg((*i_item)->text(column_number_manufacturer), -30)
                .arg((*i_item)->text(column_number_hci_version), -20)
}
void Singleton::f4();{
    }
    QDialog::changeEvent(event);
void BluetoothDevicesDialog::keyPressEvent(QKeyEvent *event)
/* NOTE: Do nothing*, but in real it "takes focus" from button_box so allow user
 * to use Enter button to jump to frame from tree widget */
}
void Singleton::f5();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f6();{
    QPixmap image;
    QString fileName = WiresharkFileDialog::getSaveFileName(this,
            tr("Save Table Image"),
            "bluetooth_devices_table.png",
            tr("PNG Image (*.png)"));
}
void Singleton::f7();{
                .arg(item->text(column_number_bd_addr_oui), -20)
                .arg(item->text(column_number_name), -30)
                .arg(item->text(column_number_lmp_version), -20)
                .arg(item->text(column_number_lmp_subversion), -20)
                .arg(item->text(column_number_manufacturer), -30)
}
void Singleton::f8();{
                .arg((*i_item)->text(column_number_bd_addr_oui), -20)
                .arg((*i_item)->text(column_number_name), -30)
                .arg((*i_item)->text(column_number_lmp_version), -20)
                .arg((*i_item)->text(column_number_lmp_subversion), -20)
                .arg((*i_item)->text(column_number_manufacturer), -30)
}
void Singleton::f9();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        updateChanges(tableWidget, field, row_number_le_iso_packets, tapinfo->changes, pinfo);
        item->setText(field);
        break;
    }
    dialog->ui->hintLabel->setText(QString(tr("%1 changes")).arg(*tapinfo->changes));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        updateChanges(tableWidget, field, row_number_le_iso_packets, tapinfo->changes, pinfo);
        item->setText(field);
        break;
    }
    dialog->ui->hintLabel->setText(QString(tr("%1 changes")).arg(*tapinfo->changes));
}
void Singleton::f2();{
            bluetooth_item_data_t       *item_data;
            item = dialog->ui->tableWidget->item(i_row, column_number_value);
            saveItemData(item, tap_device, pinfo);
            item_data = VariantPointer<bluetooth_item_data_t>::asPtr(item->data(Qt::UserRole));
            if (item_data->changes > -1) {
}
void Singleton::f3();{
        }
    }
    clipboard->setText(copy);
void BluetoothDeviceDialog::tapReset(void *tapinfo_ptr)
    bluetooth_device_tapinfo_t *tapinfo = (bluetooth_device_tapinfo_t *) tapinfo_ptr;
}
void Singleton::f4();{
        copy += QString("%1  %2  %3\n")
                .arg(ui->tableWidget->verticalHeaderItem((*i_item)->row())->text(), -40)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_value)->text(), -50)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_changes)->text(), -10);
    }
}
void Singleton::f5();{
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
            ui->retranslateUi(this);
}
void Singleton::f6();{
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_Cell);
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_Rows);
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_All);
    context_menu_.addActions(QList<QAction *>() << ui->actionSave_as_image);
    changes_ = 0;
}
void Singleton::f7();{
        if (!tap_device->is_local && bd_addr != tapinfo->bdAddr)
            return TAP_PACKET_REDRAW;
        manuf = get_ether_name(tap_device->bd_addr);
        if (manuf) {
            int pos;
}
void Singleton::f8();{
    if (!((!tap_device->is_local && tap_device->has_bd_addr) || (tap_device->is_local && tapinfo->is_local && tap_device->interface_id == tapinfo->interface_id && tap_device->adapter_id == tapinfo->adapter_id))) {
        return TAP_PACKET_REDRAW;
    }
    if (tap_device->has_bd_addr) {
        for (int i = 0; i < 6; ++i) {
}
void Singleton::f9();{
            0,
            bluetooth_device_tap_reset,
            bluetooth_device_tap_packet,
            NULL,
            NULL
}
void Singleton::f10();{
        saveItemData(item, tap_device, pinfo);
        updateChanges(tableWidget, field, row_number_authentication, tapinfo->changes, pinfo);
        item->setText(field);
        break;
    case BLUETOOTH_DEVICE_ENCRYPTION:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        updateChanges(tableWidget, field, row_number_le_iso_packets, tapinfo->changes, pinfo);
        item->setText(field);
        break;
    }
    dialog->ui->hintLabel->setText(QString(tr("%1 changes")).arg(*tapinfo->changes));
}
void Singleton::f2();{
            bluetooth_item_data_t       *item_data;
            item = dialog->ui->tableWidget->item(i_row, column_number_value);
            saveItemData(item, tap_device, pinfo);
            item_data = VariantPointer<bluetooth_item_data_t>::asPtr(item->data(Qt::UserRole));
            if (item_data->changes > -1) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        updateChanges(tableWidget, field, row_number_le_iso_packets, tapinfo->changes, pinfo);
        item->setText(field);
        break;
    }
    dialog->ui->hintLabel->setText(QString(tr("%1 changes")).arg(*tapinfo->changes));
}
void Singleton::f2();{
            bluetooth_item_data_t       *item_data;
            item = dialog->ui->tableWidget->item(i_row, column_number_value);
            saveItemData(item, tap_device, pinfo);
            item_data = VariantPointer<bluetooth_item_data_t>::asPtr(item->data(Qt::UserRole));
            if (item_data->changes > -1) {
}
void Singleton::f3();{
        }
    }
    clipboard->setText(copy);
void BluetoothDeviceDialog::tapReset(void *tapinfo_ptr)
    bluetooth_device_tapinfo_t *tapinfo = (bluetooth_device_tapinfo_t *) tapinfo_ptr;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        updateChanges(tableWidget, field, row_number_le_iso_packets, tapinfo->changes, pinfo);
        item->setText(field);
        break;
    }
    dialog->ui->hintLabel->setText(QString(tr("%1 changes")).arg(*tapinfo->changes));
}
void Singleton::f2();{
            bluetooth_item_data_t       *item_data;
            item = dialog->ui->tableWidget->item(i_row, column_number_value);
            saveItemData(item, tap_device, pinfo);
            item_data = VariantPointer<bluetooth_item_data_t>::asPtr(item->data(Qt::UserRole));
            if (item_data->changes > -1) {
}
void Singleton::f3();{
        }
    }
    clipboard->setText(copy);
void BluetoothDeviceDialog::tapReset(void *tapinfo_ptr)
    bluetooth_device_tapinfo_t *tapinfo = (bluetooth_device_tapinfo_t *) tapinfo_ptr;
}
void Singleton::f4();{
        copy += QString("%1  %2  %3\n")
                .arg(ui->tableWidget->verticalHeaderItem((*i_item)->row())->text(), -40)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_value)->text(), -50)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_changes)->text(), -10);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        updateChanges(tableWidget, field, row_number_le_iso_packets, tapinfo->changes, pinfo);
        item->setText(field);
        break;
    }
    dialog->ui->hintLabel->setText(QString(tr("%1 changes")).arg(*tapinfo->changes));
}
void Singleton::f2();{
            bluetooth_item_data_t       *item_data;
            item = dialog->ui->tableWidget->item(i_row, column_number_value);
            saveItemData(item, tap_device, pinfo);
            item_data = VariantPointer<bluetooth_item_data_t>::asPtr(item->data(Qt::UserRole));
            if (item_data->changes > -1) {
}
void Singleton::f3();{
        }
    }
    clipboard->setText(copy);
void BluetoothDeviceDialog::tapReset(void *tapinfo_ptr)
    bluetooth_device_tapinfo_t *tapinfo = (bluetooth_device_tapinfo_t *) tapinfo_ptr;
}
void Singleton::f4();{
        copy += QString("%1  %2  %3\n")
                .arg(ui->tableWidget->verticalHeaderItem((*i_item)->row())->text(), -40)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_value)->text(), -50)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_changes)->text(), -10);
    }
}
void Singleton::f5();{
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
            ui->retranslateUi(this);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        updateChanges(tableWidget, field, row_number_le_iso_packets, tapinfo->changes, pinfo);
        item->setText(field);
        break;
    }
    dialog->ui->hintLabel->setText(QString(tr("%1 changes")).arg(*tapinfo->changes));
}
void Singleton::f2();{
            bluetooth_item_data_t       *item_data;
            item = dialog->ui->tableWidget->item(i_row, column_number_value);
            saveItemData(item, tap_device, pinfo);
            item_data = VariantPointer<bluetooth_item_data_t>::asPtr(item->data(Qt::UserRole));
            if (item_data->changes > -1) {
}
void Singleton::f3();{
        }
    }
    clipboard->setText(copy);
void BluetoothDeviceDialog::tapReset(void *tapinfo_ptr)
    bluetooth_device_tapinfo_t *tapinfo = (bluetooth_device_tapinfo_t *) tapinfo_ptr;
}
void Singleton::f4();{
        copy += QString("%1  %2  %3\n")
                .arg(ui->tableWidget->verticalHeaderItem((*i_item)->row())->text(), -40)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_value)->text(), -50)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_changes)->text(), -10);
    }
}
void Singleton::f5();{
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
            ui->retranslateUi(this);
}
void Singleton::f6();{
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_Cell);
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_Rows);
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_All);
    context_menu_.addActions(QList<QAction *>() << ui->actionSave_as_image);
    changes_ = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        updateChanges(tableWidget, field, row_number_le_iso_packets, tapinfo->changes, pinfo);
        item->setText(field);
        break;
    }
    dialog->ui->hintLabel->setText(QString(tr("%1 changes")).arg(*tapinfo->changes));
}
void Singleton::f2();{
            bluetooth_item_data_t       *item_data;
            item = dialog->ui->tableWidget->item(i_row, column_number_value);
            saveItemData(item, tap_device, pinfo);
            item_data = VariantPointer<bluetooth_item_data_t>::asPtr(item->data(Qt::UserRole));
            if (item_data->changes > -1) {
}
void Singleton::f3();{
        }
    }
    clipboard->setText(copy);
void BluetoothDeviceDialog::tapReset(void *tapinfo_ptr)
    bluetooth_device_tapinfo_t *tapinfo = (bluetooth_device_tapinfo_t *) tapinfo_ptr;
}
void Singleton::f4();{
        copy += QString("%1  %2  %3\n")
                .arg(ui->tableWidget->verticalHeaderItem((*i_item)->row())->text(), -40)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_value)->text(), -50)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_changes)->text(), -10);
    }
}
void Singleton::f5();{
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
            ui->retranslateUi(this);
}
void Singleton::f6();{
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_Cell);
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_Rows);
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_All);
    context_menu_.addActions(QList<QAction *>() << ui->actionSave_as_image);
    changes_ = 0;
}
void Singleton::f7();{
        if (!tap_device->is_local && bd_addr != tapinfo->bdAddr)
            return TAP_PACKET_REDRAW;
        manuf = get_ether_name(tap_device->bd_addr);
        if (manuf) {
            int pos;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        updateChanges(tableWidget, field, row_number_le_iso_packets, tapinfo->changes, pinfo);
        item->setText(field);
        break;
    }
    dialog->ui->hintLabel->setText(QString(tr("%1 changes")).arg(*tapinfo->changes));
}
void Singleton::f2();{
            bluetooth_item_data_t       *item_data;
            item = dialog->ui->tableWidget->item(i_row, column_number_value);
            saveItemData(item, tap_device, pinfo);
            item_data = VariantPointer<bluetooth_item_data_t>::asPtr(item->data(Qt::UserRole));
            if (item_data->changes > -1) {
}
void Singleton::f3();{
        }
    }
    clipboard->setText(copy);
void BluetoothDeviceDialog::tapReset(void *tapinfo_ptr)
    bluetooth_device_tapinfo_t *tapinfo = (bluetooth_device_tapinfo_t *) tapinfo_ptr;
}
void Singleton::f4();{
        copy += QString("%1  %2  %3\n")
                .arg(ui->tableWidget->verticalHeaderItem((*i_item)->row())->text(), -40)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_value)->text(), -50)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_changes)->text(), -10);
    }
}
void Singleton::f5();{
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
            ui->retranslateUi(this);
}
void Singleton::f6();{
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_Cell);
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_Rows);
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_All);
    context_menu_.addActions(QList<QAction *>() << ui->actionSave_as_image);
    changes_ = 0;
}
void Singleton::f7();{
        if (!tap_device->is_local && bd_addr != tapinfo->bdAddr)
            return TAP_PACKET_REDRAW;
        manuf = get_ether_name(tap_device->bd_addr);
        if (manuf) {
            int pos;
}
void Singleton::f8();{
    if (!((!tap_device->is_local && tap_device->has_bd_addr) || (tap_device->is_local && tapinfo->is_local && tap_device->interface_id == tapinfo->interface_id && tap_device->adapter_id == tapinfo->adapter_id))) {
        return TAP_PACKET_REDRAW;
    }
    if (tap_device->has_bd_addr) {
        for (int i = 0; i < 6; ++i) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        updateChanges(tableWidget, field, row_number_le_iso_packets, tapinfo->changes, pinfo);
        item->setText(field);
        break;
    }
    dialog->ui->hintLabel->setText(QString(tr("%1 changes")).arg(*tapinfo->changes));
}
void Singleton::f2();{
            bluetooth_item_data_t       *item_data;
            item = dialog->ui->tableWidget->item(i_row, column_number_value);
            saveItemData(item, tap_device, pinfo);
            item_data = VariantPointer<bluetooth_item_data_t>::asPtr(item->data(Qt::UserRole));
            if (item_data->changes > -1) {
}
void Singleton::f3();{
        }
    }
    clipboard->setText(copy);
void BluetoothDeviceDialog::tapReset(void *tapinfo_ptr)
    bluetooth_device_tapinfo_t *tapinfo = (bluetooth_device_tapinfo_t *) tapinfo_ptr;
}
void Singleton::f4();{
        copy += QString("%1  %2  %3\n")
                .arg(ui->tableWidget->verticalHeaderItem((*i_item)->row())->text(), -40)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_value)->text(), -50)
                .arg(ui->tableWidget->item((*i_item)->row(), column_number_changes)->text(), -10);
    }
}
void Singleton::f5();{
    {
        switch (event->type())
        {
        case QEvent::LanguageChange:
            ui->retranslateUi(this);
}
void Singleton::f6();{
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_Cell);
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_Rows);
    context_menu_.addActions(QList<QAction *>() << ui->actionCopy_All);
    context_menu_.addActions(QList<QAction *>() << ui->actionSave_as_image);
    changes_ = 0;
}
void Singleton::f7();{
        if (!tap_device->is_local && bd_addr != tapinfo->bdAddr)
            return TAP_PACKET_REDRAW;
        manuf = get_ether_name(tap_device->bd_addr);
        if (manuf) {
            int pos;
}
void Singleton::f8();{
    if (!((!tap_device->is_local && tap_device->has_bd_addr) || (tap_device->is_local && tapinfo->is_local && tap_device->interface_id == tapinfo->interface_id && tap_device->adapter_id == tapinfo->adapter_id))) {
        return TAP_PACKET_REDRAW;
    }
    if (tap_device->has_bd_addr) {
        for (int i = 0; i < 6; ++i) {
}
void Singleton::f9();{
            0,
            bluetooth_device_tap_reset,
            bluetooth_device_tap_packet,
            NULL,
            NULL
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    connect(ui->tableTreeWidget, SIGNAL(itemCollapsed(QTreeWidgetItem *)), this, SLOT(tableItemCollapsed(QTreeWidgetItem *)));
    connect(ui->interfaceComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(interfaceCurrentIndexChanged(int)));
    connect(ui->adapterComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(adapterCurrentIndexChanged(int)));
    connect(ui->displayFilterLineEdit, SIGNAL(returnPressed()), this, SLOT(displayFilterLineEditAccepted()));
    connect(ui->resultsFilterLineEdit, SIGNAL(textChanged(const QString &)), this, SLOT(resultsFilterLineEditChanged(const QString &)));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    connect(ui->tableTreeWidget, SIGNAL(itemCollapsed(QTreeWidgetItem *)), this, SLOT(tableItemCollapsed(QTreeWidgetItem *)));
    connect(ui->interfaceComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(interfaceCurrentIndexChanged(int)));
    connect(ui->adapterComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(adapterCurrentIndexChanged(int)));
    connect(ui->displayFilterLineEdit, SIGNAL(returnPressed()), this, SLOT(displayFilterLineEditAccepted()));
    connect(ui->resultsFilterLineEdit, SIGNAL(textChanged(const QString &)), this, SLOT(resultsFilterLineEditChanged(const QString &)));
}
void Singleton::f2();{
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
        ui->tableTreeWidget->resizeColumnToContents(i);
    }
void BluetoothHciSummaryDialog::tableItemCollapsed(QTreeWidgetItem *)
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
}
void Singleton::f3();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f4();{
/*    if (button == foo_button_) */
void BluetoothHciSummaryDialog::displayFilterLineEditAccepted()
    GString *error_string;
    remove_tap_listener(&tapinfo_);
    error_string = register_tap_listener("bluetooth.hci_summary", &tapinfo_,
}
void Singleton::f5();{
                .arg((*i_item)->text(column_number_name), -60)
                .arg((*i_item)->text(column_number_ogf), -10)
                .arg((*i_item)->text(column_number_ocf), -10)
                .arg((*i_item)->text(column_number_opcode), -10)
                .arg((*i_item)->text(column_number_event), -10)
}
void Singleton::f6();{
            for (int ii_item = 0; ii_item < item->childCount(); ii_item +=1) {
                if (item->child(ii_item)->text(column_number_name) != QString(tr("Frame %1")).arg(pinfo->num))
                    continue;
                delete item->child(ii_item);
                item->setText(column_number_occurrence, QString::number(item->text(column_number_occurrence).toInt() - 1));
}
void Singleton::f7();{
            .arg(item->text(column_number_event), -10)
            .arg(item->text(column_number_subevent), -10)
            .arg(item->text(column_number_status), -10)
            .arg(item->text(column_number_reason), -10)
            .arg(item->text(column_number_hardware_error), -15)
}
void Singleton::f8();{
    tapinfo_.ui = this;
    item_link_control_            = ui->tableTreeWidget->topLevelItem(0);
    item_link_policy_             = ui->tableTreeWidget->topLevelItem(1);
    item_controller_and_baseband_ = ui->tableTreeWidget->topLevelItem(2);
    item_informational_           = ui->tableTreeWidget->topLevelItem(3);
}
void Singleton::f9();{
            break;
        }
        if (meta_item == NULL)
            break;
        item = NULL;
}
void Singleton::f10();{
                    QString("0x%1").arg(tap_hci->event, 2, 16, QChar('0'))) {
                continue;
            }
            meta_item = main_item->child(i_item);
            break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    connect(ui->tableTreeWidget, SIGNAL(itemCollapsed(QTreeWidgetItem *)), this, SLOT(tableItemCollapsed(QTreeWidgetItem *)));
    connect(ui->interfaceComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(interfaceCurrentIndexChanged(int)));
    connect(ui->adapterComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(adapterCurrentIndexChanged(int)));
    connect(ui->displayFilterLineEdit, SIGNAL(returnPressed()), this, SLOT(displayFilterLineEditAccepted()));
    connect(ui->resultsFilterLineEdit, SIGNAL(textChanged(const QString &)), this, SLOT(resultsFilterLineEditChanged(const QString &)));
}
void Singleton::f2();{
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
        ui->tableTreeWidget->resizeColumnToContents(i);
    }
void BluetoothHciSummaryDialog::tableItemCollapsed(QTreeWidgetItem *)
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    connect(ui->tableTreeWidget, SIGNAL(itemCollapsed(QTreeWidgetItem *)), this, SLOT(tableItemCollapsed(QTreeWidgetItem *)));
    connect(ui->interfaceComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(interfaceCurrentIndexChanged(int)));
    connect(ui->adapterComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(adapterCurrentIndexChanged(int)));
    connect(ui->displayFilterLineEdit, SIGNAL(returnPressed()), this, SLOT(displayFilterLineEditAccepted()));
    connect(ui->resultsFilterLineEdit, SIGNAL(textChanged(const QString &)), this, SLOT(resultsFilterLineEditChanged(const QString &)));
}
void Singleton::f2();{
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
        ui->tableTreeWidget->resizeColumnToContents(i);
    }
void BluetoothHciSummaryDialog::tableItemCollapsed(QTreeWidgetItem *)
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
}
void Singleton::f3();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    connect(ui->tableTreeWidget, SIGNAL(itemCollapsed(QTreeWidgetItem *)), this, SLOT(tableItemCollapsed(QTreeWidgetItem *)));
    connect(ui->interfaceComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(interfaceCurrentIndexChanged(int)));
    connect(ui->adapterComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(adapterCurrentIndexChanged(int)));
    connect(ui->displayFilterLineEdit, SIGNAL(returnPressed()), this, SLOT(displayFilterLineEditAccepted()));
    connect(ui->resultsFilterLineEdit, SIGNAL(textChanged(const QString &)), this, SLOT(resultsFilterLineEditChanged(const QString &)));
}
void Singleton::f2();{
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
        ui->tableTreeWidget->resizeColumnToContents(i);
    }
void BluetoothHciSummaryDialog::tableItemCollapsed(QTreeWidgetItem *)
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
}
void Singleton::f3();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f4();{
/*    if (button == foo_button_) */
void BluetoothHciSummaryDialog::displayFilterLineEditAccepted()
    GString *error_string;
    remove_tap_listener(&tapinfo_);
    error_string = register_tap_listener("bluetooth.hci_summary", &tapinfo_,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    connect(ui->tableTreeWidget, SIGNAL(itemCollapsed(QTreeWidgetItem *)), this, SLOT(tableItemCollapsed(QTreeWidgetItem *)));
    connect(ui->interfaceComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(interfaceCurrentIndexChanged(int)));
    connect(ui->adapterComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(adapterCurrentIndexChanged(int)));
    connect(ui->displayFilterLineEdit, SIGNAL(returnPressed()), this, SLOT(displayFilterLineEditAccepted()));
    connect(ui->resultsFilterLineEdit, SIGNAL(textChanged(const QString &)), this, SLOT(resultsFilterLineEditChanged(const QString &)));
}
void Singleton::f2();{
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
        ui->tableTreeWidget->resizeColumnToContents(i);
    }
void BluetoothHciSummaryDialog::tableItemCollapsed(QTreeWidgetItem *)
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
}
void Singleton::f3();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f4();{
/*    if (button == foo_button_) */
void BluetoothHciSummaryDialog::displayFilterLineEditAccepted()
    GString *error_string;
    remove_tap_listener(&tapinfo_);
    error_string = register_tap_listener("bluetooth.hci_summary", &tapinfo_,
}
void Singleton::f5();{
                .arg((*i_item)->text(column_number_name), -60)
                .arg((*i_item)->text(column_number_ogf), -10)
                .arg((*i_item)->text(column_number_ocf), -10)
                .arg((*i_item)->text(column_number_opcode), -10)
                .arg((*i_item)->text(column_number_event), -10)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    connect(ui->tableTreeWidget, SIGNAL(itemCollapsed(QTreeWidgetItem *)), this, SLOT(tableItemCollapsed(QTreeWidgetItem *)));
    connect(ui->interfaceComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(interfaceCurrentIndexChanged(int)));
    connect(ui->adapterComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(adapterCurrentIndexChanged(int)));
    connect(ui->displayFilterLineEdit, SIGNAL(returnPressed()), this, SLOT(displayFilterLineEditAccepted()));
    connect(ui->resultsFilterLineEdit, SIGNAL(textChanged(const QString &)), this, SLOT(resultsFilterLineEditChanged(const QString &)));
}
void Singleton::f2();{
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
        ui->tableTreeWidget->resizeColumnToContents(i);
    }
void BluetoothHciSummaryDialog::tableItemCollapsed(QTreeWidgetItem *)
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
}
void Singleton::f3();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f4();{
/*    if (button == foo_button_) */
void BluetoothHciSummaryDialog::displayFilterLineEditAccepted()
    GString *error_string;
    remove_tap_listener(&tapinfo_);
    error_string = register_tap_listener("bluetooth.hci_summary", &tapinfo_,
}
void Singleton::f5();{
                .arg((*i_item)->text(column_number_name), -60)
                .arg((*i_item)->text(column_number_ogf), -10)
                .arg((*i_item)->text(column_number_ocf), -10)
                .arg((*i_item)->text(column_number_opcode), -10)
                .arg((*i_item)->text(column_number_event), -10)
}
void Singleton::f6();{
            for (int ii_item = 0; ii_item < item->childCount(); ii_item +=1) {
                if (item->child(ii_item)->text(column_number_name) != QString(tr("Frame %1")).arg(pinfo->num))
                    continue;
                delete item->child(ii_item);
                item->setText(column_number_occurrence, QString::number(item->text(column_number_occurrence).toInt() - 1));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    connect(ui->tableTreeWidget, SIGNAL(itemCollapsed(QTreeWidgetItem *)), this, SLOT(tableItemCollapsed(QTreeWidgetItem *)));
    connect(ui->interfaceComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(interfaceCurrentIndexChanged(int)));
    connect(ui->adapterComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(adapterCurrentIndexChanged(int)));
    connect(ui->displayFilterLineEdit, SIGNAL(returnPressed()), this, SLOT(displayFilterLineEditAccepted()));
    connect(ui->resultsFilterLineEdit, SIGNAL(textChanged(const QString &)), this, SLOT(resultsFilterLineEditChanged(const QString &)));
}
void Singleton::f2();{
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
        ui->tableTreeWidget->resizeColumnToContents(i);
    }
void BluetoothHciSummaryDialog::tableItemCollapsed(QTreeWidgetItem *)
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
}
void Singleton::f3();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f4();{
/*    if (button == foo_button_) */
void BluetoothHciSummaryDialog::displayFilterLineEditAccepted()
    GString *error_string;
    remove_tap_listener(&tapinfo_);
    error_string = register_tap_listener("bluetooth.hci_summary", &tapinfo_,
}
void Singleton::f5();{
                .arg((*i_item)->text(column_number_name), -60)
                .arg((*i_item)->text(column_number_ogf), -10)
                .arg((*i_item)->text(column_number_ocf), -10)
                .arg((*i_item)->text(column_number_opcode), -10)
                .arg((*i_item)->text(column_number_event), -10)
}
void Singleton::f6();{
            for (int ii_item = 0; ii_item < item->childCount(); ii_item +=1) {
                if (item->child(ii_item)->text(column_number_name) != QString(tr("Frame %1")).arg(pinfo->num))
                    continue;
                delete item->child(ii_item);
                item->setText(column_number_occurrence, QString::number(item->text(column_number_occurrence).toInt() - 1));
}
void Singleton::f7();{
            .arg(item->text(column_number_event), -10)
            .arg(item->text(column_number_subevent), -10)
            .arg(item->text(column_number_status), -10)
            .arg(item->text(column_number_reason), -10)
            .arg(item->text(column_number_hardware_error), -15)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    connect(ui->tableTreeWidget, SIGNAL(itemCollapsed(QTreeWidgetItem *)), this, SLOT(tableItemCollapsed(QTreeWidgetItem *)));
    connect(ui->interfaceComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(interfaceCurrentIndexChanged(int)));
    connect(ui->adapterComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(adapterCurrentIndexChanged(int)));
    connect(ui->displayFilterLineEdit, SIGNAL(returnPressed()), this, SLOT(displayFilterLineEditAccepted()));
    connect(ui->resultsFilterLineEdit, SIGNAL(textChanged(const QString &)), this, SLOT(resultsFilterLineEditChanged(const QString &)));
}
void Singleton::f2();{
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
        ui->tableTreeWidget->resizeColumnToContents(i);
    }
void BluetoothHciSummaryDialog::tableItemCollapsed(QTreeWidgetItem *)
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
}
void Singleton::f3();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f4();{
/*    if (button == foo_button_) */
void BluetoothHciSummaryDialog::displayFilterLineEditAccepted()
    GString *error_string;
    remove_tap_listener(&tapinfo_);
    error_string = register_tap_listener("bluetooth.hci_summary", &tapinfo_,
}
void Singleton::f5();{
                .arg((*i_item)->text(column_number_name), -60)
                .arg((*i_item)->text(column_number_ogf), -10)
                .arg((*i_item)->text(column_number_ocf), -10)
                .arg((*i_item)->text(column_number_opcode), -10)
                .arg((*i_item)->text(column_number_event), -10)
}
void Singleton::f6();{
            for (int ii_item = 0; ii_item < item->childCount(); ii_item +=1) {
                if (item->child(ii_item)->text(column_number_name) != QString(tr("Frame %1")).arg(pinfo->num))
                    continue;
                delete item->child(ii_item);
                item->setText(column_number_occurrence, QString::number(item->text(column_number_occurrence).toInt() - 1));
}
void Singleton::f7();{
            .arg(item->text(column_number_event), -10)
            .arg(item->text(column_number_subevent), -10)
            .arg(item->text(column_number_status), -10)
            .arg(item->text(column_number_reason), -10)
            .arg(item->text(column_number_hardware_error), -15)
}
void Singleton::f8();{
    tapinfo_.ui = this;
    item_link_control_            = ui->tableTreeWidget->topLevelItem(0);
    item_link_policy_             = ui->tableTreeWidget->topLevelItem(1);
    item_controller_and_baseband_ = ui->tableTreeWidget->topLevelItem(2);
    item_informational_           = ui->tableTreeWidget->topLevelItem(3);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    connect(ui->tableTreeWidget, SIGNAL(itemCollapsed(QTreeWidgetItem *)), this, SLOT(tableItemCollapsed(QTreeWidgetItem *)));
    connect(ui->interfaceComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(interfaceCurrentIndexChanged(int)));
    connect(ui->adapterComboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(adapterCurrentIndexChanged(int)));
    connect(ui->displayFilterLineEdit, SIGNAL(returnPressed()), this, SLOT(displayFilterLineEditAccepted()));
    connect(ui->resultsFilterLineEdit, SIGNAL(textChanged(const QString &)), this, SLOT(resultsFilterLineEditChanged(const QString &)));
}
void Singleton::f2();{
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
        ui->tableTreeWidget->resizeColumnToContents(i);
    }
void BluetoothHciSummaryDialog::tableItemCollapsed(QTreeWidgetItem *)
    for (int i = 0; i < ui->tableTreeWidget->columnCount(); i++) {
}
void Singleton::f3();{
    QClipboard                         *clipboard = QApplication::clipboard();
    QString                             copy;
    QList<QTreeWidgetItem *>            items;
    QList<QTreeWidgetItem *>::iterator  i_item;
    items =  ui->tableTreeWidget->selectedItems();
}
void Singleton::f4();{
/*    if (button == foo_button_) */
void BluetoothHciSummaryDialog::displayFilterLineEditAccepted()
    GString *error_string;
    remove_tap_listener(&tapinfo_);
    error_string = register_tap_listener("bluetooth.hci_summary", &tapinfo_,
}
void Singleton::f5();{
                .arg((*i_item)->text(column_number_name), -60)
                .arg((*i_item)->text(column_number_ogf), -10)
                .arg((*i_item)->text(column_number_ocf), -10)
                .arg((*i_item)->text(column_number_opcode), -10)
                .arg((*i_item)->text(column_number_event), -10)
}
void Singleton::f6();{
            for (int ii_item = 0; ii_item < item->childCount(); ii_item +=1) {
                if (item->child(ii_item)->text(column_number_name) != QString(tr("Frame %1")).arg(pinfo->num))
                    continue;
                delete item->child(ii_item);
                item->setText(column_number_occurrence, QString::number(item->text(column_number_occurrence).toInt() - 1));
}
void Singleton::f7();{
            .arg(item->text(column_number_event), -10)
            .arg(item->text(column_number_subevent), -10)
            .arg(item->text(column_number_status), -10)
            .arg(item->text(column_number_reason), -10)
            .arg(item->text(column_number_hardware_error), -15)
}
void Singleton::f8();{
    tapinfo_.ui = this;
    item_link_control_            = ui->tableTreeWidget->topLevelItem(0);
    item_link_policy_             = ui->tableTreeWidget->topLevelItem(1);
    item_controller_and_baseband_ = ui->tableTreeWidget->topLevelItem(2);
    item_informational_           = ui->tableTreeWidget->topLevelItem(3);
}
void Singleton::f9();{
            break;
        }
        if (meta_item == NULL)
            break;
        item = NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    if (cap_file_->search_in_progress && (cap_file_->hex || (cap_file_->string && cap_file_->packet_data))) {
        // In the hex view, only highlight the target bytes or string. The entire
        // field can then be displayed by clicking on any of the bytes in the field.
        f_start = cap_file_->search_pos - cap_file_->search_len + 1;
        f_length = (int) cap_file_->search_len;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    if (cap_file_->search_in_progress && (cap_file_->hex || (cap_file_->string && cap_file_->packet_data))) {
        // In the hex view, only highlight the target bytes or string. The entire
        // field can then be displayed by clicking on any of the bytes in the field.
        f_start = cap_file_->search_pos - cap_file_->search_len + 1;
        f_length = (int) cap_file_->search_len;
}
void Singleton::f2();{
        {
            if (stored->length >= length && tvb_memeql(search_tvb, 0, tvb_get_ptr(stored, 0, length), length) == 0)
            {
                /* In packetDialog we do not match, because we came from different data sources.
                 * Assuming the capture files match, this should be a sufficient enough difference */
}
void Singleton::f3();{
// To do:
// - We might want to add a callback to free_data_sources in so that we
//   don't have to blindly call clear().
ByteViewTab::ByteViewTab(QWidget *parent, epan_dissect_t *edt_fixed) :
    QTabWidget(parent),
}
void Singleton::f4();{
        if (data_len > 0) {
            // Note: this does not copy the data and will be invalidated when
            // the tvb becomes invalid (e.g. when the current packet changes).
            data = QByteArray::fromRawData((const char *) tvb_get_ptr(tvb, 0, data_len), data_len);
        }
}
void Singleton::f5();{
        if (found)
        {
            int wdgIdx = bvt->property("tab_index").toInt();
            if (idx)
            {
}
void Singleton::f6();{
    /* only show the bytes for single selections */
    if (frames.count() == 1)
    {
        if (! cap_file_ || ! cap_file_->edt)
            return;
}
void Singleton::f7();{
        int data_len = (int) tvb_captured_length(tvb);
        if (data_len > 0) {
            // Note: this does not copy the data and will be invalidated when
            // the tvb becomes invalid (e.g. when the current packet changes).
            data = QByteArray::fromRawData((const char *) tvb_get_ptr(tvb, 0, data_len), data_len);
}
void Singleton::f8();{
void ByteViewTab::tabRemoved(int tab_index) {
    setTabsVisible();
    QTabWidget::tabRemoved(tab_index);
void ByteViewTab::setTabsVisible() {
    if (count() > 1)
}
void Singleton::f9();{
        p_length = parentField->position().length;
        fa_start = selected->appendix().start;
        fa_length = selected->appendix().length;
        delete parentField;
    }
}
void Singleton::f10();{
        tvbuff_t * tvb = VariantPointer<tvbuff_t>::asPtr(sender()->property(tvb_data_property));
        proto_tree * tree = edt_->tree;
        if (tvb && tree)
        {
            field_info * fi = proto_find_field_from_offset(tree, idx, tvb);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    if (cap_file_->search_in_progress && (cap_file_->hex || (cap_file_->string && cap_file_->packet_data))) {
        // In the hex view, only highlight the target bytes or string. The entire
        // field can then be displayed by clicking on any of the bytes in the field.
        f_start = cap_file_->search_pos - cap_file_->search_len + 1;
        f_length = (int) cap_file_->search_len;
}
void Singleton::f2();{
        {
            if (stored->length >= length && tvb_memeql(search_tvb, 0, tvb_get_ptr(stored, 0, length), length) == 0)
            {
                /* In packetDialog we do not match, because we came from different data sources.
                 * Assuming the capture files match, this should be a sufficient enough difference */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    if (cap_file_->search_in_progress && (cap_file_->hex || (cap_file_->string && cap_file_->packet_data))) {
        // In the hex view, only highlight the target bytes or string. The entire
        // field can then be displayed by clicking on any of the bytes in the field.
        f_start = cap_file_->search_pos - cap_file_->search_len + 1;
        f_length = (int) cap_file_->search_len;
}
void Singleton::f2();{
        {
            if (stored->length >= length && tvb_memeql(search_tvb, 0, tvb_get_ptr(stored, 0, length), length) == 0)
            {
                /* In packetDialog we do not match, because we came from different data sources.
                 * Assuming the capture files match, this should be a sufficient enough difference */
}
void Singleton::f3();{
// To do:
// - We might want to add a callback to free_data_sources in so that we
//   don't have to blindly call clear().
ByteViewTab::ByteViewTab(QWidget *parent, epan_dissect_t *edt_fixed) :
    QTabWidget(parent),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    if (cap_file_->search_in_progress && (cap_file_->hex || (cap_file_->string && cap_file_->packet_data))) {
        // In the hex view, only highlight the target bytes or string. The entire
        // field can then be displayed by clicking on any of the bytes in the field.
        f_start = cap_file_->search_pos - cap_file_->search_len + 1;
        f_length = (int) cap_file_->search_len;
}
void Singleton::f2();{
        {
            if (stored->length >= length && tvb_memeql(search_tvb, 0, tvb_get_ptr(stored, 0, length), length) == 0)
            {
                /* In packetDialog we do not match, because we came from different data sources.
                 * Assuming the capture files match, this should be a sufficient enough difference */
}
void Singleton::f3();{
// To do:
// - We might want to add a callback to free_data_sources in so that we
//   don't have to blindly call clear().
ByteViewTab::ByteViewTab(QWidget *parent, epan_dissect_t *edt_fixed) :
    QTabWidget(parent),
}
void Singleton::f4();{
        if (data_len > 0) {
            // Note: this does not copy the data and will be invalidated when
            // the tvb becomes invalid (e.g. when the current packet changes).
            data = QByteArray::fromRawData((const char *) tvb_get_ptr(tvb, 0, data_len), data_len);
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    if (cap_file_->search_in_progress && (cap_file_->hex || (cap_file_->string && cap_file_->packet_data))) {
        // In the hex view, only highlight the target bytes or string. The entire
        // field can then be displayed by clicking on any of the bytes in the field.
        f_start = cap_file_->search_pos - cap_file_->search_len + 1;
        f_length = (int) cap_file_->search_len;
}
void Singleton::f2();{
        {
            if (stored->length >= length && tvb_memeql(search_tvb, 0, tvb_get_ptr(stored, 0, length), length) == 0)
            {
                /* In packetDialog we do not match, because we came from different data sources.
                 * Assuming the capture files match, this should be a sufficient enough difference */
}
void Singleton::f3();{
// To do:
// - We might want to add a callback to free_data_sources in so that we
//   don't have to blindly call clear().
ByteViewTab::ByteViewTab(QWidget *parent, epan_dissect_t *edt_fixed) :
    QTabWidget(parent),
}
void Singleton::f4();{
        if (data_len > 0) {
            // Note: this does not copy the data and will be invalidated when
            // the tvb becomes invalid (e.g. when the current packet changes).
            data = QByteArray::fromRawData((const char *) tvb_get_ptr(tvb, 0, data_len), data_len);
        }
}
void Singleton::f5();{
        if (found)
        {
            int wdgIdx = bvt->property("tab_index").toInt();
            if (idx)
            {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    if (cap_file_->search_in_progress && (cap_file_->hex || (cap_file_->string && cap_file_->packet_data))) {
        // In the hex view, only highlight the target bytes or string. The entire
        // field can then be displayed by clicking on any of the bytes in the field.
        f_start = cap_file_->search_pos - cap_file_->search_len + 1;
        f_length = (int) cap_file_->search_len;
}
void Singleton::f2();{
        {
            if (stored->length >= length && tvb_memeql(search_tvb, 0, tvb_get_ptr(stored, 0, length), length) == 0)
            {
                /* In packetDialog we do not match, because we came from different data sources.
                 * Assuming the capture files match, this should be a sufficient enough difference */
}
void Singleton::f3();{
// To do:
// - We might want to add a callback to free_data_sources in so that we
//   don't have to blindly call clear().
ByteViewTab::ByteViewTab(QWidget *parent, epan_dissect_t *edt_fixed) :
    QTabWidget(parent),
}
void Singleton::f4();{
        if (data_len > 0) {
            // Note: this does not copy the data and will be invalidated when
            // the tvb becomes invalid (e.g. when the current packet changes).
            data = QByteArray::fromRawData((const char *) tvb_get_ptr(tvb, 0, data_len), data_len);
        }
}
void Singleton::f5();{
        if (found)
        {
            int wdgIdx = bvt->property("tab_index").toInt();
            if (idx)
            {
}
void Singleton::f6();{
    /* only show the bytes for single selections */
    if (frames.count() == 1)
    {
        if (! cap_file_ || ! cap_file_->edt)
            return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    if (cap_file_->search_in_progress && (cap_file_->hex || (cap_file_->string && cap_file_->packet_data))) {
        // In the hex view, only highlight the target bytes or string. The entire
        // field can then be displayed by clicking on any of the bytes in the field.
        f_start = cap_file_->search_pos - cap_file_->search_len + 1;
        f_length = (int) cap_file_->search_len;
}
void Singleton::f2();{
        {
            if (stored->length >= length && tvb_memeql(search_tvb, 0, tvb_get_ptr(stored, 0, length), length) == 0)
            {
                /* In packetDialog we do not match, because we came from different data sources.
                 * Assuming the capture files match, this should be a sufficient enough difference */
}
void Singleton::f3();{
// To do:
// - We might want to add a callback to free_data_sources in so that we
//   don't have to blindly call clear().
ByteViewTab::ByteViewTab(QWidget *parent, epan_dissect_t *edt_fixed) :
    QTabWidget(parent),
}
void Singleton::f4();{
        if (data_len > 0) {
            // Note: this does not copy the data and will be invalidated when
            // the tvb becomes invalid (e.g. when the current packet changes).
            data = QByteArray::fromRawData((const char *) tvb_get_ptr(tvb, 0, data_len), data_len);
        }
}
void Singleton::f5();{
        if (found)
        {
            int wdgIdx = bvt->property("tab_index").toInt();
            if (idx)
            {
}
void Singleton::f6();{
    /* only show the bytes for single selections */
    if (frames.count() == 1)
    {
        if (! cap_file_ || ! cap_file_->edt)
            return;
}
void Singleton::f7();{
        int data_len = (int) tvb_captured_length(tvb);
        if (data_len > 0) {
            // Note: this does not copy the data and will be invalidated when
            // the tvb becomes invalid (e.g. when the current packet changes).
            data = QByteArray::fromRawData((const char *) tvb_get_ptr(tvb, 0, data_len), data_len);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    if (cap_file_->search_in_progress && (cap_file_->hex || (cap_file_->string && cap_file_->packet_data))) {
        // In the hex view, only highlight the target bytes or string. The entire
        // field can then be displayed by clicking on any of the bytes in the field.
        f_start = cap_file_->search_pos - cap_file_->search_len + 1;
        f_length = (int) cap_file_->search_len;
}
void Singleton::f2();{
        {
            if (stored->length >= length && tvb_memeql(search_tvb, 0, tvb_get_ptr(stored, 0, length), length) == 0)
            {
                /* In packetDialog we do not match, because we came from different data sources.
                 * Assuming the capture files match, this should be a sufficient enough difference */
}
void Singleton::f3();{
// To do:
// - We might want to add a callback to free_data_sources in so that we
//   don't have to blindly call clear().
ByteViewTab::ByteViewTab(QWidget *parent, epan_dissect_t *edt_fixed) :
    QTabWidget(parent),
}
void Singleton::f4();{
        if (data_len > 0) {
            // Note: this does not copy the data and will be invalidated when
            // the tvb becomes invalid (e.g. when the current packet changes).
            data = QByteArray::fromRawData((const char *) tvb_get_ptr(tvb, 0, data_len), data_len);
        }
}
void Singleton::f5();{
        if (found)
        {
            int wdgIdx = bvt->property("tab_index").toInt();
            if (idx)
            {
}
void Singleton::f6();{
    /* only show the bytes for single selections */
    if (frames.count() == 1)
    {
        if (! cap_file_ || ! cap_file_->edt)
            return;
}
void Singleton::f7();{
        int data_len = (int) tvb_captured_length(tvb);
        if (data_len > 0) {
            // Note: this does not copy the data and will be invalidated when
            // the tvb becomes invalid (e.g. when the current packet changes).
            data = QByteArray::fromRawData((const char *) tvb_get_ptr(tvb, 0, data_len), data_len);
}
void Singleton::f8();{
void ByteViewTab::tabRemoved(int tab_index) {
    setTabsVisible();
    QTabWidget::tabRemoved(tab_index);
void ByteViewTab::setTabsVisible() {
    if (count() > 1)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    if (cap_file_->search_in_progress && (cap_file_->hex || (cap_file_->string && cap_file_->packet_data))) {
        // In the hex view, only highlight the target bytes or string. The entire
        // field can then be displayed by clicking on any of the bytes in the field.
        f_start = cap_file_->search_pos - cap_file_->search_len + 1;
        f_length = (int) cap_file_->search_len;
}
void Singleton::f2();{
        {
            if (stored->length >= length && tvb_memeql(search_tvb, 0, tvb_get_ptr(stored, 0, length), length) == 0)
            {
                /* In packetDialog we do not match, because we came from different data sources.
                 * Assuming the capture files match, this should be a sufficient enough difference */
}
void Singleton::f3();{
// To do:
// - We might want to add a callback to free_data_sources in so that we
//   don't have to blindly call clear().
ByteViewTab::ByteViewTab(QWidget *parent, epan_dissect_t *edt_fixed) :
    QTabWidget(parent),
}
void Singleton::f4();{
        if (data_len > 0) {
            // Note: this does not copy the data and will be invalidated when
            // the tvb becomes invalid (e.g. when the current packet changes).
            data = QByteArray::fromRawData((const char *) tvb_get_ptr(tvb, 0, data_len), data_len);
        }
}
void Singleton::f5();{
        if (found)
        {
            int wdgIdx = bvt->property("tab_index").toInt();
            if (idx)
            {
}
void Singleton::f6();{
    /* only show the bytes for single selections */
    if (frames.count() == 1)
    {
        if (! cap_file_ || ! cap_file_->edt)
            return;
}
void Singleton::f7();{
        int data_len = (int) tvb_captured_length(tvb);
        if (data_len > 0) {
            // Note: this does not copy the data and will be invalidated when
            // the tvb becomes invalid (e.g. when the current packet changes).
            data = QByteArray::fromRawData((const char *) tvb_get_ptr(tvb, 0, data_len), data_len);
}
void Singleton::f8();{
void ByteViewTab::tabRemoved(int tab_index) {
    setTabsVisible();
    QTabWidget::tabRemoved(tab_index);
void ByteViewTab::setTabsVisible() {
    if (count() > 1)
}
void Singleton::f9();{
        p_length = parentField->position().length;
        fa_start = selected->appendix().start;
        fa_length = selected->appendix().length;
        delete parentField;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        int np_start = 0;
        int np_len = 0;
        guchar c;
        for (int tvb_pos = offset; tvb_pos <= max_tvb_pos; tvb_pos++) {
            /* insert a space every separator_interval_ bytes */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        int np_start = 0;
        int np_len = 0;
        guchar c;
        for (int tvb_pos = offset; tvb_pos <= max_tvb_pos; tvb_pos++) {
            /* insert a space every separator_interval_ bytes */
}
void Singleton::f2();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}
void Singleton::f3();{
    format_range.length = length;
    switch (mode) {
    case ModeNormal:
        return false;
    case ModeField:
}
void Singleton::f4();{
            }
            if (tvb_pos == hovered_byte_offset_ || tvb_pos == marked_byte_offset_) {
                QRect ho_rect = painter->boundingRect(QRect(), 0, line.right(1));
                ho_rect.moveRight(fontMetrics().boundingRect(line).width());
                ho_rect.moveTop(row_y);
}
void Singleton::f5();{
    viewport()->update();
    QAbstractScrollArea::leaveEvent(event);
void ByteViewText::contextMenuEvent(QContextMenuEvent *event)
    ctx_menu_.exec(event->globalPos());
// Private
}
void Singleton::f6();{
    // We might want to set a composition mode when that's not the case.
    if (!hover_outlines_.isEmpty()) {
        qreal pen_width = 1.0;
        qreal hover_alpha = 0.6;
        QPen ho_pen;
}
void Singleton::f7();{
    ctx_menu_.addActions(format_actions->actions());
    connect(format_actions, &QActionGroup::triggered, this, &ByteViewText::setHexDisplayFormat);
    ctx_menu_.addSeparator();
    QActionGroup * encoding_actions = new QActionGroup(this);
    action = encoding_actions->addAction(tr("Show text based on packet"));
}
void Singleton::f8();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}
void Singleton::f9();{
Q_DECLARE_METATYPE(bytes_encoding_type)
Q_DECLARE_METATYPE(DataPrinter::DumpType)
ByteViewText::ByteViewText(const QByteArray &data, packet_char_enc encoding, QWidget *parent) :
    QAbstractScrollArea(parent),
    layout_(new QTextLayout()),
}
void Singleton::f10();{
    if (!action) {
        return;
    }
    recent.gui_bytes_encoding = action->data().value<bytes_encoding_type>();
    viewport()->update();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        int np_start = 0;
        int np_len = 0;
        guchar c;
        for (int tvb_pos = offset; tvb_pos <= max_tvb_pos; tvb_pos++) {
            /* insert a space every separator_interval_ bytes */
}
void Singleton::f2();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        int np_start = 0;
        int np_len = 0;
        guchar c;
        for (int tvb_pos = offset; tvb_pos <= max_tvb_pos; tvb_pos++) {
            /* insert a space every separator_interval_ bytes */
}
void Singleton::f2();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}
void Singleton::f3();{
    format_range.length = length;
    switch (mode) {
    case ModeNormal:
        return false;
    case ModeField:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        int np_start = 0;
        int np_len = 0;
        guchar c;
        for (int tvb_pos = offset; tvb_pos <= max_tvb_pos; tvb_pos++) {
            /* insert a space every separator_interval_ bytes */
}
void Singleton::f2();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}
void Singleton::f3();{
    format_range.length = length;
    switch (mode) {
    case ModeNormal:
        return false;
    case ModeField:
}
void Singleton::f4();{
            }
            if (tvb_pos == hovered_byte_offset_ || tvb_pos == marked_byte_offset_) {
                QRect ho_rect = painter->boundingRect(QRect(), 0, line.right(1));
                ho_rect.moveRight(fontMetrics().boundingRect(line).width());
                ho_rect.moveTop(row_y);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        int np_start = 0;
        int np_len = 0;
        guchar c;
        for (int tvb_pos = offset; tvb_pos <= max_tvb_pos; tvb_pos++) {
            /* insert a space every separator_interval_ bytes */
}
void Singleton::f2();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}
void Singleton::f3();{
    format_range.length = length;
    switch (mode) {
    case ModeNormal:
        return false;
    case ModeField:
}
void Singleton::f4();{
            }
            if (tvb_pos == hovered_byte_offset_ || tvb_pos == marked_byte_offset_) {
                QRect ho_rect = painter->boundingRect(QRect(), 0, line.right(1));
                ho_rect.moveRight(fontMetrics().boundingRect(line).width());
                ho_rect.moveTop(row_y);
}
void Singleton::f5();{
    viewport()->update();
    QAbstractScrollArea::leaveEvent(event);
void ByteViewText::contextMenuEvent(QContextMenuEvent *event)
    ctx_menu_.exec(event->globalPos());
// Private
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        int np_start = 0;
        int np_len = 0;
        guchar c;
        for (int tvb_pos = offset; tvb_pos <= max_tvb_pos; tvb_pos++) {
            /* insert a space every separator_interval_ bytes */
}
void Singleton::f2();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}
void Singleton::f3();{
    format_range.length = length;
    switch (mode) {
    case ModeNormal:
        return false;
    case ModeField:
}
void Singleton::f4();{
            }
            if (tvb_pos == hovered_byte_offset_ || tvb_pos == marked_byte_offset_) {
                QRect ho_rect = painter->boundingRect(QRect(), 0, line.right(1));
                ho_rect.moveRight(fontMetrics().boundingRect(line).width());
                ho_rect.moveTop(row_y);
}
void Singleton::f5();{
    viewport()->update();
    QAbstractScrollArea::leaveEvent(event);
void ByteViewText::contextMenuEvent(QContextMenuEvent *event)
    ctx_menu_.exec(event->globalPos());
// Private
}
void Singleton::f6();{
    // We might want to set a composition mode when that's not the case.
    if (!hover_outlines_.isEmpty()) {
        qreal pen_width = 1.0;
        qreal hover_alpha = 0.6;
        QPen ho_pen;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        int np_start = 0;
        int np_len = 0;
        guchar c;
        for (int tvb_pos = offset; tvb_pos <= max_tvb_pos; tvb_pos++) {
            /* insert a space every separator_interval_ bytes */
}
void Singleton::f2();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}
void Singleton::f3();{
    format_range.length = length;
    switch (mode) {
    case ModeNormal:
        return false;
    case ModeField:
}
void Singleton::f4();{
            }
            if (tvb_pos == hovered_byte_offset_ || tvb_pos == marked_byte_offset_) {
                QRect ho_rect = painter->boundingRect(QRect(), 0, line.right(1));
                ho_rect.moveRight(fontMetrics().boundingRect(line).width());
                ho_rect.moveTop(row_y);
}
void Singleton::f5();{
    viewport()->update();
    QAbstractScrollArea::leaveEvent(event);
void ByteViewText::contextMenuEvent(QContextMenuEvent *event)
    ctx_menu_.exec(event->globalPos());
// Private
}
void Singleton::f6();{
    // We might want to set a composition mode when that's not the case.
    if (!hover_outlines_.isEmpty()) {
        qreal pen_width = 1.0;
        qreal hover_alpha = 0.6;
        QPen ho_pen;
}
void Singleton::f7();{
    ctx_menu_.addActions(format_actions->actions());
    connect(format_actions, &QActionGroup::triggered, this, &ByteViewText::setHexDisplayFormat);
    ctx_menu_.addSeparator();
    QActionGroup * encoding_actions = new QActionGroup(this);
    action = encoding_actions->addAction(tr("Show text based on packet"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        int np_start = 0;
        int np_len = 0;
        guchar c;
        for (int tvb_pos = offset; tvb_pos <= max_tvb_pos; tvb_pos++) {
            /* insert a space every separator_interval_ bytes */
}
void Singleton::f2();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}
void Singleton::f3();{
    format_range.length = length;
    switch (mode) {
    case ModeNormal:
        return false;
    case ModeField:
}
void Singleton::f4();{
            }
            if (tvb_pos == hovered_byte_offset_ || tvb_pos == marked_byte_offset_) {
                QRect ho_rect = painter->boundingRect(QRect(), 0, line.right(1));
                ho_rect.moveRight(fontMetrics().boundingRect(line).width());
                ho_rect.moveTop(row_y);
}
void Singleton::f5();{
    viewport()->update();
    QAbstractScrollArea::leaveEvent(event);
void ByteViewText::contextMenuEvent(QContextMenuEvent *event)
    ctx_menu_.exec(event->globalPos());
// Private
}
void Singleton::f6();{
    // We might want to set a composition mode when that's not the case.
    if (!hover_outlines_.isEmpty()) {
        qreal pen_width = 1.0;
        qreal hover_alpha = 0.6;
        QPen ho_pen;
}
void Singleton::f7();{
    ctx_menu_.addActions(format_actions->actions());
    connect(format_actions, &QActionGroup::triggered, this, &ByteViewText::setHexDisplayFormat);
    ctx_menu_.addSeparator();
    QActionGroup * encoding_actions = new QActionGroup(this);
    action = encoding_actions->addAction(tr("Show text based on packet"));
}
void Singleton::f8();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        int np_start = 0;
        int np_len = 0;
        guchar c;
        for (int tvb_pos = offset; tvb_pos <= max_tvb_pos; tvb_pos++) {
            /* insert a space every separator_interval_ bytes */
}
void Singleton::f2();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}
void Singleton::f3();{
    format_range.length = length;
    switch (mode) {
    case ModeNormal:
        return false;
    case ModeField:
}
void Singleton::f4();{
            }
            if (tvb_pos == hovered_byte_offset_ || tvb_pos == marked_byte_offset_) {
                QRect ho_rect = painter->boundingRect(QRect(), 0, line.right(1));
                ho_rect.moveRight(fontMetrics().boundingRect(line).width());
                ho_rect.moveTop(row_y);
}
void Singleton::f5();{
    viewport()->update();
    QAbstractScrollArea::leaveEvent(event);
void ByteViewText::contextMenuEvent(QContextMenuEvent *event)
    ctx_menu_.exec(event->globalPos());
// Private
}
void Singleton::f6();{
    // We might want to set a composition mode when that's not the case.
    if (!hover_outlines_.isEmpty()) {
        qreal pen_width = 1.0;
        qreal hover_alpha = 0.6;
        QPen ho_pen;
}
void Singleton::f7();{
    ctx_menu_.addActions(format_actions->actions());
    connect(format_actions, &QActionGroup::triggered, this, &ByteViewText::setHexDisplayFormat);
    ctx_menu_.addSeparator();
    QActionGroup * encoding_actions = new QActionGroup(this);
    action = encoding_actions->addAction(tr("Show text based on packet"));
}
void Singleton::f8();{
    hovered_byte_offset_ = byteOffsetAtPixel(event->pos());
    emit byteHovered(hovered_byte_offset_);
    viewport()->update();
void ByteViewText::leaveEvent(QEvent *event)
    hovered_byte_offset_ = -1;
}
void Singleton::f9();{
Q_DECLARE_METATYPE(bytes_encoding_type)
Q_DECLARE_METATYPE(DataPrinter::DumpType)
ByteViewText::ByteViewText(const QByteArray &data, packet_char_enc encoding, QWidget *parent) :
    QAbstractScrollArea(parent),
    layout_(new QTextLayout()),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Prepared, cap_session));
        cap_file_ = cap_session->cf;
        break;
    case(capture_cb_capture_update_started):
        emit captureEvent(CaptureEvent(CaptureEvent::Update, CaptureEvent::Started, cap_session));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Prepared, cap_session));
        cap_file_ = cap_session->cf;
        break;
    case(capture_cb_capture_update_started):
        emit captureEvent(CaptureEvent(CaptureEvent::Update, CaptureEvent::Started, cap_session));
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
 * @file Capture file class
}
void Singleton::f3();{
    }
void CaptureFile::delayedRetapPackets()
    QTimer::singleShot(0, this, SLOT(retapPackets()));
void CaptureFile::reload()
    if (cap_file_ && cap_file_->state == FILE_READ_DONE) {
}
void Singleton::f4();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Stopping, cap_session));
        break;
    case(capture_cb_capture_failed):
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
}
void Singleton::f5();{
    }
    return name;
const QString CaptureFile::fileBaseName()
    QString baseName;
    if (isValid()) {
}
void Singleton::f6();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
    default:
        qWarning() << "main_capture_callback: event " << event << " unknown";
    }
}
void Singleton::f7();{
int CaptureFile::currentRow()
    if (isValid())
        return cap_file_->current_row;
    return -1;
const QString CaptureFile::filePath()
}
void Singleton::f8();{
    if (!capture_file) return;
    capture_file->captureFileEvent(event, data);
void CaptureFile::captureCallback(gint event, capture_session *cap_session, gpointer user_data)
    CaptureFile *capture_file = static_cast<CaptureFile *>(user_data);
    if (!capture_file) return;
}
void Singleton::f9();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
    default:
        qWarning() << "main_capture_callback: event " << event << " unknown";
    }
}
void Singleton::f10();{
    }
    return baseName;
const QString CaptureFile::fileDisplayName()
    QString displayName;
    if (isValid()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Prepared, cap_session));
        cap_file_ = cap_session->cf;
        break;
    case(capture_cb_capture_update_started):
        emit captureEvent(CaptureEvent(CaptureEvent::Update, CaptureEvent::Started, cap_session));
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
 * @file Capture file class
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Prepared, cap_session));
        cap_file_ = cap_session->cf;
        break;
    case(capture_cb_capture_update_started):
        emit captureEvent(CaptureEvent(CaptureEvent::Update, CaptureEvent::Started, cap_session));
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
 * @file Capture file class
}
void Singleton::f3();{
    }
void CaptureFile::delayedRetapPackets()
    QTimer::singleShot(0, this, SLOT(retapPackets()));
void CaptureFile::reload()
    if (cap_file_ && cap_file_->state == FILE_READ_DONE) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Prepared, cap_session));
        cap_file_ = cap_session->cf;
        break;
    case(capture_cb_capture_update_started):
        emit captureEvent(CaptureEvent(CaptureEvent::Update, CaptureEvent::Started, cap_session));
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
 * @file Capture file class
}
void Singleton::f3();{
    }
void CaptureFile::delayedRetapPackets()
    QTimer::singleShot(0, this, SLOT(retapPackets()));
void CaptureFile::reload()
    if (cap_file_ && cap_file_->state == FILE_READ_DONE) {
}
void Singleton::f4();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Stopping, cap_session));
        break;
    case(capture_cb_capture_failed):
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Prepared, cap_session));
        cap_file_ = cap_session->cf;
        break;
    case(capture_cb_capture_update_started):
        emit captureEvent(CaptureEvent(CaptureEvent::Update, CaptureEvent::Started, cap_session));
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
 * @file Capture file class
}
void Singleton::f3();{
    }
void CaptureFile::delayedRetapPackets()
    QTimer::singleShot(0, this, SLOT(retapPackets()));
void CaptureFile::reload()
    if (cap_file_ && cap_file_->state == FILE_READ_DONE) {
}
void Singleton::f4();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Stopping, cap_session));
        break;
    case(capture_cb_capture_failed):
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
}
void Singleton::f5();{
    }
    return name;
const QString CaptureFile::fileBaseName()
    QString baseName;
    if (isValid()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Prepared, cap_session));
        cap_file_ = cap_session->cf;
        break;
    case(capture_cb_capture_update_started):
        emit captureEvent(CaptureEvent(CaptureEvent::Update, CaptureEvent::Started, cap_session));
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
 * @file Capture file class
}
void Singleton::f3();{
    }
void CaptureFile::delayedRetapPackets()
    QTimer::singleShot(0, this, SLOT(retapPackets()));
void CaptureFile::reload()
    if (cap_file_ && cap_file_->state == FILE_READ_DONE) {
}
void Singleton::f4();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Stopping, cap_session));
        break;
    case(capture_cb_capture_failed):
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
}
void Singleton::f5();{
    }
    return name;
const QString CaptureFile::fileBaseName()
    QString baseName;
    if (isValid()) {
}
void Singleton::f6();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
    default:
        qWarning() << "main_capture_callback: event " << event << " unknown";
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Prepared, cap_session));
        cap_file_ = cap_session->cf;
        break;
    case(capture_cb_capture_update_started):
        emit captureEvent(CaptureEvent(CaptureEvent::Update, CaptureEvent::Started, cap_session));
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
 * @file Capture file class
}
void Singleton::f3();{
    }
void CaptureFile::delayedRetapPackets()
    QTimer::singleShot(0, this, SLOT(retapPackets()));
void CaptureFile::reload()
    if (cap_file_ && cap_file_->state == FILE_READ_DONE) {
}
void Singleton::f4();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Stopping, cap_session));
        break;
    case(capture_cb_capture_failed):
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
}
void Singleton::f5();{
    }
    return name;
const QString CaptureFile::fileBaseName()
    QString baseName;
    if (isValid()) {
}
void Singleton::f6();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
    default:
        qWarning() << "main_capture_callback: event " << event << " unknown";
    }
}
void Singleton::f7();{
int CaptureFile::currentRow()
    if (isValid())
        return cap_file_->current_row;
    return -1;
const QString CaptureFile::filePath()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Prepared, cap_session));
        cap_file_ = cap_session->cf;
        break;
    case(capture_cb_capture_update_started):
        emit captureEvent(CaptureEvent(CaptureEvent::Update, CaptureEvent::Started, cap_session));
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
 * @file Capture file class
}
void Singleton::f3();{
    }
void CaptureFile::delayedRetapPackets()
    QTimer::singleShot(0, this, SLOT(retapPackets()));
void CaptureFile::reload()
    if (cap_file_ && cap_file_->state == FILE_READ_DONE) {
}
void Singleton::f4();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Stopping, cap_session));
        break;
    case(capture_cb_capture_failed):
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
}
void Singleton::f5();{
    }
    return name;
const QString CaptureFile::fileBaseName()
    QString baseName;
    if (isValid()) {
}
void Singleton::f6();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
    default:
        qWarning() << "main_capture_callback: event " << event << " unknown";
    }
}
void Singleton::f7();{
int CaptureFile::currentRow()
    if (isValid())
        return cap_file_->current_row;
    return -1;
const QString CaptureFile::filePath()
}
void Singleton::f8();{
    if (!capture_file) return;
    capture_file->captureFileEvent(event, data);
void CaptureFile::captureCallback(gint event, capture_session *cap_session, gpointer user_data)
    CaptureFile *capture_file = static_cast<CaptureFile *>(user_data);
    if (!capture_file) return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Prepared, cap_session));
        cap_file_ = cap_session->cf;
        break;
    case(capture_cb_capture_update_started):
        emit captureEvent(CaptureEvent(CaptureEvent::Update, CaptureEvent::Started, cap_session));
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
 * @file Capture file class
}
void Singleton::f3();{
    }
void CaptureFile::delayedRetapPackets()
    QTimer::singleShot(0, this, SLOT(retapPackets()));
void CaptureFile::reload()
    if (cap_file_ && cap_file_->state == FILE_READ_DONE) {
}
void Singleton::f4();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Stopping, cap_session));
        break;
    case(capture_cb_capture_failed):
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
}
void Singleton::f5();{
    }
    return name;
const QString CaptureFile::fileBaseName()
    QString baseName;
    if (isValid()) {
}
void Singleton::f6();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
    default:
        qWarning() << "main_capture_callback: event " << event << " unknown";
    }
}
void Singleton::f7();{
int CaptureFile::currentRow()
    if (isValid())
        return cap_file_->current_row;
    return -1;
const QString CaptureFile::filePath()
}
void Singleton::f8();{
    if (!capture_file) return;
    capture_file->captureFileEvent(event, data);
void CaptureFile::captureCallback(gint event, capture_session *cap_session, gpointer user_data)
    CaptureFile *capture_file = static_cast<CaptureFile *>(user_data);
    if (!capture_file) return;
}
void Singleton::f9();{
        emit captureEvent(CaptureEvent(CaptureEvent::Capture, CaptureEvent::Failed, cap_session));
        break;
    default:
        qWarning() << "main_capture_callback: event " << event << " unknown";
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    return QDialog::Rejected;
// Windows
// We use native file dialogs here, rather than the Qt dialog
int CaptureFileDialog::selectedFileType() {
    return file_type_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    return QDialog::Rejected;
// Windows
// We use native file dialogs here, rather than the Qt dialog
int CaptureFileDialog::selectedFileType() {
    return file_type_;
}
void Singleton::f2();{
        GSList *compression_type_extensions = wtap_get_all_compression_type_extensions_list();
        for (GSList *compression_type_extension = compression_type_extensions;
            compression_type_extension != NULL;
            compression_type_extension = g_slist_next(compression_type_extension)) {
            QString suffix = QString(".") + (char *)compression_type_extension->data;
}
void Singleton::f3();{
    GString *fname = g_string_new(file_name.toUtf8().constData());
    GString *dfilter = g_string_new(display_filter_.toUtf8().constData());
    gboolean wof_status;
    // XXX Add a widget->HWND routine to qt_ui_utils and use it instead.
    wof_status = win32_open_file((HWND)parentWidget()->effectiveWinId(), title_str.toStdWString().c_str(), fname, &type, dfilter);
}
void Singleton::f4();{
    }
    return CANCELLED;
int CaptureFileDialog::merge(QString &file_name) {
    setWindowTitle(wsApp->windowTitleString(tr("Merge Capture File")));
    setNameFilters(buildFileOpenTypeList());
}
void Singleton::f5();{
    // Grow the dialog to account for the extra widgets.
    resize(width(), height() + (packet_range_group_box_.height() * 2 / 3));
    if (!file_name.isEmpty()) {
        selectFile(file_name);
    }
}
void Singleton::f6();{
/* capture_file_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f7();{
void CaptureFileDialog::preview(const QString & path)
    wtap        *wth;
    int          err;
    gchar       *err_info;
    ws_file_preview_stats stats;
}
void Singleton::f8();{
    /* Include all the file types Wireshark supports. */
    for (et = 0; et < wtap_get_num_file_type_extensions(); et++) {
        filters << fileExtensionType(et);
    }
    return filters;
}
void Singleton::f9();{
        display_filter_.append(display_filter_edit_->text());
        return QDialog::Accepted;
    } else {
        return QDialog::Rejected;
    }
}
void Singleton::f10();{
         * use the "last opened" directory saved in the preferences file if
         * there was one.
         */
        setDirectory(wsApp->lastOpenDir());
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    return QDialog::Rejected;
// Windows
// We use native file dialogs here, rather than the Qt dialog
int CaptureFileDialog::selectedFileType() {
    return file_type_;
}
void Singleton::f2();{
        GSList *compression_type_extensions = wtap_get_all_compression_type_extensions_list();
        for (GSList *compression_type_extension = compression_type_extensions;
            compression_type_extension != NULL;
            compression_type_extension = g_slist_next(compression_type_extension)) {
            QString suffix = QString(".") + (char *)compression_type_extension->data;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    return QDialog::Rejected;
// Windows
// We use native file dialogs here, rather than the Qt dialog
int CaptureFileDialog::selectedFileType() {
    return file_type_;
}
void Singleton::f2();{
        GSList *compression_type_extensions = wtap_get_all_compression_type_extensions_list();
        for (GSList *compression_type_extension = compression_type_extensions;
            compression_type_extension != NULL;
            compression_type_extension = g_slist_next(compression_type_extension)) {
            QString suffix = QString(".") + (char *)compression_type_extension->data;
}
void Singleton::f3();{
    GString *fname = g_string_new(file_name.toUtf8().constData());
    GString *dfilter = g_string_new(display_filter_.toUtf8().constData());
    gboolean wof_status;
    // XXX Add a widget->HWND routine to qt_ui_utils and use it instead.
    wof_status = win32_open_file((HWND)parentWidget()->effectiveWinId(), title_str.toStdWString().c_str(), fname, &type, dfilter);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    return QDialog::Rejected;
// Windows
// We use native file dialogs here, rather than the Qt dialog
int CaptureFileDialog::selectedFileType() {
    return file_type_;
}
void Singleton::f2();{
        GSList *compression_type_extensions = wtap_get_all_compression_type_extensions_list();
        for (GSList *compression_type_extension = compression_type_extensions;
            compression_type_extension != NULL;
            compression_type_extension = g_slist_next(compression_type_extension)) {
            QString suffix = QString(".") + (char *)compression_type_extension->data;
}
void Singleton::f3();{
    GString *fname = g_string_new(file_name.toUtf8().constData());
    GString *dfilter = g_string_new(display_filter_.toUtf8().constData());
    gboolean wof_status;
    // XXX Add a widget->HWND routine to qt_ui_utils and use it instead.
    wof_status = win32_open_file((HWND)parentWidget()->effectiveWinId(), title_str.toStdWString().c_str(), fname, &type, dfilter);
}
void Singleton::f4();{
    }
    return CANCELLED;
int CaptureFileDialog::merge(QString &file_name) {
    setWindowTitle(wsApp->windowTitleString(tr("Merge Capture File")));
    setNameFilters(buildFileOpenTypeList());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    return QDialog::Rejected;
// Windows
// We use native file dialogs here, rather than the Qt dialog
int CaptureFileDialog::selectedFileType() {
    return file_type_;
}
void Singleton::f2();{
        GSList *compression_type_extensions = wtap_get_all_compression_type_extensions_list();
        for (GSList *compression_type_extension = compression_type_extensions;
            compression_type_extension != NULL;
            compression_type_extension = g_slist_next(compression_type_extension)) {
            QString suffix = QString(".") + (char *)compression_type_extension->data;
}
void Singleton::f3();{
    GString *fname = g_string_new(file_name.toUtf8().constData());
    GString *dfilter = g_string_new(display_filter_.toUtf8().constData());
    gboolean wof_status;
    // XXX Add a widget->HWND routine to qt_ui_utils and use it instead.
    wof_status = win32_open_file((HWND)parentWidget()->effectiveWinId(), title_str.toStdWString().c_str(), fname, &type, dfilter);
}
void Singleton::f4();{
    }
    return CANCELLED;
int CaptureFileDialog::merge(QString &file_name) {
    setWindowTitle(wsApp->windowTitleString(tr("Merge Capture File")));
    setNameFilters(buildFileOpenTypeList());
}
void Singleton::f5();{
    // Grow the dialog to account for the extra widgets.
    resize(width(), height() + (packet_range_group_box_.height() * 2 / 3));
    if (!file_name.isEmpty()) {
        selectFile(file_name);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    return QDialog::Rejected;
// Windows
// We use native file dialogs here, rather than the Qt dialog
int CaptureFileDialog::selectedFileType() {
    return file_type_;
}
void Singleton::f2();{
        GSList *compression_type_extensions = wtap_get_all_compression_type_extensions_list();
        for (GSList *compression_type_extension = compression_type_extensions;
            compression_type_extension != NULL;
            compression_type_extension = g_slist_next(compression_type_extension)) {
            QString suffix = QString(".") + (char *)compression_type_extension->data;
}
void Singleton::f3();{
    GString *fname = g_string_new(file_name.toUtf8().constData());
    GString *dfilter = g_string_new(display_filter_.toUtf8().constData());
    gboolean wof_status;
    // XXX Add a widget->HWND routine to qt_ui_utils and use it instead.
    wof_status = win32_open_file((HWND)parentWidget()->effectiveWinId(), title_str.toStdWString().c_str(), fname, &type, dfilter);
}
void Singleton::f4();{
    }
    return CANCELLED;
int CaptureFileDialog::merge(QString &file_name) {
    setWindowTitle(wsApp->windowTitleString(tr("Merge Capture File")));
    setNameFilters(buildFileOpenTypeList());
}
void Singleton::f5();{
    // Grow the dialog to account for the extra widgets.
    resize(width(), height() + (packet_range_group_box_.height() * 2 / 3));
    if (!file_name.isEmpty()) {
        selectFile(file_name);
    }
}
void Singleton::f6();{
/* capture_file_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    return QDialog::Rejected;
// Windows
// We use native file dialogs here, rather than the Qt dialog
int CaptureFileDialog::selectedFileType() {
    return file_type_;
}
void Singleton::f2();{
        GSList *compression_type_extensions = wtap_get_all_compression_type_extensions_list();
        for (GSList *compression_type_extension = compression_type_extensions;
            compression_type_extension != NULL;
            compression_type_extension = g_slist_next(compression_type_extension)) {
            QString suffix = QString(".") + (char *)compression_type_extension->data;
}
void Singleton::f3();{
    GString *fname = g_string_new(file_name.toUtf8().constData());
    GString *dfilter = g_string_new(display_filter_.toUtf8().constData());
    gboolean wof_status;
    // XXX Add a widget->HWND routine to qt_ui_utils and use it instead.
    wof_status = win32_open_file((HWND)parentWidget()->effectiveWinId(), title_str.toStdWString().c_str(), fname, &type, dfilter);
}
void Singleton::f4();{
    }
    return CANCELLED;
int CaptureFileDialog::merge(QString &file_name) {
    setWindowTitle(wsApp->windowTitleString(tr("Merge Capture File")));
    setNameFilters(buildFileOpenTypeList());
}
void Singleton::f5();{
    // Grow the dialog to account for the extra widgets.
    resize(width(), height() + (packet_range_group_box_.height() * 2 / 3));
    if (!file_name.isEmpty()) {
        selectFile(file_name);
    }
}
void Singleton::f6();{
/* capture_file_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f7();{
void CaptureFileDialog::preview(const QString & path)
    wtap        *wth;
    int          err;
    gchar       *err_info;
    ws_file_preview_stats stats;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    return QDialog::Rejected;
// Windows
// We use native file dialogs here, rather than the Qt dialog
int CaptureFileDialog::selectedFileType() {
    return file_type_;
}
void Singleton::f2();{
        GSList *compression_type_extensions = wtap_get_all_compression_type_extensions_list();
        for (GSList *compression_type_extension = compression_type_extensions;
            compression_type_extension != NULL;
            compression_type_extension = g_slist_next(compression_type_extension)) {
            QString suffix = QString(".") + (char *)compression_type_extension->data;
}
void Singleton::f3();{
    GString *fname = g_string_new(file_name.toUtf8().constData());
    GString *dfilter = g_string_new(display_filter_.toUtf8().constData());
    gboolean wof_status;
    // XXX Add a widget->HWND routine to qt_ui_utils and use it instead.
    wof_status = win32_open_file((HWND)parentWidget()->effectiveWinId(), title_str.toStdWString().c_str(), fname, &type, dfilter);
}
void Singleton::f4();{
    }
    return CANCELLED;
int CaptureFileDialog::merge(QString &file_name) {
    setWindowTitle(wsApp->windowTitleString(tr("Merge Capture File")));
    setNameFilters(buildFileOpenTypeList());
}
void Singleton::f5();{
    // Grow the dialog to account for the extra widgets.
    resize(width(), height() + (packet_range_group_box_.height() * 2 / 3));
    if (!file_name.isEmpty()) {
        selectFile(file_name);
    }
}
void Singleton::f6();{
/* capture_file_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f7();{
void CaptureFileDialog::preview(const QString & path)
    wtap        *wth;
    int          err;
    gchar       *err_info;
    ws_file_preview_stats stats;
}
void Singleton::f8();{
    /* Include all the file types Wireshark supports. */
    for (et = 0; et < wtap_get_num_file_type_extensions(); et++) {
        filters << fileExtensionType(et);
    }
    return filters;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    return QDialog::Rejected;
// Windows
// We use native file dialogs here, rather than the Qt dialog
int CaptureFileDialog::selectedFileType() {
    return file_type_;
}
void Singleton::f2();{
        GSList *compression_type_extensions = wtap_get_all_compression_type_extensions_list();
        for (GSList *compression_type_extension = compression_type_extensions;
            compression_type_extension != NULL;
            compression_type_extension = g_slist_next(compression_type_extension)) {
            QString suffix = QString(".") + (char *)compression_type_extension->data;
}
void Singleton::f3();{
    GString *fname = g_string_new(file_name.toUtf8().constData());
    GString *dfilter = g_string_new(display_filter_.toUtf8().constData());
    gboolean wof_status;
    // XXX Add a widget->HWND routine to qt_ui_utils and use it instead.
    wof_status = win32_open_file((HWND)parentWidget()->effectiveWinId(), title_str.toStdWString().c_str(), fname, &type, dfilter);
}
void Singleton::f4();{
    }
    return CANCELLED;
int CaptureFileDialog::merge(QString &file_name) {
    setWindowTitle(wsApp->windowTitleString(tr("Merge Capture File")));
    setNameFilters(buildFileOpenTypeList());
}
void Singleton::f5();{
    // Grow the dialog to account for the extra widgets.
    resize(width(), height() + (packet_range_group_box_.height() * 2 / 3));
    if (!file_name.isEmpty()) {
        selectFile(file_name);
    }
}
void Singleton::f6();{
/* capture_file_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f7();{
void CaptureFileDialog::preview(const QString & path)
    wtap        *wth;
    int          err;
    gchar       *err_info;
    ws_file_preview_stats stats;
}
void Singleton::f8();{
    /* Include all the file types Wireshark supports. */
    for (et = 0; et < wtap_get_num_file_type_extensions(); et++) {
        filters << fileExtensionType(et);
    }
    return filters;
}
void Singleton::f9();{
        display_filter_.append(display_filter_edit_->text());
        return QDialog::Accepted;
    } else {
        return QDialog::Rejected;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    fillDetails();
    // XXX - this just handles the first comment in the first section;
    // add support for multiple sections with multiple comments.
    wtap_block_t shb = wtap_file_get_shb(cap_file_.capFile()->provider.wth, 0);
    char *shb_comment;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    fillDetails();
    // XXX - this just handles the first comment in the first section;
    // add support for multiple sections with multiple comments.
    wtap_block_t shb = wtap_file_get_shb(cap_file_.capFile()->provider.wth, 0);
    char *shb_comment;
}
void Singleton::f2();{
            break;
        }
    }
    QDialog::changeEvent(event);
void CaptureFilePropertiesDialog::on_buttonBox_helpRequested()
}
void Singleton::f3();{
                << table_row_end;
        }
        out << table_end;
    }
    // Information from file sections.
}
void Singleton::f4();{
        cursor.insertBlock();
        cursor.insertHtml(section_tmpl_.arg(tr("Packet Comments")));
        for (guint32 framenum = 1; framenum <= cap_file_.capFile()->count ; framenum++) {
            frame_data *fdata = frame_data_sequence_find(cap_file_.capFile()->provider.frames, framenum);
            char *pkt_comment = cf_get_packet_comment(cap_file_.capFile(), fdata);
}
void Singleton::f5();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f6();{
void CaptureFilePropertiesDialog::fillDetails()
    if (!cap_file_.isValid()) return;
    ui->detailsTextEdit->clear();
    QTextCursor cursor = ui->detailsTextEdit->textCursor();
    QString summary = summaryToHtml();
}
void Singleton::f7();{
    if (marked_seconds > 0) {
            marked_str =
                    gchar_free_to_qstring(format_size(summary.marked_bytes * 8 / marked_seconds, format_size_unit_none|format_size_prefix_si));
    }
    out << table_row_begin
}
void Singleton::f8();{
        out << table_begin;
        // start time
        out << table_row_begin
            << table_vheader_tmpl.arg(tr("First packet"))
            << table_data_tmpl.arg(time_t_to_qstring((time_t)summary.start_time))
}
void Singleton::f9();{
        << table_row_end;
    QString format_str = wtap_file_type_subtype_string(summary.file_type);
    const char *compression_type_description = wtap_compression_type_description(summary.compression_type);
    if (compression_type_description != nullptr) {
        format_str += QString(" (%1)").arg(compression_type_description);
}
void Singleton::f10();{
    }
    button = ui->buttonBox->button(QDialogButtonBox::Close);
    if (button) {
        button->setDefault(true);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    fillDetails();
    // XXX - this just handles the first comment in the first section;
    // add support for multiple sections with multiple comments.
    wtap_block_t shb = wtap_file_get_shb(cap_file_.capFile()->provider.wth, 0);
    char *shb_comment;
}
void Singleton::f2();{
            break;
        }
    }
    QDialog::changeEvent(event);
void CaptureFilePropertiesDialog::on_buttonBox_helpRequested()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    fillDetails();
    // XXX - this just handles the first comment in the first section;
    // add support for multiple sections with multiple comments.
    wtap_block_t shb = wtap_file_get_shb(cap_file_.capFile()->provider.wth, 0);
    char *shb_comment;
}
void Singleton::f2();{
            break;
        }
    }
    QDialog::changeEvent(event);
void CaptureFilePropertiesDialog::on_buttonBox_helpRequested()
}
void Singleton::f3();{
                << table_row_end;
        }
        out << table_end;
    }
    // Information from file sections.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    fillDetails();
    // XXX - this just handles the first comment in the first section;
    // add support for multiple sections with multiple comments.
    wtap_block_t shb = wtap_file_get_shb(cap_file_.capFile()->provider.wth, 0);
    char *shb_comment;
}
void Singleton::f2();{
            break;
        }
    }
    QDialog::changeEvent(event);
void CaptureFilePropertiesDialog::on_buttonBox_helpRequested()
}
void Singleton::f3();{
                << table_row_end;
        }
        out << table_end;
    }
    // Information from file sections.
}
void Singleton::f4();{
        cursor.insertBlock();
        cursor.insertHtml(section_tmpl_.arg(tr("Packet Comments")));
        for (guint32 framenum = 1; framenum <= cap_file_.capFile()->count ; framenum++) {
            frame_data *fdata = frame_data_sequence_find(cap_file_.capFile()->provider.frames, framenum);
            char *pkt_comment = cf_get_packet_comment(cap_file_.capFile(), fdata);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    fillDetails();
    // XXX - this just handles the first comment in the first section;
    // add support for multiple sections with multiple comments.
    wtap_block_t shb = wtap_file_get_shb(cap_file_.capFile()->provider.wth, 0);
    char *shb_comment;
}
void Singleton::f2();{
            break;
        }
    }
    QDialog::changeEvent(event);
void CaptureFilePropertiesDialog::on_buttonBox_helpRequested()
}
void Singleton::f3();{
                << table_row_end;
        }
        out << table_end;
    }
    // Information from file sections.
}
void Singleton::f4();{
        cursor.insertBlock();
        cursor.insertHtml(section_tmpl_.arg(tr("Packet Comments")));
        for (guint32 framenum = 1; framenum <= cap_file_.capFile()->count ; framenum++) {
            frame_data *fdata = frame_data_sequence_find(cap_file_.capFile()->provider.frames, framenum);
            char *pkt_comment = cf_get_packet_comment(cap_file_.capFile(), fdata);
}
void Singleton::f5();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    fillDetails();
    // XXX - this just handles the first comment in the first section;
    // add support for multiple sections with multiple comments.
    wtap_block_t shb = wtap_file_get_shb(cap_file_.capFile()->provider.wth, 0);
    char *shb_comment;
}
void Singleton::f2();{
            break;
        }
    }
    QDialog::changeEvent(event);
void CaptureFilePropertiesDialog::on_buttonBox_helpRequested()
}
void Singleton::f3();{
                << table_row_end;
        }
        out << table_end;
    }
    // Information from file sections.
}
void Singleton::f4();{
        cursor.insertBlock();
        cursor.insertHtml(section_tmpl_.arg(tr("Packet Comments")));
        for (guint32 framenum = 1; framenum <= cap_file_.capFile()->count ; framenum++) {
            frame_data *fdata = frame_data_sequence_find(cap_file_.capFile()->provider.frames, framenum);
            char *pkt_comment = cf_get_packet_comment(cap_file_.capFile(), fdata);
}
void Singleton::f5();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f6();{
void CaptureFilePropertiesDialog::fillDetails()
    if (!cap_file_.isValid()) return;
    ui->detailsTextEdit->clear();
    QTextCursor cursor = ui->detailsTextEdit->textCursor();
    QString summary = summaryToHtml();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    fillDetails();
    // XXX - this just handles the first comment in the first section;
    // add support for multiple sections with multiple comments.
    wtap_block_t shb = wtap_file_get_shb(cap_file_.capFile()->provider.wth, 0);
    char *shb_comment;
}
void Singleton::f2();{
            break;
        }
    }
    QDialog::changeEvent(event);
void CaptureFilePropertiesDialog::on_buttonBox_helpRequested()
}
void Singleton::f3();{
                << table_row_end;
        }
        out << table_end;
    }
    // Information from file sections.
}
void Singleton::f4();{
        cursor.insertBlock();
        cursor.insertHtml(section_tmpl_.arg(tr("Packet Comments")));
        for (guint32 framenum = 1; framenum <= cap_file_.capFile()->count ; framenum++) {
            frame_data *fdata = frame_data_sequence_find(cap_file_.capFile()->provider.frames, framenum);
            char *pkt_comment = cf_get_packet_comment(cap_file_.capFile(), fdata);
}
void Singleton::f5();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f6();{
void CaptureFilePropertiesDialog::fillDetails()
    if (!cap_file_.isValid()) return;
    ui->detailsTextEdit->clear();
    QTextCursor cursor = ui->detailsTextEdit->textCursor();
    QString summary = summaryToHtml();
}
void Singleton::f7();{
    if (marked_seconds > 0) {
            marked_str =
                    gchar_free_to_qstring(format_size(summary.marked_bytes * 8 / marked_seconds, format_size_unit_none|format_size_prefix_si));
    }
    out << table_row_begin
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    fillDetails();
    // XXX - this just handles the first comment in the first section;
    // add support for multiple sections with multiple comments.
    wtap_block_t shb = wtap_file_get_shb(cap_file_.capFile()->provider.wth, 0);
    char *shb_comment;
}
void Singleton::f2();{
            break;
        }
    }
    QDialog::changeEvent(event);
void CaptureFilePropertiesDialog::on_buttonBox_helpRequested()
}
void Singleton::f3();{
                << table_row_end;
        }
        out << table_end;
    }
    // Information from file sections.
}
void Singleton::f4();{
        cursor.insertBlock();
        cursor.insertHtml(section_tmpl_.arg(tr("Packet Comments")));
        for (guint32 framenum = 1; framenum <= cap_file_.capFile()->count ; framenum++) {
            frame_data *fdata = frame_data_sequence_find(cap_file_.capFile()->provider.frames, framenum);
            char *pkt_comment = cf_get_packet_comment(cap_file_.capFile(), fdata);
}
void Singleton::f5();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f6();{
void CaptureFilePropertiesDialog::fillDetails()
    if (!cap_file_.isValid()) return;
    ui->detailsTextEdit->clear();
    QTextCursor cursor = ui->detailsTextEdit->textCursor();
    QString summary = summaryToHtml();
}
void Singleton::f7();{
    if (marked_seconds > 0) {
            marked_str =
                    gchar_free_to_qstring(format_size(summary.marked_bytes * 8 / marked_seconds, format_size_unit_none|format_size_prefix_si));
    }
    out << table_row_begin
}
void Singleton::f8();{
        out << table_begin;
        // start time
        out << table_row_begin
            << table_vheader_tmpl.arg(tr("First packet"))
            << table_data_tmpl.arg(time_t_to_qstring((time_t)summary.start_time))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    fillDetails();
    // XXX - this just handles the first comment in the first section;
    // add support for multiple sections with multiple comments.
    wtap_block_t shb = wtap_file_get_shb(cap_file_.capFile()->provider.wth, 0);
    char *shb_comment;
}
void Singleton::f2();{
            break;
        }
    }
    QDialog::changeEvent(event);
void CaptureFilePropertiesDialog::on_buttonBox_helpRequested()
}
void Singleton::f3();{
                << table_row_end;
        }
        out << table_end;
    }
    // Information from file sections.
}
void Singleton::f4();{
        cursor.insertBlock();
        cursor.insertHtml(section_tmpl_.arg(tr("Packet Comments")));
        for (guint32 framenum = 1; framenum <= cap_file_.capFile()->count ; framenum++) {
            frame_data *fdata = frame_data_sequence_find(cap_file_.capFile()->provider.frames, framenum);
            char *pkt_comment = cf_get_packet_comment(cap_file_.capFile(), fdata);
}
void Singleton::f5();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f6();{
void CaptureFilePropertiesDialog::fillDetails()
    if (!cap_file_.isValid()) return;
    ui->detailsTextEdit->clear();
    QTextCursor cursor = ui->detailsTextEdit->textCursor();
    QString summary = summaryToHtml();
}
void Singleton::f7();{
    if (marked_seconds > 0) {
            marked_str =
                    gchar_free_to_qstring(format_size(summary.marked_bytes * 8 / marked_seconds, format_size_unit_none|format_size_prefix_si));
    }
    out << table_row_begin
}
void Singleton::f8();{
        out << table_begin;
        // start time
        out << table_row_begin
            << table_vheader_tmpl.arg(tr("First packet"))
            << table_data_tmpl.arg(time_t_to_qstring((time_t)summary.start_time))
}
void Singleton::f9();{
        << table_row_end;
    QString format_str = wtap_file_type_subtype_string(summary.file_type);
    const char *compression_type_description = wtap_compression_type_description(summary.compression_type);
    if (compression_type_description != nullptr) {
        format_str += QString(" (%1)").arg(compression_type_description);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    case QEvent::ApplicationPaletteChange:
        updateStyleSheet();
        break;
    default:
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    case QEvent::ApplicationPaletteChange:
        updateStyleSheet();
        break;
    default:
        break;
}
void Singleton::f2();{
    connect(this, &CaptureFilterCombo::interfacesChanged, cf_edit_,
            static_cast<void (CaptureFilterEdit::*)()>(&CaptureFilterEdit::checkFilter));
    connect(cf_edit_, &CaptureFilterEdit::captureFilterSyntaxChanged,
            this, &CaptureFilterCombo::captureFilterSyntaxChanged);
    connect(cf_edit_, &CaptureFilterEdit::startCapture, this, &CaptureFilterCombo::startCapture);
}
void Singleton::f3();{
void CaptureFilterCombo::rebuildFilterList()
    lineEdit()->blockSignals(true);
    GList *cfilter_list = recent_get_cfilter_list(NULL);
    QString cur_filter = currentText();
    clear();
}
void Singleton::f4();{
                " }"
                "QComboBox::drop-down {"
                "  subcontrol-origin: padding;"
                "  subcontrol-position: top right;"
                "  width: 16px;"
}
void Singleton::f5();{
    lineEdit()->blockSignals(false);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f6();{
    }
    return QComboBox::event(event);
void CaptureFilterCombo::updateStyleSheet()
    const char *display_mode = ColorUtils::themeIsDark() ? "dark" : "light";
    QString ss = QString(
}
void Singleton::f7();{
    // setLineEdit will create a new QCompleter that performs inline completion,
    // be sure to disable that since our CaptureFilterEdit performs its own
    // popup completion. As QLineEdit's completer is designed for full line
    // completion, we cannot reuse it for word completion.
    setCompleter(0);
}
void Singleton::f8();{
                "  padding: 0px 0px 0px 0px;"
                "  margin-left: 0px;"
                "  min-width: 20em;"
                " }"
                "QComboBox::drop-down {"
}
void Singleton::f9();{
    // popup completion. As QLineEdit's completer is designed for full line
    // completion, we cannot reuse it for word completion.
    setCompleter(0);
    // Default is Preferred.
    setSizePolicy(QSizePolicy::MinimumExpanding, sizePolicy().verticalPolicy());
}
void Singleton::f10();{
void CaptureFilterCombo::writeRecent(FILE *rf)
    int i;
    for (i = 0; i < count(); i++) {
        const QByteArray& filter = itemText(i).toUtf8();
        if (!filter.isEmpty()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    case QEvent::ApplicationPaletteChange:
        updateStyleSheet();
        break;
    default:
        break;
}
void Singleton::f2();{
    connect(this, &CaptureFilterCombo::interfacesChanged, cf_edit_,
            static_cast<void (CaptureFilterEdit::*)()>(&CaptureFilterEdit::checkFilter));
    connect(cf_edit_, &CaptureFilterEdit::captureFilterSyntaxChanged,
            this, &CaptureFilterCombo::captureFilterSyntaxChanged);
    connect(cf_edit_, &CaptureFilterEdit::startCapture, this, &CaptureFilterCombo::startCapture);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    case QEvent::ApplicationPaletteChange:
        updateStyleSheet();
        break;
    default:
        break;
}
void Singleton::f2();{
    connect(this, &CaptureFilterCombo::interfacesChanged, cf_edit_,
            static_cast<void (CaptureFilterEdit::*)()>(&CaptureFilterEdit::checkFilter));
    connect(cf_edit_, &CaptureFilterEdit::captureFilterSyntaxChanged,
            this, &CaptureFilterCombo::captureFilterSyntaxChanged);
    connect(cf_edit_, &CaptureFilterEdit::startCapture, this, &CaptureFilterCombo::startCapture);
}
void Singleton::f3();{
void CaptureFilterCombo::rebuildFilterList()
    lineEdit()->blockSignals(true);
    GList *cfilter_list = recent_get_cfilter_list(NULL);
    QString cur_filter = currentText();
    clear();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    case QEvent::ApplicationPaletteChange:
        updateStyleSheet();
        break;
    default:
        break;
}
void Singleton::f2();{
    connect(this, &CaptureFilterCombo::interfacesChanged, cf_edit_,
            static_cast<void (CaptureFilterEdit::*)()>(&CaptureFilterEdit::checkFilter));
    connect(cf_edit_, &CaptureFilterEdit::captureFilterSyntaxChanged,
            this, &CaptureFilterCombo::captureFilterSyntaxChanged);
    connect(cf_edit_, &CaptureFilterEdit::startCapture, this, &CaptureFilterCombo::startCapture);
}
void Singleton::f3();{
void CaptureFilterCombo::rebuildFilterList()
    lineEdit()->blockSignals(true);
    GList *cfilter_list = recent_get_cfilter_list(NULL);
    QString cur_filter = currentText();
    clear();
}
void Singleton::f4();{
                " }"
                "QComboBox::drop-down {"
                "  subcontrol-origin: padding;"
                "  subcontrol-position: top right;"
                "  width: 16px;"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    case QEvent::ApplicationPaletteChange:
        updateStyleSheet();
        break;
    default:
        break;
}
void Singleton::f2();{
    connect(this, &CaptureFilterCombo::interfacesChanged, cf_edit_,
            static_cast<void (CaptureFilterEdit::*)()>(&CaptureFilterEdit::checkFilter));
    connect(cf_edit_, &CaptureFilterEdit::captureFilterSyntaxChanged,
            this, &CaptureFilterCombo::captureFilterSyntaxChanged);
    connect(cf_edit_, &CaptureFilterEdit::startCapture, this, &CaptureFilterCombo::startCapture);
}
void Singleton::f3();{
void CaptureFilterCombo::rebuildFilterList()
    lineEdit()->blockSignals(true);
    GList *cfilter_list = recent_get_cfilter_list(NULL);
    QString cur_filter = currentText();
    clear();
}
void Singleton::f4();{
                " }"
                "QComboBox::drop-down {"
                "  subcontrol-origin: padding;"
                "  subcontrol-position: top right;"
                "  width: 16px;"
}
void Singleton::f5();{
    lineEdit()->blockSignals(false);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    case QEvent::ApplicationPaletteChange:
        updateStyleSheet();
        break;
    default:
        break;
}
void Singleton::f2();{
    connect(this, &CaptureFilterCombo::interfacesChanged, cf_edit_,
            static_cast<void (CaptureFilterEdit::*)()>(&CaptureFilterEdit::checkFilter));
    connect(cf_edit_, &CaptureFilterEdit::captureFilterSyntaxChanged,
            this, &CaptureFilterCombo::captureFilterSyntaxChanged);
    connect(cf_edit_, &CaptureFilterEdit::startCapture, this, &CaptureFilterCombo::startCapture);
}
void Singleton::f3();{
void CaptureFilterCombo::rebuildFilterList()
    lineEdit()->blockSignals(true);
    GList *cfilter_list = recent_get_cfilter_list(NULL);
    QString cur_filter = currentText();
    clear();
}
void Singleton::f4();{
                " }"
                "QComboBox::drop-down {"
                "  subcontrol-origin: padding;"
                "  subcontrol-position: top right;"
                "  width: 16px;"
}
void Singleton::f5();{
    lineEdit()->blockSignals(false);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f6();{
    }
    return QComboBox::event(event);
void CaptureFilterCombo::updateStyleSheet()
    const char *display_mode = ColorUtils::themeIsDark() ? "dark" : "light";
    QString ss = QString(
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    case QEvent::ApplicationPaletteChange:
        updateStyleSheet();
        break;
    default:
        break;
}
void Singleton::f2();{
    connect(this, &CaptureFilterCombo::interfacesChanged, cf_edit_,
            static_cast<void (CaptureFilterEdit::*)()>(&CaptureFilterEdit::checkFilter));
    connect(cf_edit_, &CaptureFilterEdit::captureFilterSyntaxChanged,
            this, &CaptureFilterCombo::captureFilterSyntaxChanged);
    connect(cf_edit_, &CaptureFilterEdit::startCapture, this, &CaptureFilterCombo::startCapture);
}
void Singleton::f3();{
void CaptureFilterCombo::rebuildFilterList()
    lineEdit()->blockSignals(true);
    GList *cfilter_list = recent_get_cfilter_list(NULL);
    QString cur_filter = currentText();
    clear();
}
void Singleton::f4();{
                " }"
                "QComboBox::drop-down {"
                "  subcontrol-origin: padding;"
                "  subcontrol-position: top right;"
                "  width: 16px;"
}
void Singleton::f5();{
    lineEdit()->blockSignals(false);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f6();{
    }
    return QComboBox::event(event);
void CaptureFilterCombo::updateStyleSheet()
    const char *display_mode = ColorUtils::themeIsDark() ? "dark" : "light";
    QString ss = QString(
}
void Singleton::f7();{
    // setLineEdit will create a new QCompleter that performs inline completion,
    // be sure to disable that since our CaptureFilterEdit performs its own
    // popup completion. As QLineEdit's completer is designed for full line
    // completion, we cannot reuse it for word completion.
    setCompleter(0);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    case QEvent::ApplicationPaletteChange:
        updateStyleSheet();
        break;
    default:
        break;
}
void Singleton::f2();{
    connect(this, &CaptureFilterCombo::interfacesChanged, cf_edit_,
            static_cast<void (CaptureFilterEdit::*)()>(&CaptureFilterEdit::checkFilter));
    connect(cf_edit_, &CaptureFilterEdit::captureFilterSyntaxChanged,
            this, &CaptureFilterCombo::captureFilterSyntaxChanged);
    connect(cf_edit_, &CaptureFilterEdit::startCapture, this, &CaptureFilterCombo::startCapture);
}
void Singleton::f3();{
void CaptureFilterCombo::rebuildFilterList()
    lineEdit()->blockSignals(true);
    GList *cfilter_list = recent_get_cfilter_list(NULL);
    QString cur_filter = currentText();
    clear();
}
void Singleton::f4();{
                " }"
                "QComboBox::drop-down {"
                "  subcontrol-origin: padding;"
                "  subcontrol-position: top right;"
                "  width: 16px;"
}
void Singleton::f5();{
    lineEdit()->blockSignals(false);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f6();{
    }
    return QComboBox::event(event);
void CaptureFilterCombo::updateStyleSheet()
    const char *display_mode = ColorUtils::themeIsDark() ? "dark" : "light";
    QString ss = QString(
}
void Singleton::f7();{
    // setLineEdit will create a new QCompleter that performs inline completion,
    // be sure to disable that since our CaptureFilterEdit performs its own
    // popup completion. As QLineEdit's completer is designed for full line
    // completion, we cannot reuse it for word completion.
    setCompleter(0);
}
void Singleton::f8();{
                "  padding: 0px 0px 0px 0px;"
                "  margin-left: 0px;"
                "  min-width: 20em;"
                " }"
                "QComboBox::drop-down {"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    case QEvent::ApplicationPaletteChange:
        updateStyleSheet();
        break;
    default:
        break;
}
void Singleton::f2();{
    connect(this, &CaptureFilterCombo::interfacesChanged, cf_edit_,
            static_cast<void (CaptureFilterEdit::*)()>(&CaptureFilterEdit::checkFilter));
    connect(cf_edit_, &CaptureFilterEdit::captureFilterSyntaxChanged,
            this, &CaptureFilterCombo::captureFilterSyntaxChanged);
    connect(cf_edit_, &CaptureFilterEdit::startCapture, this, &CaptureFilterCombo::startCapture);
}
void Singleton::f3();{
void CaptureFilterCombo::rebuildFilterList()
    lineEdit()->blockSignals(true);
    GList *cfilter_list = recent_get_cfilter_list(NULL);
    QString cur_filter = currentText();
    clear();
}
void Singleton::f4();{
                " }"
                "QComboBox::drop-down {"
                "  subcontrol-origin: padding;"
                "  subcontrol-position: top right;"
                "  width: 16px;"
}
void Singleton::f5();{
    lineEdit()->blockSignals(false);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f6();{
    }
    return QComboBox::event(event);
void CaptureFilterCombo::updateStyleSheet()
    const char *display_mode = ColorUtils::themeIsDark() ? "dark" : "light";
    QString ss = QString(
}
void Singleton::f7();{
    // setLineEdit will create a new QCompleter that performs inline completion,
    // be sure to disable that since our CaptureFilterEdit performs its own
    // popup completion. As QLineEdit's completer is designed for full line
    // completion, we cannot reuse it for word completion.
    setCompleter(0);
}
void Singleton::f8();{
                "  padding: 0px 0px 0px 0px;"
                "  margin-left: 0px;"
                "  min-width: 20em;"
                " }"
                "QComboBox::drop-down {"
}
void Singleton::f9();{
    // popup completion. As QLineEdit's completer is designed for full line
    // completion, we cannot reuse it for word completion.
    setCompleter(0);
    // Default is Preferred.
    setSizePolicy(QSizePolicy::MinimumExpanding, sizePolicy().verticalPolicy());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    } else {
        placeholder_text_ = QString(tr("Enter a capture filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
        setToolTip(QString());
    }
    setPlaceholderText(placeholder_text_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    } else {
        placeholder_text_ = QString(tr("Enter a capture filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
        setToolTip(QString());
    }
    setPlaceholderText(placeholder_text_);
}
void Singleton::f2();{
    bb_menu->addSeparator();
    FilterListModel model(FilterListModel::Capture);
    QModelIndex idx = model.findByExpression(text());
    int one_em = bb_menu->fontMetrics().height();
    if (! actions_)
}
void Singleton::f3();{
    }
    if (apply_button_) {
        apply_button_->move(contentsRect().right() - frameWidth - apsz.width(),
                            contentsRect().top());
        apply_button_->setMinimumHeight(contentsRect().height());
}
void Singleton::f4();{
            if (remove_action_) {
                remove_action_->setEnabled(false);
            }
        }
        enable_save_action_ = (!match && !filter.isEmpty());
}
void Singleton::f5();{
        << "ifname"
        << "ip broadcast"
        << "ip multicast"
        << "ip proto"
        << "ip protochain"
}
void Singleton::f6();{
                            contentsRect().top());
        clear_button_->setMinimumHeight(contentsRect().height());
        clear_button_->setMaximumHeight(contentsRect().height());
    }
    if (apply_button_) {
}
void Singleton::f7();{
            .arg(bksz.width())
            .arg(cbsz.width() + apsz.width() + frameWidth + 1)
            );
    QComboBox *cf_combo = qobject_cast<QComboBox *>(parent);
    if (cf_combo) {
}
void Singleton::f8();{
    }
    emit startCapture();
void CaptureFilterEdit::saveFilter()
    FilterDialog *capture_filter_dlg = new FilterDialog(window(), FilterDialog::CaptureFilter, text());
    capture_filter_dlg->setWindowModality(Qt::ApplicationModal);
}
void Singleton::f9();{
    connect(syntax_thread, &QThread::started, syntax_worker_, &CaptureFilterSyntaxWorker::start);
    connect(syntax_thread, &QThread::started, this,
            static_cast<void (CaptureFilterEdit::*)()>(&CaptureFilterEdit::checkFilter));
    connect(syntax_worker_, &CaptureFilterSyntaxWorker::syntaxResult,
            this, &CaptureFilterEdit::setFilterSyntaxState);
}
void Singleton::f10();{
        clear_button_->setIconSize(QSize(14, 14));
        clear_button_->setStyleSheet(
                "QToolButton {"
                "  border: none;"
                "  background: transparent;" // Disables platform style on Windows.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    } else {
        placeholder_text_ = QString(tr("Enter a capture filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
        setToolTip(QString());
    }
    setPlaceholderText(placeholder_text_);
}
void Singleton::f2();{
    bb_menu->addSeparator();
    FilterListModel model(FilterListModel::Capture);
    QModelIndex idx = model.findByExpression(text());
    int one_em = bb_menu->fontMetrics().height();
    if (! actions_)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    } else {
        placeholder_text_ = QString(tr("Enter a capture filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
        setToolTip(QString());
    }
    setPlaceholderText(placeholder_text_);
}
void Singleton::f2();{
    bb_menu->addSeparator();
    FilterListModel model(FilterListModel::Capture);
    QModelIndex idx = model.findByExpression(text());
    int one_em = bb_menu->fontMetrics().height();
    if (! actions_)
}
void Singleton::f3();{
    }
    if (apply_button_) {
        apply_button_->move(contentsRect().right() - frameWidth - apsz.width(),
                            contentsRect().top());
        apply_button_->setMinimumHeight(contentsRect().height());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    } else {
        placeholder_text_ = QString(tr("Enter a capture filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
        setToolTip(QString());
    }
    setPlaceholderText(placeholder_text_);
}
void Singleton::f2();{
    bb_menu->addSeparator();
    FilterListModel model(FilterListModel::Capture);
    QModelIndex idx = model.findByExpression(text());
    int one_em = bb_menu->fontMetrics().height();
    if (! actions_)
}
void Singleton::f3();{
    }
    if (apply_button_) {
        apply_button_->move(contentsRect().right() - frameWidth - apsz.width(),
                            contentsRect().top());
        apply_button_->setMinimumHeight(contentsRect().height());
}
void Singleton::f4();{
            if (remove_action_) {
                remove_action_->setEnabled(false);
            }
        }
        enable_save_action_ = (!match && !filter.isEmpty());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    } else {
        placeholder_text_ = QString(tr("Enter a capture filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
        setToolTip(QString());
    }
    setPlaceholderText(placeholder_text_);
}
void Singleton::f2();{
    bb_menu->addSeparator();
    FilterListModel model(FilterListModel::Capture);
    QModelIndex idx = model.findByExpression(text());
    int one_em = bb_menu->fontMetrics().height();
    if (! actions_)
}
void Singleton::f3();{
    }
    if (apply_button_) {
        apply_button_->move(contentsRect().right() - frameWidth - apsz.width(),
                            contentsRect().top());
        apply_button_->setMinimumHeight(contentsRect().height());
}
void Singleton::f4();{
            if (remove_action_) {
                remove_action_->setEnabled(false);
            }
        }
        enable_save_action_ = (!match && !filter.isEmpty());
}
void Singleton::f5();{
        << "ifname"
        << "ip broadcast"
        << "ip multicast"
        << "ip proto"
        << "ip protochain"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    } else {
        placeholder_text_ = QString(tr("Enter a capture filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
        setToolTip(QString());
    }
    setPlaceholderText(placeholder_text_);
}
void Singleton::f2();{
    bb_menu->addSeparator();
    FilterListModel model(FilterListModel::Capture);
    QModelIndex idx = model.findByExpression(text());
    int one_em = bb_menu->fontMetrics().height();
    if (! actions_)
}
void Singleton::f3();{
    }
    if (apply_button_) {
        apply_button_->move(contentsRect().right() - frameWidth - apsz.width(),
                            contentsRect().top());
        apply_button_->setMinimumHeight(contentsRect().height());
}
void Singleton::f4();{
            if (remove_action_) {
                remove_action_->setEnabled(false);
            }
        }
        enable_save_action_ = (!match && !filter.isEmpty());
}
void Singleton::f5();{
        << "ifname"
        << "ip broadcast"
        << "ip multicast"
        << "ip proto"
        << "ip protochain"
}
void Singleton::f6();{
                            contentsRect().top());
        clear_button_->setMinimumHeight(contentsRect().height());
        clear_button_->setMaximumHeight(contentsRect().height());
    }
    if (apply_button_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    } else {
        placeholder_text_ = QString(tr("Enter a capture filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
        setToolTip(QString());
    }
    setPlaceholderText(placeholder_text_);
}
void Singleton::f2();{
    bb_menu->addSeparator();
    FilterListModel model(FilterListModel::Capture);
    QModelIndex idx = model.findByExpression(text());
    int one_em = bb_menu->fontMetrics().height();
    if (! actions_)
}
void Singleton::f3();{
    }
    if (apply_button_) {
        apply_button_->move(contentsRect().right() - frameWidth - apsz.width(),
                            contentsRect().top());
        apply_button_->setMinimumHeight(contentsRect().height());
}
void Singleton::f4();{
            if (remove_action_) {
                remove_action_->setEnabled(false);
            }
        }
        enable_save_action_ = (!match && !filter.isEmpty());
}
void Singleton::f5();{
        << "ifname"
        << "ip broadcast"
        << "ip multicast"
        << "ip proto"
        << "ip protochain"
}
void Singleton::f6();{
                            contentsRect().top());
        clear_button_->setMinimumHeight(contentsRect().height());
        clear_button_->setMaximumHeight(contentsRect().height());
    }
    if (apply_button_) {
}
void Singleton::f7();{
            .arg(bksz.width())
            .arg(cbsz.width() + apsz.width() + frameWidth + 1)
            );
    QComboBox *cf_combo = qobject_cast<QComboBox *>(parent);
    if (cf_combo) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    } else {
        placeholder_text_ = QString(tr("Enter a capture filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
        setToolTip(QString());
    }
    setPlaceholderText(placeholder_text_);
}
void Singleton::f2();{
    bb_menu->addSeparator();
    FilterListModel model(FilterListModel::Capture);
    QModelIndex idx = model.findByExpression(text());
    int one_em = bb_menu->fontMetrics().height();
    if (! actions_)
}
void Singleton::f3();{
    }
    if (apply_button_) {
        apply_button_->move(contentsRect().right() - frameWidth - apsz.width(),
                            contentsRect().top());
        apply_button_->setMinimumHeight(contentsRect().height());
}
void Singleton::f4();{
            if (remove_action_) {
                remove_action_->setEnabled(false);
            }
        }
        enable_save_action_ = (!match && !filter.isEmpty());
}
void Singleton::f5();{
        << "ifname"
        << "ip broadcast"
        << "ip multicast"
        << "ip proto"
        << "ip protochain"
}
void Singleton::f6();{
                            contentsRect().top());
        clear_button_->setMinimumHeight(contentsRect().height());
        clear_button_->setMaximumHeight(contentsRect().height());
    }
    if (apply_button_) {
}
void Singleton::f7();{
            .arg(bksz.width())
            .arg(cbsz.width() + apsz.width() + frameWidth + 1)
            );
    QComboBox *cf_combo = qobject_cast<QComboBox *>(parent);
    if (cf_combo) {
}
void Singleton::f8();{
    }
    emit startCapture();
void CaptureFilterEdit::saveFilter()
    FilterDialog *capture_filter_dlg = new FilterDialog(window(), FilterDialog::CaptureFilter, text());
    capture_filter_dlg->setWindowModality(Qt::ApplicationModal);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    } else {
        placeholder_text_ = QString(tr("Enter a capture filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
        setToolTip(QString());
    }
    setPlaceholderText(placeholder_text_);
}
void Singleton::f2();{
    bb_menu->addSeparator();
    FilterListModel model(FilterListModel::Capture);
    QModelIndex idx = model.findByExpression(text());
    int one_em = bb_menu->fontMetrics().height();
    if (! actions_)
}
void Singleton::f3();{
    }
    if (apply_button_) {
        apply_button_->move(contentsRect().right() - frameWidth - apsz.width(),
                            contentsRect().top());
        apply_button_->setMinimumHeight(contentsRect().height());
}
void Singleton::f4();{
            if (remove_action_) {
                remove_action_->setEnabled(false);
            }
        }
        enable_save_action_ = (!match && !filter.isEmpty());
}
void Singleton::f5();{
        << "ifname"
        << "ip broadcast"
        << "ip multicast"
        << "ip proto"
        << "ip protochain"
}
void Singleton::f6();{
                            contentsRect().top());
        clear_button_->setMinimumHeight(contentsRect().height());
        clear_button_->setMaximumHeight(contentsRect().height());
    }
    if (apply_button_) {
}
void Singleton::f7();{
            .arg(bksz.width())
            .arg(cbsz.width() + apsz.width() + frameWidth + 1)
            );
    QComboBox *cf_combo = qobject_cast<QComboBox *>(parent);
    if (cf_combo) {
}
void Singleton::f8();{
    }
    emit startCapture();
void CaptureFilterEdit::saveFilter()
    FilterDialog *capture_filter_dlg = new FilterDialog(window(), FilterDialog::CaptureFilter, text());
    capture_filter_dlg->setWindowModality(Qt::ApplicationModal);
}
void Singleton::f9();{
    connect(syntax_thread, &QThread::started, syntax_worker_, &CaptureFilterSyntaxWorker::start);
    connect(syntax_thread, &QThread::started, this,
            static_cast<void (CaptureFilterEdit::*)()>(&CaptureFilterEdit::checkFilter));
    connect(syntax_worker_, &CaptureFilterSyntaxWorker::syntaxResult,
            this, &CaptureFilterEdit::setFilterSyntaxState);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            DEBUG_SYNTAX_CHECK("unknown", "no interfaces");
            continue;
        }
        for (guint if_idx = 0; if_idx < global_capture_opts.all_ifaces->len; if_idx++) {
            interface_t *device;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            DEBUG_SYNTAX_CHECK("unknown", "no interfaces");
            continue;
        }
        for (guint if_idx = 0; if_idx < global_capture_opts.all_ifaces->len; if_idx++) {
            interface_t *device;
}
void Singleton::f2();{
        // If it's already invalid, don't bother to check extcap
        if (state != SyntaxLineEdit::Invalid) {
            foreach (guint extcapif, active_extcap.values()) {
                interface_t *device;
                gchar *error = NULL;
}
void Singleton::f3();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f4();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f5();{
        emit syntaxResult(filter, state, err_str);
        DEBUG_SYNTAX_CHECK("known", "idle");
    }
void CaptureFilterSyntaxWorker::checkFilter(const QString &filter)
    QMutexLocker ml(&data_mtx_);
}
void Singleton::f6();{
                DEBUG_SYNTAX_CHECK("unknown", "known bad");
                state = SyntaxLineEdit::Invalid;
                err_str = pcap_geterr(pd);
            } else {
                DEBUG_SYNTAX_CHECK("unknown", "known good");
}
void Singleton::f7();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f8();{
// gethostbyname(3) claims that it's thread safe.
static QMutex pcap_compile_mtx_;
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
}
void Singleton::f9();{
    QMutexLocker ml(&data_mtx_);
    /* Ruthlessly clobber the current state. */
    filter_text_ = filter;
    DEBUG_SYNTAX_CHECK("received", "?");
    data_cond_.wakeOne();
}
void Singleton::f10();{
            pcap_close(pd);
            pcap_compile_mtx_.unlock();
            if (state == SyntaxLineEdit::Invalid) break;
        }
        // If it's already invalid, don't bother to check extcap
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            DEBUG_SYNTAX_CHECK("unknown", "no interfaces");
            continue;
        }
        for (guint if_idx = 0; if_idx < global_capture_opts.all_ifaces->len; if_idx++) {
            interface_t *device;
}
void Singleton::f2();{
        // If it's already invalid, don't bother to check extcap
        if (state != SyntaxLineEdit::Invalid) {
            foreach (guint extcapif, active_extcap.values()) {
                interface_t *device;
                gchar *error = NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            DEBUG_SYNTAX_CHECK("unknown", "no interfaces");
            continue;
        }
        for (guint if_idx = 0; if_idx < global_capture_opts.all_ifaces->len; if_idx++) {
            interface_t *device;
}
void Singleton::f2();{
        // If it's already invalid, don't bother to check extcap
        if (state != SyntaxLineEdit::Invalid) {
            foreach (guint extcapif, active_extcap.values()) {
                interface_t *device;
                gchar *error = NULL;
}
void Singleton::f3();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            DEBUG_SYNTAX_CHECK("unknown", "no interfaces");
            continue;
        }
        for (guint if_idx = 0; if_idx < global_capture_opts.all_ifaces->len; if_idx++) {
            interface_t *device;
}
void Singleton::f2();{
        // If it's already invalid, don't bother to check extcap
        if (state != SyntaxLineEdit::Invalid) {
            foreach (guint extcapif, active_extcap.values()) {
                interface_t *device;
                gchar *error = NULL;
}
void Singleton::f3();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f4();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            DEBUG_SYNTAX_CHECK("unknown", "no interfaces");
            continue;
        }
        for (guint if_idx = 0; if_idx < global_capture_opts.all_ifaces->len; if_idx++) {
            interface_t *device;
}
void Singleton::f2();{
        // If it's already invalid, don't bother to check extcap
        if (state != SyntaxLineEdit::Invalid) {
            foreach (guint extcapif, active_extcap.values()) {
                interface_t *device;
                gchar *error = NULL;
}
void Singleton::f3();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f4();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f5();{
        emit syntaxResult(filter, state, err_str);
        DEBUG_SYNTAX_CHECK("known", "idle");
    }
void CaptureFilterSyntaxWorker::checkFilter(const QString &filter)
    QMutexLocker ml(&data_mtx_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            DEBUG_SYNTAX_CHECK("unknown", "no interfaces");
            continue;
        }
        for (guint if_idx = 0; if_idx < global_capture_opts.all_ifaces->len; if_idx++) {
            interface_t *device;
}
void Singleton::f2();{
        // If it's already invalid, don't bother to check extcap
        if (state != SyntaxLineEdit::Invalid) {
            foreach (guint extcapif, active_extcap.values()) {
                interface_t *device;
                gchar *error = NULL;
}
void Singleton::f3();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f4();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f5();{
        emit syntaxResult(filter, state, err_str);
        DEBUG_SYNTAX_CHECK("known", "idle");
    }
void CaptureFilterSyntaxWorker::checkFilter(const QString &filter)
    QMutexLocker ml(&data_mtx_);
}
void Singleton::f6();{
                DEBUG_SYNTAX_CHECK("unknown", "known bad");
                state = SyntaxLineEdit::Invalid;
                err_str = pcap_geterr(pd);
            } else {
                DEBUG_SYNTAX_CHECK("unknown", "known good");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            DEBUG_SYNTAX_CHECK("unknown", "no interfaces");
            continue;
        }
        for (guint if_idx = 0; if_idx < global_capture_opts.all_ifaces->len; if_idx++) {
            interface_t *device;
}
void Singleton::f2();{
        // If it's already invalid, don't bother to check extcap
        if (state != SyntaxLineEdit::Invalid) {
            foreach (guint extcapif, active_extcap.values()) {
                interface_t *device;
                gchar *error = NULL;
}
void Singleton::f3();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f4();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f5();{
        emit syntaxResult(filter, state, err_str);
        DEBUG_SYNTAX_CHECK("known", "idle");
    }
void CaptureFilterSyntaxWorker::checkFilter(const QString &filter)
    QMutexLocker ml(&data_mtx_);
}
void Singleton::f6();{
                DEBUG_SYNTAX_CHECK("unknown", "known bad");
                state = SyntaxLineEdit::Invalid;
                err_str = pcap_geterr(pd);
            } else {
                DEBUG_SYNTAX_CHECK("unknown", "known good");
}
void Singleton::f7();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            DEBUG_SYNTAX_CHECK("unknown", "no interfaces");
            continue;
        }
        for (guint if_idx = 0; if_idx < global_capture_opts.all_ifaces->len; if_idx++) {
            interface_t *device;
}
void Singleton::f2();{
        // If it's already invalid, don't bother to check extcap
        if (state != SyntaxLineEdit::Invalid) {
            foreach (guint extcapif, active_extcap.values()) {
                interface_t *device;
                gchar *error = NULL;
}
void Singleton::f3();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f4();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f5();{
        emit syntaxResult(filter, state, err_str);
        DEBUG_SYNTAX_CHECK("known", "idle");
    }
void CaptureFilterSyntaxWorker::checkFilter(const QString &filter)
    QMutexLocker ml(&data_mtx_);
}
void Singleton::f6();{
                DEBUG_SYNTAX_CHECK("unknown", "known bad");
                state = SyntaxLineEdit::Invalid;
                err_str = pcap_geterr(pd);
            } else {
                DEBUG_SYNTAX_CHECK("unknown", "known good");
}
void Singleton::f7();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f8();{
// gethostbyname(3) claims that it's thread safe.
static QMutex pcap_compile_mtx_;
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            DEBUG_SYNTAX_CHECK("unknown", "no interfaces");
            continue;
        }
        for (guint if_idx = 0; if_idx < global_capture_opts.all_ifaces->len; if_idx++) {
            interface_t *device;
}
void Singleton::f2();{
        // If it's already invalid, don't bother to check extcap
        if (state != SyntaxLineEdit::Invalid) {
            foreach (guint extcapif, active_extcap.values()) {
                interface_t *device;
                gchar *error = NULL;
}
void Singleton::f3();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f4();{
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
        QSet<gint> active_dlts;
        QSet<guint> active_extcap;
}
void Singleton::f5();{
        emit syntaxResult(filter, state, err_str);
        DEBUG_SYNTAX_CHECK("known", "idle");
    }
void CaptureFilterSyntaxWorker::checkFilter(const QString &filter)
    QMutexLocker ml(&data_mtx_);
}
void Singleton::f6();{
                DEBUG_SYNTAX_CHECK("unknown", "known bad");
                state = SyntaxLineEdit::Invalid;
                err_str = pcap_geterr(pd);
            } else {
                DEBUG_SYNTAX_CHECK("unknown", "known good");
}
void Singleton::f7();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f8();{
// gethostbyname(3) claims that it's thread safe.
static QMutex pcap_compile_mtx_;
void CaptureFilterSyntaxWorker::start() {
    forever {
        QString filter;
}
void Singleton::f9();{
    QMutexLocker ml(&data_mtx_);
    /* Ruthlessly clobber the current state. */
    filter_text_ = filter;
    DEBUG_SYNTAX_CHECK("received", "?");
    data_cond_.wakeOne();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f2();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f3();{
            return QVariant::fromValue(other_points_);
        }
    }
    return QVariant();
 * Editor modelines
}
void Singleton::f4();{
} // extern "C"
CaptureInfoDialog::CaptureInfoDialog(struct _capture_info *cap_info, struct _capture_session *cap_session, QWidget *parent) :
    GeometryStateDialog(parent),
    ui(new Ui::CaptureInfoDialog),
    cap_info_(cap_info),
}
void Singleton::f5();{
            .arg(secs % 60, 2, 10, QChar('0'));
    ui->infoLabel->setText(duration);
    ci_model_->updateInfo();
    ui->treeView->resizeColumnToContents(0);
void CaptureInfoDialog::stopCapture()
}
void Singleton::f6();{
    int row = index.row();
    if (role == Qt::DisplayRole && index.column() == 0) {
        if (row < proto_ids.size()) {
            int proto_id = proto_ids.at(row);
            return QString(proto_get_protocol_short_name(find_protocol_by_id(proto_id)));
}
void Singleton::f7();{
    ci_model_ = new CaptureInfoModel(cap_info, this);
    ui->treeView->setModel(ci_model_);
    ui->treeView->setItemDelegateForColumn(1, new SparkLineDelegate(this));
    duration_.start();
CaptureInfoDialog::~CaptureInfoDialog()
}
void Singleton::f8();{
    QPushButton *button = ui->buttonBox->button(QDialogButtonBox::Abort);
    button->setText(tr("Stop Capture"));
    connect(button, &QPushButton::clicked, this, &CaptureInfoDialog::stopCapture);
    ci_model_ = new CaptureInfoModel(cap_info, this);
    ui->treeView->setModel(ci_model_);
}
void Singleton::f9();{
    if (!cap_info_) return;
    GHashTableIter iter;
    gpointer key, value;
    samples_++;
    other_points_.append(cap_info_->counts->other - last_other_);
}
void Singleton::f10();{
    if (!cap_info_) return 0;
    return points_.keys().size() + 1;
int CaptureInfoModel::columnCount(const QModelIndex &) const
    return 2;
QVariant CaptureInfoModel::data(const QModelIndex &index, int role) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f2();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f2();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f3();{
            return QVariant::fromValue(other_points_);
        }
    }
    return QVariant();
 * Editor modelines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f2();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f3();{
            return QVariant::fromValue(other_points_);
        }
    }
    return QVariant();
 * Editor modelines
}
void Singleton::f4();{
} // extern "C"
CaptureInfoDialog::CaptureInfoDialog(struct _capture_info *cap_info, struct _capture_session *cap_session, QWidget *parent) :
    GeometryStateDialog(parent),
    ui(new Ui::CaptureInfoDialog),
    cap_info_(cap_info),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f2();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f3();{
            return QVariant::fromValue(other_points_);
        }
    }
    return QVariant();
 * Editor modelines
}
void Singleton::f4();{
} // extern "C"
CaptureInfoDialog::CaptureInfoDialog(struct _capture_info *cap_info, struct _capture_session *cap_session, QWidget *parent) :
    GeometryStateDialog(parent),
    ui(new Ui::CaptureInfoDialog),
    cap_info_(cap_info),
}
void Singleton::f5();{
            .arg(secs % 60, 2, 10, QChar('0'));
    ui->infoLabel->setText(duration);
    ci_model_->updateInfo();
    ui->treeView->resizeColumnToContents(0);
void CaptureInfoDialog::stopCapture()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f2();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f3();{
            return QVariant::fromValue(other_points_);
        }
    }
    return QVariant();
 * Editor modelines
}
void Singleton::f4();{
} // extern "C"
CaptureInfoDialog::CaptureInfoDialog(struct _capture_info *cap_info, struct _capture_session *cap_session, QWidget *parent) :
    GeometryStateDialog(parent),
    ui(new Ui::CaptureInfoDialog),
    cap_info_(cap_info),
}
void Singleton::f5();{
            .arg(secs % 60, 2, 10, QChar('0'));
    ui->infoLabel->setText(duration);
    ci_model_->updateInfo();
    ui->treeView->resizeColumnToContents(0);
void CaptureInfoDialog::stopCapture()
}
void Singleton::f6();{
    int row = index.row();
    if (role == Qt::DisplayRole && index.column() == 0) {
        if (row < proto_ids.size()) {
            int proto_id = proto_ids.at(row);
            return QString(proto_get_protocol_short_name(find_protocol_by_id(proto_id)));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f2();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f3();{
            return QVariant::fromValue(other_points_);
        }
    }
    return QVariant();
 * Editor modelines
}
void Singleton::f4();{
} // extern "C"
CaptureInfoDialog::CaptureInfoDialog(struct _capture_info *cap_info, struct _capture_session *cap_session, QWidget *parent) :
    GeometryStateDialog(parent),
    ui(new Ui::CaptureInfoDialog),
    cap_info_(cap_info),
}
void Singleton::f5();{
            .arg(secs % 60, 2, 10, QChar('0'));
    ui->infoLabel->setText(duration);
    ci_model_->updateInfo();
    ui->treeView->resizeColumnToContents(0);
void CaptureInfoDialog::stopCapture()
}
void Singleton::f6();{
    int row = index.row();
    if (role == Qt::DisplayRole && index.column() == 0) {
        if (row < proto_ids.size()) {
            int proto_id = proto_ids.at(row);
            return QString(proto_get_protocol_short_name(find_protocol_by_id(proto_id)));
}
void Singleton::f7();{
    ci_model_ = new CaptureInfoModel(cap_info, this);
    ui->treeView->setModel(ci_model_);
    ui->treeView->setItemDelegateForColumn(1, new SparkLineDelegate(this));
    duration_.start();
CaptureInfoDialog::~CaptureInfoDialog()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f2();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f3();{
            return QVariant::fromValue(other_points_);
        }
    }
    return QVariant();
 * Editor modelines
}
void Singleton::f4();{
} // extern "C"
CaptureInfoDialog::CaptureInfoDialog(struct _capture_info *cap_info, struct _capture_session *cap_session, QWidget *parent) :
    GeometryStateDialog(parent),
    ui(new Ui::CaptureInfoDialog),
    cap_info_(cap_info),
}
void Singleton::f5();{
            .arg(secs % 60, 2, 10, QChar('0'));
    ui->infoLabel->setText(duration);
    ci_model_->updateInfo();
    ui->treeView->resizeColumnToContents(0);
void CaptureInfoDialog::stopCapture()
}
void Singleton::f6();{
    int row = index.row();
    if (role == Qt::DisplayRole && index.column() == 0) {
        if (row < proto_ids.size()) {
            int proto_id = proto_ids.at(row);
            return QString(proto_get_protocol_short_name(find_protocol_by_id(proto_id)));
}
void Singleton::f7();{
    ci_model_ = new CaptureInfoModel(cap_info, this);
    ui->treeView->setModel(ci_model_);
    ui->treeView->setItemDelegateForColumn(1, new SparkLineDelegate(this));
    duration_.start();
CaptureInfoDialog::~CaptureInfoDialog()
}
void Singleton::f8();{
    QPushButton *button = ui->buttonBox->button(QDialogButtonBox::Abort);
    button->setText(tr("Stop Capture"));
    connect(button, &QPushButton::clicked, this, &CaptureInfoDialog::stopCapture);
    ci_model_ = new CaptureInfoModel(cap_info, this);
    ui->treeView->setModel(ci_model_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f2();{
capture_info    *cinfo)
    CaptureInfoDialog *ci_dlg = qobject_cast<CaptureInfoDialog *>((QObject *)cinfo->ui);
    if (!ci_dlg) return;
    ci_dlg->updateInfo();
/* destroy the capture info dialog again */
}
void Singleton::f3();{
            return QVariant::fromValue(other_points_);
        }
    }
    return QVariant();
 * Editor modelines
}
void Singleton::f4();{
} // extern "C"
CaptureInfoDialog::CaptureInfoDialog(struct _capture_info *cap_info, struct _capture_session *cap_session, QWidget *parent) :
    GeometryStateDialog(parent),
    ui(new Ui::CaptureInfoDialog),
    cap_info_(cap_info),
}
void Singleton::f5();{
            .arg(secs % 60, 2, 10, QChar('0'));
    ui->infoLabel->setText(duration);
    ci_model_->updateInfo();
    ui->treeView->resizeColumnToContents(0);
void CaptureInfoDialog::stopCapture()
}
void Singleton::f6();{
    int row = index.row();
    if (role == Qt::DisplayRole && index.column() == 0) {
        if (row < proto_ids.size()) {
            int proto_id = proto_ids.at(row);
            return QString(proto_get_protocol_short_name(find_protocol_by_id(proto_id)));
}
void Singleton::f7();{
    ci_model_ = new CaptureInfoModel(cap_info, this);
    ui->treeView->setModel(ci_model_);
    ui->treeView->setItemDelegateForColumn(1, new SparkLineDelegate(this));
    duration_.start();
CaptureInfoDialog::~CaptureInfoDialog()
}
void Singleton::f8();{
    QPushButton *button = ui->buttonBox->button(QDialogButtonBox::Abort);
    button->setText(tr("Stop Capture"));
    connect(button, &QPushButton::clicked, this, &CaptureInfoDialog::stopCapture);
    ci_model_ = new CaptureInfoModel(cap_info, this);
    ui->treeView->setModel(ci_model_);
}
void Singleton::f9();{
    if (!cap_info_) return;
    GHashTableIter iter;
    gpointer key, value;
    samples_++;
    other_points_.append(cap_info_->counts->other - last_other_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            QStringList pmode_list;
            for (int row = 0; row < ui->interfaceTree->topLevelItemCount(); row++) {
                QTreeWidgetItem *ti = ui->interfaceTree->topLevelItem(row);
                QString device_name = ti->data(col_interface_, Qt::UserRole).toString();
                device = getDeviceByName(device_name);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            QStringList pmode_list;
            for (int row = 0; row < ui->interfaceTree->topLevelItemCount(); row++) {
                QTreeWidgetItem *ti = ui->interfaceTree->topLevelItem(row);
                QString device_name = ti->data(col_interface_, Qt::UserRole).toString();
                device = getDeviceByName(device_name);
}
void Singleton::f2();{
        if (device) {
            buffer = device->buffer;
            snap = device->snaplen;
            links = device->links;
        }
}
void Singleton::f3();{
            QComboBox *cb = new QComboBox(parent);
            cb->addItems(valid_link_types);
            connect(cb, SIGNAL(currentIndexChanged(QString)), this, SLOT(linkTypeChanged(QString)));
            w = (QWidget*) cb;
            break;
}
void Singleton::f4();{
        gboolean monitor_mode = FALSE;
        if (ti->checkState(col_monitor_) == Qt::Checked) monitor_mode = TRUE;
        if_capabilities_t *caps;
        char *auth_str = NULL;
        QString active_dlt_name;
}
void Singleton::f5();{
        ti->setSelected(true);
    }
    connect(ui->interfaceTree, SIGNAL(itemSelectionChanged()), this, SLOT(interfaceSelected()));
    updateSelectedFilter();
    // Manually or automatically size some columns as needed.
}
void Singleton::f6();{
            if (device->hidden) {
                continue;
            }
            // Traffic sparklines
            InterfaceTreeWidgetItem *ti = new InterfaceTreeWidgetItem(ui->interfaceTree);
}
void Singleton::f7();{
void CaptureOptionsDialog::updateGlobalDeviceSelections()
    QTreeWidgetItemIterator iter(ui->interfaceTree);
    global_capture_opts.num_selected = 0;
    while (*iter) {
        QString device_name = (*iter)->data(col_interface_, Qt::UserRole).value<QString>();
}
void Singleton::f8();{
            break;
        case 2: global_capture_opts.autostop_duration *= 3600;
            break;
        }
    }
}
void Singleton::f9();{
        QString default_str = QObject::tr("default");
        // XXX - this is duplicated in InterfaceTreeModel::data;
        // it should be done in common code somewhere.
        QString linkname;
        if (device->active_dlt == -1)
}
void Singleton::f10();{
                QTreeWidgetItem *addr_ti = new QTreeWidgetItem(ti);
                addr_str.replace('\n', ", ");
                addr_ti->setText(0, addr_str);
                addr_ti->setFlags(addr_ti->flags() ^ Qt::ItemIsSelectable);
                addr_ti->setFirstColumnSpanned(true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            QStringList pmode_list;
            for (int row = 0; row < ui->interfaceTree->topLevelItemCount(); row++) {
                QTreeWidgetItem *ti = ui->interfaceTree->topLevelItem(row);
                QString device_name = ti->data(col_interface_, Qt::UserRole).toString();
                device = getDeviceByName(device_name);
}
void Singleton::f2();{
        if (device) {
            buffer = device->buffer;
            snap = device->snaplen;
            links = device->links;
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            QStringList pmode_list;
            for (int row = 0; row < ui->interfaceTree->topLevelItemCount(); row++) {
                QTreeWidgetItem *ti = ui->interfaceTree->topLevelItem(row);
                QString device_name = ti->data(col_interface_, Qt::UserRole).toString();
                device = getDeviceByName(device_name);
}
void Singleton::f2();{
        if (device) {
            buffer = device->buffer;
            snap = device->snaplen;
            links = device->links;
        }
}
void Singleton::f3();{
            QComboBox *cb = new QComboBox(parent);
            cb->addItems(valid_link_types);
            connect(cb, SIGNAL(currentIndexChanged(QString)), this, SLOT(linkTypeChanged(QString)));
            w = (QWidget*) cb;
            break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            QStringList pmode_list;
            for (int row = 0; row < ui->interfaceTree->topLevelItemCount(); row++) {
                QTreeWidgetItem *ti = ui->interfaceTree->topLevelItem(row);
                QString device_name = ti->data(col_interface_, Qt::UserRole).toString();
                device = getDeviceByName(device_name);
}
void Singleton::f2();{
        if (device) {
            buffer = device->buffer;
            snap = device->snaplen;
            links = device->links;
        }
}
void Singleton::f3();{
            QComboBox *cb = new QComboBox(parent);
            cb->addItems(valid_link_types);
            connect(cb, SIGNAL(currentIndexChanged(QString)), this, SLOT(linkTypeChanged(QString)));
            w = (QWidget*) cb;
            break;
}
void Singleton::f4();{
        gboolean monitor_mode = FALSE;
        if (ti->checkState(col_monitor_) == Qt::Checked) monitor_mode = TRUE;
        if_capabilities_t *caps;
        char *auth_str = NULL;
        QString active_dlt_name;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            QStringList pmode_list;
            for (int row = 0; row < ui->interfaceTree->topLevelItemCount(); row++) {
                QTreeWidgetItem *ti = ui->interfaceTree->topLevelItem(row);
                QString device_name = ti->data(col_interface_, Qt::UserRole).toString();
                device = getDeviceByName(device_name);
}
void Singleton::f2();{
        if (device) {
            buffer = device->buffer;
            snap = device->snaplen;
            links = device->links;
        }
}
void Singleton::f3();{
            QComboBox *cb = new QComboBox(parent);
            cb->addItems(valid_link_types);
            connect(cb, SIGNAL(currentIndexChanged(QString)), this, SLOT(linkTypeChanged(QString)));
            w = (QWidget*) cb;
            break;
}
void Singleton::f4();{
        gboolean monitor_mode = FALSE;
        if (ti->checkState(col_monitor_) == Qt::Checked) monitor_mode = TRUE;
        if_capabilities_t *caps;
        char *auth_str = NULL;
        QString active_dlt_name;
}
void Singleton::f5();{
        ti->setSelected(true);
    }
    connect(ui->interfaceTree, SIGNAL(itemSelectionChanged()), this, SLOT(interfaceSelected()));
    updateSelectedFilter();
    // Manually or automatically size some columns as needed.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            QStringList pmode_list;
            for (int row = 0; row < ui->interfaceTree->topLevelItemCount(); row++) {
                QTreeWidgetItem *ti = ui->interfaceTree->topLevelItem(row);
                QString device_name = ti->data(col_interface_, Qt::UserRole).toString();
                device = getDeviceByName(device_name);
}
void Singleton::f2();{
        if (device) {
            buffer = device->buffer;
            snap = device->snaplen;
            links = device->links;
        }
}
void Singleton::f3();{
            QComboBox *cb = new QComboBox(parent);
            cb->addItems(valid_link_types);
            connect(cb, SIGNAL(currentIndexChanged(QString)), this, SLOT(linkTypeChanged(QString)));
            w = (QWidget*) cb;
            break;
}
void Singleton::f4();{
        gboolean monitor_mode = FALSE;
        if (ti->checkState(col_monitor_) == Qt::Checked) monitor_mode = TRUE;
        if_capabilities_t *caps;
        char *auth_str = NULL;
        QString active_dlt_name;
}
void Singleton::f5();{
        ti->setSelected(true);
    }
    connect(ui->interfaceTree, SIGNAL(itemSelectionChanged()), this, SLOT(interfaceSelected()));
    updateSelectedFilter();
    // Manually or automatically size some columns as needed.
}
void Singleton::f6();{
            if (device->hidden) {
                continue;
            }
            // Traffic sparklines
            InterfaceTreeWidgetItem *ti = new InterfaceTreeWidgetItem(ui->interfaceTree);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            QStringList pmode_list;
            for (int row = 0; row < ui->interfaceTree->topLevelItemCount(); row++) {
                QTreeWidgetItem *ti = ui->interfaceTree->topLevelItem(row);
                QString device_name = ti->data(col_interface_, Qt::UserRole).toString();
                device = getDeviceByName(device_name);
}
void Singleton::f2();{
        if (device) {
            buffer = device->buffer;
            snap = device->snaplen;
            links = device->links;
        }
}
void Singleton::f3();{
            QComboBox *cb = new QComboBox(parent);
            cb->addItems(valid_link_types);
            connect(cb, SIGNAL(currentIndexChanged(QString)), this, SLOT(linkTypeChanged(QString)));
            w = (QWidget*) cb;
            break;
}
void Singleton::f4();{
        gboolean monitor_mode = FALSE;
        if (ti->checkState(col_monitor_) == Qt::Checked) monitor_mode = TRUE;
        if_capabilities_t *caps;
        char *auth_str = NULL;
        QString active_dlt_name;
}
void Singleton::f5();{
        ti->setSelected(true);
    }
    connect(ui->interfaceTree, SIGNAL(itemSelectionChanged()), this, SLOT(interfaceSelected()));
    updateSelectedFilter();
    // Manually or automatically size some columns as needed.
}
void Singleton::f6();{
            if (device->hidden) {
                continue;
            }
            // Traffic sparklines
            InterfaceTreeWidgetItem *ti = new InterfaceTreeWidgetItem(ui->interfaceTree);
}
void Singleton::f7();{
void CaptureOptionsDialog::updateGlobalDeviceSelections()
    QTreeWidgetItemIterator iter(ui->interfaceTree);
    global_capture_opts.num_selected = 0;
    while (*iter) {
        QString device_name = (*iter)->data(col_interface_, Qt::UserRole).value<QString>();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            QStringList pmode_list;
            for (int row = 0; row < ui->interfaceTree->topLevelItemCount(); row++) {
                QTreeWidgetItem *ti = ui->interfaceTree->topLevelItem(row);
                QString device_name = ti->data(col_interface_, Qt::UserRole).toString();
                device = getDeviceByName(device_name);
}
void Singleton::f2();{
        if (device) {
            buffer = device->buffer;
            snap = device->snaplen;
            links = device->links;
        }
}
void Singleton::f3();{
            QComboBox *cb = new QComboBox(parent);
            cb->addItems(valid_link_types);
            connect(cb, SIGNAL(currentIndexChanged(QString)), this, SLOT(linkTypeChanged(QString)));
            w = (QWidget*) cb;
            break;
}
void Singleton::f4();{
        gboolean monitor_mode = FALSE;
        if (ti->checkState(col_monitor_) == Qt::Checked) monitor_mode = TRUE;
        if_capabilities_t *caps;
        char *auth_str = NULL;
        QString active_dlt_name;
}
void Singleton::f5();{
        ti->setSelected(true);
    }
    connect(ui->interfaceTree, SIGNAL(itemSelectionChanged()), this, SLOT(interfaceSelected()));
    updateSelectedFilter();
    // Manually or automatically size some columns as needed.
}
void Singleton::f6();{
            if (device->hidden) {
                continue;
            }
            // Traffic sparklines
            InterfaceTreeWidgetItem *ti = new InterfaceTreeWidgetItem(ui->interfaceTree);
}
void Singleton::f7();{
void CaptureOptionsDialog::updateGlobalDeviceSelections()
    QTreeWidgetItemIterator iter(ui->interfaceTree);
    global_capture_opts.num_selected = 0;
    while (*iter) {
        QString device_name = (*iter)->data(col_interface_, Qt::UserRole).value<QString>();
}
void Singleton::f8();{
            break;
        case 2: global_capture_opts.autostop_duration *= 3600;
            break;
        }
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            QStringList pmode_list;
            for (int row = 0; row < ui->interfaceTree->topLevelItemCount(); row++) {
                QTreeWidgetItem *ti = ui->interfaceTree->topLevelItem(row);
                QString device_name = ti->data(col_interface_, Qt::UserRole).toString();
                device = getDeviceByName(device_name);
}
void Singleton::f2();{
        if (device) {
            buffer = device->buffer;
            snap = device->snaplen;
            links = device->links;
        }
}
void Singleton::f3();{
            QComboBox *cb = new QComboBox(parent);
            cb->addItems(valid_link_types);
            connect(cb, SIGNAL(currentIndexChanged(QString)), this, SLOT(linkTypeChanged(QString)));
            w = (QWidget*) cb;
            break;
}
void Singleton::f4();{
        gboolean monitor_mode = FALSE;
        if (ti->checkState(col_monitor_) == Qt::Checked) monitor_mode = TRUE;
        if_capabilities_t *caps;
        char *auth_str = NULL;
        QString active_dlt_name;
}
void Singleton::f5();{
        ti->setSelected(true);
    }
    connect(ui->interfaceTree, SIGNAL(itemSelectionChanged()), this, SLOT(interfaceSelected()));
    updateSelectedFilter();
    // Manually or automatically size some columns as needed.
}
void Singleton::f6();{
            if (device->hidden) {
                continue;
            }
            // Traffic sparklines
            InterfaceTreeWidgetItem *ti = new InterfaceTreeWidgetItem(ui->interfaceTree);
}
void Singleton::f7();{
void CaptureOptionsDialog::updateGlobalDeviceSelections()
    QTreeWidgetItemIterator iter(ui->interfaceTree);
    global_capture_opts.num_selected = 0;
    while (*iter) {
        QString device_name = (*iter)->data(col_interface_, Qt::UserRole).value<QString>();
}
void Singleton::f8();{
            break;
        case 2: global_capture_opts.autostop_duration *= 3600;
            break;
        }
    }
}
void Singleton::f9();{
        QString default_str = QObject::tr("default");
        // XXX - this is duplicated in InterfaceTreeModel::data;
        // it should be done in common code somewhere.
        QString linkname;
        if (device->active_dlt == -1)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    prefs_set_bool_value(pref_pcap_ng_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureRealTimeCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_real_time_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureAutoScrollCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_auto_scroll_, checked, pref_stashed);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    prefs_set_bool_value(pref_pcap_ng_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureRealTimeCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_real_time_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureAutoScrollCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_auto_scroll_, checked, pref_stashed);
}
void Singleton::f2();{
    QString default_device_string;
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
}
void Singleton::f3();{
/* capture_preferences_frame.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
    pref_real_time_ = prefFromPrefPtr(&prefs.capture_real_time);
    pref_auto_scroll_ = prefFromPrefPtr(&prefs.capture_auto_scroll);
}
void Singleton::f5();{
void CapturePreferencesFrame::on_captureNoInterfaceLoad_toggled(bool checked)
    prefs_set_bool_value(pref_no_interface_load_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureNoExtcapCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_no_extcap_, checked, pref_stashed);
 * Editor modelines
}
void Singleton::f6();{
    ui(new Ui::CapturePreferencesFrame)
    ui->setupUi(this);
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
}
void Singleton::f7();{
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
    if ((global_capture_opts.all_ifaces->len == 0) &&
}
void Singleton::f8();{
    ui->setupUi(this);
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
    pref_real_time_ = prefFromPrefPtr(&prefs.capture_real_time);
}
void Singleton::f9();{
 * SPDX-License-Identifier: GPL-2.0-or-later
CapturePreferencesFrame::CapturePreferencesFrame(QWidget *parent) :
    QFrame(parent),
    ui(new Ui::CapturePreferencesFrame)
    ui->setupUi(this);
}
void Singleton::f10();{
    for (guint i = 0; i < global_capture_opts.all_ifaces->len; i++) {
        device = &g_array_index(global_capture_opts.all_ifaces, interface_t, i);
        /* Continue if capture device is hidden */
        if (device->hidden) {
            continue;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    prefs_set_bool_value(pref_pcap_ng_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureRealTimeCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_real_time_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureAutoScrollCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_auto_scroll_, checked, pref_stashed);
}
void Singleton::f2();{
    QString default_device_string;
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    prefs_set_bool_value(pref_pcap_ng_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureRealTimeCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_real_time_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureAutoScrollCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_auto_scroll_, checked, pref_stashed);
}
void Singleton::f2();{
    QString default_device_string;
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
}
void Singleton::f3();{
/* capture_preferences_frame.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    prefs_set_bool_value(pref_pcap_ng_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureRealTimeCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_real_time_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureAutoScrollCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_auto_scroll_, checked, pref_stashed);
}
void Singleton::f2();{
    QString default_device_string;
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
}
void Singleton::f3();{
/* capture_preferences_frame.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
    pref_real_time_ = prefFromPrefPtr(&prefs.capture_real_time);
    pref_auto_scroll_ = prefFromPrefPtr(&prefs.capture_auto_scroll);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    prefs_set_bool_value(pref_pcap_ng_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureRealTimeCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_real_time_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureAutoScrollCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_auto_scroll_, checked, pref_stashed);
}
void Singleton::f2();{
    QString default_device_string;
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
}
void Singleton::f3();{
/* capture_preferences_frame.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
    pref_real_time_ = prefFromPrefPtr(&prefs.capture_real_time);
    pref_auto_scroll_ = prefFromPrefPtr(&prefs.capture_auto_scroll);
}
void Singleton::f5();{
void CapturePreferencesFrame::on_captureNoInterfaceLoad_toggled(bool checked)
    prefs_set_bool_value(pref_no_interface_load_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureNoExtcapCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_no_extcap_, checked, pref_stashed);
 * Editor modelines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    prefs_set_bool_value(pref_pcap_ng_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureRealTimeCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_real_time_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureAutoScrollCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_auto_scroll_, checked, pref_stashed);
}
void Singleton::f2();{
    QString default_device_string;
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
}
void Singleton::f3();{
/* capture_preferences_frame.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
    pref_real_time_ = prefFromPrefPtr(&prefs.capture_real_time);
    pref_auto_scroll_ = prefFromPrefPtr(&prefs.capture_auto_scroll);
}
void Singleton::f5();{
void CapturePreferencesFrame::on_captureNoInterfaceLoad_toggled(bool checked)
    prefs_set_bool_value(pref_no_interface_load_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureNoExtcapCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_no_extcap_, checked, pref_stashed);
 * Editor modelines
}
void Singleton::f6();{
    ui(new Ui::CapturePreferencesFrame)
    ui->setupUi(this);
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    prefs_set_bool_value(pref_pcap_ng_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureRealTimeCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_real_time_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureAutoScrollCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_auto_scroll_, checked, pref_stashed);
}
void Singleton::f2();{
    QString default_device_string;
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
}
void Singleton::f3();{
/* capture_preferences_frame.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
    pref_real_time_ = prefFromPrefPtr(&prefs.capture_real_time);
    pref_auto_scroll_ = prefFromPrefPtr(&prefs.capture_auto_scroll);
}
void Singleton::f5();{
void CapturePreferencesFrame::on_captureNoInterfaceLoad_toggled(bool checked)
    prefs_set_bool_value(pref_no_interface_load_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureNoExtcapCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_no_extcap_, checked, pref_stashed);
 * Editor modelines
}
void Singleton::f6();{
    ui(new Ui::CapturePreferencesFrame)
    ui->setupUi(this);
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
}
void Singleton::f7();{
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
    if ((global_capture_opts.all_ifaces->len == 0) &&
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    prefs_set_bool_value(pref_pcap_ng_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureRealTimeCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_real_time_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureAutoScrollCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_auto_scroll_, checked, pref_stashed);
}
void Singleton::f2();{
    QString default_device_string;
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
}
void Singleton::f3();{
/* capture_preferences_frame.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
    pref_real_time_ = prefFromPrefPtr(&prefs.capture_real_time);
    pref_auto_scroll_ = prefFromPrefPtr(&prefs.capture_auto_scroll);
}
void Singleton::f5();{
void CapturePreferencesFrame::on_captureNoInterfaceLoad_toggled(bool checked)
    prefs_set_bool_value(pref_no_interface_load_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureNoExtcapCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_no_extcap_, checked, pref_stashed);
 * Editor modelines
}
void Singleton::f6();{
    ui(new Ui::CapturePreferencesFrame)
    ui->setupUi(this);
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
}
void Singleton::f7();{
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
    if ((global_capture_opts.all_ifaces->len == 0) &&
}
void Singleton::f8();{
    ui->setupUi(this);
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
    pref_real_time_ = prefFromPrefPtr(&prefs.capture_real_time);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    prefs_set_bool_value(pref_pcap_ng_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureRealTimeCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_real_time_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureAutoScrollCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_auto_scroll_, checked, pref_stashed);
}
void Singleton::f2();{
    QString default_device_string;
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
}
void Singleton::f3();{
/* capture_preferences_frame.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
    pref_real_time_ = prefFromPrefPtr(&prefs.capture_real_time);
    pref_auto_scroll_ = prefFromPrefPtr(&prefs.capture_auto_scroll);
}
void Singleton::f5();{
void CapturePreferencesFrame::on_captureNoInterfaceLoad_toggled(bool checked)
    prefs_set_bool_value(pref_no_interface_load_, checked, pref_stashed);
void CapturePreferencesFrame::on_captureNoExtcapCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_no_extcap_, checked, pref_stashed);
 * Editor modelines
}
void Singleton::f6();{
    ui(new Ui::CapturePreferencesFrame)
    ui->setupUi(this);
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
}
void Singleton::f7();{
    if (prefs_get_string_value(pref_device_, pref_stashed)) {
        default_device_string = prefs_get_string_value(pref_device_, pref_stashed);
    }
    ui->defaultInterfaceComboBox->clear();
    if ((global_capture_opts.all_ifaces->len == 0) &&
}
void Singleton::f8();{
    ui->setupUi(this);
    pref_device_ = prefFromPrefPtr(&prefs.capture_device);
    pref_prom_mode_ = prefFromPrefPtr(&prefs.capture_prom_mode);
    pref_pcap_ng_ = prefFromPrefPtr(&prefs.capture_pcap_ng);
    pref_real_time_ = prefFromPrefPtr(&prefs.capture_real_time);
}
void Singleton::f9();{
 * SPDX-License-Identifier: GPL-2.0-or-later
CapturePreferencesFrame::CapturePreferencesFrame(QWidget *parent) :
    QFrame(parent),
    ui(new Ui::CapturePreferencesFrame)
    ui->setupUi(this);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
  require += info_version[argc];
  require += info_version_internal[argc];
  require += info_simulate[argc];
  require += info_simulate_version[argc];
  require += info_cray[argc];
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
  require += info_version[argc];
  require += info_version_internal[argc];
  require += info_simulate[argc];
  require += info_simulate_version[argc];
  require += info_cray[argc];
}
void Singleton::f2();{
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
}
void Singleton::f3();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}
void Singleton::f4();{
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
/* __GHS_VERSION_NUMBER = VVVVRP */
}
void Singleton::f5();{
/* Identify known platforms by name.  */
/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
}
void Singleton::f6();{
  SIMULATE_VERSION_MAJOR,
  '.', SIMULATE_VERSION_MINOR,
   '.', SIMULATE_VERSION_PATCH,
    '.', SIMULATE_VERSION_TWEAK,
  ']','\0'};
}
void Singleton::f7();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}
void Singleton::f8();{
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
}
void Singleton::f9();{
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))
/* Construct a string literal encoding the version number components. */
}
void Singleton::f10();{
/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
  require += info_version[argc];
  require += info_version_internal[argc];
  require += info_simulate[argc];
  require += info_simulate_version[argc];
  require += info_cray[argc];
}
void Singleton::f2();{
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
  require += info_version[argc];
  require += info_version_internal[argc];
  require += info_simulate[argc];
  require += info_simulate_version[argc];
  require += info_cray[argc];
}
void Singleton::f2();{
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
}
void Singleton::f3();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
  require += info_version[argc];
  require += info_version_internal[argc];
  require += info_simulate[argc];
  require += info_simulate_version[argc];
  require += info_cray[argc];
}
void Singleton::f2();{
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
}
void Singleton::f3();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}
void Singleton::f4();{
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
/* __GHS_VERSION_NUMBER = VVVVRP */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
  require += info_version[argc];
  require += info_version_internal[argc];
  require += info_simulate[argc];
  require += info_simulate_version[argc];
  require += info_cray[argc];
}
void Singleton::f2();{
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
}
void Singleton::f3();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}
void Singleton::f4();{
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
/* __GHS_VERSION_NUMBER = VVVVRP */
}
void Singleton::f5();{
/* Identify known platforms by name.  */
/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
  require += info_version[argc];
  require += info_version_internal[argc];
  require += info_simulate[argc];
  require += info_simulate_version[argc];
  require += info_cray[argc];
}
void Singleton::f2();{
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
}
void Singleton::f3();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}
void Singleton::f4();{
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
/* __GHS_VERSION_NUMBER = VVVVRP */
}
void Singleton::f5();{
/* Identify known platforms by name.  */
/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
}
void Singleton::f6();{
  SIMULATE_VERSION_MAJOR,
  '.', SIMULATE_VERSION_MINOR,
   '.', SIMULATE_VERSION_PATCH,
    '.', SIMULATE_VERSION_TWEAK,
  ']','\0'};
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
  require += info_version[argc];
  require += info_version_internal[argc];
  require += info_simulate[argc];
  require += info_simulate_version[argc];
  require += info_cray[argc];
}
void Singleton::f2();{
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
}
void Singleton::f3();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}
void Singleton::f4();{
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
/* __GHS_VERSION_NUMBER = VVVVRP */
}
void Singleton::f5();{
/* Identify known platforms by name.  */
/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
}
void Singleton::f6();{
  SIMULATE_VERSION_MAJOR,
  '.', SIMULATE_VERSION_MINOR,
   '.', SIMULATE_VERSION_PATCH,
    '.', SIMULATE_VERSION_TWEAK,
  ']','\0'};
}
void Singleton::f7();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
  require += info_version[argc];
  require += info_version_internal[argc];
  require += info_simulate[argc];
  require += info_simulate_version[argc];
  require += info_cray[argc];
}
void Singleton::f2();{
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
}
void Singleton::f3();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}
void Singleton::f4();{
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
/* __GHS_VERSION_NUMBER = VVVVRP */
}
void Singleton::f5();{
/* Identify known platforms by name.  */
/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
}
void Singleton::f6();{
  SIMULATE_VERSION_MAJOR,
  '.', SIMULATE_VERSION_MINOR,
   '.', SIMULATE_VERSION_PATCH,
    '.', SIMULATE_VERSION_TWEAK,
  ']','\0'};
}
void Singleton::f7();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}
void Singleton::f8();{
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
  require += info_version[argc];
  require += info_version_internal[argc];
  require += info_simulate[argc];
  require += info_simulate_version[argc];
  require += info_cray[argc];
}
void Singleton::f2();{
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
}
void Singleton::f3();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}
void Singleton::f4();{
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __IBMCPP__ = VRP */
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
/* __GHS_VERSION_NUMBER = VVVVRP */
}
void Singleton::f5();{
/* Identify known platforms by name.  */
/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
}
void Singleton::f6();{
  SIMULATE_VERSION_MAJOR,
  '.', SIMULATE_VERSION_MINOR,
   '.', SIMULATE_VERSION_PATCH,
    '.', SIMULATE_VERSION_TWEAK,
  ']','\0'};
}
void Singleton::f7();{
  /* __BORLANDC__ = 0xVRR */
   /* __WATCOMC__ = VVRR */
   /* __WATCOMC__ = VVRP + 1100 */
   /* __SUNPRO_CC = 0xVRRP */
   /* __SUNPRO_CC = 0xVRP */
}
void Singleton::f8();{
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
}
void Singleton::f9();{
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))
/* Construct a string literal encoding the version number components. */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        displayEdit->setText(index.model()->data(index, Qt::EditRole).toString());
        break;
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        displayEdit->setText(index.model()->data(index, Qt::EditRole).toString());
        break;
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
}
void Singleton::f2();{
    if (!name_edit) return;
    if (name.isEmpty()) {
        name_edit->setSyntaxState(SyntaxLineEdit::Empty);
    } else if (name.contains("@")) {
        name_edit->setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f3();{
            emit invalidField(index, displayEdit->syntaxErrorMessage());
        }
        else
        {
            emit validField(index);
}
void Singleton::f4();{
        Q_ASSERT(FALSE);
        return 0;
    }
    return 0;
void ColoringRulesDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
}
void Singleton::f5();{
    switch (index.column())
    {
    case ColoringRulesModel::colName:
    {
        SyntaxLineEdit *editor = new SyntaxLineEdit(parent);
}
void Singleton::f6();{
        {
            emit validField(index);
        }
        break;
    }
}
void Singleton::f7();{
                              const QModelIndex &index) const
    switch (index.column())
    {
    case ColoringRulesModel::colName:
    {
}
void Singleton::f8();{
        break;
    }
    default:
        QStyledItemDelegate::setModelData(editor, model, index);
        break;
}
void Singleton::f9();{
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
        break;
    }
}
void Singleton::f10();{
void ColoringRulesDelegate::updateEditorGeometry(QWidget *editor,
        const QStyleOptionViewItem &option, const QModelIndex&) const
    editor->setGeometry(option.rect);
void ColoringRulesDelegate::ruleNameChanged(const QString name)
    SyntaxLineEdit *name_edit = qobject_cast<SyntaxLineEdit*>(QObject::sender());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        displayEdit->setText(index.model()->data(index, Qt::EditRole).toString());
        break;
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
}
void Singleton::f2();{
    if (!name_edit) return;
    if (name.isEmpty()) {
        name_edit->setSyntaxState(SyntaxLineEdit::Empty);
    } else if (name.contains("@")) {
        name_edit->setSyntaxState(SyntaxLineEdit::Invalid);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        displayEdit->setText(index.model()->data(index, Qt::EditRole).toString());
        break;
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
}
void Singleton::f2();{
    if (!name_edit) return;
    if (name.isEmpty()) {
        name_edit->setSyntaxState(SyntaxLineEdit::Empty);
    } else if (name.contains("@")) {
        name_edit->setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f3();{
            emit invalidField(index, displayEdit->syntaxErrorMessage());
        }
        else
        {
            emit validField(index);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        displayEdit->setText(index.model()->data(index, Qt::EditRole).toString());
        break;
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
}
void Singleton::f2();{
    if (!name_edit) return;
    if (name.isEmpty()) {
        name_edit->setSyntaxState(SyntaxLineEdit::Empty);
    } else if (name.contains("@")) {
        name_edit->setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f3();{
            emit invalidField(index, displayEdit->syntaxErrorMessage());
        }
        else
        {
            emit validField(index);
}
void Singleton::f4();{
        Q_ASSERT(FALSE);
        return 0;
    }
    return 0;
void ColoringRulesDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        displayEdit->setText(index.model()->data(index, Qt::EditRole).toString());
        break;
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
}
void Singleton::f2();{
    if (!name_edit) return;
    if (name.isEmpty()) {
        name_edit->setSyntaxState(SyntaxLineEdit::Empty);
    } else if (name.contains("@")) {
        name_edit->setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f3();{
            emit invalidField(index, displayEdit->syntaxErrorMessage());
        }
        else
        {
            emit validField(index);
}
void Singleton::f4();{
        Q_ASSERT(FALSE);
        return 0;
    }
    return 0;
void ColoringRulesDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
}
void Singleton::f5();{
    switch (index.column())
    {
    case ColoringRulesModel::colName:
    {
        SyntaxLineEdit *editor = new SyntaxLineEdit(parent);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        displayEdit->setText(index.model()->data(index, Qt::EditRole).toString());
        break;
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
}
void Singleton::f2();{
    if (!name_edit) return;
    if (name.isEmpty()) {
        name_edit->setSyntaxState(SyntaxLineEdit::Empty);
    } else if (name.contains("@")) {
        name_edit->setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f3();{
            emit invalidField(index, displayEdit->syntaxErrorMessage());
        }
        else
        {
            emit validField(index);
}
void Singleton::f4();{
        Q_ASSERT(FALSE);
        return 0;
    }
    return 0;
void ColoringRulesDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
}
void Singleton::f5();{
    switch (index.column())
    {
    case ColoringRulesModel::colName:
    {
        SyntaxLineEdit *editor = new SyntaxLineEdit(parent);
}
void Singleton::f6();{
        {
            emit validField(index);
        }
        break;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        displayEdit->setText(index.model()->data(index, Qt::EditRole).toString());
        break;
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
}
void Singleton::f2();{
    if (!name_edit) return;
    if (name.isEmpty()) {
        name_edit->setSyntaxState(SyntaxLineEdit::Empty);
    } else if (name.contains("@")) {
        name_edit->setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f3();{
            emit invalidField(index, displayEdit->syntaxErrorMessage());
        }
        else
        {
            emit validField(index);
}
void Singleton::f4();{
        Q_ASSERT(FALSE);
        return 0;
    }
    return 0;
void ColoringRulesDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
}
void Singleton::f5();{
    switch (index.column())
    {
    case ColoringRulesModel::colName:
    {
        SyntaxLineEdit *editor = new SyntaxLineEdit(parent);
}
void Singleton::f6();{
        {
            emit validField(index);
        }
        break;
    }
}
void Singleton::f7();{
                              const QModelIndex &index) const
    switch (index.column())
    {
    case ColoringRulesModel::colName:
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        displayEdit->setText(index.model()->data(index, Qt::EditRole).toString());
        break;
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
}
void Singleton::f2();{
    if (!name_edit) return;
    if (name.isEmpty()) {
        name_edit->setSyntaxState(SyntaxLineEdit::Empty);
    } else if (name.contains("@")) {
        name_edit->setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f3();{
            emit invalidField(index, displayEdit->syntaxErrorMessage());
        }
        else
        {
            emit validField(index);
}
void Singleton::f4();{
        Q_ASSERT(FALSE);
        return 0;
    }
    return 0;
void ColoringRulesDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
}
void Singleton::f5();{
    switch (index.column())
    {
    case ColoringRulesModel::colName:
    {
        SyntaxLineEdit *editor = new SyntaxLineEdit(parent);
}
void Singleton::f6();{
        {
            emit validField(index);
        }
        break;
    }
}
void Singleton::f7();{
                              const QModelIndex &index) const
    switch (index.column())
    {
    case ColoringRulesModel::colName:
    {
}
void Singleton::f8();{
        break;
    }
    default:
        QStyledItemDelegate::setModelData(editor, model, index);
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        displayEdit->setText(index.model()->data(index, Qt::EditRole).toString());
        break;
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
}
void Singleton::f2();{
    if (!name_edit) return;
    if (name.isEmpty()) {
        name_edit->setSyntaxState(SyntaxLineEdit::Empty);
    } else if (name.contains("@")) {
        name_edit->setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f3();{
            emit invalidField(index, displayEdit->syntaxErrorMessage());
        }
        else
        {
            emit validField(index);
}
void Singleton::f4();{
        Q_ASSERT(FALSE);
        return 0;
    }
    return 0;
void ColoringRulesDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
}
void Singleton::f5();{
    switch (index.column())
    {
    case ColoringRulesModel::colName:
    {
        SyntaxLineEdit *editor = new SyntaxLineEdit(parent);
}
void Singleton::f6();{
        {
            emit validField(index);
        }
        break;
    }
}
void Singleton::f7();{
                              const QModelIndex &index) const
    switch (index.column())
    {
    case ColoringRulesModel::colName:
    {
}
void Singleton::f8();{
        break;
    }
    default:
        QStyledItemDelegate::setModelData(editor, model, index);
        break;
}
void Singleton::f9();{
    }
    default:
        QStyledItemDelegate::setEditorData(editor, index);
        break;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            this, SLOT(invalidField(const QModelIndex&, const QString&)));
    connect(&colorRuleDelegate_, SIGNAL(validField(const QModelIndex&)),
            this, SLOT(validField(const QModelIndex&)));
    connect(ui->coloringRulesTreeView, &QTreeView::clicked, this, &ColoringRulesDialog::treeItemClicked);
    connect(&colorRuleModel_, SIGNAL(rowsInserted(const QModelIndex &, int, int)), this, SLOT(rowCountChanged()));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            this, SLOT(invalidField(const QModelIndex&, const QString&)));
    connect(&colorRuleDelegate_, SIGNAL(validField(const QModelIndex&)),
            this, SLOT(validField(const QModelIndex&)));
    connect(ui->coloringRulesTreeView, &QTreeView::clicked, this, &ColoringRulesDialog::treeItemClicked);
    connect(&colorRuleModel_, SIGNAL(rowsInserted(const QModelIndex &, int, int)), this, SLOT(rowCountChanged()));
}
void Singleton::f2();{
    //set edit on display filter
    ui->coloringRulesTreeView->edit(colorRuleModel_.index(0, 1));
void ColoringRulesDialog::on_newToolButton_clicked()
    addRule();
void ColoringRulesDialog::on_deleteToolButton_clicked()
}
void Singleton::f3();{
    {
        errors_.insert(index, err);
        updateHint(index);
    }
    else
}
void Singleton::f4();{
    updateHint(index);
void ColoringRulesDialog::validField(const QModelIndex &index)
    QList<QModelIndex> keys = errors_.keys();
    bool update = false;
    foreach (QModelIndex key, keys)
}
void Singleton::f5();{
        return;
    QString filter = colorRuleModel_.data(colorRuleModel_.index(current.row(), ColoringRulesModel::colFilter), Qt::DisplayRole).toString();
    emit filterAction(filter, FilterAction::ActionApply, FilterAction::ActionTypePlain);
void ColoringRulesDialog::addRule(bool copy_from_current)
    const QModelIndex &current = ui->coloringRulesTreeView->currentIndex();
}
void Singleton::f6();{
    dfilter_free(dfp);
    if (err_msg)
    {
        error->append(err_msg);
        g_free(err_msg);
}
void Singleton::f7();{
        for (int i = selectedList.count()-1; i >= 0; i--) {
            QModelIndex deleteIndex = selectedList[i];
            //selectedList includes all cells, use first column as key to remove row
            if (deleteIndex.isValid() && (deleteIndex.column() == 0)) {
                colorRuleModel_.removeRows(deleteIndex.row(), 1);
}
void Singleton::f8();{
    updateHint();
ColoringRulesDialog::~ColoringRulesDialog()
    delete ui;
void ColoringRulesDialog::checkUnknownColorfilters()
    if (prefs.unknown_colorfilters) {
}
void Singleton::f9();{
                                                         wsApp->lastOpenDir().path());
        if (!file_name.isEmpty()) {
            if (!colorRuleModel_.importColors(file_name, err)) {
                simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", err.toUtf8().constData());
            }
}
void Singleton::f10();{
                simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", err.toUtf8().constData());
            }
            checkUnknownColorfilters();
        }
    } else if (button == export_button_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            this, SLOT(invalidField(const QModelIndex&, const QString&)));
    connect(&colorRuleDelegate_, SIGNAL(validField(const QModelIndex&)),
            this, SLOT(validField(const QModelIndex&)));
    connect(ui->coloringRulesTreeView, &QTreeView::clicked, this, &ColoringRulesDialog::treeItemClicked);
    connect(&colorRuleModel_, SIGNAL(rowsInserted(const QModelIndex &, int, int)), this, SLOT(rowCountChanged()));
}
void Singleton::f2();{
    //set edit on display filter
    ui->coloringRulesTreeView->edit(colorRuleModel_.index(0, 1));
void ColoringRulesDialog::on_newToolButton_clicked()
    addRule();
void ColoringRulesDialog::on_deleteToolButton_clicked()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            this, SLOT(invalidField(const QModelIndex&, const QString&)));
    connect(&colorRuleDelegate_, SIGNAL(validField(const QModelIndex&)),
            this, SLOT(validField(const QModelIndex&)));
    connect(ui->coloringRulesTreeView, &QTreeView::clicked, this, &ColoringRulesDialog::treeItemClicked);
    connect(&colorRuleModel_, SIGNAL(rowsInserted(const QModelIndex &, int, int)), this, SLOT(rowCountChanged()));
}
void Singleton::f2();{
    //set edit on display filter
    ui->coloringRulesTreeView->edit(colorRuleModel_.index(0, 1));
void ColoringRulesDialog::on_newToolButton_clicked()
    addRule();
void ColoringRulesDialog::on_deleteToolButton_clicked()
}
void Singleton::f3();{
    {
        errors_.insert(index, err);
        updateHint(index);
    }
    else
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            this, SLOT(invalidField(const QModelIndex&, const QString&)));
    connect(&colorRuleDelegate_, SIGNAL(validField(const QModelIndex&)),
            this, SLOT(validField(const QModelIndex&)));
    connect(ui->coloringRulesTreeView, &QTreeView::clicked, this, &ColoringRulesDialog::treeItemClicked);
    connect(&colorRuleModel_, SIGNAL(rowsInserted(const QModelIndex &, int, int)), this, SLOT(rowCountChanged()));
}
void Singleton::f2();{
    //set edit on display filter
    ui->coloringRulesTreeView->edit(colorRuleModel_.index(0, 1));
void ColoringRulesDialog::on_newToolButton_clicked()
    addRule();
void ColoringRulesDialog::on_deleteToolButton_clicked()
}
void Singleton::f3();{
    {
        errors_.insert(index, err);
        updateHint(index);
    }
    else
}
void Singleton::f4();{
    updateHint(index);
void ColoringRulesDialog::validField(const QModelIndex &index)
    QList<QModelIndex> keys = errors_.keys();
    bool update = false;
    foreach (QModelIndex key, keys)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            this, SLOT(invalidField(const QModelIndex&, const QString&)));
    connect(&colorRuleDelegate_, SIGNAL(validField(const QModelIndex&)),
            this, SLOT(validField(const QModelIndex&)));
    connect(ui->coloringRulesTreeView, &QTreeView::clicked, this, &ColoringRulesDialog::treeItemClicked);
    connect(&colorRuleModel_, SIGNAL(rowsInserted(const QModelIndex &, int, int)), this, SLOT(rowCountChanged()));
}
void Singleton::f2();{
    //set edit on display filter
    ui->coloringRulesTreeView->edit(colorRuleModel_.index(0, 1));
void ColoringRulesDialog::on_newToolButton_clicked()
    addRule();
void ColoringRulesDialog::on_deleteToolButton_clicked()
}
void Singleton::f3();{
    {
        errors_.insert(index, err);
        updateHint(index);
    }
    else
}
void Singleton::f4();{
    updateHint(index);
void ColoringRulesDialog::validField(const QModelIndex &index)
    QList<QModelIndex> keys = errors_.keys();
    bool update = false;
    foreach (QModelIndex key, keys)
}
void Singleton::f5();{
        return;
    QString filter = colorRuleModel_.data(colorRuleModel_.index(current.row(), ColoringRulesModel::colFilter), Qt::DisplayRole).toString();
    emit filterAction(filter, FilterAction::ActionApply, FilterAction::ActionTypePlain);
void ColoringRulesDialog::addRule(bool copy_from_current)
    const QModelIndex &current = ui->coloringRulesTreeView->currentIndex();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            this, SLOT(invalidField(const QModelIndex&, const QString&)));
    connect(&colorRuleDelegate_, SIGNAL(validField(const QModelIndex&)),
            this, SLOT(validField(const QModelIndex&)));
    connect(ui->coloringRulesTreeView, &QTreeView::clicked, this, &ColoringRulesDialog::treeItemClicked);
    connect(&colorRuleModel_, SIGNAL(rowsInserted(const QModelIndex &, int, int)), this, SLOT(rowCountChanged()));
}
void Singleton::f2();{
    //set edit on display filter
    ui->coloringRulesTreeView->edit(colorRuleModel_.index(0, 1));
void ColoringRulesDialog::on_newToolButton_clicked()
    addRule();
void ColoringRulesDialog::on_deleteToolButton_clicked()
}
void Singleton::f3();{
    {
        errors_.insert(index, err);
        updateHint(index);
    }
    else
}
void Singleton::f4();{
    updateHint(index);
void ColoringRulesDialog::validField(const QModelIndex &index)
    QList<QModelIndex> keys = errors_.keys();
    bool update = false;
    foreach (QModelIndex key, keys)
}
void Singleton::f5();{
        return;
    QString filter = colorRuleModel_.data(colorRuleModel_.index(current.row(), ColoringRulesModel::colFilter), Qt::DisplayRole).toString();
    emit filterAction(filter, FilterAction::ActionApply, FilterAction::ActionTypePlain);
void ColoringRulesDialog::addRule(bool copy_from_current)
    const QModelIndex &current = ui->coloringRulesTreeView->currentIndex();
}
void Singleton::f6();{
    dfilter_free(dfp);
    if (err_msg)
    {
        error->append(err_msg);
        g_free(err_msg);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            this, SLOT(invalidField(const QModelIndex&, const QString&)));
    connect(&colorRuleDelegate_, SIGNAL(validField(const QModelIndex&)),
            this, SLOT(validField(const QModelIndex&)));
    connect(ui->coloringRulesTreeView, &QTreeView::clicked, this, &ColoringRulesDialog::treeItemClicked);
    connect(&colorRuleModel_, SIGNAL(rowsInserted(const QModelIndex &, int, int)), this, SLOT(rowCountChanged()));
}
void Singleton::f2();{
    //set edit on display filter
    ui->coloringRulesTreeView->edit(colorRuleModel_.index(0, 1));
void ColoringRulesDialog::on_newToolButton_clicked()
    addRule();
void ColoringRulesDialog::on_deleteToolButton_clicked()
}
void Singleton::f3();{
    {
        errors_.insert(index, err);
        updateHint(index);
    }
    else
}
void Singleton::f4();{
    updateHint(index);
void ColoringRulesDialog::validField(const QModelIndex &index)
    QList<QModelIndex> keys = errors_.keys();
    bool update = false;
    foreach (QModelIndex key, keys)
}
void Singleton::f5();{
        return;
    QString filter = colorRuleModel_.data(colorRuleModel_.index(current.row(), ColoringRulesModel::colFilter), Qt::DisplayRole).toString();
    emit filterAction(filter, FilterAction::ActionApply, FilterAction::ActionTypePlain);
void ColoringRulesDialog::addRule(bool copy_from_current)
    const QModelIndex &current = ui->coloringRulesTreeView->currentIndex();
}
void Singleton::f6();{
    dfilter_free(dfp);
    if (err_msg)
    {
        error->append(err_msg);
        g_free(err_msg);
}
void Singleton::f7();{
        for (int i = selectedList.count()-1; i >= 0; i--) {
            QModelIndex deleteIndex = selectedList[i];
            //selectedList includes all cells, use first column as key to remove row
            if (deleteIndex.isValid() && (deleteIndex.column() == 0)) {
                colorRuleModel_.removeRows(deleteIndex.row(), 1);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            this, SLOT(invalidField(const QModelIndex&, const QString&)));
    connect(&colorRuleDelegate_, SIGNAL(validField(const QModelIndex&)),
            this, SLOT(validField(const QModelIndex&)));
    connect(ui->coloringRulesTreeView, &QTreeView::clicked, this, &ColoringRulesDialog::treeItemClicked);
    connect(&colorRuleModel_, SIGNAL(rowsInserted(const QModelIndex &, int, int)), this, SLOT(rowCountChanged()));
}
void Singleton::f2();{
    //set edit on display filter
    ui->coloringRulesTreeView->edit(colorRuleModel_.index(0, 1));
void ColoringRulesDialog::on_newToolButton_clicked()
    addRule();
void ColoringRulesDialog::on_deleteToolButton_clicked()
}
void Singleton::f3();{
    {
        errors_.insert(index, err);
        updateHint(index);
    }
    else
}
void Singleton::f4();{
    updateHint(index);
void ColoringRulesDialog::validField(const QModelIndex &index)
    QList<QModelIndex> keys = errors_.keys();
    bool update = false;
    foreach (QModelIndex key, keys)
}
void Singleton::f5();{
        return;
    QString filter = colorRuleModel_.data(colorRuleModel_.index(current.row(), ColoringRulesModel::colFilter), Qt::DisplayRole).toString();
    emit filterAction(filter, FilterAction::ActionApply, FilterAction::ActionTypePlain);
void ColoringRulesDialog::addRule(bool copy_from_current)
    const QModelIndex &current = ui->coloringRulesTreeView->currentIndex();
}
void Singleton::f6();{
    dfilter_free(dfp);
    if (err_msg)
    {
        error->append(err_msg);
        g_free(err_msg);
}
void Singleton::f7();{
        for (int i = selectedList.count()-1; i >= 0; i--) {
            QModelIndex deleteIndex = selectedList[i];
            //selectedList includes all cells, use first column as key to remove row
            if (deleteIndex.isValid() && (deleteIndex.column() == 0)) {
                colorRuleModel_.removeRows(deleteIndex.row(), 1);
}
void Singleton::f8();{
    updateHint();
ColoringRulesDialog::~ColoringRulesDialog()
    delete ui;
void ColoringRulesDialog::checkUnknownColorfilters()
    if (prefs.unknown_colorfilters) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            this, SLOT(invalidField(const QModelIndex&, const QString&)));
    connect(&colorRuleDelegate_, SIGNAL(validField(const QModelIndex&)),
            this, SLOT(validField(const QModelIndex&)));
    connect(ui->coloringRulesTreeView, &QTreeView::clicked, this, &ColoringRulesDialog::treeItemClicked);
    connect(&colorRuleModel_, SIGNAL(rowsInserted(const QModelIndex &, int, int)), this, SLOT(rowCountChanged()));
}
void Singleton::f2();{
    //set edit on display filter
    ui->coloringRulesTreeView->edit(colorRuleModel_.index(0, 1));
void ColoringRulesDialog::on_newToolButton_clicked()
    addRule();
void ColoringRulesDialog::on_deleteToolButton_clicked()
}
void Singleton::f3();{
    {
        errors_.insert(index, err);
        updateHint(index);
    }
    else
}
void Singleton::f4();{
    updateHint(index);
void ColoringRulesDialog::validField(const QModelIndex &index)
    QList<QModelIndex> keys = errors_.keys();
    bool update = false;
    foreach (QModelIndex key, keys)
}
void Singleton::f5();{
        return;
    QString filter = colorRuleModel_.data(colorRuleModel_.index(current.row(), ColoringRulesModel::colFilter), Qt::DisplayRole).toString();
    emit filterAction(filter, FilterAction::ActionApply, FilterAction::ActionTypePlain);
void ColoringRulesDialog::addRule(bool copy_from_current)
    const QModelIndex &current = ui->coloringRulesTreeView->currentIndex();
}
void Singleton::f6();{
    dfilter_free(dfp);
    if (err_msg)
    {
        error->append(err_msg);
        g_free(err_msg);
}
void Singleton::f7();{
        for (int i = selectedList.count()-1; i >= 0; i--) {
            QModelIndex deleteIndex = selectedList[i];
            //selectedList includes all cells, use first column as key to remove row
            if (deleteIndex.isValid() && (deleteIndex.column() == 0)) {
                colorRuleModel_.removeRows(deleteIndex.row(), 1);
}
void Singleton::f8();{
    updateHint();
ColoringRulesDialog::~ColoringRulesDialog()
    delete ui;
void ColoringRulesDialog::checkUnknownColorfilters()
    if (prefs.unknown_colorfilters) {
}
void Singleton::f9();{
                                                         wsApp->lastOpenDir().path());
        if (!file_name.isEmpty()) {
            if (!colorRuleModel_.importColors(file_name, err)) {
                simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", err.toUtf8().constData());
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        case colName:
            rule->name_ = value.toString();
            break;
        case colFilter:
            rule->filter_ = value.toString();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        case colName:
            rule->name_ = value.toString();
            break;
        case colFilter:
            rule->filter_ = value.toString();
}
void Singleton::f2();{
    Q_ASSERT(parent_item);
    child_item = parent_item->child(row);
    if (child_item) {
        return createIndex(row, column, child_item);
    }
}
void Singleton::f3();{
    return true;
bool ColoringRulesModel::removeRows(int row, int count, const QModelIndex& parent)
    if (row < 0)
        return false;
    beginRemoveRows(parent, row, row+(count-1));
}
void Singleton::f4();{
        default:
            return false;
        }
        break;
    case Qt::BackgroundRole:
}
void Singleton::f5();{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    switch (index.column())
    {
    case colName:
        flags |= (Qt::ItemIsUserCheckable|Qt::ItemIsEditable);
}
void Singleton::f6();{
    return success;
bool ColoringRulesModel::writeColors(QString& err)
    GSList *cfl = createColorFilterList();
    bool success = true;
    gchar* err_msg = NULL;
}
void Singleton::f7();{
    case Qt::ForegroundRole:
        return rule->foreground_;
    }
    return QVariant();
bool ColoringRulesModel::setData(const QModelIndex &dataIndex, const QVariant &value, int role)
}
void Singleton::f8();{
    case Qt::UserRole:
        {
        ColoringRuleItem* new_rule = VariantPointer<ColoringRuleItem>::asPtr(value);
        *rule = *new_rule;
        topLeft = index(dataIndex.row(), colName);
}
void Singleton::f9();{
    for (int row = 0; row < root_->childCount(); row++)
    {
        ColoringRuleItem* rule = root_->child(row);
        if (rule == NULL)
            continue;
}
void Singleton::f10();{
    beginInsertRows(parent, row, row+(count-1));
    for (int i = row; i < row + count; i++)
    {
        ColoringRuleItem* item = new ColoringRuleItem(true, tr("New coloring rule"), "", defaultForeground_, defaultBackground_, root_);
        root_->insertChild(i, item);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        case colName:
            rule->name_ = value.toString();
            break;
        case colFilter:
            rule->filter_ = value.toString();
}
void Singleton::f2();{
    Q_ASSERT(parent_item);
    child_item = parent_item->child(row);
    if (child_item) {
        return createIndex(row, column, child_item);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        case colName:
            rule->name_ = value.toString();
            break;
        case colFilter:
            rule->filter_ = value.toString();
}
void Singleton::f2();{
    Q_ASSERT(parent_item);
    child_item = parent_item->child(row);
    if (child_item) {
        return createIndex(row, column, child_item);
    }
}
void Singleton::f3();{
    return true;
bool ColoringRulesModel::removeRows(int row, int count, const QModelIndex& parent)
    if (row < 0)
        return false;
    beginRemoveRows(parent, row, row+(count-1));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        case colName:
            rule->name_ = value.toString();
            break;
        case colFilter:
            rule->filter_ = value.toString();
}
void Singleton::f2();{
    Q_ASSERT(parent_item);
    child_item = parent_item->child(row);
    if (child_item) {
        return createIndex(row, column, child_item);
    }
}
void Singleton::f3();{
    return true;
bool ColoringRulesModel::removeRows(int row, int count, const QModelIndex& parent)
    if (row < 0)
        return false;
    beginRemoveRows(parent, row, row+(count-1));
}
void Singleton::f4();{
        default:
            return false;
        }
        break;
    case Qt::BackgroundRole:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        case colName:
            rule->name_ = value.toString();
            break;
        case colFilter:
            rule->filter_ = value.toString();
}
void Singleton::f2();{
    Q_ASSERT(parent_item);
    child_item = parent_item->child(row);
    if (child_item) {
        return createIndex(row, column, child_item);
    }
}
void Singleton::f3();{
    return true;
bool ColoringRulesModel::removeRows(int row, int count, const QModelIndex& parent)
    if (row < 0)
        return false;
    beginRemoveRows(parent, row, row+(count-1));
}
void Singleton::f4();{
        default:
            return false;
        }
        break;
    case Qt::BackgroundRole:
}
void Singleton::f5();{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    switch (index.column())
    {
    case colName:
        flags |= (Qt::ItemIsUserCheckable|Qt::ItemIsEditable);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        case colName:
            rule->name_ = value.toString();
            break;
        case colFilter:
            rule->filter_ = value.toString();
}
void Singleton::f2();{
    Q_ASSERT(parent_item);
    child_item = parent_item->child(row);
    if (child_item) {
        return createIndex(row, column, child_item);
    }
}
void Singleton::f3();{
    return true;
bool ColoringRulesModel::removeRows(int row, int count, const QModelIndex& parent)
    if (row < 0)
        return false;
    beginRemoveRows(parent, row, row+(count-1));
}
void Singleton::f4();{
        default:
            return false;
        }
        break;
    case Qt::BackgroundRole:
}
void Singleton::f5();{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    switch (index.column())
    {
    case colName:
        flags |= (Qt::ItemIsUserCheckable|Qt::ItemIsEditable);
}
void Singleton::f6();{
    return success;
bool ColoringRulesModel::writeColors(QString& err)
    GSList *cfl = createColorFilterList();
    bool success = true;
    gchar* err_msg = NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        case colName:
            rule->name_ = value.toString();
            break;
        case colFilter:
            rule->filter_ = value.toString();
}
void Singleton::f2();{
    Q_ASSERT(parent_item);
    child_item = parent_item->child(row);
    if (child_item) {
        return createIndex(row, column, child_item);
    }
}
void Singleton::f3();{
    return true;
bool ColoringRulesModel::removeRows(int row, int count, const QModelIndex& parent)
    if (row < 0)
        return false;
    beginRemoveRows(parent, row, row+(count-1));
}
void Singleton::f4();{
        default:
            return false;
        }
        break;
    case Qt::BackgroundRole:
}
void Singleton::f5();{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    switch (index.column())
    {
    case colName:
        flags |= (Qt::ItemIsUserCheckable|Qt::ItemIsEditable);
}
void Singleton::f6();{
    return success;
bool ColoringRulesModel::writeColors(QString& err)
    GSList *cfl = createColorFilterList();
    bool success = true;
    gchar* err_msg = NULL;
}
void Singleton::f7();{
    case Qt::ForegroundRole:
        return rule->foreground_;
    }
    return QVariant();
bool ColoringRulesModel::setData(const QModelIndex &dataIndex, const QVariant &value, int role)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        case colName:
            rule->name_ = value.toString();
            break;
        case colFilter:
            rule->filter_ = value.toString();
}
void Singleton::f2();{
    Q_ASSERT(parent_item);
    child_item = parent_item->child(row);
    if (child_item) {
        return createIndex(row, column, child_item);
    }
}
void Singleton::f3();{
    return true;
bool ColoringRulesModel::removeRows(int row, int count, const QModelIndex& parent)
    if (row < 0)
        return false;
    beginRemoveRows(parent, row, row+(count-1));
}
void Singleton::f4();{
        default:
            return false;
        }
        break;
    case Qt::BackgroundRole:
}
void Singleton::f5();{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    switch (index.column())
    {
    case colName:
        flags |= (Qt::ItemIsUserCheckable|Qt::ItemIsEditable);
}
void Singleton::f6();{
    return success;
bool ColoringRulesModel::writeColors(QString& err)
    GSList *cfl = createColorFilterList();
    bool success = true;
    gchar* err_msg = NULL;
}
void Singleton::f7();{
    case Qt::ForegroundRole:
        return rule->foreground_;
    }
    return QVariant();
bool ColoringRulesModel::setData(const QModelIndex &dataIndex, const QVariant &value, int role)
}
void Singleton::f8();{
    case Qt::UserRole:
        {
        ColoringRuleItem* new_rule = VariantPointer<ColoringRuleItem>::asPtr(value);
        *rule = *new_rule;
        topLeft = index(dataIndex.row(), colName);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        case colName:
            rule->name_ = value.toString();
            break;
        case colFilter:
            rule->filter_ = value.toString();
}
void Singleton::f2();{
    Q_ASSERT(parent_item);
    child_item = parent_item->child(row);
    if (child_item) {
        return createIndex(row, column, child_item);
    }
}
void Singleton::f3();{
    return true;
bool ColoringRulesModel::removeRows(int row, int count, const QModelIndex& parent)
    if (row < 0)
        return false;
    beginRemoveRows(parent, row, row+(count-1));
}
void Singleton::f4();{
        default:
            return false;
        }
        break;
    case Qt::BackgroundRole:
}
void Singleton::f5();{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    switch (index.column())
    {
    case colName:
        flags |= (Qt::ItemIsUserCheckable|Qt::ItemIsEditable);
}
void Singleton::f6();{
    return success;
bool ColoringRulesModel::writeColors(QString& err)
    GSList *cfl = createColorFilterList();
    bool success = true;
    gchar* err_msg = NULL;
}
void Singleton::f7();{
    case Qt::ForegroundRole:
        return rule->foreground_;
    }
    return QVariant();
bool ColoringRulesModel::setData(const QModelIndex &dataIndex, const QVariant &value, int role)
}
void Singleton::f8();{
    case Qt::UserRole:
        {
        ColoringRuleItem* new_rule = VariantPointer<ColoringRuleItem>::asPtr(value);
        *rule = *new_rule;
        topLeft = index(dataIndex.row(), colName);
}
void Singleton::f9();{
    for (int row = 0; row < root_->childCount(); row++)
    {
        ColoringRuleItem* rule = root_->child(row);
        if (rule == NULL)
            continue;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}
void Singleton::f2();{
QList<QRgb> ColorUtils::sequence_colors_;
QRgb ColorUtils::sequenceColor(int item)
    if (sequence_colors_.isEmpty()) {
        // Available sequence colors. Copied from gtk/graph_analysis.c.
        // XXX - Add custom?
}
void Singleton::f3();{
    return link_style;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f4();{
                << qRgb(255, 160, 123)
                << qRgb(255, 182, 193)
                << qRgb(250, 250, 210)
                << qRgb(255, 255, 52)
                << qRgb(103, 205, 170)
}
void Singleton::f5();{
QBrush ColorUtils::themeLinkBrush()
    // https://bugreports.qt.io/browse/QTBUG-71740
    if (themeIsDark()) {
        return QBrush(tango_sky_blue_2);
    }
}
void Singleton::f6();{
                << qRgb(103, 205, 170)
                << qRgb(224, 255, 255)
                << qRgb(176, 196, 222)
                << qRgb(135, 206, 254)
                << qRgb(211, 211, 211);
}
void Singleton::f7();{
    color_t colort;
    // Convert [0,255] values to [0,65535] values
    colort.red = (color.red() << 8) | color.red();
    colort.green = (color.green() << 8) | color.green();
    colort.blue = (color.blue() << 8) | color.blue();
}
void Singleton::f8();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}
void Singleton::f9();{
// and ORing them together.
// Converting from [0,65535] to [0,255] without rounding involves
// just shifting the 16-bit value right 8 bits; I guess you could
// round them by adding 0x80 to the value before shifting.
QColor ColorUtils::fromColorT (const color_t *color) {
}
void Singleton::f10();{
    color_t colort;
    // Convert [0,255] values to [0,65535] values
    colort.red = (color.red() << 8) | color.red();
    colort.green = (color.green() << 8) | color.green();
    colort.blue = (color.blue() << 8) | color.blue();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}
void Singleton::f2();{
QList<QRgb> ColorUtils::sequence_colors_;
QRgb ColorUtils::sequenceColor(int item)
    if (sequence_colors_.isEmpty()) {
        // Available sequence colors. Copied from gtk/graph_analysis.c.
        // XXX - Add custom?
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}
void Singleton::f2();{
QList<QRgb> ColorUtils::sequence_colors_;
QRgb ColorUtils::sequenceColor(int item)
    if (sequence_colors_.isEmpty()) {
        // Available sequence colors. Copied from gtk/graph_analysis.c.
        // XXX - Add custom?
}
void Singleton::f3();{
    return link_style;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}
void Singleton::f2();{
QList<QRgb> ColorUtils::sequence_colors_;
QRgb ColorUtils::sequenceColor(int item)
    if (sequence_colors_.isEmpty()) {
        // Available sequence colors. Copied from gtk/graph_analysis.c.
        // XXX - Add custom?
}
void Singleton::f3();{
    return link_style;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f4();{
                << qRgb(255, 160, 123)
                << qRgb(255, 182, 193)
                << qRgb(250, 250, 210)
                << qRgb(255, 255, 52)
                << qRgb(103, 205, 170)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}
void Singleton::f2();{
QList<QRgb> ColorUtils::sequence_colors_;
QRgb ColorUtils::sequenceColor(int item)
    if (sequence_colors_.isEmpty()) {
        // Available sequence colors. Copied from gtk/graph_analysis.c.
        // XXX - Add custom?
}
void Singleton::f3();{
    return link_style;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f4();{
                << qRgb(255, 160, 123)
                << qRgb(255, 182, 193)
                << qRgb(250, 250, 210)
                << qRgb(255, 255, 52)
                << qRgb(103, 205, 170)
}
void Singleton::f5();{
QBrush ColorUtils::themeLinkBrush()
    // https://bugreports.qt.io/browse/QTBUG-71740
    if (themeIsDark()) {
        return QBrush(tango_sky_blue_2);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}
void Singleton::f2();{
QList<QRgb> ColorUtils::sequence_colors_;
QRgb ColorUtils::sequenceColor(int item)
    if (sequence_colors_.isEmpty()) {
        // Available sequence colors. Copied from gtk/graph_analysis.c.
        // XXX - Add custom?
}
void Singleton::f3();{
    return link_style;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f4();{
                << qRgb(255, 160, 123)
                << qRgb(255, 182, 193)
                << qRgb(250, 250, 210)
                << qRgb(255, 255, 52)
                << qRgb(103, 205, 170)
}
void Singleton::f5();{
QBrush ColorUtils::themeLinkBrush()
    // https://bugreports.qt.io/browse/QTBUG-71740
    if (themeIsDark()) {
        return QBrush(tango_sky_blue_2);
    }
}
void Singleton::f6();{
                << qRgb(103, 205, 170)
                << qRgb(224, 255, 255)
                << qRgb(176, 196, 222)
                << qRgb(135, 206, 254)
                << qRgb(211, 211, 211);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}
void Singleton::f2();{
QList<QRgb> ColorUtils::sequence_colors_;
QRgb ColorUtils::sequenceColor(int item)
    if (sequence_colors_.isEmpty()) {
        // Available sequence colors. Copied from gtk/graph_analysis.c.
        // XXX - Add custom?
}
void Singleton::f3();{
    return link_style;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f4();{
                << qRgb(255, 160, 123)
                << qRgb(255, 182, 193)
                << qRgb(250, 250, 210)
                << qRgb(255, 255, 52)
                << qRgb(103, 205, 170)
}
void Singleton::f5();{
QBrush ColorUtils::themeLinkBrush()
    // https://bugreports.qt.io/browse/QTBUG-71740
    if (themeIsDark()) {
        return QBrush(tango_sky_blue_2);
    }
}
void Singleton::f6();{
                << qRgb(103, 205, 170)
                << qRgb(224, 255, 255)
                << qRgb(176, 196, 222)
                << qRgb(135, 206, 254)
                << qRgb(211, 211, 211);
}
void Singleton::f7();{
    color_t colort;
    // Convert [0,255] values to [0,65535] values
    colort.red = (color.red() << 8) | color.red();
    colort.green = (color.green() << 8) | color.green();
    colort.blue = (color.blue() << 8) | color.blue();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}
void Singleton::f2();{
QList<QRgb> ColorUtils::sequence_colors_;
QRgb ColorUtils::sequenceColor(int item)
    if (sequence_colors_.isEmpty()) {
        // Available sequence colors. Copied from gtk/graph_analysis.c.
        // XXX - Add custom?
}
void Singleton::f3();{
    return link_style;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f4();{
                << qRgb(255, 160, 123)
                << qRgb(255, 182, 193)
                << qRgb(250, 250, 210)
                << qRgb(255, 255, 52)
                << qRgb(103, 205, 170)
}
void Singleton::f5();{
QBrush ColorUtils::themeLinkBrush()
    // https://bugreports.qt.io/browse/QTBUG-71740
    if (themeIsDark()) {
        return QBrush(tango_sky_blue_2);
    }
}
void Singleton::f6();{
                << qRgb(103, 205, 170)
                << qRgb(224, 255, 255)
                << qRgb(176, 196, 222)
                << qRgb(135, 206, 254)
                << qRgb(211, 211, 211);
}
void Singleton::f7();{
    color_t colort;
    // Convert [0,255] values to [0,65535] values
    colort.red = (color.red() << 8) | color.red();
    colort.green = (color.green() << 8) | color.green();
    colort.blue = (color.blue() << 8) | color.blue();
}
void Singleton::f8();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}
void Singleton::f2();{
QList<QRgb> ColorUtils::sequence_colors_;
QRgb ColorUtils::sequenceColor(int item)
    if (sequence_colors_.isEmpty()) {
        // Available sequence colors. Copied from gtk/graph_analysis.c.
        // XXX - Add custom?
}
void Singleton::f3();{
    return link_style;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f4();{
                << qRgb(255, 160, 123)
                << qRgb(255, 182, 193)
                << qRgb(250, 250, 210)
                << qRgb(255, 255, 52)
                << qRgb(103, 205, 170)
}
void Singleton::f5();{
QBrush ColorUtils::themeLinkBrush()
    // https://bugreports.qt.io/browse/QTBUG-71740
    if (themeIsDark()) {
        return QBrush(tango_sky_blue_2);
    }
}
void Singleton::f6();{
                << qRgb(103, 205, 170)
                << qRgb(224, 255, 255)
                << qRgb(176, 196, 222)
                << qRgb(135, 206, 254)
                << qRgb(211, 211, 211);
}
void Singleton::f7();{
    color_t colort;
    // Convert [0,255] values to [0,65535] values
    colort.red = (color.red() << 8) | color.red();
    colort.green = (color.green() << 8) | color.green();
    colort.blue = (color.blue() << 8) | color.blue();
}
void Singleton::f8();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Colors we use in various parts of the UI.
// New colors should be chosen from tango_colors.h. The expert and hidden
// colors come from the GTK+ UI and are grandfathered in.
}
void Singleton::f9();{
// and ORing them together.
// Converting from [0,65535] to [0,255] without rounding involves
// just shifting the 16-bit value right 8 bits; I guess you could
// round them by adding 0x80 to the value before shifting.
QColor ColorUtils::fromColorT (const color_t *color) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(syntaxIsValid());
    saved_occurrence_ = occurrence;
void ColumnEditorFrame::on_buttonBox_rejected()
    cur_column_ = -1;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(syntaxIsValid());
    saved_occurrence_ = occurrence;
void ColumnEditorFrame::on_buttonBox_rejected()
    cur_column_ = -1;
}
void Singleton::f2();{
    saved_occurrence_ = QString::number(get_column_custom_occurrence(column));
    ui->typeComboBox->setCurrentIndex(get_column_format(column));
    setFields(ui->typeComboBox->currentIndex());
void ColumnEditorFrame::showEvent(QShowEvent *event)
    ui->titleLineEdit->setFocus();
}
void Singleton::f3();{
    connect(ui->fieldsNameLineEdit, SIGNAL(textChanged(QString)),
            ui->fieldsNameLineEdit, SLOT(checkCustomColumn(QString)));
ColumnEditorFrame::~ColumnEditorFrame()
    delete ui;
bool ColumnEditorFrame::syntaxIsValid(void)
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
            }
        }
    }
    AccordionFrame::keyPressEvent(event);
 * Editor modelines
}
void Singleton::f6();{
                on_buttonBox_accepted();
            } else if (ui->fieldsNameLineEdit->syntaxState() == SyntaxLineEdit::Empty) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing fields."));
            } else if (ui->fieldsNameLineEdit->syntaxState() != SyntaxLineEdit::Valid) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Invalid fields."));
}
void Singleton::f7();{
    cur_column_ = -1;
    animatedHide();
void ColumnEditorFrame::on_buttonBox_accepted()
    QByteArray col_str;
    if (cur_column_ >= 0) {
}
void Singleton::f8();{
            col_str = ui->fieldsNameLineEdit->text().toUtf8();
            set_column_custom_fields(cur_column_, col_str.constData());
            recent_set_column_width(cur_column_, width);
            recent_set_column_xalign(cur_column_, xalign);
            if (!ui->occurrenceLineEdit->text().isEmpty()) {
}
void Singleton::f9();{
        col_str = ui->titleLineEdit->text().toUtf8();
        set_column_title(cur_column_, col_str.constData());
        set_column_format(cur_column_, ui->typeComboBox->currentIndex());
        if (ui->typeComboBox->currentIndex() == COL_CUSTOM) {
            gint width = recent_get_column_width(cur_column_);
}
void Singleton::f10();{
    return ((ui->fieldsNameLineEdit->syntaxState() == SyntaxLineEdit::Valid) &&
            (ui->occurrenceLineEdit->syntaxState() != SyntaxLineEdit::Invalid));
void ColumnEditorFrame::setFields(int index)
    bool ok = true;
    if (index == COL_CUSTOM) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(syntaxIsValid());
    saved_occurrence_ = occurrence;
void ColumnEditorFrame::on_buttonBox_rejected()
    cur_column_ = -1;
}
void Singleton::f2();{
    saved_occurrence_ = QString::number(get_column_custom_occurrence(column));
    ui->typeComboBox->setCurrentIndex(get_column_format(column));
    setFields(ui->typeComboBox->currentIndex());
void ColumnEditorFrame::showEvent(QShowEvent *event)
    ui->titleLineEdit->setFocus();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(syntaxIsValid());
    saved_occurrence_ = occurrence;
void ColumnEditorFrame::on_buttonBox_rejected()
    cur_column_ = -1;
}
void Singleton::f2();{
    saved_occurrence_ = QString::number(get_column_custom_occurrence(column));
    ui->typeComboBox->setCurrentIndex(get_column_format(column));
    setFields(ui->typeComboBox->currentIndex());
void ColumnEditorFrame::showEvent(QShowEvent *event)
    ui->titleLineEdit->setFocus();
}
void Singleton::f3();{
    connect(ui->fieldsNameLineEdit, SIGNAL(textChanged(QString)),
            ui->fieldsNameLineEdit, SLOT(checkCustomColumn(QString)));
ColumnEditorFrame::~ColumnEditorFrame()
    delete ui;
bool ColumnEditorFrame::syntaxIsValid(void)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(syntaxIsValid());
    saved_occurrence_ = occurrence;
void ColumnEditorFrame::on_buttonBox_rejected()
    cur_column_ = -1;
}
void Singleton::f2();{
    saved_occurrence_ = QString::number(get_column_custom_occurrence(column));
    ui->typeComboBox->setCurrentIndex(get_column_format(column));
    setFields(ui->typeComboBox->currentIndex());
void ColumnEditorFrame::showEvent(QShowEvent *event)
    ui->titleLineEdit->setFocus();
}
void Singleton::f3();{
    connect(ui->fieldsNameLineEdit, SIGNAL(textChanged(QString)),
            ui->fieldsNameLineEdit, SLOT(checkCustomColumn(QString)));
ColumnEditorFrame::~ColumnEditorFrame()
    delete ui;
bool ColumnEditorFrame::syntaxIsValid(void)
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(syntaxIsValid());
    saved_occurrence_ = occurrence;
void ColumnEditorFrame::on_buttonBox_rejected()
    cur_column_ = -1;
}
void Singleton::f2();{
    saved_occurrence_ = QString::number(get_column_custom_occurrence(column));
    ui->typeComboBox->setCurrentIndex(get_column_format(column));
    setFields(ui->typeComboBox->currentIndex());
void ColumnEditorFrame::showEvent(QShowEvent *event)
    ui->titleLineEdit->setFocus();
}
void Singleton::f3();{
    connect(ui->fieldsNameLineEdit, SIGNAL(textChanged(QString)),
            ui->fieldsNameLineEdit, SLOT(checkCustomColumn(QString)));
ColumnEditorFrame::~ColumnEditorFrame()
    delete ui;
bool ColumnEditorFrame::syntaxIsValid(void)
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
            }
        }
    }
    AccordionFrame::keyPressEvent(event);
 * Editor modelines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(syntaxIsValid());
    saved_occurrence_ = occurrence;
void ColumnEditorFrame::on_buttonBox_rejected()
    cur_column_ = -1;
}
void Singleton::f2();{
    saved_occurrence_ = QString::number(get_column_custom_occurrence(column));
    ui->typeComboBox->setCurrentIndex(get_column_format(column));
    setFields(ui->typeComboBox->currentIndex());
void ColumnEditorFrame::showEvent(QShowEvent *event)
    ui->titleLineEdit->setFocus();
}
void Singleton::f3();{
    connect(ui->fieldsNameLineEdit, SIGNAL(textChanged(QString)),
            ui->fieldsNameLineEdit, SLOT(checkCustomColumn(QString)));
ColumnEditorFrame::~ColumnEditorFrame()
    delete ui;
bool ColumnEditorFrame::syntaxIsValid(void)
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
            }
        }
    }
    AccordionFrame::keyPressEvent(event);
 * Editor modelines
}
void Singleton::f6();{
                on_buttonBox_accepted();
            } else if (ui->fieldsNameLineEdit->syntaxState() == SyntaxLineEdit::Empty) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing fields."));
            } else if (ui->fieldsNameLineEdit->syntaxState() != SyntaxLineEdit::Valid) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Invalid fields."));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(syntaxIsValid());
    saved_occurrence_ = occurrence;
void ColumnEditorFrame::on_buttonBox_rejected()
    cur_column_ = -1;
}
void Singleton::f2();{
    saved_occurrence_ = QString::number(get_column_custom_occurrence(column));
    ui->typeComboBox->setCurrentIndex(get_column_format(column));
    setFields(ui->typeComboBox->currentIndex());
void ColumnEditorFrame::showEvent(QShowEvent *event)
    ui->titleLineEdit->setFocus();
}
void Singleton::f3();{
    connect(ui->fieldsNameLineEdit, SIGNAL(textChanged(QString)),
            ui->fieldsNameLineEdit, SLOT(checkCustomColumn(QString)));
ColumnEditorFrame::~ColumnEditorFrame()
    delete ui;
bool ColumnEditorFrame::syntaxIsValid(void)
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
            }
        }
    }
    AccordionFrame::keyPressEvent(event);
 * Editor modelines
}
void Singleton::f6();{
                on_buttonBox_accepted();
            } else if (ui->fieldsNameLineEdit->syntaxState() == SyntaxLineEdit::Empty) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing fields."));
            } else if (ui->fieldsNameLineEdit->syntaxState() != SyntaxLineEdit::Valid) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Invalid fields."));
}
void Singleton::f7();{
    cur_column_ = -1;
    animatedHide();
void ColumnEditorFrame::on_buttonBox_accepted()
    QByteArray col_str;
    if (cur_column_ >= 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(syntaxIsValid());
    saved_occurrence_ = occurrence;
void ColumnEditorFrame::on_buttonBox_rejected()
    cur_column_ = -1;
}
void Singleton::f2();{
    saved_occurrence_ = QString::number(get_column_custom_occurrence(column));
    ui->typeComboBox->setCurrentIndex(get_column_format(column));
    setFields(ui->typeComboBox->currentIndex());
void ColumnEditorFrame::showEvent(QShowEvent *event)
    ui->titleLineEdit->setFocus();
}
void Singleton::f3();{
    connect(ui->fieldsNameLineEdit, SIGNAL(textChanged(QString)),
            ui->fieldsNameLineEdit, SLOT(checkCustomColumn(QString)));
ColumnEditorFrame::~ColumnEditorFrame()
    delete ui;
bool ColumnEditorFrame::syntaxIsValid(void)
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
            }
        }
    }
    AccordionFrame::keyPressEvent(event);
 * Editor modelines
}
void Singleton::f6();{
                on_buttonBox_accepted();
            } else if (ui->fieldsNameLineEdit->syntaxState() == SyntaxLineEdit::Empty) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing fields."));
            } else if (ui->fieldsNameLineEdit->syntaxState() != SyntaxLineEdit::Valid) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Invalid fields."));
}
void Singleton::f7();{
    cur_column_ = -1;
    animatedHide();
void ColumnEditorFrame::on_buttonBox_accepted()
    QByteArray col_str;
    if (cur_column_ >= 0) {
}
void Singleton::f8();{
            col_str = ui->fieldsNameLineEdit->text().toUtf8();
            set_column_custom_fields(cur_column_, col_str.constData());
            recent_set_column_width(cur_column_, width);
            recent_set_column_xalign(cur_column_, xalign);
            if (!ui->occurrenceLineEdit->text().isEmpty()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(syntaxIsValid());
    saved_occurrence_ = occurrence;
void ColumnEditorFrame::on_buttonBox_rejected()
    cur_column_ = -1;
}
void Singleton::f2();{
    saved_occurrence_ = QString::number(get_column_custom_occurrence(column));
    ui->typeComboBox->setCurrentIndex(get_column_format(column));
    setFields(ui->typeComboBox->currentIndex());
void ColumnEditorFrame::showEvent(QShowEvent *event)
    ui->titleLineEdit->setFocus();
}
void Singleton::f3();{
    connect(ui->fieldsNameLineEdit, SIGNAL(textChanged(QString)),
            ui->fieldsNameLineEdit, SLOT(checkCustomColumn(QString)));
ColumnEditorFrame::~ColumnEditorFrame()
    delete ui;
bool ColumnEditorFrame::syntaxIsValid(void)
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
            }
        }
    }
    AccordionFrame::keyPressEvent(event);
 * Editor modelines
}
void Singleton::f6();{
                on_buttonBox_accepted();
            } else if (ui->fieldsNameLineEdit->syntaxState() == SyntaxLineEdit::Empty) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing fields."));
            } else if (ui->fieldsNameLineEdit->syntaxState() != SyntaxLineEdit::Valid) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Invalid fields."));
}
void Singleton::f7();{
    cur_column_ = -1;
    animatedHide();
void ColumnEditorFrame::on_buttonBox_accepted()
    QByteArray col_str;
    if (cur_column_ >= 0) {
}
void Singleton::f8();{
            col_str = ui->fieldsNameLineEdit->text().toUtf8();
            set_column_custom_fields(cur_column_, col_str.constData());
            recent_set_column_width(cur_column_, width);
            recent_set_column_xalign(cur_column_, xalign);
            if (!ui->occurrenceLineEdit->text().isEmpty()) {
}
void Singleton::f9();{
        col_str = ui->titleLineEdit->text().toUtf8();
        set_column_title(cur_column_, col_str.constData());
        set_column_format(cur_column_, ui->typeComboBox->currentIndex());
        if (ui->typeComboBox->currentIndex() == COL_CUSTOM) {
            gint width = recent_get_column_width(cur_column_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    if (! index.isValid() || index.column() >= store_.count())
        return QVariant();
    ListElement ne = store_.at(index.row());
    if (role == Qt::DisplayRole)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    if (! index.isValid() || index.column() >= store_.count())
        return QVariant();
    ListElement ne = store_.at(index.row());
    if (role == Qt::DisplayRole)
    {
}
void Singleton::f2();{
            store_[index.row()].type = val;
    }
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
}
void Singleton::f3();{
        fmt_data *cfmt = (fmt_data *) cur->data;
        ListElement ne;
        ne.nr = nr;
        ne.displayed = cfmt->visible;
        ne.title = cfmt->title;
}
void Singleton::f4();{
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
    }
    else if (index.column() == ColumnListModel::COL_FIELDS)
}
void Singleton::f5();{
    editor->setGeometry(option.rect);
ColumnListModel::ColumnListModel(QObject * parent):
    QAbstractTableModel(parent)
    populate();
QVariant ColumnListModel::headerData(int section, Qt::Orientation orientation, int role) const
}
void Singleton::f6();{
    editor->setGeometry(option.rect);
ColumnListModel::ColumnListModel(QObject * parent):
    QAbstractTableModel(parent)
    populate();
QVariant ColumnListModel::headerData(int section, Qt::Orientation orientation, int role) const
}
void Singleton::f7();{
    int occurrence;
    bool displayed;
    bool changed;
static QList<ListElement> store_;
ColumnProxyModel::ColumnProxyModel(QObject * parent) :
}
void Singleton::f8();{
    elem.displayed = true;
    elem.type = elem.originalType = COL_NUMBER;
    elem.occurrence = 0;
    elem.customFields = QString();
    store_ << elem;
}
void Singleton::f9();{
            case COL_DISPLAYED:
                return QVariant();
            case ColumnListModel::COL_TITLE:
                return ne.title;
            case ColumnListModel::COL_TYPE:
}
void Singleton::f10();{
        if (index.data().toString().length() == 0)
        {
            QModelIndex typeIndex = index.sibling(index.row(), ColumnListModel::COL_TYPE);
            model->setData(typeIndex, index.data(ColumnListModel::OriginalType).toInt(), Qt::EditRole);
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    if (! index.isValid() || index.column() >= store_.count())
        return QVariant();
    ListElement ne = store_.at(index.row());
    if (role == Qt::DisplayRole)
    {
}
void Singleton::f2();{
            store_[index.row()].type = val;
    }
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    if (! index.isValid() || index.column() >= store_.count())
        return QVariant();
    ListElement ne = store_.at(index.row());
    if (role == Qt::DisplayRole)
    {
}
void Singleton::f2();{
            store_[index.row()].type = val;
    }
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
}
void Singleton::f3();{
        fmt_data *cfmt = (fmt_data *) cur->data;
        ListElement ne;
        ne.nr = nr;
        ne.displayed = cfmt->visible;
        ne.title = cfmt->title;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    if (! index.isValid() || index.column() >= store_.count())
        return QVariant();
    ListElement ne = store_.at(index.row());
    if (role == Qt::DisplayRole)
    {
}
void Singleton::f2();{
            store_[index.row()].type = val;
    }
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
}
void Singleton::f3();{
        fmt_data *cfmt = (fmt_data *) cur->data;
        ListElement ne;
        ne.nr = nr;
        ne.displayed = cfmt->visible;
        ne.title = cfmt->title;
}
void Singleton::f4();{
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
    }
    else if (index.column() == ColumnListModel::COL_FIELDS)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    if (! index.isValid() || index.column() >= store_.count())
        return QVariant();
    ListElement ne = store_.at(index.row());
    if (role == Qt::DisplayRole)
    {
}
void Singleton::f2();{
            store_[index.row()].type = val;
    }
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
}
void Singleton::f3();{
        fmt_data *cfmt = (fmt_data *) cur->data;
        ListElement ne;
        ne.nr = nr;
        ne.displayed = cfmt->visible;
        ne.title = cfmt->title;
}
void Singleton::f4();{
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
    }
    else if (index.column() == ColumnListModel::COL_FIELDS)
}
void Singleton::f5();{
    editor->setGeometry(option.rect);
ColumnListModel::ColumnListModel(QObject * parent):
    QAbstractTableModel(parent)
    populate();
QVariant ColumnListModel::headerData(int section, Qt::Orientation orientation, int role) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    if (! index.isValid() || index.column() >= store_.count())
        return QVariant();
    ListElement ne = store_.at(index.row());
    if (role == Qt::DisplayRole)
    {
}
void Singleton::f2();{
            store_[index.row()].type = val;
    }
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
}
void Singleton::f3();{
        fmt_data *cfmt = (fmt_data *) cur->data;
        ListElement ne;
        ne.nr = nr;
        ne.displayed = cfmt->visible;
        ne.title = cfmt->title;
}
void Singleton::f4();{
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
    }
    else if (index.column() == ColumnListModel::COL_FIELDS)
}
void Singleton::f5();{
    editor->setGeometry(option.rect);
ColumnListModel::ColumnListModel(QObject * parent):
    QAbstractTableModel(parent)
    populate();
QVariant ColumnListModel::headerData(int section, Qt::Orientation orientation, int role) const
}
void Singleton::f6();{
    editor->setGeometry(option.rect);
ColumnListModel::ColumnListModel(QObject * parent):
    QAbstractTableModel(parent)
    populate();
QVariant ColumnListModel::headerData(int section, Qt::Orientation orientation, int role) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    if (! index.isValid() || index.column() >= store_.count())
        return QVariant();
    ListElement ne = store_.at(index.row());
    if (role == Qt::DisplayRole)
    {
}
void Singleton::f2();{
            store_[index.row()].type = val;
    }
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
}
void Singleton::f3();{
        fmt_data *cfmt = (fmt_data *) cur->data;
        ListElement ne;
        ne.nr = nr;
        ne.displayed = cfmt->visible;
        ne.title = cfmt->title;
}
void Singleton::f4();{
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
    }
    else if (index.column() == ColumnListModel::COL_FIELDS)
}
void Singleton::f5();{
    editor->setGeometry(option.rect);
ColumnListModel::ColumnListModel(QObject * parent):
    QAbstractTableModel(parent)
    populate();
QVariant ColumnListModel::headerData(int section, Qt::Orientation orientation, int role) const
}
void Singleton::f6();{
    editor->setGeometry(option.rect);
ColumnListModel::ColumnListModel(QObject * parent):
    QAbstractTableModel(parent)
    populate();
QVariant ColumnListModel::headerData(int section, Qt::Orientation orientation, int role) const
}
void Singleton::f7();{
    int occurrence;
    bool displayed;
    bool changed;
static QList<ListElement> store_;
ColumnProxyModel::ColumnProxyModel(QObject * parent) :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    if (! index.isValid() || index.column() >= store_.count())
        return QVariant();
    ListElement ne = store_.at(index.row());
    if (role == Qt::DisplayRole)
    {
}
void Singleton::f2();{
            store_[index.row()].type = val;
    }
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
}
void Singleton::f3();{
        fmt_data *cfmt = (fmt_data *) cur->data;
        ListElement ne;
        ne.nr = nr;
        ne.displayed = cfmt->visible;
        ne.title = cfmt->title;
}
void Singleton::f4();{
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
    }
    else if (index.column() == ColumnListModel::COL_FIELDS)
}
void Singleton::f5();{
    editor->setGeometry(option.rect);
ColumnListModel::ColumnListModel(QObject * parent):
    QAbstractTableModel(parent)
    populate();
QVariant ColumnListModel::headerData(int section, Qt::Orientation orientation, int role) const
}
void Singleton::f6();{
    editor->setGeometry(option.rect);
ColumnListModel::ColumnListModel(QObject * parent):
    QAbstractTableModel(parent)
    populate();
QVariant ColumnListModel::headerData(int section, Qt::Orientation orientation, int role) const
}
void Singleton::f7();{
    int occurrence;
    bool displayed;
    bool changed;
static QList<ListElement> store_;
ColumnProxyModel::ColumnProxyModel(QObject * parent) :
}
void Singleton::f8();{
    elem.displayed = true;
    elem.type = elem.originalType = COL_NUMBER;
    elem.occurrence = 0;
    elem.customFields = QString();
    store_ << elem;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    if (! index.isValid() || index.column() >= store_.count())
        return QVariant();
    ListElement ne = store_.at(index.row());
    if (role == Qt::DisplayRole)
    {
}
void Singleton::f2();{
            store_[index.row()].type = val;
    }
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
}
void Singleton::f3();{
        fmt_data *cfmt = (fmt_data *) cur->data;
        ListElement ne;
        ne.nr = nr;
        ne.displayed = cfmt->visible;
        ne.title = cfmt->title;
}
void Singleton::f4();{
    else if (index.column() == ColumnListModel::COL_TITLE)
    {
        store_[index.row()].title = value.toString();
    }
    else if (index.column() == ColumnListModel::COL_FIELDS)
}
void Singleton::f5();{
    editor->setGeometry(option.rect);
ColumnListModel::ColumnListModel(QObject * parent):
    QAbstractTableModel(parent)
    populate();
QVariant ColumnListModel::headerData(int section, Qt::Orientation orientation, int role) const
}
void Singleton::f6();{
    editor->setGeometry(option.rect);
ColumnListModel::ColumnListModel(QObject * parent):
    QAbstractTableModel(parent)
    populate();
QVariant ColumnListModel::headerData(int section, Qt::Orientation orientation, int role) const
}
void Singleton::f7();{
    int occurrence;
    bool displayed;
    bool changed;
static QList<ListElement> store_;
ColumnProxyModel::ColumnProxyModel(QObject * parent) :
}
void Singleton::f8();{
    elem.displayed = true;
    elem.type = elem.originalType = COL_NUMBER;
    elem.occurrence = 0;
    elem.customFields = QString();
    store_ << elem;
}
void Singleton::f9();{
            case COL_DISPLAYED:
                return QVariant();
            case ColumnListModel::COL_TITLE:
                return ne.title;
            case ColumnListModel::COL_TYPE:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
    contextMenu->exec(mapToGlobal(pos));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
    contextMenu->exec(mapToGlobal(pos));
}
void Singleton::f2();{
    if (ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0)
    {
        QModelIndex selIndex = ui->columnTreeView->selectionModel()->selectedIndexes().at(0);
        model_->deleteEntry(proxyModel_->mapToSource(selIndex).row());
    }
}
void Singleton::f3();{
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
}
void Singleton::f4();{
    ui->deleteToolButton->setEnabled(ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0);
void ColumnPreferencesFrame::on_chkShowDisplayedOnly_stateChanged(int /*state*/)
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
}
void Singleton::f5();{
    contextMenu->exec(mapToGlobal(pos));
void ColumnPreferencesFrame::resetAction(bool /*checked*/)
    model_->reset();
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    QFrame(parent),
    ui(new Ui::ColumnPreferencesFrame)
    ui->setupUi(this);
    model_ = new ColumnListModel();
    proxyModel_ = new ColumnProxyModel();
}
void Singleton::f7();{
    int one_em = ui->columnTreeView->fontMetrics().height();
    ui->columnTreeView->setColumnWidth(ColumnListModel::COL_FIELDS, one_em * 10);
    ui->columnTreeView->setColumnWidth(ColumnListModel::COL_OCCURRENCE, one_em * 5);
    ui->columnTreeView->setMinimumWidth(one_em * 20);
    ui->columnTreeView->setMinimumHeight(one_em * 12);
}
void Singleton::f8();{
    ui(new Ui::ColumnPreferencesFrame)
    ui->setupUi(this);
    model_ = new ColumnListModel();
    proxyModel_ = new ColumnProxyModel();
    proxyModel_->setSourceModel(model_);
}
void Singleton::f9();{
    const QItemSelection &/*deselected*/)
    ui->deleteToolButton->setEnabled(ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0);
void ColumnPreferencesFrame::on_chkShowDisplayedOnly_stateChanged(int /*state*/)
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
}
void Singleton::f10();{
    model_->addEntry();
void ColumnPreferencesFrame::on_deleteToolButton_clicked()
    if (ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0)
    {
        QModelIndex selIndex = ui->columnTreeView->selectionModel()->selectedIndexes().at(0);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
    contextMenu->exec(mapToGlobal(pos));
}
void Singleton::f2();{
    if (ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0)
    {
        QModelIndex selIndex = ui->columnTreeView->selectionModel()->selectedIndexes().at(0);
        model_->deleteEntry(proxyModel_->mapToSource(selIndex).row());
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
    contextMenu->exec(mapToGlobal(pos));
}
void Singleton::f2();{
    if (ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0)
    {
        QModelIndex selIndex = ui->columnTreeView->selectionModel()->selectedIndexes().at(0);
        model_->deleteEntry(proxyModel_->mapToSource(selIndex).row());
    }
}
void Singleton::f3();{
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
    contextMenu->exec(mapToGlobal(pos));
}
void Singleton::f2();{
    if (ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0)
    {
        QModelIndex selIndex = ui->columnTreeView->selectionModel()->selectedIndexes().at(0);
        model_->deleteEntry(proxyModel_->mapToSource(selIndex).row());
    }
}
void Singleton::f3();{
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
}
void Singleton::f4();{
    ui->deleteToolButton->setEnabled(ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0);
void ColumnPreferencesFrame::on_chkShowDisplayedOnly_stateChanged(int /*state*/)
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
    contextMenu->exec(mapToGlobal(pos));
}
void Singleton::f2();{
    if (ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0)
    {
        QModelIndex selIndex = ui->columnTreeView->selectionModel()->selectedIndexes().at(0);
        model_->deleteEntry(proxyModel_->mapToSource(selIndex).row());
    }
}
void Singleton::f3();{
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
}
void Singleton::f4();{
    ui->deleteToolButton->setEnabled(ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0);
void ColumnPreferencesFrame::on_chkShowDisplayedOnly_stateChanged(int /*state*/)
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
}
void Singleton::f5();{
    contextMenu->exec(mapToGlobal(pos));
void ColumnPreferencesFrame::resetAction(bool /*checked*/)
    model_->reset();
 * Editor modelines
 * Local Variables:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
    contextMenu->exec(mapToGlobal(pos));
}
void Singleton::f2();{
    if (ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0)
    {
        QModelIndex selIndex = ui->columnTreeView->selectionModel()->selectedIndexes().at(0);
        model_->deleteEntry(proxyModel_->mapToSource(selIndex).row());
    }
}
void Singleton::f3();{
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
}
void Singleton::f4();{
    ui->deleteToolButton->setEnabled(ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0);
void ColumnPreferencesFrame::on_chkShowDisplayedOnly_stateChanged(int /*state*/)
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
}
void Singleton::f5();{
    contextMenu->exec(mapToGlobal(pos));
void ColumnPreferencesFrame::resetAction(bool /*checked*/)
    model_->reset();
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    QFrame(parent),
    ui(new Ui::ColumnPreferencesFrame)
    ui->setupUi(this);
    model_ = new ColumnListModel();
    proxyModel_ = new ColumnProxyModel();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
    contextMenu->exec(mapToGlobal(pos));
}
void Singleton::f2();{
    if (ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0)
    {
        QModelIndex selIndex = ui->columnTreeView->selectionModel()->selectedIndexes().at(0);
        model_->deleteEntry(proxyModel_->mapToSource(selIndex).row());
    }
}
void Singleton::f3();{
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
}
void Singleton::f4();{
    ui->deleteToolButton->setEnabled(ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0);
void ColumnPreferencesFrame::on_chkShowDisplayedOnly_stateChanged(int /*state*/)
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
}
void Singleton::f5();{
    contextMenu->exec(mapToGlobal(pos));
void ColumnPreferencesFrame::resetAction(bool /*checked*/)
    model_->reset();
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    QFrame(parent),
    ui(new Ui::ColumnPreferencesFrame)
    ui->setupUi(this);
    model_ = new ColumnListModel();
    proxyModel_ = new ColumnProxyModel();
}
void Singleton::f7();{
    int one_em = ui->columnTreeView->fontMetrics().height();
    ui->columnTreeView->setColumnWidth(ColumnListModel::COL_FIELDS, one_em * 10);
    ui->columnTreeView->setColumnWidth(ColumnListModel::COL_OCCURRENCE, one_em * 5);
    ui->columnTreeView->setMinimumWidth(one_em * 20);
    ui->columnTreeView->setMinimumHeight(one_em * 12);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
    contextMenu->exec(mapToGlobal(pos));
}
void Singleton::f2();{
    if (ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0)
    {
        QModelIndex selIndex = ui->columnTreeView->selectionModel()->selectedIndexes().at(0);
        model_->deleteEntry(proxyModel_->mapToSource(selIndex).row());
    }
}
void Singleton::f3();{
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
}
void Singleton::f4();{
    ui->deleteToolButton->setEnabled(ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0);
void ColumnPreferencesFrame::on_chkShowDisplayedOnly_stateChanged(int /*state*/)
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
}
void Singleton::f5();{
    contextMenu->exec(mapToGlobal(pos));
void ColumnPreferencesFrame::resetAction(bool /*checked*/)
    model_->reset();
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    QFrame(parent),
    ui(new Ui::ColumnPreferencesFrame)
    ui->setupUi(this);
    model_ = new ColumnListModel();
    proxyModel_ = new ColumnProxyModel();
}
void Singleton::f7();{
    int one_em = ui->columnTreeView->fontMetrics().height();
    ui->columnTreeView->setColumnWidth(ColumnListModel::COL_FIELDS, one_em * 10);
    ui->columnTreeView->setColumnWidth(ColumnListModel::COL_OCCURRENCE, one_em * 5);
    ui->columnTreeView->setMinimumWidth(one_em * 20);
    ui->columnTreeView->setMinimumHeight(one_em * 12);
}
void Singleton::f8();{
    ui(new Ui::ColumnPreferencesFrame)
    ui->setupUi(this);
    model_ = new ColumnListModel();
    proxyModel_ = new ColumnProxyModel();
    proxyModel_->setSourceModel(model_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
    contextMenu->exec(mapToGlobal(pos));
}
void Singleton::f2();{
    if (ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0)
    {
        QModelIndex selIndex = ui->columnTreeView->selectionModel()->selectedIndexes().at(0);
        model_->deleteEntry(proxyModel_->mapToSource(selIndex).row());
    }
}
void Singleton::f3();{
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
    QAction * action = contextMenu->addAction(tr("Reset all changes"));
    connect(action, &QAction::triggered, this, &ColumnPreferencesFrame::resetAction);
}
void Singleton::f4();{
    ui->deleteToolButton->setEnabled(ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0);
void ColumnPreferencesFrame::on_chkShowDisplayedOnly_stateChanged(int /*state*/)
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
    QMenu * contextMenu = new QMenu(this);
}
void Singleton::f5();{
    contextMenu->exec(mapToGlobal(pos));
void ColumnPreferencesFrame::resetAction(bool /*checked*/)
    model_->reset();
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    QFrame(parent),
    ui(new Ui::ColumnPreferencesFrame)
    ui->setupUi(this);
    model_ = new ColumnListModel();
    proxyModel_ = new ColumnProxyModel();
}
void Singleton::f7();{
    int one_em = ui->columnTreeView->fontMetrics().height();
    ui->columnTreeView->setColumnWidth(ColumnListModel::COL_FIELDS, one_em * 10);
    ui->columnTreeView->setColumnWidth(ColumnListModel::COL_OCCURRENCE, one_em * 5);
    ui->columnTreeView->setMinimumWidth(one_em * 20);
    ui->columnTreeView->setMinimumHeight(one_em * 12);
}
void Singleton::f8();{
    ui(new Ui::ColumnPreferencesFrame)
    ui->setupUi(this);
    model_ = new ColumnListModel();
    proxyModel_ = new ColumnProxyModel();
    proxyModel_->setSourceModel(model_);
}
void Singleton::f9();{
    const QItemSelection &/*deselected*/)
    ui->deleteToolButton->setEnabled(ui->columnTreeView->selectionModel()->selectedIndexes().count() > 0);
void ColumnPreferencesFrame::on_chkShowDisplayedOnly_stateChanged(int /*state*/)
    proxyModel_->setShowDisplayedOnly(ui->chkShowDisplayedOnly->checkState() == Qt::Checked ? true : false);
void ColumnPreferencesFrame::on_columnTreeView_customContextMenuRequested(const QPoint &pos)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
  switch (type) {
  case T_STOP:
    return T_STOP;
  case CT_BOOLEAN_FALSE:
  case CT_BOOLEAN_TRUE:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
  switch (type) {
  case T_STOP:
    return T_STOP;
  case CT_BOOLEAN_FALSE:
  case CT_BOOLEAN_TRUE:
}
void Singleton::f2();{
  case CT_LIST:
    return T_LIST;
  case CT_SET:
    return T_SET;
  case CT_MAP:
}
void Singleton::f3();{
  uint8_t b;
  if (!readByte(b)) {
    return false;
  uint8_t ctype = b & 0xf;
  type = getTType(ctype);
}
void Singleton::f4();{
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
}
void Singleton::f5();{
    CT_BOOLEAN_TRUE, // T_BOOL
    CT_BYTE,         // T_BYTE
    CT_DOUBLE,       // T_DOUBLE
    0,               // unused
    CT_I16,          // T_I16
}
void Singleton::f6();{
  readTags_.top() = tag;
  return true;
TType CompactProtocol::getTType(uint8_t type) {
  switch (type) {
  case T_STOP:
}
void Singleton::f7();{
    tag = 0;
    return true;
  uint8_t diff = (b & 0xf0) >> 4;
  if (diff) {
    tag = readTags_.top() + diff;
}
void Singleton::f8();{
  uint8_t b;
  if (!readByte(b)) {
    return false;
  uint8_t ctype = b & 0xf;
  type = getTType(ctype);
}
void Singleton::f9();{
    0,               // unused
    CT_BOOLEAN_TRUE, // T_BOOL
    CT_BYTE,         // T_BYTE
    CT_DOUBLE,       // T_DOUBLE
    0,               // unused
}
void Singleton::f10();{
    0,               // unused
    CT_I64,          // T_I64
    CT_BINARY,       // T_STRING
    CT_STRUCT,       // T_STRUCT
    CT_MAP,          // T_MAP
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
  switch (type) {
  case T_STOP:
    return T_STOP;
  case CT_BOOLEAN_FALSE:
  case CT_BOOLEAN_TRUE:
}
void Singleton::f2();{
  case CT_LIST:
    return T_LIST;
  case CT_SET:
    return T_SET;
  case CT_MAP:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
  switch (type) {
  case T_STOP:
    return T_STOP;
  case CT_BOOLEAN_FALSE:
  case CT_BOOLEAN_TRUE:
}
void Singleton::f2();{
  case CT_LIST:
    return T_LIST;
  case CT_SET:
    return T_SET;
  case CT_MAP:
}
void Singleton::f3();{
  uint8_t b;
  if (!readByte(b)) {
    return false;
  uint8_t ctype = b & 0xf;
  type = getTType(ctype);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
  switch (type) {
  case T_STOP:
    return T_STOP;
  case CT_BOOLEAN_FALSE:
  case CT_BOOLEAN_TRUE:
}
void Singleton::f2();{
  case CT_LIST:
    return T_LIST;
  case CT_SET:
    return T_SET;
  case CT_MAP:
}
void Singleton::f3();{
  uint8_t b;
  if (!readByte(b)) {
    return false;
  uint8_t ctype = b & 0xf;
  type = getTType(ctype);
}
void Singleton::f4();{
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
  switch (type) {
  case T_STOP:
    return T_STOP;
  case CT_BOOLEAN_FALSE:
  case CT_BOOLEAN_TRUE:
}
void Singleton::f2();{
  case CT_LIST:
    return T_LIST;
  case CT_SET:
    return T_SET;
  case CT_MAP:
}
void Singleton::f3();{
  uint8_t b;
  if (!readByte(b)) {
    return false;
  uint8_t ctype = b & 0xf;
  type = getTType(ctype);
}
void Singleton::f4();{
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
}
void Singleton::f5();{
    CT_BOOLEAN_TRUE, // T_BOOL
    CT_BYTE,         // T_BYTE
    CT_DOUBLE,       // T_DOUBLE
    0,               // unused
    CT_I16,          // T_I16
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
  switch (type) {
  case T_STOP:
    return T_STOP;
  case CT_BOOLEAN_FALSE:
  case CT_BOOLEAN_TRUE:
}
void Singleton::f2();{
  case CT_LIST:
    return T_LIST;
  case CT_SET:
    return T_SET;
  case CT_MAP:
}
void Singleton::f3();{
  uint8_t b;
  if (!readByte(b)) {
    return false;
  uint8_t ctype = b & 0xf;
  type = getTType(ctype);
}
void Singleton::f4();{
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
}
void Singleton::f5();{
    CT_BOOLEAN_TRUE, // T_BOOL
    CT_BYTE,         // T_BYTE
    CT_DOUBLE,       // T_DOUBLE
    0,               // unused
    CT_I16,          // T_I16
}
void Singleton::f6();{
  readTags_.top() = tag;
  return true;
TType CompactProtocol::getTType(uint8_t type) {
  switch (type) {
  case T_STOP:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
  switch (type) {
  case T_STOP:
    return T_STOP;
  case CT_BOOLEAN_FALSE:
  case CT_BOOLEAN_TRUE:
}
void Singleton::f2();{
  case CT_LIST:
    return T_LIST;
  case CT_SET:
    return T_SET;
  case CT_MAP:
}
void Singleton::f3();{
  uint8_t b;
  if (!readByte(b)) {
    return false;
  uint8_t ctype = b & 0xf;
  type = getTType(ctype);
}
void Singleton::f4();{
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
}
void Singleton::f5();{
    CT_BOOLEAN_TRUE, // T_BOOL
    CT_BYTE,         // T_BYTE
    CT_DOUBLE,       // T_DOUBLE
    0,               // unused
    CT_I16,          // T_I16
}
void Singleton::f6();{
  readTags_.top() = tag;
  return true;
TType CompactProtocol::getTType(uint8_t type) {
  switch (type) {
  case T_STOP:
}
void Singleton::f7();{
    tag = 0;
    return true;
  uint8_t diff = (b & 0xf0) >> 4;
  if (diff) {
    tag = readTags_.top() + diff;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
  switch (type) {
  case T_STOP:
    return T_STOP;
  case CT_BOOLEAN_FALSE:
  case CT_BOOLEAN_TRUE:
}
void Singleton::f2();{
  case CT_LIST:
    return T_LIST;
  case CT_SET:
    return T_SET;
  case CT_MAP:
}
void Singleton::f3();{
  uint8_t b;
  if (!readByte(b)) {
    return false;
  uint8_t ctype = b & 0xf;
  type = getTType(ctype);
}
void Singleton::f4();{
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
}
void Singleton::f5();{
    CT_BOOLEAN_TRUE, // T_BOOL
    CT_BYTE,         // T_BYTE
    CT_DOUBLE,       // T_DOUBLE
    0,               // unused
    CT_I16,          // T_I16
}
void Singleton::f6();{
  readTags_.top() = tag;
  return true;
TType CompactProtocol::getTType(uint8_t type) {
  switch (type) {
  case T_STOP:
}
void Singleton::f7();{
    tag = 0;
    return true;
  uint8_t diff = (b & 0xf0) >> 4;
  if (diff) {
    tag = readTags_.top() + diff;
}
void Singleton::f8();{
  uint8_t b;
  if (!readByte(b)) {
    return false;
  uint8_t ctype = b & 0xf;
  type = getTType(ctype);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
  switch (type) {
  case T_STOP:
    return T_STOP;
  case CT_BOOLEAN_FALSE:
  case CT_BOOLEAN_TRUE:
}
void Singleton::f2();{
  case CT_LIST:
    return T_LIST;
  case CT_SET:
    return T_SET;
  case CT_MAP:
}
void Singleton::f3();{
  uint8_t b;
  if (!readByte(b)) {
    return false;
  uint8_t ctype = b & 0xf;
  type = getTType(ctype);
}
void Singleton::f4();{
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
}
void Singleton::f5();{
    CT_BOOLEAN_TRUE, // T_BOOL
    CT_BYTE,         // T_BYTE
    CT_DOUBLE,       // T_DOUBLE
    0,               // unused
    CT_I16,          // T_I16
}
void Singleton::f6();{
  readTags_.top() = tag;
  return true;
TType CompactProtocol::getTType(uint8_t type) {
  switch (type) {
  case T_STOP:
}
void Singleton::f7();{
    tag = 0;
    return true;
  uint8_t diff = (b & 0xf0) >> 4;
  if (diff) {
    tag = readTags_.top() + diff;
}
void Singleton::f8();{
  uint8_t b;
  if (!readByte(b)) {
    return false;
  uint8_t ctype = b & 0xf;
  type = getTType(ctype);
}
void Singleton::f9();{
    0,               // unused
    CT_BOOLEAN_TRUE, // T_BOOL
    CT_BYTE,         // T_BYTE
    CT_DOUBLE,       // T_DOUBLE
    0,               // unused
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    ui->filterList->setCurrentFont(wsApp->monospaceFont());
    copy_bt_ = ui->buttonBox->addButton(tr("Copy"), QDialogButtonBox::ActionRole);
    copy_bt_->setToolTip(tr("Copy filter text to the clipboard."));
    connect(copy_bt_, SIGNAL(clicked()), this, SLOT(copyFilterText()));
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    ui->filterList->setCurrentFont(wsApp->monospaceFont());
    copy_bt_ = ui->buttonBox->addButton(tr("Copy"), QDialogButtonBox::ActionRole);
    copy_bt_->setToolTip(tr("Copy filter text to the clipboard."));
    connect(copy_bt_, SIGNAL(clicked()), this, SLOT(copyFilterText()));
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
}
void Singleton::f2();{
    delete ui;
void CompiledFilterOutput::compileFilter()
    struct bpf_program fcode;
    foreach (QString interfaces, intList_) {
        for (guint i = 0; i < global_capture_opts.all_ifaces->len; i++) {
}
void Singleton::f3();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f4();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f5();{
    ui->filterList->clear();
    ui->filterList->setPlainText(iter.value());
void CompiledFilterOutput::copyFilterText()
    wsApp->clipboard()->setText(ui->filterList->toPlainText());
// Editor modelines  -  https://www.wireshark.org/tools/modelines.html
}
void Singleton::f6();{
                    compile_results.insert(interfaces, QString(bpf_code_dump->str));
                    g_string_free(bpf_code_dump, TRUE);
                    ui->interfaceList->addItem(new QListWidgetItem(interfaces));
                }
                break;
}
void Singleton::f7();{
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
    close_bt->setDefault(true);
    interface_list_ = ui->interfaceList;
    pcap_compile_mtx = g_new(GMutex,1);
    g_mutex_init(pcap_compile_mtx);
}
void Singleton::f8();{
                        g_string_append(bpf_code_dump, "\n");
                    }
                    g_mutex_unlock(pcap_compile_mtx);
                    compile_results.insert(interfaces, QString(bpf_code_dump->str));
                    g_string_free(bpf_code_dump, TRUE);
}
void Singleton::f9();{
CompiledFilterOutput::~CompiledFilterOutput()
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
}
void Singleton::f10();{
        for (guint i = 0; i < global_capture_opts.all_ifaces->len; i++) {
            interface_t *device = &g_array_index(global_capture_opts.all_ifaces, interface_t, i);
            if (interfaces.compare(device->display_name)) {
                continue;
            } else {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    ui->filterList->setCurrentFont(wsApp->monospaceFont());
    copy_bt_ = ui->buttonBox->addButton(tr("Copy"), QDialogButtonBox::ActionRole);
    copy_bt_->setToolTip(tr("Copy filter text to the clipboard."));
    connect(copy_bt_, SIGNAL(clicked()), this, SLOT(copyFilterText()));
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
}
void Singleton::f2();{
    delete ui;
void CompiledFilterOutput::compileFilter()
    struct bpf_program fcode;
    foreach (QString interfaces, intList_) {
        for (guint i = 0; i < global_capture_opts.all_ifaces->len; i++) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    ui->filterList->setCurrentFont(wsApp->monospaceFont());
    copy_bt_ = ui->buttonBox->addButton(tr("Copy"), QDialogButtonBox::ActionRole);
    copy_bt_->setToolTip(tr("Copy filter text to the clipboard."));
    connect(copy_bt_, SIGNAL(clicked()), this, SLOT(copyFilterText()));
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
}
void Singleton::f2();{
    delete ui;
void CompiledFilterOutput::compileFilter()
    struct bpf_program fcode;
    foreach (QString interfaces, intList_) {
        for (guint i = 0; i < global_capture_opts.all_ifaces->len; i++) {
}
void Singleton::f3();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    ui->filterList->setCurrentFont(wsApp->monospaceFont());
    copy_bt_ = ui->buttonBox->addButton(tr("Copy"), QDialogButtonBox::ActionRole);
    copy_bt_->setToolTip(tr("Copy filter text to the clipboard."));
    connect(copy_bt_, SIGNAL(clicked()), this, SLOT(copyFilterText()));
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
}
void Singleton::f2();{
    delete ui;
void CompiledFilterOutput::compileFilter()
    struct bpf_program fcode;
    foreach (QString interfaces, intList_) {
        for (guint i = 0; i < global_capture_opts.all_ifaces->len; i++) {
}
void Singleton::f3();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f4();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    ui->filterList->setCurrentFont(wsApp->monospaceFont());
    copy_bt_ = ui->buttonBox->addButton(tr("Copy"), QDialogButtonBox::ActionRole);
    copy_bt_->setToolTip(tr("Copy filter text to the clipboard."));
    connect(copy_bt_, SIGNAL(clicked()), this, SLOT(copyFilterText()));
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
}
void Singleton::f2();{
    delete ui;
void CompiledFilterOutput::compileFilter()
    struct bpf_program fcode;
    foreach (QString interfaces, intList_) {
        for (guint i = 0; i < global_capture_opts.all_ifaces->len; i++) {
}
void Singleton::f3();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f4();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f5();{
    ui->filterList->clear();
    ui->filterList->setPlainText(iter.value());
void CompiledFilterOutput::copyFilterText()
    wsApp->clipboard()->setText(ui->filterList->toPlainText());
// Editor modelines  -  https://www.wireshark.org/tools/modelines.html
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    ui->filterList->setCurrentFont(wsApp->monospaceFont());
    copy_bt_ = ui->buttonBox->addButton(tr("Copy"), QDialogButtonBox::ActionRole);
    copy_bt_->setToolTip(tr("Copy filter text to the clipboard."));
    connect(copy_bt_, SIGNAL(clicked()), this, SLOT(copyFilterText()));
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
}
void Singleton::f2();{
    delete ui;
void CompiledFilterOutput::compileFilter()
    struct bpf_program fcode;
    foreach (QString interfaces, intList_) {
        for (guint i = 0; i < global_capture_opts.all_ifaces->len; i++) {
}
void Singleton::f3();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f4();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f5();{
    ui->filterList->clear();
    ui->filterList->setPlainText(iter.value());
void CompiledFilterOutput::copyFilterText()
    wsApp->clipboard()->setText(ui->filterList->toPlainText());
// Editor modelines  -  https://www.wireshark.org/tools/modelines.html
}
void Singleton::f6();{
                    compile_results.insert(interfaces, QString(bpf_code_dump->str));
                    g_string_free(bpf_code_dump, TRUE);
                    ui->interfaceList->addItem(new QListWidgetItem(interfaces));
                }
                break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    ui->filterList->setCurrentFont(wsApp->monospaceFont());
    copy_bt_ = ui->buttonBox->addButton(tr("Copy"), QDialogButtonBox::ActionRole);
    copy_bt_->setToolTip(tr("Copy filter text to the clipboard."));
    connect(copy_bt_, SIGNAL(clicked()), this, SLOT(copyFilterText()));
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
}
void Singleton::f2();{
    delete ui;
void CompiledFilterOutput::compileFilter()
    struct bpf_program fcode;
    foreach (QString interfaces, intList_) {
        for (guint i = 0; i < global_capture_opts.all_ifaces->len; i++) {
}
void Singleton::f3();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f4();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f5();{
    ui->filterList->clear();
    ui->filterList->setPlainText(iter.value());
void CompiledFilterOutput::copyFilterText()
    wsApp->clipboard()->setText(ui->filterList->toPlainText());
// Editor modelines  -  https://www.wireshark.org/tools/modelines.html
}
void Singleton::f6();{
                    compile_results.insert(interfaces, QString(bpf_code_dump->str));
                    g_string_free(bpf_code_dump, TRUE);
                    ui->interfaceList->addItem(new QListWidgetItem(interfaces));
                }
                break;
}
void Singleton::f7();{
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
    close_bt->setDefault(true);
    interface_list_ = ui->interfaceList;
    pcap_compile_mtx = g_new(GMutex,1);
    g_mutex_init(pcap_compile_mtx);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    ui->filterList->setCurrentFont(wsApp->monospaceFont());
    copy_bt_ = ui->buttonBox->addButton(tr("Copy"), QDialogButtonBox::ActionRole);
    copy_bt_->setToolTip(tr("Copy filter text to the clipboard."));
    connect(copy_bt_, SIGNAL(clicked()), this, SLOT(copyFilterText()));
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
}
void Singleton::f2();{
    delete ui;
void CompiledFilterOutput::compileFilter()
    struct bpf_program fcode;
    foreach (QString interfaces, intList_) {
        for (guint i = 0; i < global_capture_opts.all_ifaces->len; i++) {
}
void Singleton::f3();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f4();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f5();{
    ui->filterList->clear();
    ui->filterList->setPlainText(iter.value());
void CompiledFilterOutput::copyFilterText()
    wsApp->clipboard()->setText(ui->filterList->toPlainText());
// Editor modelines  -  https://www.wireshark.org/tools/modelines.html
}
void Singleton::f6();{
                    compile_results.insert(interfaces, QString(bpf_code_dump->str));
                    g_string_free(bpf_code_dump, TRUE);
                    ui->interfaceList->addItem(new QListWidgetItem(interfaces));
                }
                break;
}
void Singleton::f7();{
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
    close_bt->setDefault(true);
    interface_list_ = ui->interfaceList;
    pcap_compile_mtx = g_new(GMutex,1);
    g_mutex_init(pcap_compile_mtx);
}
void Singleton::f8();{
                        g_string_append(bpf_code_dump, "\n");
                    }
                    g_mutex_unlock(pcap_compile_mtx);
                    compile_results.insert(interfaces, QString(bpf_code_dump->str));
                    g_string_free(bpf_code_dump, TRUE);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    ui->filterList->setCurrentFont(wsApp->monospaceFont());
    copy_bt_ = ui->buttonBox->addButton(tr("Copy"), QDialogButtonBox::ActionRole);
    copy_bt_->setToolTip(tr("Copy filter text to the clipboard."));
    connect(copy_bt_, SIGNAL(clicked()), this, SLOT(copyFilterText()));
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
}
void Singleton::f2();{
    delete ui;
void CompiledFilterOutput::compileFilter()
    struct bpf_program fcode;
    foreach (QString interfaces, intList_) {
        for (guint i = 0; i < global_capture_opts.all_ifaces->len; i++) {
}
void Singleton::f3();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f4();{
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
        parentWidget()->raise();
}
void Singleton::f5();{
    ui->filterList->clear();
    ui->filterList->setPlainText(iter.value());
void CompiledFilterOutput::copyFilterText()
    wsApp->clipboard()->setText(ui->filterList->toPlainText());
// Editor modelines  -  https://www.wireshark.org/tools/modelines.html
}
void Singleton::f6();{
                    compile_results.insert(interfaces, QString(bpf_code_dump->str));
                    g_string_free(bpf_code_dump, TRUE);
                    ui->interfaceList->addItem(new QListWidgetItem(interfaces));
                }
                break;
}
void Singleton::f7();{
    QPushButton *close_bt = ui->buttonBox->button(QDialogButtonBox::Close);
    close_bt->setDefault(true);
    interface_list_ = ui->interfaceList;
    pcap_compile_mtx = g_new(GMutex,1);
    g_mutex_init(pcap_compile_mtx);
}
void Singleton::f8();{
                        g_string_append(bpf_code_dump, "\n");
                    }
                    g_mutex_unlock(pcap_compile_mtx);
                    compile_results.insert(interfaces, QString(bpf_code_dump->str));
                    g_string_free(bpf_code_dump, TRUE);
}
void Singleton::f9();{
CompiledFilterOutput::~CompiledFilterOutput()
    // For some reason closing this dialog either lowers the Capture Options dialog
    // or raises the main window. Work around the problem for now by manually raising
    // and activating our parent (presumably the Capture Options dialog).
    if (parentWidget()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            setColumnWidth(i, one_en * (int) strlen("000.000.000.000"));
            break;
        case CONV_COLUMN_SRC_PORT:
        case CONV_COLUMN_DST_PORT:
            setColumnWidth(i, one_en * (int) strlen("000000"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            setColumnWidth(i, one_en * (int) strlen("000.000.000.000"));
            break;
        case CONV_COLUMN_SRC_PORT:
        case CONV_COLUMN_DST_PORT:
            setColumnWidth(i, one_en * (int) strlen("000000"));
}
void Singleton::f2();{
            case CONV_COLUMN_PACKETS:
                return QString("%L1").arg(conv_item->tx_frames + conv_item->rx_frames);
            case CONV_COLUMN_BYTES:
                return gchar_free_to_qstring(format_size(conv_item->tx_bytes + conv_item->rx_bytes, format_size_unit_none|format_size_prefix_si));
            case CONV_COLUMN_PKT_AB:
}
void Singleton::f3();{
                recent.conversation_tabs = g_list_append(recent.conversation_tabs, title);
            }
        }
    }
void ConversationDialog::captureFileClosing()
}
void Singleton::f4();{
    TrafficTableTreeWidget(parent, table),
    min_rel_start_time_(0),
    max_rel_stop_time_(0)
    setColumnCount(CONV_NUM_COLUMNS);
    setUniformRowHeights(true);
}
void Singleton::f5();{
    }
QMap<FilterAction::ActionDirection, conv_direction_e> fad_to_cd_;
void ConversationTreeWidget::initDirectionMap()
    if (fad_to_cd_.size() > 0) {
        return;
}
void Singleton::f6();{
    proto_id_to_tree_[proto_id] = conv_tree;
    const char* table_name = proto_get_protocol_short_name(find_protocol_by_id(proto_id));
    trafficTableTabWidget()->addTab(conv_tree, table_name);
    conv_tree->setItemDelegateForColumn(CONV_COLUMN_START, new TimelineDelegate(conv_tree));
    conv_tree->setItemDelegateForColumn(CONV_COLUMN_DURATION, new TimelineDelegate(conv_tree));
}
void Singleton::f7();{
        conv_protos.removeAll(cli_proto_id);
        conv_protos.prepend(cli_proto_id);
    }
    // QTabWidget selects the first item by default.
    foreach (int conv_proto, conv_protos) {
}
void Singleton::f8();{
    ConversationTreeWidget *conv_tree = qobject_cast<ConversationTreeWidget *>((ConversationTreeWidget *)hash->user_data);
    if (!conv_tree) return;
    conv_tree->updateItems();
void ConversationTreeWidget::updateStartTime(bool absolute)
    headerItem()->setText(CONV_COLUMN_START, absolute
}
void Singleton::f9();{
// Bugs:
// - Slow for large numbers of items.
// - Name resolution doesn't do anything if its preference is disabled.
// - Columns don't resize correctly.
// - Closing the capture file clears conversation data.
}
void Singleton::f10();{
    int proto_id = get_conversation_proto_id(table);
    if (!table || proto_id_to_tree_.contains(proto_id)) {
        return false;
    }
    ConversationTreeWidget *conv_tree = new ConversationTreeWidget(this, table);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            setColumnWidth(i, one_en * (int) strlen("000.000.000.000"));
            break;
        case CONV_COLUMN_SRC_PORT:
        case CONV_COLUMN_DST_PORT:
            setColumnWidth(i, one_en * (int) strlen("000000"));
}
void Singleton::f2();{
            case CONV_COLUMN_PACKETS:
                return QString("%L1").arg(conv_item->tx_frames + conv_item->rx_frames);
            case CONV_COLUMN_BYTES:
                return gchar_free_to_qstring(format_size(conv_item->tx_bytes + conv_item->rx_bytes, format_size_unit_none|format_size_prefix_si));
            case CONV_COLUMN_PKT_AB:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            setColumnWidth(i, one_en * (int) strlen("000.000.000.000"));
            break;
        case CONV_COLUMN_SRC_PORT:
        case CONV_COLUMN_DST_PORT:
            setColumnWidth(i, one_en * (int) strlen("000000"));
}
void Singleton::f2();{
            case CONV_COLUMN_PACKETS:
                return QString("%L1").arg(conv_item->tx_frames + conv_item->rx_frames);
            case CONV_COLUMN_BYTES:
                return gchar_free_to_qstring(format_size(conv_item->tx_bytes + conv_item->rx_bytes, format_size_unit_none|format_size_prefix_si));
            case CONV_COLUMN_PKT_AB:
}
void Singleton::f3();{
                recent.conversation_tabs = g_list_append(recent.conversation_tabs, title);
            }
        }
    }
void ConversationDialog::captureFileClosing()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            setColumnWidth(i, one_en * (int) strlen("000.000.000.000"));
            break;
        case CONV_COLUMN_SRC_PORT:
        case CONV_COLUMN_DST_PORT:
            setColumnWidth(i, one_en * (int) strlen("000000"));
}
void Singleton::f2();{
            case CONV_COLUMN_PACKETS:
                return QString("%L1").arg(conv_item->tx_frames + conv_item->rx_frames);
            case CONV_COLUMN_BYTES:
                return gchar_free_to_qstring(format_size(conv_item->tx_bytes + conv_item->rx_bytes, format_size_unit_none|format_size_prefix_si));
            case CONV_COLUMN_PKT_AB:
}
void Singleton::f3();{
                recent.conversation_tabs = g_list_append(recent.conversation_tabs, title);
            }
        }
    }
void ConversationDialog::captureFileClosing()
}
void Singleton::f4();{
    TrafficTableTreeWidget(parent, table),
    min_rel_start_time_(0),
    max_rel_stop_time_(0)
    setColumnCount(CONV_NUM_COLUMNS);
    setUniformRowHeights(true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            setColumnWidth(i, one_en * (int) strlen("000.000.000.000"));
            break;
        case CONV_COLUMN_SRC_PORT:
        case CONV_COLUMN_DST_PORT:
            setColumnWidth(i, one_en * (int) strlen("000000"));
}
void Singleton::f2();{
            case CONV_COLUMN_PACKETS:
                return QString("%L1").arg(conv_item->tx_frames + conv_item->rx_frames);
            case CONV_COLUMN_BYTES:
                return gchar_free_to_qstring(format_size(conv_item->tx_bytes + conv_item->rx_bytes, format_size_unit_none|format_size_prefix_si));
            case CONV_COLUMN_PKT_AB:
}
void Singleton::f3();{
                recent.conversation_tabs = g_list_append(recent.conversation_tabs, title);
            }
        }
    }
void ConversationDialog::captureFileClosing()
}
void Singleton::f4();{
    TrafficTableTreeWidget(parent, table),
    min_rel_start_time_(0),
    max_rel_stop_time_(0)
    setColumnCount(CONV_NUM_COLUMNS);
    setUniformRowHeights(true);
}
void Singleton::f5();{
    }
QMap<FilterAction::ActionDirection, conv_direction_e> fad_to_cd_;
void ConversationTreeWidget::initDirectionMap()
    if (fad_to_cd_.size() > 0) {
        return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            setColumnWidth(i, one_en * (int) strlen("000.000.000.000"));
            break;
        case CONV_COLUMN_SRC_PORT:
        case CONV_COLUMN_DST_PORT:
            setColumnWidth(i, one_en * (int) strlen("000000"));
}
void Singleton::f2();{
            case CONV_COLUMN_PACKETS:
                return QString("%L1").arg(conv_item->tx_frames + conv_item->rx_frames);
            case CONV_COLUMN_BYTES:
                return gchar_free_to_qstring(format_size(conv_item->tx_bytes + conv_item->rx_bytes, format_size_unit_none|format_size_prefix_si));
            case CONV_COLUMN_PKT_AB:
}
void Singleton::f3();{
                recent.conversation_tabs = g_list_append(recent.conversation_tabs, title);
            }
        }
    }
void ConversationDialog::captureFileClosing()
}
void Singleton::f4();{
    TrafficTableTreeWidget(parent, table),
    min_rel_start_time_(0),
    max_rel_stop_time_(0)
    setColumnCount(CONV_NUM_COLUMNS);
    setUniformRowHeights(true);
}
void Singleton::f5();{
    }
QMap<FilterAction::ActionDirection, conv_direction_e> fad_to_cd_;
void ConversationTreeWidget::initDirectionMap()
    if (fad_to_cd_.size() > 0) {
        return;
}
void Singleton::f6();{
    proto_id_to_tree_[proto_id] = conv_tree;
    const char* table_name = proto_get_protocol_short_name(find_protocol_by_id(proto_id));
    trafficTableTabWidget()->addTab(conv_tree, table_name);
    conv_tree->setItemDelegateForColumn(CONV_COLUMN_START, new TimelineDelegate(conv_tree));
    conv_tree->setItemDelegateForColumn(CONV_COLUMN_DURATION, new TimelineDelegate(conv_tree));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            setColumnWidth(i, one_en * (int) strlen("000.000.000.000"));
            break;
        case CONV_COLUMN_SRC_PORT:
        case CONV_COLUMN_DST_PORT:
            setColumnWidth(i, one_en * (int) strlen("000000"));
}
void Singleton::f2();{
            case CONV_COLUMN_PACKETS:
                return QString("%L1").arg(conv_item->tx_frames + conv_item->rx_frames);
            case CONV_COLUMN_BYTES:
                return gchar_free_to_qstring(format_size(conv_item->tx_bytes + conv_item->rx_bytes, format_size_unit_none|format_size_prefix_si));
            case CONV_COLUMN_PKT_AB:
}
void Singleton::f3();{
                recent.conversation_tabs = g_list_append(recent.conversation_tabs, title);
            }
        }
    }
void ConversationDialog::captureFileClosing()
}
void Singleton::f4();{
    TrafficTableTreeWidget(parent, table),
    min_rel_start_time_(0),
    max_rel_stop_time_(0)
    setColumnCount(CONV_NUM_COLUMNS);
    setUniformRowHeights(true);
}
void Singleton::f5();{
    }
QMap<FilterAction::ActionDirection, conv_direction_e> fad_to_cd_;
void ConversationTreeWidget::initDirectionMap()
    if (fad_to_cd_.size() > 0) {
        return;
}
void Singleton::f6();{
    proto_id_to_tree_[proto_id] = conv_tree;
    const char* table_name = proto_get_protocol_short_name(find_protocol_by_id(proto_id));
    trafficTableTabWidget()->addTab(conv_tree, table_name);
    conv_tree->setItemDelegateForColumn(CONV_COLUMN_START, new TimelineDelegate(conv_tree));
    conv_tree->setItemDelegateForColumn(CONV_COLUMN_DURATION, new TimelineDelegate(conv_tree));
}
void Singleton::f7();{
        conv_protos.removeAll(cli_proto_id);
        conv_protos.prepend(cli_proto_id);
    }
    // QTabWidget selects the first item by default.
    foreach (int conv_proto, conv_protos) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            setColumnWidth(i, one_en * (int) strlen("000.000.000.000"));
            break;
        case CONV_COLUMN_SRC_PORT:
        case CONV_COLUMN_DST_PORT:
            setColumnWidth(i, one_en * (int) strlen("000000"));
}
void Singleton::f2();{
            case CONV_COLUMN_PACKETS:
                return QString("%L1").arg(conv_item->tx_frames + conv_item->rx_frames);
            case CONV_COLUMN_BYTES:
                return gchar_free_to_qstring(format_size(conv_item->tx_bytes + conv_item->rx_bytes, format_size_unit_none|format_size_prefix_si));
            case CONV_COLUMN_PKT_AB:
}
void Singleton::f3();{
                recent.conversation_tabs = g_list_append(recent.conversation_tabs, title);
            }
        }
    }
void ConversationDialog::captureFileClosing()
}
void Singleton::f4();{
    TrafficTableTreeWidget(parent, table),
    min_rel_start_time_(0),
    max_rel_stop_time_(0)
    setColumnCount(CONV_NUM_COLUMNS);
    setUniformRowHeights(true);
}
void Singleton::f5();{
    }
QMap<FilterAction::ActionDirection, conv_direction_e> fad_to_cd_;
void ConversationTreeWidget::initDirectionMap()
    if (fad_to_cd_.size() > 0) {
        return;
}
void Singleton::f6();{
    proto_id_to_tree_[proto_id] = conv_tree;
    const char* table_name = proto_get_protocol_short_name(find_protocol_by_id(proto_id));
    trafficTableTabWidget()->addTab(conv_tree, table_name);
    conv_tree->setItemDelegateForColumn(CONV_COLUMN_START, new TimelineDelegate(conv_tree));
    conv_tree->setItemDelegateForColumn(CONV_COLUMN_DURATION, new TimelineDelegate(conv_tree));
}
void Singleton::f7();{
        conv_protos.removeAll(cli_proto_id);
        conv_protos.prepend(cli_proto_id);
    }
    // QTabWidget selects the first item by default.
    foreach (int conv_proto, conv_protos) {
}
void Singleton::f8();{
    ConversationTreeWidget *conv_tree = qobject_cast<ConversationTreeWidget *>((ConversationTreeWidget *)hash->user_data);
    if (!conv_tree) return;
    conv_tree->updateItems();
void ConversationTreeWidget::updateStartTime(bool absolute)
    headerItem()->setText(CONV_COLUMN_START, absolute
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            setColumnWidth(i, one_en * (int) strlen("000.000.000.000"));
            break;
        case CONV_COLUMN_SRC_PORT:
        case CONV_COLUMN_DST_PORT:
            setColumnWidth(i, one_en * (int) strlen("000000"));
}
void Singleton::f2();{
            case CONV_COLUMN_PACKETS:
                return QString("%L1").arg(conv_item->tx_frames + conv_item->rx_frames);
            case CONV_COLUMN_BYTES:
                return gchar_free_to_qstring(format_size(conv_item->tx_bytes + conv_item->rx_bytes, format_size_unit_none|format_size_prefix_si));
            case CONV_COLUMN_PKT_AB:
}
void Singleton::f3();{
                recent.conversation_tabs = g_list_append(recent.conversation_tabs, title);
            }
        }
    }
void ConversationDialog::captureFileClosing()
}
void Singleton::f4();{
    TrafficTableTreeWidget(parent, table),
    min_rel_start_time_(0),
    max_rel_stop_time_(0)
    setColumnCount(CONV_NUM_COLUMNS);
    setUniformRowHeights(true);
}
void Singleton::f5();{
    }
QMap<FilterAction::ActionDirection, conv_direction_e> fad_to_cd_;
void ConversationTreeWidget::initDirectionMap()
    if (fad_to_cd_.size() > 0) {
        return;
}
void Singleton::f6();{
    proto_id_to_tree_[proto_id] = conv_tree;
    const char* table_name = proto_get_protocol_short_name(find_protocol_by_id(proto_id));
    trafficTableTabWidget()->addTab(conv_tree, table_name);
    conv_tree->setItemDelegateForColumn(CONV_COLUMN_START, new TimelineDelegate(conv_tree));
    conv_tree->setItemDelegateForColumn(CONV_COLUMN_DURATION, new TimelineDelegate(conv_tree));
}
void Singleton::f7();{
        conv_protos.removeAll(cli_proto_id);
        conv_protos.prepend(cli_proto_id);
    }
    // QTabWidget selects the first item by default.
    foreach (int conv_proto, conv_protos) {
}
void Singleton::f8();{
    ConversationTreeWidget *conv_tree = qobject_cast<ConversationTreeWidget *>((ConversationTreeWidget *)hash->user_data);
    if (!conv_tree) return;
    conv_tree->updateItems();
void ConversationTreeWidget::updateStartTime(bool absolute)
    headerItem()->setText(CONV_COLUMN_START, absolute
}
void Singleton::f9();{
// Bugs:
// - Slow for large numbers of items.
// - Name resolution doesn't do anything if its preference is disabled.
// - Columns don't resize correctly.
// - Closing the capture file clears conversation data.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    if (global.count() > 0)
    {
        if (actions().count() > 0)
            buttonMenu_->addSeparator();
        buttonMenu_->addActions(global);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    if (global.count() > 0)
    {
        if (actions().count() > 0)
            buttonMenu_->addSeparator();
        buttonMenu_->addActions(global);
}
void Singleton::f2();{
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
    setEnabled(false);
    if (filename.length() <= 0)
        return;
}
void Singleton::f3();{
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
        if (! idx.data(ProfileModel::DATA_PATH_IS_NOT_DESCRIPTION).toBool() || idx.data(ProfileModel::DATA_IS_SELECTED).toBool())
            continue;
        QDir profileDir(profilePath);
}
void Singleton::f4();{
    }
    buttonMenu_->addActions(user);
    if (global.count() > 0)
    {
        if (actions().count() > 0)
}
void Singleton::f5();{
    {
        QModelIndex idx = model.index(cnt, ProfileModel::COL_NAME);
        QString profilePath = idx.data(ProfileModel::DATA_PATH).toString();
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
}
void Singleton::f6();{
    if (filename.length() <= 0)
        return;
    ProfileModel model(this);
    QList<QAction *> global;
    QList<QAction *> user;
}
void Singleton::f7();{
        setToolTip(toolTip);
    }
    if (fileName.length() > 0)
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
}
void Singleton::f8();{
    QPushButton(parent),
    buttonMenu_(Q_NULLPTR)
    setText(tr("Copy from"));
    if (toolTip.length() == 0)
        setToolTip(tr("Copy entries from another profile."));
}
void Singleton::f9();{
            continue;
        QDir profileDir(profilePath);
        if (! profileDir.exists())
            continue;
        QFileInfo fi = profileDir.filePath(filename);
}
void Singleton::f10();{
        else if (idx.data(ProfileModel::DATA_IS_GLOBAL).toBool())
            global << pa;
        else
            user << pa;
        pa->setFont(idx.data(Qt::FontRole).value<QFont>());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    if (global.count() > 0)
    {
        if (actions().count() > 0)
            buttonMenu_->addSeparator();
        buttonMenu_->addActions(global);
}
void Singleton::f2();{
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
    setEnabled(false);
    if (filename.length() <= 0)
        return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    if (global.count() > 0)
    {
        if (actions().count() > 0)
            buttonMenu_->addSeparator();
        buttonMenu_->addActions(global);
}
void Singleton::f2();{
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
    setEnabled(false);
    if (filename.length() <= 0)
        return;
}
void Singleton::f3();{
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
        if (! idx.data(ProfileModel::DATA_PATH_IS_NOT_DESCRIPTION).toBool() || idx.data(ProfileModel::DATA_IS_SELECTED).toBool())
            continue;
        QDir profileDir(profilePath);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    if (global.count() > 0)
    {
        if (actions().count() > 0)
            buttonMenu_->addSeparator();
        buttonMenu_->addActions(global);
}
void Singleton::f2();{
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
    setEnabled(false);
    if (filename.length() <= 0)
        return;
}
void Singleton::f3();{
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
        if (! idx.data(ProfileModel::DATA_PATH_IS_NOT_DESCRIPTION).toBool() || idx.data(ProfileModel::DATA_IS_SELECTED).toBool())
            continue;
        QDir profileDir(profilePath);
}
void Singleton::f4();{
    }
    buttonMenu_->addActions(user);
    if (global.count() > 0)
    {
        if (actions().count() > 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    if (global.count() > 0)
    {
        if (actions().count() > 0)
            buttonMenu_->addSeparator();
        buttonMenu_->addActions(global);
}
void Singleton::f2();{
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
    setEnabled(false);
    if (filename.length() <= 0)
        return;
}
void Singleton::f3();{
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
        if (! idx.data(ProfileModel::DATA_PATH_IS_NOT_DESCRIPTION).toBool() || idx.data(ProfileModel::DATA_IS_SELECTED).toBool())
            continue;
        QDir profileDir(profilePath);
}
void Singleton::f4();{
    }
    buttonMenu_->addActions(user);
    if (global.count() > 0)
    {
        if (actions().count() > 0)
}
void Singleton::f5();{
    {
        QModelIndex idx = model.index(cnt, ProfileModel::COL_NAME);
        QString profilePath = idx.data(ProfileModel::DATA_PATH).toString();
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    if (global.count() > 0)
    {
        if (actions().count() > 0)
            buttonMenu_->addSeparator();
        buttonMenu_->addActions(global);
}
void Singleton::f2();{
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
    setEnabled(false);
    if (filename.length() <= 0)
        return;
}
void Singleton::f3();{
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
        if (! idx.data(ProfileModel::DATA_PATH_IS_NOT_DESCRIPTION).toBool() || idx.data(ProfileModel::DATA_IS_SELECTED).toBool())
            continue;
        QDir profileDir(profilePath);
}
void Singleton::f4();{
    }
    buttonMenu_->addActions(user);
    if (global.count() > 0)
    {
        if (actions().count() > 0)
}
void Singleton::f5();{
    {
        QModelIndex idx = model.index(cnt, ProfileModel::COL_NAME);
        QString profilePath = idx.data(ProfileModel::DATA_PATH).toString();
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
}
void Singleton::f6();{
    if (filename.length() <= 0)
        return;
    ProfileModel model(this);
    QList<QAction *> global;
    QList<QAction *> user;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    if (global.count() > 0)
    {
        if (actions().count() > 0)
            buttonMenu_->addSeparator();
        buttonMenu_->addActions(global);
}
void Singleton::f2();{
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
    setEnabled(false);
    if (filename.length() <= 0)
        return;
}
void Singleton::f3();{
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
        if (! idx.data(ProfileModel::DATA_PATH_IS_NOT_DESCRIPTION).toBool() || idx.data(ProfileModel::DATA_IS_SELECTED).toBool())
            continue;
        QDir profileDir(profilePath);
}
void Singleton::f4();{
    }
    buttonMenu_->addActions(user);
    if (global.count() > 0)
    {
        if (actions().count() > 0)
}
void Singleton::f5();{
    {
        QModelIndex idx = model.index(cnt, ProfileModel::COL_NAME);
        QString profilePath = idx.data(ProfileModel::DATA_PATH).toString();
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
}
void Singleton::f6();{
    if (filename.length() <= 0)
        return;
    ProfileModel model(this);
    QList<QAction *> global;
    QList<QAction *> user;
}
void Singleton::f7();{
        setToolTip(toolTip);
    }
    if (fileName.length() > 0)
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    if (global.count() > 0)
    {
        if (actions().count() > 0)
            buttonMenu_->addSeparator();
        buttonMenu_->addActions(global);
}
void Singleton::f2();{
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
    setEnabled(false);
    if (filename.length() <= 0)
        return;
}
void Singleton::f3();{
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
        if (! idx.data(ProfileModel::DATA_PATH_IS_NOT_DESCRIPTION).toBool() || idx.data(ProfileModel::DATA_IS_SELECTED).toBool())
            continue;
        QDir profileDir(profilePath);
}
void Singleton::f4();{
    }
    buttonMenu_->addActions(user);
    if (global.count() > 0)
    {
        if (actions().count() > 0)
}
void Singleton::f5();{
    {
        QModelIndex idx = model.index(cnt, ProfileModel::COL_NAME);
        QString profilePath = idx.data(ProfileModel::DATA_PATH).toString();
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
}
void Singleton::f6();{
    if (filename.length() <= 0)
        return;
    ProfileModel model(this);
    QList<QAction *> global;
    QList<QAction *> user;
}
void Singleton::f7();{
        setToolTip(toolTip);
    }
    if (fileName.length() > 0)
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
}
void Singleton::f8();{
    QPushButton(parent),
    buttonMenu_(Q_NULLPTR)
    setText(tr("Copy from"));
    if (toolTip.length() == 0)
        setToolTip(tr("Copy entries from another profile."));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    if (global.count() > 0)
    {
        if (actions().count() > 0)
            buttonMenu_->addSeparator();
        buttonMenu_->addActions(global);
}
void Singleton::f2();{
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
    setEnabled(false);
    if (filename.length() <= 0)
        return;
}
void Singleton::f3();{
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
        if (! idx.data(ProfileModel::DATA_PATH_IS_NOT_DESCRIPTION).toBool() || idx.data(ProfileModel::DATA_IS_SELECTED).toBool())
            continue;
        QDir profileDir(profilePath);
}
void Singleton::f4();{
    }
    buttonMenu_->addActions(user);
    if (global.count() > 0)
    {
        if (actions().count() > 0)
}
void Singleton::f5();{
    {
        QModelIndex idx = model.index(cnt, ProfileModel::COL_NAME);
        QString profilePath = idx.data(ProfileModel::DATA_PATH).toString();
        if (! idx.isValid() || profilePath.isEmpty())
            continue;
}
void Singleton::f6();{
    if (filename.length() <= 0)
        return;
    ProfileModel model(this);
    QList<QAction *> global;
    QList<QAction *> user;
}
void Singleton::f7();{
        setToolTip(toolTip);
    }
    if (fileName.length() > 0)
        setFilename(fileName);
void CopyFromProfileButton::setFilename(QString filename)
}
void Singleton::f8();{
    QPushButton(parent),
    buttonMenu_(Q_NULLPTR)
    setText(tr("Copy from"));
    if (toolTip.length() == 0)
        setToolTip(tr("Copy entries from another profile."));
}
void Singleton::f9();{
            continue;
        QDir profileDir(profilePath);
        if (! profileDir.exists())
            continue;
        QFileInfo fi = profileDir.filePath(filename);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f2();{
void CredentialsDialog::actionGoToPacket(const QModelIndex& idx)
    if (!idx.isValid())
        return;
    QVariant packet_data = idx.data(Qt::UserRole);
    QVariant hf_id = idx.data(CredentialsModel::ColumnHFID);
}
void Singleton::f3();{
        hf_id = QVariant::fromValue(0);
    if (packet_data.canConvert(QVariant::Int))
        packet_list_->goToPacket(packet_data.toInt(), hf_id.toInt());
 * Editor modelines
 * Local Variables:
}
void Singleton::f4();{
        else
            UrlLinkDelegate::paint(painter, option, index);
    }
CredentialsDialog::CredentialsDialog(QWidget &parent, CaptureFile &cf, PacketList *packet_list) :
    WiresharkDialog(parent, cf),
}
void Singleton::f5();{
    {
        bool ok = false;
        int val = index.data(Qt::UserRole).toInt(&ok);
        if (!ok || val <= 0)
            QStyledItemDelegate::paint(painter, option, index);
}
void Singleton::f6();{
    ui->auths->setModel(proxyModel);
    setWindowSubtitle(tr("Credentials"));
    ui->auths->setRootIsDecorated(false);
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_NUM, new CredentialsUrlDelegate(this));
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_USERNAME, new CredentialsUrlDelegate(this));
}
void Singleton::f7();{
    ui->auths->resizeColumnToContents(CredentialsModel::COL_NUM);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_PROTO);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_USERNAME);
    ui->auths->setSortingEnabled(true);
    ui->auths->sortByColumn(CredentialsModel::COL_NUM, Qt::AscendingOrder);
}
void Singleton::f8();{
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_USERNAME, new CredentialsUrlDelegate(this));
    ui->auths->resizeColumnToContents(CredentialsModel::COL_NUM);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_PROTO);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_USERNAME);
    ui->auths->setSortingEnabled(true);
}
void Singleton::f9();{
        if (!ok || val <= 0)
            QStyledItemDelegate::paint(painter, option, index);
        else
            UrlLinkDelegate::paint(painter, option, index);
    }
}
void Singleton::f10();{
    if (packet_data.canConvert(QVariant::Int))
        packet_list_->goToPacket(packet_data.toInt(), hf_id.toInt());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f2();{
void CredentialsDialog::actionGoToPacket(const QModelIndex& idx)
    if (!idx.isValid())
        return;
    QVariant packet_data = idx.data(Qt::UserRole);
    QVariant hf_id = idx.data(CredentialsModel::ColumnHFID);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f2();{
void CredentialsDialog::actionGoToPacket(const QModelIndex& idx)
    if (!idx.isValid())
        return;
    QVariant packet_data = idx.data(Qt::UserRole);
    QVariant hf_id = idx.data(CredentialsModel::ColumnHFID);
}
void Singleton::f3();{
        hf_id = QVariant::fromValue(0);
    if (packet_data.canConvert(QVariant::Int))
        packet_list_->goToPacket(packet_data.toInt(), hf_id.toInt());
 * Editor modelines
 * Local Variables:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f2();{
void CredentialsDialog::actionGoToPacket(const QModelIndex& idx)
    if (!idx.isValid())
        return;
    QVariant packet_data = idx.data(Qt::UserRole);
    QVariant hf_id = idx.data(CredentialsModel::ColumnHFID);
}
void Singleton::f3();{
        hf_id = QVariant::fromValue(0);
    if (packet_data.canConvert(QVariant::Int))
        packet_list_->goToPacket(packet_data.toInt(), hf_id.toInt());
 * Editor modelines
 * Local Variables:
}
void Singleton::f4();{
        else
            UrlLinkDelegate::paint(painter, option, index);
    }
CredentialsDialog::CredentialsDialog(QWidget &parent, CaptureFile &cf, PacketList *packet_list) :
    WiresharkDialog(parent, cf),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f2();{
void CredentialsDialog::actionGoToPacket(const QModelIndex& idx)
    if (!idx.isValid())
        return;
    QVariant packet_data = idx.data(Qt::UserRole);
    QVariant hf_id = idx.data(CredentialsModel::ColumnHFID);
}
void Singleton::f3();{
        hf_id = QVariant::fromValue(0);
    if (packet_data.canConvert(QVariant::Int))
        packet_list_->goToPacket(packet_data.toInt(), hf_id.toInt());
 * Editor modelines
 * Local Variables:
}
void Singleton::f4();{
        else
            UrlLinkDelegate::paint(painter, option, index);
    }
CredentialsDialog::CredentialsDialog(QWidget &parent, CaptureFile &cf, PacketList *packet_list) :
    WiresharkDialog(parent, cf),
}
void Singleton::f5();{
    {
        bool ok = false;
        int val = index.data(Qt::UserRole).toInt(&ok);
        if (!ok || val <= 0)
            QStyledItemDelegate::paint(painter, option, index);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f2();{
void CredentialsDialog::actionGoToPacket(const QModelIndex& idx)
    if (!idx.isValid())
        return;
    QVariant packet_data = idx.data(Qt::UserRole);
    QVariant hf_id = idx.data(CredentialsModel::ColumnHFID);
}
void Singleton::f3();{
        hf_id = QVariant::fromValue(0);
    if (packet_data.canConvert(QVariant::Int))
        packet_list_->goToPacket(packet_data.toInt(), hf_id.toInt());
 * Editor modelines
 * Local Variables:
}
void Singleton::f4();{
        else
            UrlLinkDelegate::paint(painter, option, index);
    }
CredentialsDialog::CredentialsDialog(QWidget &parent, CaptureFile &cf, PacketList *packet_list) :
    WiresharkDialog(parent, cf),
}
void Singleton::f5();{
    {
        bool ok = false;
        int val = index.data(Qt::UserRole).toInt(&ok);
        if (!ok || val <= 0)
            QStyledItemDelegate::paint(painter, option, index);
}
void Singleton::f6();{
    ui->auths->setModel(proxyModel);
    setWindowSubtitle(tr("Credentials"));
    ui->auths->setRootIsDecorated(false);
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_NUM, new CredentialsUrlDelegate(this));
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_USERNAME, new CredentialsUrlDelegate(this));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f2();{
void CredentialsDialog::actionGoToPacket(const QModelIndex& idx)
    if (!idx.isValid())
        return;
    QVariant packet_data = idx.data(Qt::UserRole);
    QVariant hf_id = idx.data(CredentialsModel::ColumnHFID);
}
void Singleton::f3();{
        hf_id = QVariant::fromValue(0);
    if (packet_data.canConvert(QVariant::Int))
        packet_list_->goToPacket(packet_data.toInt(), hf_id.toInt());
 * Editor modelines
 * Local Variables:
}
void Singleton::f4();{
        else
            UrlLinkDelegate::paint(painter, option, index);
    }
CredentialsDialog::CredentialsDialog(QWidget &parent, CaptureFile &cf, PacketList *packet_list) :
    WiresharkDialog(parent, cf),
}
void Singleton::f5();{
    {
        bool ok = false;
        int val = index.data(Qt::UserRole).toInt(&ok);
        if (!ok || val <= 0)
            QStyledItemDelegate::paint(painter, option, index);
}
void Singleton::f6();{
    ui->auths->setModel(proxyModel);
    setWindowSubtitle(tr("Credentials"));
    ui->auths->setRootIsDecorated(false);
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_NUM, new CredentialsUrlDelegate(this));
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_USERNAME, new CredentialsUrlDelegate(this));
}
void Singleton::f7();{
    ui->auths->resizeColumnToContents(CredentialsModel::COL_NUM);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_PROTO);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_USERNAME);
    ui->auths->setSortingEnabled(true);
    ui->auths->sortByColumn(CredentialsModel::COL_NUM, Qt::AscendingOrder);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f2();{
void CredentialsDialog::actionGoToPacket(const QModelIndex& idx)
    if (!idx.isValid())
        return;
    QVariant packet_data = idx.data(Qt::UserRole);
    QVariant hf_id = idx.data(CredentialsModel::ColumnHFID);
}
void Singleton::f3();{
        hf_id = QVariant::fromValue(0);
    if (packet_data.canConvert(QVariant::Int))
        packet_list_->goToPacket(packet_data.toInt(), hf_id.toInt());
 * Editor modelines
 * Local Variables:
}
void Singleton::f4();{
        else
            UrlLinkDelegate::paint(painter, option, index);
    }
CredentialsDialog::CredentialsDialog(QWidget &parent, CaptureFile &cf, PacketList *packet_list) :
    WiresharkDialog(parent, cf),
}
void Singleton::f5();{
    {
        bool ok = false;
        int val = index.data(Qt::UserRole).toInt(&ok);
        if (!ok || val <= 0)
            QStyledItemDelegate::paint(painter, option, index);
}
void Singleton::f6();{
    ui->auths->setModel(proxyModel);
    setWindowSubtitle(tr("Credentials"));
    ui->auths->setRootIsDecorated(false);
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_NUM, new CredentialsUrlDelegate(this));
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_USERNAME, new CredentialsUrlDelegate(this));
}
void Singleton::f7();{
    ui->auths->resizeColumnToContents(CredentialsModel::COL_NUM);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_PROTO);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_USERNAME);
    ui->auths->setSortingEnabled(true);
    ui->auths->sortByColumn(CredentialsModel::COL_NUM, Qt::AscendingOrder);
}
void Singleton::f8();{
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_USERNAME, new CredentialsUrlDelegate(this));
    ui->auths->resizeColumnToContents(CredentialsModel::COL_NUM);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_PROTO);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_USERNAME);
    ui->auths->setSortingEnabled(true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f2();{
void CredentialsDialog::actionGoToPacket(const QModelIndex& idx)
    if (!idx.isValid())
        return;
    QVariant packet_data = idx.data(Qt::UserRole);
    QVariant hf_id = idx.data(CredentialsModel::ColumnHFID);
}
void Singleton::f3();{
        hf_id = QVariant::fromValue(0);
    if (packet_data.canConvert(QVariant::Int))
        packet_list_->goToPacket(packet_data.toInt(), hf_id.toInt());
 * Editor modelines
 * Local Variables:
}
void Singleton::f4();{
        else
            UrlLinkDelegate::paint(painter, option, index);
    }
CredentialsDialog::CredentialsDialog(QWidget &parent, CaptureFile &cf, PacketList *packet_list) :
    WiresharkDialog(parent, cf),
}
void Singleton::f5();{
    {
        bool ok = false;
        int val = index.data(Qt::UserRole).toInt(&ok);
        if (!ok || val <= 0)
            QStyledItemDelegate::paint(painter, option, index);
}
void Singleton::f6();{
    ui->auths->setModel(proxyModel);
    setWindowSubtitle(tr("Credentials"));
    ui->auths->setRootIsDecorated(false);
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_NUM, new CredentialsUrlDelegate(this));
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_USERNAME, new CredentialsUrlDelegate(this));
}
void Singleton::f7();{
    ui->auths->resizeColumnToContents(CredentialsModel::COL_NUM);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_PROTO);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_USERNAME);
    ui->auths->setSortingEnabled(true);
    ui->auths->sortByColumn(CredentialsModel::COL_NUM, Qt::AscendingOrder);
}
void Singleton::f8();{
    ui->auths->setItemDelegateForColumn(CredentialsModel::COL_USERNAME, new CredentialsUrlDelegate(this));
    ui->auths->resizeColumnToContents(CredentialsModel::COL_NUM);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_PROTO);
    ui->auths->resizeColumnToContents(CredentialsModel::COL_USERNAME);
    ui->auths->setSortingEnabled(true);
}
void Singleton::f9();{
        if (!ok || val <= 0)
            QStyledItemDelegate::paint(painter, option, index);
        else
            UrlLinkDelegate::paint(painter, option, index);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * Copyright 2019 - Dario Lombardo <lomato@gmail.com>
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * Copyright 2019 - Dario Lombardo <lomato@gmail.com>
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f2();{
    tap_credential_t* clone = new tap_credential_t;
    clone->num = auth->num;
    clone->username_num = auth->username_num;
    clone->password_hf_id = auth->password_hf_id;
    clone->username = qstring_strdup(auth->username);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            delete *itr;
        }
        credentials_.clear();
        emit endRemoveRows();
    }
}
void Singleton::f5();{
            case COL_PROTO:
                return QString(tr("Protocol"));
            case COL_USERNAME:
                return QString(tr("Username"));
            case COL_INFO:
}
void Singleton::f6();{
    if (orientation == Qt::Horizontal) {
        switch (section) {
            case COL_NUM:
                return QString(tr("Packet No."));
            case COL_PROTO:
}
void Singleton::f7();{
CredentialsModel::CredentialsModel(QObject *parent)
    :QAbstractListModel(parent)
int CredentialsModel::rowCount(const QModelIndex &) const
    return credentials_.count();
int CredentialsModel::columnCount(const QModelIndex &) const
}
void Singleton::f8();{
    clone->proto = auth->proto;
    clone->info = qstring_strdup(auth->info);
    credentials_.append(clone);
    emit endInsertRows();
void CredentialsModel::clear()
}
void Singleton::f9();{
    if (orientation == Qt::Horizontal) {
        switch (section) {
            case COL_NUM:
                return QString(tr("Packet No."));
            case COL_PROTO:
}
void Singleton::f10();{
                }
                break;
            default:
                return QVariant();
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * Copyright 2019 - Dario Lombardo <lomato@gmail.com>
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f2();{
    tap_credential_t* clone = new tap_credential_t;
    clone->num = auth->num;
    clone->username_num = auth->username_num;
    clone->password_hf_id = auth->password_hf_id;
    clone->username = qstring_strdup(auth->username);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * Copyright 2019 - Dario Lombardo <lomato@gmail.com>
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f2();{
    tap_credential_t* clone = new tap_credential_t;
    clone->num = auth->num;
    clone->username_num = auth->username_num;
    clone->password_hf_id = auth->password_hf_id;
    clone->username = qstring_strdup(auth->username);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * Copyright 2019 - Dario Lombardo <lomato@gmail.com>
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f2();{
    tap_credential_t* clone = new tap_credential_t;
    clone->num = auth->num;
    clone->username_num = auth->username_num;
    clone->password_hf_id = auth->password_hf_id;
    clone->username = qstring_strdup(auth->username);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            delete *itr;
        }
        credentials_.clear();
        emit endRemoveRows();
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * Copyright 2019 - Dario Lombardo <lomato@gmail.com>
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f2();{
    tap_credential_t* clone = new tap_credential_t;
    clone->num = auth->num;
    clone->username_num = auth->username_num;
    clone->password_hf_id = auth->password_hf_id;
    clone->username = qstring_strdup(auth->username);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            delete *itr;
        }
        credentials_.clear();
        emit endRemoveRows();
    }
}
void Singleton::f5();{
            case COL_PROTO:
                return QString(tr("Protocol"));
            case COL_USERNAME:
                return QString(tr("Username"));
            case COL_INFO:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * Copyright 2019 - Dario Lombardo <lomato@gmail.com>
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f2();{
    tap_credential_t* clone = new tap_credential_t;
    clone->num = auth->num;
    clone->username_num = auth->username_num;
    clone->password_hf_id = auth->password_hf_id;
    clone->username = qstring_strdup(auth->username);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            delete *itr;
        }
        credentials_.clear();
        emit endRemoveRows();
    }
}
void Singleton::f5();{
            case COL_PROTO:
                return QString(tr("Protocol"));
            case COL_USERNAME:
                return QString(tr("Username"));
            case COL_INFO:
}
void Singleton::f6();{
    if (orientation == Qt::Horizontal) {
        switch (section) {
            case COL_NUM:
                return QString(tr("Packet No."));
            case COL_PROTO:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * Copyright 2019 - Dario Lombardo <lomato@gmail.com>
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f2();{
    tap_credential_t* clone = new tap_credential_t;
    clone->num = auth->num;
    clone->username_num = auth->username_num;
    clone->password_hf_id = auth->password_hf_id;
    clone->username = qstring_strdup(auth->username);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            delete *itr;
        }
        credentials_.clear();
        emit endRemoveRows();
    }
}
void Singleton::f5();{
            case COL_PROTO:
                return QString(tr("Protocol"));
            case COL_USERNAME:
                return QString(tr("Username"));
            case COL_INFO:
}
void Singleton::f6();{
    if (orientation == Qt::Horizontal) {
        switch (section) {
            case COL_NUM:
                return QString(tr("Packet No."));
            case COL_PROTO:
}
void Singleton::f7();{
CredentialsModel::CredentialsModel(QObject *parent)
    :QAbstractListModel(parent)
int CredentialsModel::rowCount(const QModelIndex &) const
    return credentials_.count();
int CredentialsModel::columnCount(const QModelIndex &) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * Copyright 2019 - Dario Lombardo <lomato@gmail.com>
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f2();{
    tap_credential_t* clone = new tap_credential_t;
    clone->num = auth->num;
    clone->username_num = auth->username_num;
    clone->password_hf_id = auth->password_hf_id;
    clone->username = qstring_strdup(auth->username);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            delete *itr;
        }
        credentials_.clear();
        emit endRemoveRows();
    }
}
void Singleton::f5();{
            case COL_PROTO:
                return QString(tr("Protocol"));
            case COL_USERNAME:
                return QString(tr("Username"));
            case COL_INFO:
}
void Singleton::f6();{
    if (orientation == Qt::Horizontal) {
        switch (section) {
            case COL_NUM:
                return QString(tr("Packet No."));
            case COL_PROTO:
}
void Singleton::f7();{
CredentialsModel::CredentialsModel(QObject *parent)
    :QAbstractListModel(parent)
int CredentialsModel::rowCount(const QModelIndex &) const
    return credentials_.count();
int CredentialsModel::columnCount(const QModelIndex &) const
}
void Singleton::f8();{
    clone->proto = auth->proto;
    clone->info = qstring_strdup(auth->info);
    credentials_.append(clone);
    emit endInsertRows();
void CredentialsModel::clear()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * Copyright 2019 - Dario Lombardo <lomato@gmail.com>
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f2();{
    tap_credential_t* clone = new tap_credential_t;
    clone->num = auth->num;
    clone->username_num = auth->username_num;
    clone->password_hf_id = auth->password_hf_id;
    clone->username = qstring_strdup(auth->username);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            delete *itr;
        }
        credentials_.clear();
        emit endRemoveRows();
    }
}
void Singleton::f5();{
            case COL_PROTO:
                return QString(tr("Protocol"));
            case COL_USERNAME:
                return QString(tr("Username"));
            case COL_INFO:
}
void Singleton::f6();{
    if (orientation == Qt::Horizontal) {
        switch (section) {
            case COL_NUM:
                return QString(tr("Packet No."));
            case COL_PROTO:
}
void Singleton::f7();{
CredentialsModel::CredentialsModel(QObject *parent)
    :QAbstractListModel(parent)
int CredentialsModel::rowCount(const QModelIndex &) const
    return credentials_.count();
int CredentialsModel::columnCount(const QModelIndex &) const
}
void Singleton::f8();{
    clone->proto = auth->proto;
    clone->info = qstring_strdup(auth->info);
    credentials_.append(clone);
    emit endInsertRows();
void CredentialsModel::clear()
}
void Singleton::f9();{
    if (orientation == Qt::Horizontal) {
        switch (section) {
            case COL_NUM:
                return QString(tr("Packet No."));
            case COL_PROTO:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    QString byteStr;
    QString dataStr;
    int cnt = 0;
    while (cnt < printData.length())
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    QString byteStr;
    QString dataStr;
    int cnt = 0;
    while (cnt < printData.length())
    {
}
void Singleton::f2();{
        {
            QChar ch(printData[cnt]);
            if (g_ascii_isprint(printData[cnt]))
                dataStr += printData[cnt];
            else
}
void Singleton::f3();{
                dataStr += printData[cnt];
            else
                dataStr += '.';
        }
        cnt++;
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
DataPrinter::DataPrinter(QObject * parent)
}
void Singleton::f5();{
        break;
    case DP_HexOnly:
        clipboard_text = hexTextDump(printData, false);
        break;
    default:
}
void Singleton::f6();{
            clipboard_text += QString("\\x%1").arg((uint8_t) printData[i], 2, 16, QChar('0'));
        }
        // End quote
        clipboard_text += QString("\"\n");
        break;
}
void Singleton::f7();{
    action->setProperty("printertype", DataPrinter::DP_PrintableText);
    connect(action, &QAction::triggered, dpi, &DataPrinter::copyIDataBytes);
    action = new QAction(tr(UTF8_HORIZONTAL_ELLIPSIS "as a Hex Stream"), actions);
    action->setToolTip(tr("Copy packet bytes as a stream of hex."));
    action->setProperty("printertype", DataPrinter::DP_HexStream);
}
void Singleton::f8();{
    int dump_type = sendingAction->property("printertype").toInt();
    if (dump_type >= 0 && dump_type <= DataPrinter::DP_Binary) {
        DataPrinter printer;
        printer.toClipboard((DataPrinter::DumpType) dump_type, dynamic_cast<IDataPrintable *>(dataObject));
    }
}
void Singleton::f9();{
        clipboard_text += byteStr.mid(offset * 3, byteLineLength_ * 3);
        if (showASCII)
        {
            /* separation bytes for byte and text */
            clipboard_text += QString(3, ' ');
}
void Singleton::f10();{
                clipboard_text += ch;
            }
        }
        break;
    case DP_HexStream:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    QString byteStr;
    QString dataStr;
    int cnt = 0;
    while (cnt < printData.length())
    {
}
void Singleton::f2();{
        {
            QChar ch(printData[cnt]);
            if (g_ascii_isprint(printData[cnt]))
                dataStr += printData[cnt];
            else
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    QString byteStr;
    QString dataStr;
    int cnt = 0;
    while (cnt < printData.length())
    {
}
void Singleton::f2();{
        {
            QChar ch(printData[cnt]);
            if (g_ascii_isprint(printData[cnt]))
                dataStr += printData[cnt];
            else
}
void Singleton::f3();{
                dataStr += printData[cnt];
            else
                dataStr += '.';
        }
        cnt++;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    QString byteStr;
    QString dataStr;
    int cnt = 0;
    while (cnt < printData.length())
    {
}
void Singleton::f2();{
        {
            QChar ch(printData[cnt]);
            if (g_ascii_isprint(printData[cnt]))
                dataStr += printData[cnt];
            else
}
void Singleton::f3();{
                dataStr += printData[cnt];
            else
                dataStr += '.';
        }
        cnt++;
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
DataPrinter::DataPrinter(QObject * parent)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    QString byteStr;
    QString dataStr;
    int cnt = 0;
    while (cnt < printData.length())
    {
}
void Singleton::f2();{
        {
            QChar ch(printData[cnt]);
            if (g_ascii_isprint(printData[cnt]))
                dataStr += printData[cnt];
            else
}
void Singleton::f3();{
                dataStr += printData[cnt];
            else
                dataStr += '.';
        }
        cnt++;
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
DataPrinter::DataPrinter(QObject * parent)
}
void Singleton::f5();{
        break;
    case DP_HexOnly:
        clipboard_text = hexTextDump(printData, false);
        break;
    default:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    QString byteStr;
    QString dataStr;
    int cnt = 0;
    while (cnt < printData.length())
    {
}
void Singleton::f2();{
        {
            QChar ch(printData[cnt]);
            if (g_ascii_isprint(printData[cnt]))
                dataStr += printData[cnt];
            else
}
void Singleton::f3();{
                dataStr += printData[cnt];
            else
                dataStr += '.';
        }
        cnt++;
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
DataPrinter::DataPrinter(QObject * parent)
}
void Singleton::f5();{
        break;
    case DP_HexOnly:
        clipboard_text = hexTextDump(printData, false);
        break;
    default:
}
void Singleton::f6();{
            clipboard_text += QString("\\x%1").arg((uint8_t) printData[i], 2, 16, QChar('0'));
        }
        // End quote
        clipboard_text += QString("\"\n");
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    QString byteStr;
    QString dataStr;
    int cnt = 0;
    while (cnt < printData.length())
    {
}
void Singleton::f2();{
        {
            QChar ch(printData[cnt]);
            if (g_ascii_isprint(printData[cnt]))
                dataStr += printData[cnt];
            else
}
void Singleton::f3();{
                dataStr += printData[cnt];
            else
                dataStr += '.';
        }
        cnt++;
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
DataPrinter::DataPrinter(QObject * parent)
}
void Singleton::f5();{
        break;
    case DP_HexOnly:
        clipboard_text = hexTextDump(printData, false);
        break;
    default:
}
void Singleton::f6();{
            clipboard_text += QString("\\x%1").arg((uint8_t) printData[i], 2, 16, QChar('0'));
        }
        // End quote
        clipboard_text += QString("\"\n");
        break;
}
void Singleton::f7();{
    action->setProperty("printertype", DataPrinter::DP_PrintableText);
    connect(action, &QAction::triggered, dpi, &DataPrinter::copyIDataBytes);
    action = new QAction(tr(UTF8_HORIZONTAL_ELLIPSIS "as a Hex Stream"), actions);
    action->setToolTip(tr("Copy packet bytes as a stream of hex."));
    action->setProperty("printertype", DataPrinter::DP_HexStream);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    QString byteStr;
    QString dataStr;
    int cnt = 0;
    while (cnt < printData.length())
    {
}
void Singleton::f2();{
        {
            QChar ch(printData[cnt]);
            if (g_ascii_isprint(printData[cnt]))
                dataStr += printData[cnt];
            else
}
void Singleton::f3();{
                dataStr += printData[cnt];
            else
                dataStr += '.';
        }
        cnt++;
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
DataPrinter::DataPrinter(QObject * parent)
}
void Singleton::f5();{
        break;
    case DP_HexOnly:
        clipboard_text = hexTextDump(printData, false);
        break;
    default:
}
void Singleton::f6();{
            clipboard_text += QString("\\x%1").arg((uint8_t) printData[i], 2, 16, QChar('0'));
        }
        // End quote
        clipboard_text += QString("\"\n");
        break;
}
void Singleton::f7();{
    action->setProperty("printertype", DataPrinter::DP_PrintableText);
    connect(action, &QAction::triggered, dpi, &DataPrinter::copyIDataBytes);
    action = new QAction(tr(UTF8_HORIZONTAL_ELLIPSIS "as a Hex Stream"), actions);
    action->setToolTip(tr("Copy packet bytes as a stream of hex."));
    action->setProperty("printertype", DataPrinter::DP_HexStream);
}
void Singleton::f8();{
    int dump_type = sendingAction->property("printertype").toInt();
    if (dump_type >= 0 && dump_type <= DataPrinter::DP_Binary) {
        DataPrinter printer;
        printer.toClipboard((DataPrinter::DumpType) dump_type, dynamic_cast<IDataPrintable *>(dataObject));
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    QString byteStr;
    QString dataStr;
    int cnt = 0;
    while (cnt < printData.length())
    {
}
void Singleton::f2();{
        {
            QChar ch(printData[cnt]);
            if (g_ascii_isprint(printData[cnt]))
                dataStr += printData[cnt];
            else
}
void Singleton::f3();{
                dataStr += printData[cnt];
            else
                dataStr += '.';
        }
        cnt++;
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
DataPrinter::DataPrinter(QObject * parent)
}
void Singleton::f5();{
        break;
    case DP_HexOnly:
        clipboard_text = hexTextDump(printData, false);
        break;
    default:
}
void Singleton::f6();{
            clipboard_text += QString("\\x%1").arg((uint8_t) printData[i], 2, 16, QChar('0'));
        }
        // End quote
        clipboard_text += QString("\"\n");
        break;
}
void Singleton::f7();{
    action->setProperty("printertype", DataPrinter::DP_PrintableText);
    connect(action, &QAction::triggered, dpi, &DataPrinter::copyIDataBytes);
    action = new QAction(tr(UTF8_HORIZONTAL_ELLIPSIS "as a Hex Stream"), actions);
    action->setToolTip(tr("Copy packet bytes as a stream of hex."));
    action->setProperty("printertype", DataPrinter::DP_HexStream);
}
void Singleton::f8();{
    int dump_type = sendingAction->property("printertype").toInt();
    if (dump_type >= 0 && dump_type <= DataPrinter::DP_Binary) {
        DataPrinter printer;
        printer.toClipboard((DataPrinter::DumpType) dump_type, dynamic_cast<IDataPrintable *>(dataObject));
    }
}
void Singleton::f9();{
        clipboard_text += byteStr.mid(offset * 3, byteLineLength_ * 3);
        if (showASCII)
        {
            /* separation bytes for byte and text */
            clipboard_text += QString(3, ' ');
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                        //Don't limit user to just what's in combo box
                        cb_editor->setEditable(true);
                        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
                        //add the current value of the column
                        const QString& current_value = index.model()->data(index, Qt::EditRole).toString();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                        //Don't limit user to just what's in combo box
                        cb_editor->setEditable(true);
                        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
                        //add the current value of the column
                        const QString& current_value = index.model()->data(index, Qt::EditRole).toString();
}
void Singleton::f2();{
            cb_editor->setFixedWidth(protoColWidth);
        editor = cb_editor;
        break;
        }
    case DecodeAsModel::colSelector:
}
void Singleton::f3();{
        } else {
            editor = QStyledItemDelegate::createEditor(parentWidget, option, index);
        }
        break;
        }
}
void Singleton::f4();{
        }
        //Make sure the combo box is at least as wide as the column
        QTreeView* parentTree = (QTreeView*)parent();
        int protoColWidth = parentTree->columnWidth(index.column());
        if (protoColWidth > cb_editor->size().width())
}
void Singleton::f5();{
        QString table_ui_name;
        collectDAProtocols(da_set, packet_list);
        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
        //put the protocols from the packet first in the combo box
        foreach (table_ui_name, packet_list) {
}
void Singleton::f6();{
        {
            if (g_strcmp0(proto.table_ui_name, item->tableUIName_) == 0) {
                if (edt_present) {
                    cap_file_->edt->pi.curr_layer_num = proto.curr_layer_num;
                }
}
void Singleton::f7();{
        if ((g_strcmp0(proto_name, entry->name) == 0) &&
            (g_strcmp0(item->tableName_, entry->table_name) == 0) &&
            (cap_file_ && cap_file_->edt) &&
            (entry->num_items > 1)) {
                return true;
}
void Singleton::f8();{
        }
    }
    //filter out those in selected packet
    foreach(packet_proto_data_t proto, packet_proto_list_)
    {
}
void Singleton::f9();{
    if (cap_file_ && cap_file_->edt) {
        wmem_list_frame_t * protos = wmem_list_head(cap_file_->edt->pi.layers);
        guint8 curr_layer_num = 1;
        while (protos != NULL) {
            int proto_id = GPOINTER_TO_INT(wmem_list_frame_data(protos));
}
void Singleton::f10();{
                                //don't duplicate entries
                                if (cb_editor->findText(entryStr) < 0)
                                    cb_editor->addItem(entryStr);
                            }
                        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                        //Don't limit user to just what's in combo box
                        cb_editor->setEditable(true);
                        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
                        //add the current value of the column
                        const QString& current_value = index.model()->data(index, Qt::EditRole).toString();
}
void Singleton::f2();{
            cb_editor->setFixedWidth(protoColWidth);
        editor = cb_editor;
        break;
        }
    case DecodeAsModel::colSelector:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                        //Don't limit user to just what's in combo box
                        cb_editor->setEditable(true);
                        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
                        //add the current value of the column
                        const QString& current_value = index.model()->data(index, Qt::EditRole).toString();
}
void Singleton::f2();{
            cb_editor->setFixedWidth(protoColWidth);
        editor = cb_editor;
        break;
        }
    case DecodeAsModel::colSelector:
}
void Singleton::f3();{
        } else {
            editor = QStyledItemDelegate::createEditor(parentWidget, option, index);
        }
        break;
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                        //Don't limit user to just what's in combo box
                        cb_editor->setEditable(true);
                        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
                        //add the current value of the column
                        const QString& current_value = index.model()->data(index, Qt::EditRole).toString();
}
void Singleton::f2();{
            cb_editor->setFixedWidth(protoColWidth);
        editor = cb_editor;
        break;
        }
    case DecodeAsModel::colSelector:
}
void Singleton::f3();{
        } else {
            editor = QStyledItemDelegate::createEditor(parentWidget, option, index);
        }
        break;
        }
}
void Singleton::f4();{
        }
        //Make sure the combo box is at least as wide as the column
        QTreeView* parentTree = (QTreeView*)parent();
        int protoColWidth = parentTree->columnWidth(index.column());
        if (protoColWidth > cb_editor->size().width())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                        //Don't limit user to just what's in combo box
                        cb_editor->setEditable(true);
                        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
                        //add the current value of the column
                        const QString& current_value = index.model()->data(index, Qt::EditRole).toString();
}
void Singleton::f2();{
            cb_editor->setFixedWidth(protoColWidth);
        editor = cb_editor;
        break;
        }
    case DecodeAsModel::colSelector:
}
void Singleton::f3();{
        } else {
            editor = QStyledItemDelegate::createEditor(parentWidget, option, index);
        }
        break;
        }
}
void Singleton::f4();{
        }
        //Make sure the combo box is at least as wide as the column
        QTreeView* parentTree = (QTreeView*)parent();
        int protoColWidth = parentTree->columnWidth(index.column());
        if (protoColWidth > cb_editor->size().width())
}
void Singleton::f5();{
        QString table_ui_name;
        collectDAProtocols(da_set, packet_list);
        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
        //put the protocols from the packet first in the combo box
        foreach (table_ui_name, packet_list) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                        //Don't limit user to just what's in combo box
                        cb_editor->setEditable(true);
                        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
                        //add the current value of the column
                        const QString& current_value = index.model()->data(index, Qt::EditRole).toString();
}
void Singleton::f2();{
            cb_editor->setFixedWidth(protoColWidth);
        editor = cb_editor;
        break;
        }
    case DecodeAsModel::colSelector:
}
void Singleton::f3();{
        } else {
            editor = QStyledItemDelegate::createEditor(parentWidget, option, index);
        }
        break;
        }
}
void Singleton::f4();{
        }
        //Make sure the combo box is at least as wide as the column
        QTreeView* parentTree = (QTreeView*)parent();
        int protoColWidth = parentTree->columnWidth(index.column());
        if (protoColWidth > cb_editor->size().width())
}
void Singleton::f5();{
        QString table_ui_name;
        collectDAProtocols(da_set, packet_list);
        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
        //put the protocols from the packet first in the combo box
        foreach (table_ui_name, packet_list) {
}
void Singleton::f6();{
        {
            if (g_strcmp0(proto.table_ui_name, item->tableUIName_) == 0) {
                if (edt_present) {
                    cap_file_->edt->pi.curr_layer_num = proto.curr_layer_num;
                }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                        //Don't limit user to just what's in combo box
                        cb_editor->setEditable(true);
                        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
                        //add the current value of the column
                        const QString& current_value = index.model()->data(index, Qt::EditRole).toString();
}
void Singleton::f2();{
            cb_editor->setFixedWidth(protoColWidth);
        editor = cb_editor;
        break;
        }
    case DecodeAsModel::colSelector:
}
void Singleton::f3();{
        } else {
            editor = QStyledItemDelegate::createEditor(parentWidget, option, index);
        }
        break;
        }
}
void Singleton::f4();{
        }
        //Make sure the combo box is at least as wide as the column
        QTreeView* parentTree = (QTreeView*)parent();
        int protoColWidth = parentTree->columnWidth(index.column());
        if (protoColWidth > cb_editor->size().width())
}
void Singleton::f5();{
        QString table_ui_name;
        collectDAProtocols(da_set, packet_list);
        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
        //put the protocols from the packet first in the combo box
        foreach (table_ui_name, packet_list) {
}
void Singleton::f6();{
        {
            if (g_strcmp0(proto.table_ui_name, item->tableUIName_) == 0) {
                if (edt_present) {
                    cap_file_->edt->pi.curr_layer_num = proto.curr_layer_num;
                }
}
void Singleton::f7();{
        if ((g_strcmp0(proto_name, entry->name) == 0) &&
            (g_strcmp0(item->tableName_, entry->table_name) == 0) &&
            (cap_file_ && cap_file_->edt) &&
            (entry->num_items > 1)) {
                return true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                        //Don't limit user to just what's in combo box
                        cb_editor->setEditable(true);
                        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
                        //add the current value of the column
                        const QString& current_value = index.model()->data(index, Qt::EditRole).toString();
}
void Singleton::f2();{
            cb_editor->setFixedWidth(protoColWidth);
        editor = cb_editor;
        break;
        }
    case DecodeAsModel::colSelector:
}
void Singleton::f3();{
        } else {
            editor = QStyledItemDelegate::createEditor(parentWidget, option, index);
        }
        break;
        }
}
void Singleton::f4();{
        }
        //Make sure the combo box is at least as wide as the column
        QTreeView* parentTree = (QTreeView*)parent();
        int protoColWidth = parentTree->columnWidth(index.column());
        if (protoColWidth > cb_editor->size().width())
}
void Singleton::f5();{
        QString table_ui_name;
        collectDAProtocols(da_set, packet_list);
        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
        //put the protocols from the packet first in the combo box
        foreach (table_ui_name, packet_list) {
}
void Singleton::f6();{
        {
            if (g_strcmp0(proto.table_ui_name, item->tableUIName_) == 0) {
                if (edt_present) {
                    cap_file_->edt->pi.curr_layer_num = proto.curr_layer_num;
                }
}
void Singleton::f7();{
        if ((g_strcmp0(proto_name, entry->name) == 0) &&
            (g_strcmp0(item->tableName_, entry->table_name) == 0) &&
            (cap_file_ && cap_file_->edt) &&
            (entry->num_items > 1)) {
                return true;
}
void Singleton::f8();{
        }
    }
    //filter out those in selected packet
    foreach(packet_proto_data_t proto, packet_proto_list_)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                        //Don't limit user to just what's in combo box
                        cb_editor->setEditable(true);
                        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
                        //add the current value of the column
                        const QString& current_value = index.model()->data(index, Qt::EditRole).toString();
}
void Singleton::f2();{
            cb_editor->setFixedWidth(protoColWidth);
        editor = cb_editor;
        break;
        }
    case DecodeAsModel::colSelector:
}
void Singleton::f3();{
        } else {
            editor = QStyledItemDelegate::createEditor(parentWidget, option, index);
        }
        break;
        }
}
void Singleton::f4();{
        }
        //Make sure the combo box is at least as wide as the column
        QTreeView* parentTree = (QTreeView*)parent();
        int protoColWidth = parentTree->columnWidth(index.column());
        if (protoColWidth > cb_editor->size().width())
}
void Singleton::f5();{
        QString table_ui_name;
        collectDAProtocols(da_set, packet_list);
        cb_editor->setSizeAdjustPolicy(QComboBox::AdjustToContents);
        //put the protocols from the packet first in the combo box
        foreach (table_ui_name, packet_list) {
}
void Singleton::f6();{
        {
            if (g_strcmp0(proto.table_ui_name, item->tableUIName_) == 0) {
                if (edt_present) {
                    cap_file_->edt->pi.curr_layer_num = proto.curr_layer_num;
                }
}
void Singleton::f7();{
        if ((g_strcmp0(proto_name, entry->name) == 0) &&
            (g_strcmp0(item->tableName_, entry->table_name) == 0) &&
            (cap_file_ && cap_file_->edt) &&
            (entry->num_items > 1)) {
                return true;
}
void Singleton::f8();{
        }
    }
    //filter out those in selected packet
    foreach(packet_proto_data_t proto, packet_proto_list_)
    {
}
void Singleton::f9();{
    if (cap_file_ && cap_file_->edt) {
        wmem_list_frame_t * protos = wmem_list_head(cap_file_->edt->pi.layers);
        guint8 curr_layer_num = 1;
        while (protos != NULL) {
            int proto_id = GPOINTER_TO_INT(wmem_list_frame_data(protos));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
    wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
void DecodeAsDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (ui->buttonBox->standardButton(button)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
    wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
void DecodeAsDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (ui->buttonBox->standardButton(button)) {
}
void Singleton::f2();{
    delegate_ = new DecodeAsDelegate(ui->decodeAsTreeView, cf);
    ui->decodeAsTreeView->setModel(model_);
    ui->decodeAsTreeView->setItemDelegate(delegate_);
    ui->newToolButton->setStockIcon("list-add");
    ui->deleteToolButton->setStockIcon("list-remove");
}
void Singleton::f3();{
    delete model_;
    delete delegate_;
void DecodeAsDialog::fillTable()
    model_->fillTable();
    resizeColumns();
}
void Singleton::f4();{
    }
void DecodeAsDialog::on_copyToolButton_clicked()
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
}
void Singleton::f5();{
/* decode_as_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f6();{
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
}
void Singleton::f7();{
    } else {
        ui->deleteToolButton->setEnabled(false);
        ui->copyToolButton->setEnabled(false);
        ui->clearToolButton->setEnabled(false);
    }
}
void Singleton::f8();{
            g_free(err);
        }
        }
        break;
    case QDialogButtonBox::Help:
}
void Singleton::f9();{
    const QModelIndex &current = ui->decodeAsTreeView->currentIndex();
    if (copy_from_current && !current.isValid()) return;
//    XXX - This doesn't appear to work as intended to give "edit triggers on demand"
    ui->decodeAsTreeView->setEditTriggers(ui->decodeAsTreeView->editTriggers() | QAbstractItemView::CurrentChanged | QAbstractItemView::AnyKeyPressed);
    // should not fail, but you never know.
}
void Singleton::f10();{
        applyChanges();
        break;
    case QDialogButtonBox::Save:
        {
        gchar* err = NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
    wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
void DecodeAsDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (ui->buttonBox->standardButton(button)) {
}
void Singleton::f2();{
    delegate_ = new DecodeAsDelegate(ui->decodeAsTreeView, cf);
    ui->decodeAsTreeView->setModel(model_);
    ui->decodeAsTreeView->setItemDelegate(delegate_);
    ui->newToolButton->setStockIcon("list-add");
    ui->deleteToolButton->setStockIcon("list-remove");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
    wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
void DecodeAsDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (ui->buttonBox->standardButton(button)) {
}
void Singleton::f2();{
    delegate_ = new DecodeAsDelegate(ui->decodeAsTreeView, cf);
    ui->decodeAsTreeView->setModel(model_);
    ui->decodeAsTreeView->setItemDelegate(delegate_);
    ui->newToolButton->setStockIcon("list-add");
    ui->deleteToolButton->setStockIcon("list-remove");
}
void Singleton::f3();{
    delete model_;
    delete delegate_;
void DecodeAsDialog::fillTable()
    model_->fillTable();
    resizeColumns();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
    wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
void DecodeAsDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (ui->buttonBox->standardButton(button)) {
}
void Singleton::f2();{
    delegate_ = new DecodeAsDelegate(ui->decodeAsTreeView, cf);
    ui->decodeAsTreeView->setModel(model_);
    ui->decodeAsTreeView->setItemDelegate(delegate_);
    ui->newToolButton->setStockIcon("list-add");
    ui->deleteToolButton->setStockIcon("list-remove");
}
void Singleton::f3();{
    delete model_;
    delete delegate_;
void DecodeAsDialog::fillTable()
    model_->fillTable();
    resizeColumns();
}
void Singleton::f4();{
    }
void DecodeAsDialog::on_copyToolButton_clicked()
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
    wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
void DecodeAsDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (ui->buttonBox->standardButton(button)) {
}
void Singleton::f2();{
    delegate_ = new DecodeAsDelegate(ui->decodeAsTreeView, cf);
    ui->decodeAsTreeView->setModel(model_);
    ui->decodeAsTreeView->setItemDelegate(delegate_);
    ui->newToolButton->setStockIcon("list-add");
    ui->deleteToolButton->setStockIcon("list-remove");
}
void Singleton::f3();{
    delete model_;
    delete delegate_;
void DecodeAsDialog::fillTable()
    model_->fillTable();
    resizeColumns();
}
void Singleton::f4();{
    }
void DecodeAsDialog::on_copyToolButton_clicked()
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
}
void Singleton::f5();{
/* decode_as_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
    wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
void DecodeAsDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (ui->buttonBox->standardButton(button)) {
}
void Singleton::f2();{
    delegate_ = new DecodeAsDelegate(ui->decodeAsTreeView, cf);
    ui->decodeAsTreeView->setModel(model_);
    ui->decodeAsTreeView->setItemDelegate(delegate_);
    ui->newToolButton->setStockIcon("list-add");
    ui->deleteToolButton->setStockIcon("list-remove");
}
void Singleton::f3();{
    delete model_;
    delete delegate_;
void DecodeAsDialog::fillTable()
    model_->fillTable();
    resizeColumns();
}
void Singleton::f4();{
    }
void DecodeAsDialog::on_copyToolButton_clicked()
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
}
void Singleton::f5();{
/* decode_as_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f6();{
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
    wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
void DecodeAsDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (ui->buttonBox->standardButton(button)) {
}
void Singleton::f2();{
    delegate_ = new DecodeAsDelegate(ui->decodeAsTreeView, cf);
    ui->decodeAsTreeView->setModel(model_);
    ui->decodeAsTreeView->setItemDelegate(delegate_);
    ui->newToolButton->setStockIcon("list-add");
    ui->deleteToolButton->setStockIcon("list-remove");
}
void Singleton::f3();{
    delete model_;
    delete delegate_;
void DecodeAsDialog::fillTable()
    model_->fillTable();
    resizeColumns();
}
void Singleton::f4();{
    }
void DecodeAsDialog::on_copyToolButton_clicked()
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
}
void Singleton::f5();{
/* decode_as_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f6();{
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
}
void Singleton::f7();{
    } else {
        ui->deleteToolButton->setEnabled(false);
        ui->copyToolButton->setEnabled(false);
        ui->clearToolButton->setEnabled(false);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
    wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
void DecodeAsDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (ui->buttonBox->standardButton(button)) {
}
void Singleton::f2();{
    delegate_ = new DecodeAsDelegate(ui->decodeAsTreeView, cf);
    ui->decodeAsTreeView->setModel(model_);
    ui->decodeAsTreeView->setItemDelegate(delegate_);
    ui->newToolButton->setStockIcon("list-add");
    ui->deleteToolButton->setStockIcon("list-remove");
}
void Singleton::f3();{
    delete model_;
    delete delegate_;
void DecodeAsDialog::fillTable()
    model_->fillTable();
    resizeColumns();
}
void Singleton::f4();{
    }
void DecodeAsDialog::on_copyToolButton_clicked()
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
}
void Singleton::f5();{
/* decode_as_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f6();{
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
}
void Singleton::f7();{
    } else {
        ui->deleteToolButton->setEnabled(false);
        ui->copyToolButton->setEnabled(false);
        ui->clearToolButton->setEnabled(false);
    }
}
void Singleton::f8();{
            g_free(err);
        }
        }
        break;
    case QDialogButtonBox::Help:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
    wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
void DecodeAsDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (ui->buttonBox->standardButton(button)) {
}
void Singleton::f2();{
    delegate_ = new DecodeAsDelegate(ui->decodeAsTreeView, cf);
    ui->decodeAsTreeView->setModel(model_);
    ui->decodeAsTreeView->setItemDelegate(delegate_);
    ui->newToolButton->setStockIcon("list-add");
    ui->deleteToolButton->setStockIcon("list-remove");
}
void Singleton::f3();{
    delete model_;
    delete delegate_;
void DecodeAsDialog::fillTable()
    model_->fillTable();
    resizeColumns();
}
void Singleton::f4();{
    }
void DecodeAsDialog::on_copyToolButton_clicked()
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
}
void Singleton::f5();{
/* decode_as_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f6();{
    addRecord(true);
void DecodeAsDialog::on_clearToolButton_clicked()
    model_->clearAll();
void DecodeAsDialog::applyChanges()
    model_->applyChanges();
}
void Singleton::f7();{
    } else {
        ui->deleteToolButton->setEnabled(false);
        ui->copyToolButton->setEnabled(false);
        ui->clearToolButton->setEnabled(false);
    }
}
void Singleton::f8();{
            g_free(err);
        }
        }
        break;
    case QDialogButtonBox::Help:
}
void Singleton::f9();{
    const QModelIndex &current = ui->decodeAsTreeView->currentIndex();
    if (copy_from_current && !current.isValid()) return;
//    XXX - This doesn't appear to work as intended to give "edit triggers on demand"
    ui->decodeAsTreeView->setEditTriggers(ui->decodeAsTreeView->editTriggers() | QAbstractItemView::CurrentChanged | QAbstractItemView::AnyKeyPressed);
    // should not fail, but you never know.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    case FT_UINT24:
    case FT_UINT32:
        model->changed_uint_entries_ << UintPair(table_name, GPOINTER_TO_UINT(key));
        break;
    case FT_NONE:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    case FT_UINT24:
    case FT_UINT32:
        model->changed_uint_entries_ << UintPair(table_name, GPOINTER_TO_UINT(key));
        break;
    case FT_NONE:
}
void Singleton::f2();{
        ftenum_t selector_type = get_dissector_table_selector_type(item->tableName_);
        if ((selector_type != FT_NONE) &&
            (item->selectorDCERPC_ == NULL))
            flags |= Qt::ItemIsEditable;
        break;
}
void Singleton::f3();{
        break;
    case FT_NONE:
        //doesn't really matter, just avoiding the assert
        return "0";
    default:
}
void Singleton::f4();{
    case colTable:
        return tr("Field");
    case colSelector:
        return tr("Value");
    case colType:
}
void Singleton::f5();{
            } else if (IS_FT_UINT(selector_type)) {
                QString type_desc = tr("Integer, base ");
                switch (get_dissector_table_param(item->tableName_)) {
                case BASE_OCT:
                    type_desc.append("8");
}
void Singleton::f6();{
        return;
    beginResetModel();
    decode_as_items_.clear();
    endResetModel();
bool DecodeAsModel::copyRow(int dst_row, int src_row)
}
void Singleton::f7();{
        switch (get_dissector_table_param(table_name)) {
        case BASE_DEC:
            entry_str = QString::number(num_val);
            break;
        case BASE_HEX:
}
void Singleton::f8();{
    if (model == NULL)
        return;
    DecodeAsItem* item = new DecodeAsItem();
    item->tableName_ = "dcerpc.uuid";
    item->tableUIName_ = get_dissector_table_ui_name(item->tableName_);
}
void Singleton::f9();{
                item->tableName_ = entry->table_name;
                item->tableUIName_ = get_dissector_table_ui_name(entry->table_name);
                //all other columns affected
                emit dataChanged(index(cur_index.row(), colSelector),
                                 index(cur_index.row(), colProtocol));
}
void Singleton::f10();{
    if (count != 1 || row < 0 || row > rowCount())
        return false;
    beginInsertRows(QModelIndex(), row, row);
    DecodeAsItem* item = new DecodeAsItem();
    DecodeAsItem* alternativeItem = NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    case FT_UINT24:
    case FT_UINT32:
        model->changed_uint_entries_ << UintPair(table_name, GPOINTER_TO_UINT(key));
        break;
    case FT_NONE:
}
void Singleton::f2();{
        ftenum_t selector_type = get_dissector_table_selector_type(item->tableName_);
        if ((selector_type != FT_NONE) &&
            (item->selectorDCERPC_ == NULL))
            flags |= Qt::ItemIsEditable;
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    case FT_UINT24:
    case FT_UINT32:
        model->changed_uint_entries_ << UintPair(table_name, GPOINTER_TO_UINT(key));
        break;
    case FT_NONE:
}
void Singleton::f2();{
        ftenum_t selector_type = get_dissector_table_selector_type(item->tableName_);
        if ((selector_type != FT_NONE) &&
            (item->selectorDCERPC_ == NULL))
            flags |= Qt::ItemIsEditable;
        break;
}
void Singleton::f3();{
        break;
    case FT_NONE:
        //doesn't really matter, just avoiding the assert
        return "0";
    default:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    case FT_UINT24:
    case FT_UINT32:
        model->changed_uint_entries_ << UintPair(table_name, GPOINTER_TO_UINT(key));
        break;
    case FT_NONE:
}
void Singleton::f2();{
        ftenum_t selector_type = get_dissector_table_selector_type(item->tableName_);
        if ((selector_type != FT_NONE) &&
            (item->selectorDCERPC_ == NULL))
            flags |= Qt::ItemIsEditable;
        break;
}
void Singleton::f3();{
        break;
    case FT_NONE:
        //doesn't really matter, just avoiding the assert
        return "0";
    default:
}
void Singleton::f4();{
    case colTable:
        return tr("Field");
    case colSelector:
        return tr("Value");
    case colType:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    case FT_UINT24:
    case FT_UINT32:
        model->changed_uint_entries_ << UintPair(table_name, GPOINTER_TO_UINT(key));
        break;
    case FT_NONE:
}
void Singleton::f2();{
        ftenum_t selector_type = get_dissector_table_selector_type(item->tableName_);
        if ((selector_type != FT_NONE) &&
            (item->selectorDCERPC_ == NULL))
            flags |= Qt::ItemIsEditable;
        break;
}
void Singleton::f3();{
        break;
    case FT_NONE:
        //doesn't really matter, just avoiding the assert
        return "0";
    default:
}
void Singleton::f4();{
    case colTable:
        return tr("Field");
    case colSelector:
        return tr("Value");
    case colType:
}
void Singleton::f5();{
            } else if (IS_FT_UINT(selector_type)) {
                QString type_desc = tr("Integer, base ");
                switch (get_dissector_table_param(item->tableName_)) {
                case BASE_OCT:
                    type_desc.append("8");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    case FT_UINT24:
    case FT_UINT32:
        model->changed_uint_entries_ << UintPair(table_name, GPOINTER_TO_UINT(key));
        break;
    case FT_NONE:
}
void Singleton::f2();{
        ftenum_t selector_type = get_dissector_table_selector_type(item->tableName_);
        if ((selector_type != FT_NONE) &&
            (item->selectorDCERPC_ == NULL))
            flags |= Qt::ItemIsEditable;
        break;
}
void Singleton::f3();{
        break;
    case FT_NONE:
        //doesn't really matter, just avoiding the assert
        return "0";
    default:
}
void Singleton::f4();{
    case colTable:
        return tr("Field");
    case colSelector:
        return tr("Value");
    case colType:
}
void Singleton::f5();{
            } else if (IS_FT_UINT(selector_type)) {
                QString type_desc = tr("Integer, base ");
                switch (get_dissector_table_param(item->tableName_)) {
                case BASE_OCT:
                    type_desc.append("8");
}
void Singleton::f6();{
        return;
    beginResetModel();
    decode_as_items_.clear();
    endResetModel();
bool DecodeAsModel::copyRow(int dst_row, int src_row)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    case FT_UINT24:
    case FT_UINT32:
        model->changed_uint_entries_ << UintPair(table_name, GPOINTER_TO_UINT(key));
        break;
    case FT_NONE:
}
void Singleton::f2();{
        ftenum_t selector_type = get_dissector_table_selector_type(item->tableName_);
        if ((selector_type != FT_NONE) &&
            (item->selectorDCERPC_ == NULL))
            flags |= Qt::ItemIsEditable;
        break;
}
void Singleton::f3();{
        break;
    case FT_NONE:
        //doesn't really matter, just avoiding the assert
        return "0";
    default:
}
void Singleton::f4();{
    case colTable:
        return tr("Field");
    case colSelector:
        return tr("Value");
    case colType:
}
void Singleton::f5();{
            } else if (IS_FT_UINT(selector_type)) {
                QString type_desc = tr("Integer, base ");
                switch (get_dissector_table_param(item->tableName_)) {
                case BASE_OCT:
                    type_desc.append("8");
}
void Singleton::f6();{
        return;
    beginResetModel();
    decode_as_items_.clear();
    endResetModel();
bool DecodeAsModel::copyRow(int dst_row, int src_row)
}
void Singleton::f7();{
        switch (get_dissector_table_param(table_name)) {
        case BASE_DEC:
            entry_str = QString::number(num_val);
            break;
        case BASE_HEX:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    case FT_UINT24:
    case FT_UINT32:
        model->changed_uint_entries_ << UintPair(table_name, GPOINTER_TO_UINT(key));
        break;
    case FT_NONE:
}
void Singleton::f2();{
        ftenum_t selector_type = get_dissector_table_selector_type(item->tableName_);
        if ((selector_type != FT_NONE) &&
            (item->selectorDCERPC_ == NULL))
            flags |= Qt::ItemIsEditable;
        break;
}
void Singleton::f3();{
        break;
    case FT_NONE:
        //doesn't really matter, just avoiding the assert
        return "0";
    default:
}
void Singleton::f4();{
    case colTable:
        return tr("Field");
    case colSelector:
        return tr("Value");
    case colType:
}
void Singleton::f5();{
            } else if (IS_FT_UINT(selector_type)) {
                QString type_desc = tr("Integer, base ");
                switch (get_dissector_table_param(item->tableName_)) {
                case BASE_OCT:
                    type_desc.append("8");
}
void Singleton::f6();{
        return;
    beginResetModel();
    decode_as_items_.clear();
    endResetModel();
bool DecodeAsModel::copyRow(int dst_row, int src_row)
}
void Singleton::f7();{
        switch (get_dissector_table_param(table_name)) {
        case BASE_DEC:
            entry_str = QString::number(num_val);
            break;
        case BASE_HEX:
}
void Singleton::f8();{
    if (model == NULL)
        return;
    DecodeAsItem* item = new DecodeAsItem();
    item->tableName_ = "dcerpc.uuid";
    item->tableUIName_ = get_dissector_table_ui_name(item->tableName_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    case FT_UINT24:
    case FT_UINT32:
        model->changed_uint_entries_ << UintPair(table_name, GPOINTER_TO_UINT(key));
        break;
    case FT_NONE:
}
void Singleton::f2();{
        ftenum_t selector_type = get_dissector_table_selector_type(item->tableName_);
        if ((selector_type != FT_NONE) &&
            (item->selectorDCERPC_ == NULL))
            flags |= Qt::ItemIsEditable;
        break;
}
void Singleton::f3();{
        break;
    case FT_NONE:
        //doesn't really matter, just avoiding the assert
        return "0";
    default:
}
void Singleton::f4();{
    case colTable:
        return tr("Field");
    case colSelector:
        return tr("Value");
    case colType:
}
void Singleton::f5();{
            } else if (IS_FT_UINT(selector_type)) {
                QString type_desc = tr("Integer, base ");
                switch (get_dissector_table_param(item->tableName_)) {
                case BASE_OCT:
                    type_desc.append("8");
}
void Singleton::f6();{
        return;
    beginResetModel();
    decode_as_items_.clear();
    endResetModel();
bool DecodeAsModel::copyRow(int dst_row, int src_row)
}
void Singleton::f7();{
        switch (get_dissector_table_param(table_name)) {
        case BASE_DEC:
            entry_str = QString::number(num_val);
            break;
        case BASE_HEX:
}
void Singleton::f8();{
    if (model == NULL)
        return;
    DecodeAsItem* item = new DecodeAsItem();
    item->tableName_ = "dcerpc.uuid";
    item->tableUIName_ = get_dissector_table_ui_name(item->tableName_);
}
void Singleton::f9();{
                item->tableName_ = entry->table_name;
                item->tableUIName_ = get_dissector_table_ui_name(entry->table_name);
                //all other columns affected
                emit dataChanged(index(cur_index.row(), colSelector),
                                 index(cur_index.row(), colProtocol));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        // Only show a tooltip for the arrow.
        QHelpEvent *he = (QHelpEvent *) event;
        QStyleOptionComboBox opt;
        initStyleOption(&opt);
        QRect scr = style()->subControlRect(QStyle::CC_ComboBox, &opt, QStyle::SC_ComboBoxArrow, this);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        // Only show a tooltip for the arrow.
        QHelpEvent *he = (QHelpEvent *) event;
        QStyleOptionComboBox opt;
        initStyleOption(&opt);
        QRect scr = style()->subControlRect(QStyle::CC_ComboBox, &opt, QStyle::SC_ComboBoxArrow, this);
}
void Singleton::f2();{
    DisplayFilterEdit *df_edit = qobject_cast<DisplayFilterEdit *>(lineEdit());
    if (df_edit) df_edit->applyDisplayFilter();
void DisplayFilterCombo::setDisplayFilter(QString filter)
    lineEdit()->setText(filter);
    lineEdit()->setFocus();
}
void Singleton::f3();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f4();{
                "  top: 1px;"
                "  left: 1px;"
                "}"
                ).arg(display_mode);
    setStyleSheet(ss);
}
void Singleton::f5();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f6();{
    // cursor position to the end of the field which breaks the completer.
    // Therefore disable this and rely on dfilter_combo_add_recent being called.
    setInsertPolicy(QComboBox::NoInsert);
    // Default is Preferred.
    setSizePolicy(QSizePolicy::MinimumExpanding, sizePolicy().verticalPolicy());
}
void Singleton::f7();{
        return;
    cur_display_filter_combo->writeRecent(rf);
void DisplayFilterCombo::writeRecent(FILE *rf) {
    int i;
    for (i = 0; i < count(); i++) {
}
void Singleton::f8();{
    // popup completion. As QLineEdit's completer is designed for full line
    // completion, we cannot reuse it for word completion.
    setCompleter(0);
    // When the combobox menu is not entirely populated, pressing Enter would
    // normally append entries to the end. However, before doing so it moves the
}
void Singleton::f9();{
    // cursor position to the end of the field which breaks the completer.
    // Therefore disable this and rely on dfilter_combo_add_recent being called.
    setInsertPolicy(QComboBox::NoInsert);
    // Default is Preferred.
    setSizePolicy(QSizePolicy::MinimumExpanding, sizePolicy().verticalPolicy());
}
void Singleton::f10();{
void DisplayFilterCombo::writeRecent(FILE *rf) {
    int i;
    for (i = 0; i < count(); i++) {
        const QByteArray& filter = itemText(i).toUtf8();
        if (!filter.isEmpty()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        // Only show a tooltip for the arrow.
        QHelpEvent *he = (QHelpEvent *) event;
        QStyleOptionComboBox opt;
        initStyleOption(&opt);
        QRect scr = style()->subControlRect(QStyle::CC_ComboBox, &opt, QStyle::SC_ComboBoxArrow, this);
}
void Singleton::f2();{
    DisplayFilterEdit *df_edit = qobject_cast<DisplayFilterEdit *>(lineEdit());
    if (df_edit) df_edit->applyDisplayFilter();
void DisplayFilterCombo::setDisplayFilter(QString filter)
    lineEdit()->setText(filter);
    lineEdit()->setFocus();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        // Only show a tooltip for the arrow.
        QHelpEvent *he = (QHelpEvent *) event;
        QStyleOptionComboBox opt;
        initStyleOption(&opt);
        QRect scr = style()->subControlRect(QStyle::CC_ComboBox, &opt, QStyle::SC_ComboBoxArrow, this);
}
void Singleton::f2();{
    DisplayFilterEdit *df_edit = qobject_cast<DisplayFilterEdit *>(lineEdit());
    if (df_edit) df_edit->applyDisplayFilter();
void DisplayFilterCombo::setDisplayFilter(QString filter)
    lineEdit()->setText(filter);
    lineEdit()->setFocus();
}
void Singleton::f3();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        // Only show a tooltip for the arrow.
        QHelpEvent *he = (QHelpEvent *) event;
        QStyleOptionComboBox opt;
        initStyleOption(&opt);
        QRect scr = style()->subControlRect(QStyle::CC_ComboBox, &opt, QStyle::SC_ComboBoxArrow, this);
}
void Singleton::f2();{
    DisplayFilterEdit *df_edit = qobject_cast<DisplayFilterEdit *>(lineEdit());
    if (df_edit) df_edit->applyDisplayFilter();
void DisplayFilterCombo::setDisplayFilter(QString filter)
    lineEdit()->setText(filter);
    lineEdit()->setFocus();
}
void Singleton::f3();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f4();{
                "  top: 1px;"
                "  left: 1px;"
                "}"
                ).arg(display_mode);
    setStyleSheet(ss);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        // Only show a tooltip for the arrow.
        QHelpEvent *he = (QHelpEvent *) event;
        QStyleOptionComboBox opt;
        initStyleOption(&opt);
        QRect scr = style()->subControlRect(QStyle::CC_ComboBox, &opt, QStyle::SC_ComboBoxArrow, this);
}
void Singleton::f2();{
    DisplayFilterEdit *df_edit = qobject_cast<DisplayFilterEdit *>(lineEdit());
    if (df_edit) df_edit->applyDisplayFilter();
void DisplayFilterCombo::setDisplayFilter(QString filter)
    lineEdit()->setText(filter);
    lineEdit()->setFocus();
}
void Singleton::f3();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f4();{
                "  top: 1px;"
                "  left: 1px;"
                "}"
                ).arg(display_mode);
    setStyleSheet(ss);
}
void Singleton::f5();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        // Only show a tooltip for the arrow.
        QHelpEvent *he = (QHelpEvent *) event;
        QStyleOptionComboBox opt;
        initStyleOption(&opt);
        QRect scr = style()->subControlRect(QStyle::CC_ComboBox, &opt, QStyle::SC_ComboBoxArrow, this);
}
void Singleton::f2();{
    DisplayFilterEdit *df_edit = qobject_cast<DisplayFilterEdit *>(lineEdit());
    if (df_edit) df_edit->applyDisplayFilter();
void DisplayFilterCombo::setDisplayFilter(QString filter)
    lineEdit()->setText(filter);
    lineEdit()->setFocus();
}
void Singleton::f3();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f4();{
                "  top: 1px;"
                "  left: 1px;"
                "}"
                ).arg(display_mode);
    setStyleSheet(ss);
}
void Singleton::f5();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f6();{
    // cursor position to the end of the field which breaks the completer.
    // Therefore disable this and rely on dfilter_combo_add_recent being called.
    setInsertPolicy(QComboBox::NoInsert);
    // Default is Preferred.
    setSizePolicy(QSizePolicy::MinimumExpanding, sizePolicy().verticalPolicy());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        // Only show a tooltip for the arrow.
        QHelpEvent *he = (QHelpEvent *) event;
        QStyleOptionComboBox opt;
        initStyleOption(&opt);
        QRect scr = style()->subControlRect(QStyle::CC_ComboBox, &opt, QStyle::SC_ComboBoxArrow, this);
}
void Singleton::f2();{
    DisplayFilterEdit *df_edit = qobject_cast<DisplayFilterEdit *>(lineEdit());
    if (df_edit) df_edit->applyDisplayFilter();
void DisplayFilterCombo::setDisplayFilter(QString filter)
    lineEdit()->setText(filter);
    lineEdit()->setFocus();
}
void Singleton::f3();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f4();{
                "  top: 1px;"
                "  left: 1px;"
                "}"
                ).arg(display_mode);
    setStyleSheet(ss);
}
void Singleton::f5();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f6();{
    // cursor position to the end of the field which breaks the completer.
    // Therefore disable this and rely on dfilter_combo_add_recent being called.
    setInsertPolicy(QComboBox::NoInsert);
    // Default is Preferred.
    setSizePolicy(QSizePolicy::MinimumExpanding, sizePolicy().verticalPolicy());
}
void Singleton::f7();{
        return;
    cur_display_filter_combo->writeRecent(rf);
void DisplayFilterCombo::writeRecent(FILE *rf) {
    int i;
    for (i = 0; i < count(); i++) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        // Only show a tooltip for the arrow.
        QHelpEvent *he = (QHelpEvent *) event;
        QStyleOptionComboBox opt;
        initStyleOption(&opt);
        QRect scr = style()->subControlRect(QStyle::CC_ComboBox, &opt, QStyle::SC_ComboBoxArrow, this);
}
void Singleton::f2();{
    DisplayFilterEdit *df_edit = qobject_cast<DisplayFilterEdit *>(lineEdit());
    if (df_edit) df_edit->applyDisplayFilter();
void DisplayFilterCombo::setDisplayFilter(QString filter)
    lineEdit()->setText(filter);
    lineEdit()->setFocus();
}
void Singleton::f3();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f4();{
                "  top: 1px;"
                "  left: 1px;"
                "}"
                ).arg(display_mode);
    setStyleSheet(ss);
}
void Singleton::f5();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f6();{
    // cursor position to the end of the field which breaks the completer.
    // Therefore disable this and rely on dfilter_combo_add_recent being called.
    setInsertPolicy(QComboBox::NoInsert);
    // Default is Preferred.
    setSizePolicy(QSizePolicy::MinimumExpanding, sizePolicy().verticalPolicy());
}
void Singleton::f7();{
        return;
    cur_display_filter_combo->writeRecent(rf);
void DisplayFilterCombo::writeRecent(FILE *rf) {
    int i;
    for (i = 0; i < count(); i++) {
}
void Singleton::f8();{
    // popup completion. As QLineEdit's completer is designed for full line
    // completion, we cannot reuse it for word completion.
    setCompleter(0);
    // When the combobox menu is not entirely populated, pressing Enter would
    // normally append entries to the end. However, before doing so it moves the
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        // Only show a tooltip for the arrow.
        QHelpEvent *he = (QHelpEvent *) event;
        QStyleOptionComboBox opt;
        initStyleOption(&opt);
        QRect scr = style()->subControlRect(QStyle::CC_ComboBox, &opt, QStyle::SC_ComboBoxArrow, this);
}
void Singleton::f2();{
    DisplayFilterEdit *df_edit = qobject_cast<DisplayFilterEdit *>(lineEdit());
    if (df_edit) df_edit->applyDisplayFilter();
void DisplayFilterCombo::setDisplayFilter(QString filter)
    lineEdit()->setText(filter);
    lineEdit()->setFocus();
}
void Singleton::f3();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f4();{
                "  top: 1px;"
                "  left: 1px;"
                "}"
                ).arg(display_mode);
    setStyleSheet(ss);
}
void Singleton::f5();{
    // that means we might trigger a temporary status message so we block
    // the lineEdit's signals.
    // Another approach would be to update QComboBox->model directly.
    bool block_state = cur_display_filter_combo->lineEdit()->blockSignals(true);
    cur_display_filter_combo->addItem(filter);
}
void Singleton::f6();{
    // cursor position to the end of the field which breaks the completer.
    // Therefore disable this and rely on dfilter_combo_add_recent being called.
    setInsertPolicy(QComboBox::NoInsert);
    // Default is Preferred.
    setSizePolicy(QSizePolicy::MinimumExpanding, sizePolicy().verticalPolicy());
}
void Singleton::f7();{
        return;
    cur_display_filter_combo->writeRecent(rf);
void DisplayFilterCombo::writeRecent(FILE *rf) {
    int i;
    for (i = 0; i < count(); i++) {
}
void Singleton::f8();{
    // popup completion. As QLineEdit's completer is designed for full line
    // completion, we cannot reuse it for word completion.
    setCompleter(0);
    // When the combobox menu is not entirely populated, pressing Enter would
    // normally append entries to the end. However, before doing so it moves the
}
void Singleton::f9();{
    // cursor position to the end of the field which breaks the completer.
    // Therefore disable this and rely on dfilter_combo_add_recent being called.
    setInsertPolicy(QComboBox::NoInsert);
    // Default is Preferred.
    setSizePolicy(QSizePolicy::MinimumExpanding, sizePolicy().verticalPolicy());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
    SyntaxLineEdit::focusOutEvent(event);
bool DisplayFilterEdit::checkFilter()
    checkFilter(text());
    return syntaxState() != Invalid;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
    SyntaxLineEdit::focusOutEvent(event);
bool DisplayFilterEdit::checkFilter()
    checkFilter(text());
    return syntaxState() != Invalid;
}
void Singleton::f2();{
        }
        // Draw the right border by hand. We could try to do this in the
        // style sheet but it's a pain.
        QColor divider_color = Qt::gray;
        QColor divider_color = palette().shadow().color();
}
void Singleton::f3();{
        placeholder_text_ = QString(tr("Apply a display filter %1 <%2/>")).arg(UTF8_HORIZONTAL_ELLIPSIS)
    .arg(DEFAULT_MODIFIER);
        break;
    case DisplayFilterToEnter:
        placeholder_text_ = QString(tr("Enter a display filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f4();{
    QAction * first = menu->actions().at(0);
    QAction * na = new QAction(tr("Left align buttons"), this);
    na->setCheckable(true);
    na->setChecked(leftAlignActions_);
    connect(na, &QAction::triggered, this, &DisplayFilterEdit::triggerAlignementAction);
}
void Singleton::f5();{
        QColor divider_color = palette().shadow().color();
        QPainter painter(this);
        painter.setPen(divider_color);
        QRect cr = contentsRect();
        int xpos = 0;
}
void Singleton::f6();{
        filterText = data->filter();
    }
    /* Moving items around */
    if (filterText.length() > 0) {
        if (event->source() != this)
}
void Singleton::f7();{
            event->mimeData()->hasFormat(WiresharkMimeData::DisplayFilterMimeType)) {
        if (event->source() != this)
        {
            event->setDropAction(Qt::CopyAction);
            event->accept();
}
void Singleton::f8();{
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()) ||
            event->mimeData()->hasFormat(WiresharkMimeData::DisplayFilterMimeType)) {
        if (event->source() != this)
        {
            event->setDropAction(Qt::CopyAction);
}
void Singleton::f9();{
            wsApp->pushStatus(WiresharkApplication::FilterSyntax, cursor_field_msg);
        }
    }
    if (field_word.length() < 1) {
        completion_model_->setStringList(QStringList());
}
void Singleton::f10();{
    if (syntaxState() == Valid) {
        wsApp->popStatus(WiresharkApplication::FilterSyntax);
        header_field_info *hfinfo = proto_registrar_get_byname(field_word.toUtf8().constData());
        if (hfinfo) {
            QString cursor_field_msg = QString("%1: %2")
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
    SyntaxLineEdit::focusOutEvent(event);
bool DisplayFilterEdit::checkFilter()
    checkFilter(text());
    return syntaxState() != Invalid;
}
void Singleton::f2();{
        }
        // Draw the right border by hand. We could try to do this in the
        // style sheet but it's a pain.
        QColor divider_color = Qt::gray;
        QColor divider_color = palette().shadow().color();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
    SyntaxLineEdit::focusOutEvent(event);
bool DisplayFilterEdit::checkFilter()
    checkFilter(text());
    return syntaxState() != Invalid;
}
void Singleton::f2();{
        }
        // Draw the right border by hand. We could try to do this in the
        // style sheet but it's a pain.
        QColor divider_color = Qt::gray;
        QColor divider_color = palette().shadow().color();
}
void Singleton::f3();{
        placeholder_text_ = QString(tr("Apply a display filter %1 <%2/>")).arg(UTF8_HORIZONTAL_ELLIPSIS)
    .arg(DEFAULT_MODIFIER);
        break;
    case DisplayFilterToEnter:
        placeholder_text_ = QString(tr("Enter a display filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
    SyntaxLineEdit::focusOutEvent(event);
bool DisplayFilterEdit::checkFilter()
    checkFilter(text());
    return syntaxState() != Invalid;
}
void Singleton::f2();{
        }
        // Draw the right border by hand. We could try to do this in the
        // style sheet but it's a pain.
        QColor divider_color = Qt::gray;
        QColor divider_color = palette().shadow().color();
}
void Singleton::f3();{
        placeholder_text_ = QString(tr("Apply a display filter %1 <%2/>")).arg(UTF8_HORIZONTAL_ELLIPSIS)
    .arg(DEFAULT_MODIFIER);
        break;
    case DisplayFilterToEnter:
        placeholder_text_ = QString(tr("Enter a display filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f4();{
    QAction * first = menu->actions().at(0);
    QAction * na = new QAction(tr("Left align buttons"), this);
    na->setCheckable(true);
    na->setChecked(leftAlignActions_);
    connect(na, &QAction::triggered, this, &DisplayFilterEdit::triggerAlignementAction);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
    SyntaxLineEdit::focusOutEvent(event);
bool DisplayFilterEdit::checkFilter()
    checkFilter(text());
    return syntaxState() != Invalid;
}
void Singleton::f2();{
        }
        // Draw the right border by hand. We could try to do this in the
        // style sheet but it's a pain.
        QColor divider_color = Qt::gray;
        QColor divider_color = palette().shadow().color();
}
void Singleton::f3();{
        placeholder_text_ = QString(tr("Apply a display filter %1 <%2/>")).arg(UTF8_HORIZONTAL_ELLIPSIS)
    .arg(DEFAULT_MODIFIER);
        break;
    case DisplayFilterToEnter:
        placeholder_text_ = QString(tr("Enter a display filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f4();{
    QAction * first = menu->actions().at(0);
    QAction * na = new QAction(tr("Left align buttons"), this);
    na->setCheckable(true);
    na->setChecked(leftAlignActions_);
    connect(na, &QAction::triggered, this, &DisplayFilterEdit::triggerAlignementAction);
}
void Singleton::f5();{
        QColor divider_color = palette().shadow().color();
        QPainter painter(this);
        painter.setPen(divider_color);
        QRect cr = contentsRect();
        int xpos = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
    SyntaxLineEdit::focusOutEvent(event);
bool DisplayFilterEdit::checkFilter()
    checkFilter(text());
    return syntaxState() != Invalid;
}
void Singleton::f2();{
        }
        // Draw the right border by hand. We could try to do this in the
        // style sheet but it's a pain.
        QColor divider_color = Qt::gray;
        QColor divider_color = palette().shadow().color();
}
void Singleton::f3();{
        placeholder_text_ = QString(tr("Apply a display filter %1 <%2/>")).arg(UTF8_HORIZONTAL_ELLIPSIS)
    .arg(DEFAULT_MODIFIER);
        break;
    case DisplayFilterToEnter:
        placeholder_text_ = QString(tr("Enter a display filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f4();{
    QAction * first = menu->actions().at(0);
    QAction * na = new QAction(tr("Left align buttons"), this);
    na->setCheckable(true);
    na->setChecked(leftAlignActions_);
    connect(na, &QAction::triggered, this, &DisplayFilterEdit::triggerAlignementAction);
}
void Singleton::f5();{
        QColor divider_color = palette().shadow().color();
        QPainter painter(this);
        painter.setPen(divider_color);
        QRect cr = contentsRect();
        int xpos = 0;
}
void Singleton::f6();{
        filterText = data->filter();
    }
    /* Moving items around */
    if (filterText.length() > 0) {
        if (event->source() != this)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
    SyntaxLineEdit::focusOutEvent(event);
bool DisplayFilterEdit::checkFilter()
    checkFilter(text());
    return syntaxState() != Invalid;
}
void Singleton::f2();{
        }
        // Draw the right border by hand. We could try to do this in the
        // style sheet but it's a pain.
        QColor divider_color = Qt::gray;
        QColor divider_color = palette().shadow().color();
}
void Singleton::f3();{
        placeholder_text_ = QString(tr("Apply a display filter %1 <%2/>")).arg(UTF8_HORIZONTAL_ELLIPSIS)
    .arg(DEFAULT_MODIFIER);
        break;
    case DisplayFilterToEnter:
        placeholder_text_ = QString(tr("Enter a display filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f4();{
    QAction * first = menu->actions().at(0);
    QAction * na = new QAction(tr("Left align buttons"), this);
    na->setCheckable(true);
    na->setChecked(leftAlignActions_);
    connect(na, &QAction::triggered, this, &DisplayFilterEdit::triggerAlignementAction);
}
void Singleton::f5();{
        QColor divider_color = palette().shadow().color();
        QPainter painter(this);
        painter.setPen(divider_color);
        QRect cr = contentsRect();
        int xpos = 0;
}
void Singleton::f6();{
        filterText = data->filter();
    }
    /* Moving items around */
    if (filterText.length() > 0) {
        if (event->source() != this)
}
void Singleton::f7();{
            event->mimeData()->hasFormat(WiresharkMimeData::DisplayFilterMimeType)) {
        if (event->source() != this)
        {
            event->setDropAction(Qt::CopyAction);
            event->accept();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
    SyntaxLineEdit::focusOutEvent(event);
bool DisplayFilterEdit::checkFilter()
    checkFilter(text());
    return syntaxState() != Invalid;
}
void Singleton::f2();{
        }
        // Draw the right border by hand. We could try to do this in the
        // style sheet but it's a pain.
        QColor divider_color = Qt::gray;
        QColor divider_color = palette().shadow().color();
}
void Singleton::f3();{
        placeholder_text_ = QString(tr("Apply a display filter %1 <%2/>")).arg(UTF8_HORIZONTAL_ELLIPSIS)
    .arg(DEFAULT_MODIFIER);
        break;
    case DisplayFilterToEnter:
        placeholder_text_ = QString(tr("Enter a display filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f4();{
    QAction * first = menu->actions().at(0);
    QAction * na = new QAction(tr("Left align buttons"), this);
    na->setCheckable(true);
    na->setChecked(leftAlignActions_);
    connect(na, &QAction::triggered, this, &DisplayFilterEdit::triggerAlignementAction);
}
void Singleton::f5();{
        QColor divider_color = palette().shadow().color();
        QPainter painter(this);
        painter.setPen(divider_color);
        QRect cr = contentsRect();
        int xpos = 0;
}
void Singleton::f6();{
        filterText = data->filter();
    }
    /* Moving items around */
    if (filterText.length() > 0) {
        if (event->source() != this)
}
void Singleton::f7();{
            event->mimeData()->hasFormat(WiresharkMimeData::DisplayFilterMimeType)) {
        if (event->source() != this)
        {
            event->setDropAction(Qt::CopyAction);
            event->accept();
}
void Singleton::f8();{
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()) ||
            event->mimeData()->hasFormat(WiresharkMimeData::DisplayFilterMimeType)) {
        if (event->source() != this)
        {
            event->setDropAction(Qt::CopyAction);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
    SyntaxLineEdit::focusOutEvent(event);
bool DisplayFilterEdit::checkFilter()
    checkFilter(text());
    return syntaxState() != Invalid;
}
void Singleton::f2();{
        }
        // Draw the right border by hand. We could try to do this in the
        // style sheet but it's a pain.
        QColor divider_color = Qt::gray;
        QColor divider_color = palette().shadow().color();
}
void Singleton::f3();{
        placeholder_text_ = QString(tr("Apply a display filter %1 <%2/>")).arg(UTF8_HORIZONTAL_ELLIPSIS)
    .arg(DEFAULT_MODIFIER);
        break;
    case DisplayFilterToEnter:
        placeholder_text_ = QString(tr("Enter a display filter %1")).arg(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f4();{
    QAction * first = menu->actions().at(0);
    QAction * na = new QAction(tr("Left align buttons"), this);
    na->setCheckable(true);
    na->setChecked(leftAlignActions_);
    connect(na, &QAction::triggered, this, &DisplayFilterEdit::triggerAlignementAction);
}
void Singleton::f5();{
        QColor divider_color = palette().shadow().color();
        QPainter painter(this);
        painter.setPen(divider_color);
        QRect cr = contentsRect();
        int xpos = 0;
}
void Singleton::f6();{
        filterText = data->filter();
    }
    /* Moving items around */
    if (filterText.length() > 0) {
        if (event->source() != this)
}
void Singleton::f7();{
            event->mimeData()->hasFormat(WiresharkMimeData::DisplayFilterMimeType)) {
        if (event->source() != this)
        {
            event->setDropAction(Qt::CopyAction);
            event->accept();
}
void Singleton::f8();{
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()) ||
            event->mimeData()->hasFormat(WiresharkMimeData::DisplayFilterMimeType)) {
        if (event->source() != this)
        {
            event->setDropAction(Qt::CopyAction);
}
void Singleton::f9();{
            wsApp->pushStatus(WiresharkApplication::FilterSyntax, cursor_field_msg);
        }
    }
    if (field_word.length() < 1) {
        completion_model_->setStringList(QStringList());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            break;
        case contains_op_:
            li->setHidden(!ftype_can_contains(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_contains(FT_BYTES)));
            break;
        case matches_op_:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            break;
        case contains_op_:
            li->setHidden(!ftype_can_contains(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_contains(FT_BYTES)));
            break;
        case matches_op_:
}
void Singleton::f2();{
void DisplayFilterExpressionDialog::on_buttonBox_accepted()
    emit insertDisplayFilter(ui->displayFilterLineEdit->text());
void DisplayFilterExpressionDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILTER_EXPRESSION_DIALOG);
 * Editor modelines
}
void Singleton::f3();{
                        fillEnumIntValues(vals, base);
                    }
                }
                break;
            }
}
void Singleton::f4();{
        void *field_cookie;
        int proto_id = proto_ti->data(0, Qt::UserRole).toInt();
        QList <QTreeWidgetItem *> field_list;
        for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo != NULL;
             hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
}
void Singleton::f5();{
    }
    wsApp->processEvents(QEventLoop::ExcludeUserInputEvents | QEventLoop::ExcludeSocketNotifiers, 1);
    ui->fieldTreeWidget->sortByColumn(0, Qt::AscendingOrder);
    updateWidgets();
void DisplayFilterExpressionDialog::updateWidgets()
}
void Singleton::f6();{
    }
    hint.append("</i></small>");
    ui->hintLabel->setText(hint);
    QPushButton *ok_bt = ui->buttonBox->button(QDialogButtonBox::Ok);
    if (ok_bt) {
}
void Singleton::f7();{
    if (field_) {
        filter = field_;
        QListWidgetItem *rli = ui->relationListWidget->currentItem();
        if (rli && rli->type() != present_op_) {
            value_enable = true;
}
void Singleton::f8();{
    setAttribute(Qt::WA_DeleteOnClose, true);
    setWindowTitle(wsApp->windowTitleString(tr("Display Filter Expression")));
    setWindowIcon(wsApp->normalIcon());
    proto_initialize_all_prefixes();
    ui->fieldTreeWidget->setToolTip(ui->fieldLabel->toolTip());
}
void Singleton::f9();{
    if (all_show) {
        // Select "==" if it's present and we have a value, "is present" otherwise
        int row = ui->relationListWidget->count() > 1 && ui->enumListWidget->count() > 0 ? 1 : 0;
        ui->relationListWidget->setCurrentRow(row);
    }
}
void Singleton::f10();{
            li->setHidden(!ftype_can_lt(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_lt(FT_BYTES)));
            break;
        case ge_op_:
            li->setHidden(!ftype_can_ge(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_ge(FT_BYTES)));
            break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            break;
        case contains_op_:
            li->setHidden(!ftype_can_contains(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_contains(FT_BYTES)));
            break;
        case matches_op_:
}
void Singleton::f2();{
void DisplayFilterExpressionDialog::on_buttonBox_accepted()
    emit insertDisplayFilter(ui->displayFilterLineEdit->text());
void DisplayFilterExpressionDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILTER_EXPRESSION_DIALOG);
 * Editor modelines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            break;
        case contains_op_:
            li->setHidden(!ftype_can_contains(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_contains(FT_BYTES)));
            break;
        case matches_op_:
}
void Singleton::f2();{
void DisplayFilterExpressionDialog::on_buttonBox_accepted()
    emit insertDisplayFilter(ui->displayFilterLineEdit->text());
void DisplayFilterExpressionDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILTER_EXPRESSION_DIALOG);
 * Editor modelines
}
void Singleton::f3();{
                        fillEnumIntValues(vals, base);
                    }
                }
                break;
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            break;
        case contains_op_:
            li->setHidden(!ftype_can_contains(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_contains(FT_BYTES)));
            break;
        case matches_op_:
}
void Singleton::f2();{
void DisplayFilterExpressionDialog::on_buttonBox_accepted()
    emit insertDisplayFilter(ui->displayFilterLineEdit->text());
void DisplayFilterExpressionDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILTER_EXPRESSION_DIALOG);
 * Editor modelines
}
void Singleton::f3();{
                        fillEnumIntValues(vals, base);
                    }
                }
                break;
            }
}
void Singleton::f4();{
        void *field_cookie;
        int proto_id = proto_ti->data(0, Qt::UserRole).toInt();
        QList <QTreeWidgetItem *> field_list;
        for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo != NULL;
             hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            break;
        case contains_op_:
            li->setHidden(!ftype_can_contains(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_contains(FT_BYTES)));
            break;
        case matches_op_:
}
void Singleton::f2();{
void DisplayFilterExpressionDialog::on_buttonBox_accepted()
    emit insertDisplayFilter(ui->displayFilterLineEdit->text());
void DisplayFilterExpressionDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILTER_EXPRESSION_DIALOG);
 * Editor modelines
}
void Singleton::f3();{
                        fillEnumIntValues(vals, base);
                    }
                }
                break;
            }
}
void Singleton::f4();{
        void *field_cookie;
        int proto_id = proto_ti->data(0, Qt::UserRole).toInt();
        QList <QTreeWidgetItem *> field_list;
        for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo != NULL;
             hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
}
void Singleton::f5();{
    }
    wsApp->processEvents(QEventLoop::ExcludeUserInputEvents | QEventLoop::ExcludeSocketNotifiers, 1);
    ui->fieldTreeWidget->sortByColumn(0, Qt::AscendingOrder);
    updateWidgets();
void DisplayFilterExpressionDialog::updateWidgets()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            break;
        case contains_op_:
            li->setHidden(!ftype_can_contains(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_contains(FT_BYTES)));
            break;
        case matches_op_:
}
void Singleton::f2();{
void DisplayFilterExpressionDialog::on_buttonBox_accepted()
    emit insertDisplayFilter(ui->displayFilterLineEdit->text());
void DisplayFilterExpressionDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILTER_EXPRESSION_DIALOG);
 * Editor modelines
}
void Singleton::f3();{
                        fillEnumIntValues(vals, base);
                    }
                }
                break;
            }
}
void Singleton::f4();{
        void *field_cookie;
        int proto_id = proto_ti->data(0, Qt::UserRole).toInt();
        QList <QTreeWidgetItem *> field_list;
        for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo != NULL;
             hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
}
void Singleton::f5();{
    }
    wsApp->processEvents(QEventLoop::ExcludeUserInputEvents | QEventLoop::ExcludeSocketNotifiers, 1);
    ui->fieldTreeWidget->sortByColumn(0, Qt::AscendingOrder);
    updateWidgets();
void DisplayFilterExpressionDialog::updateWidgets()
}
void Singleton::f6();{
    }
    hint.append("</i></small>");
    ui->hintLabel->setText(hint);
    QPushButton *ok_bt = ui->buttonBox->button(QDialogButtonBox::Ok);
    if (ok_bt) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            break;
        case contains_op_:
            li->setHidden(!ftype_can_contains(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_contains(FT_BYTES)));
            break;
        case matches_op_:
}
void Singleton::f2();{
void DisplayFilterExpressionDialog::on_buttonBox_accepted()
    emit insertDisplayFilter(ui->displayFilterLineEdit->text());
void DisplayFilterExpressionDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILTER_EXPRESSION_DIALOG);
 * Editor modelines
}
void Singleton::f3();{
                        fillEnumIntValues(vals, base);
                    }
                }
                break;
            }
}
void Singleton::f4();{
        void *field_cookie;
        int proto_id = proto_ti->data(0, Qt::UserRole).toInt();
        QList <QTreeWidgetItem *> field_list;
        for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo != NULL;
             hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
}
void Singleton::f5();{
    }
    wsApp->processEvents(QEventLoop::ExcludeUserInputEvents | QEventLoop::ExcludeSocketNotifiers, 1);
    ui->fieldTreeWidget->sortByColumn(0, Qt::AscendingOrder);
    updateWidgets();
void DisplayFilterExpressionDialog::updateWidgets()
}
void Singleton::f6();{
    }
    hint.append("</i></small>");
    ui->hintLabel->setText(hint);
    QPushButton *ok_bt = ui->buttonBox->button(QDialogButtonBox::Ok);
    if (ok_bt) {
}
void Singleton::f7();{
    if (field_) {
        filter = field_;
        QListWidgetItem *rli = ui->relationListWidget->currentItem();
        if (rli && rli->type() != present_op_) {
            value_enable = true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            break;
        case contains_op_:
            li->setHidden(!ftype_can_contains(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_contains(FT_BYTES)));
            break;
        case matches_op_:
}
void Singleton::f2();{
void DisplayFilterExpressionDialog::on_buttonBox_accepted()
    emit insertDisplayFilter(ui->displayFilterLineEdit->text());
void DisplayFilterExpressionDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILTER_EXPRESSION_DIALOG);
 * Editor modelines
}
void Singleton::f3();{
                        fillEnumIntValues(vals, base);
                    }
                }
                break;
            }
}
void Singleton::f4();{
        void *field_cookie;
        int proto_id = proto_ti->data(0, Qt::UserRole).toInt();
        QList <QTreeWidgetItem *> field_list;
        for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo != NULL;
             hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
}
void Singleton::f5();{
    }
    wsApp->processEvents(QEventLoop::ExcludeUserInputEvents | QEventLoop::ExcludeSocketNotifiers, 1);
    ui->fieldTreeWidget->sortByColumn(0, Qt::AscendingOrder);
    updateWidgets();
void DisplayFilterExpressionDialog::updateWidgets()
}
void Singleton::f6();{
    }
    hint.append("</i></small>");
    ui->hintLabel->setText(hint);
    QPushButton *ok_bt = ui->buttonBox->button(QDialogButtonBox::Ok);
    if (ok_bt) {
}
void Singleton::f7();{
    if (field_) {
        filter = field_;
        QListWidgetItem *rli = ui->relationListWidget->currentItem();
        if (rli && rli->type() != present_op_) {
            value_enable = true;
}
void Singleton::f8();{
    setAttribute(Qt::WA_DeleteOnClose, true);
    setWindowTitle(wsApp->windowTitleString(tr("Display Filter Expression")));
    setWindowIcon(wsApp->normalIcon());
    proto_initialize_all_prefixes();
    ui->fieldTreeWidget->setToolTip(ui->fieldLabel->toolTip());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            break;
        case contains_op_:
            li->setHidden(!ftype_can_contains(ftype_) && !(ftype_can_slice(ftype_) && ftype_can_contains(FT_BYTES)));
            break;
        case matches_op_:
}
void Singleton::f2();{
void DisplayFilterExpressionDialog::on_buttonBox_accepted()
    emit insertDisplayFilter(ui->displayFilterLineEdit->text());
void DisplayFilterExpressionDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILTER_EXPRESSION_DIALOG);
 * Editor modelines
}
void Singleton::f3();{
                        fillEnumIntValues(vals, base);
                    }
                }
                break;
            }
}
void Singleton::f4();{
        void *field_cookie;
        int proto_id = proto_ti->data(0, Qt::UserRole).toInt();
        QList <QTreeWidgetItem *> field_list;
        for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo != NULL;
             hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
}
void Singleton::f5();{
    }
    wsApp->processEvents(QEventLoop::ExcludeUserInputEvents | QEventLoop::ExcludeSocketNotifiers, 1);
    ui->fieldTreeWidget->sortByColumn(0, Qt::AscendingOrder);
    updateWidgets();
void DisplayFilterExpressionDialog::updateWidgets()
}
void Singleton::f6();{
    }
    hint.append("</i></small>");
    ui->hintLabel->setText(hint);
    QPushButton *ok_bt = ui->buttonBox->button(QDialogButtonBox::Ok);
    if (ok_bt) {
}
void Singleton::f7();{
    if (field_) {
        filter = field_;
        QListWidgetItem *rli = ui->relationListWidget->currentItem();
        if (rli && rli->type() != present_op_) {
            value_enable = true;
}
void Singleton::f8();{
    setAttribute(Qt::WA_DeleteOnClose, true);
    setWindowTitle(wsApp->windowTitleString(tr("Display Filter Expression")));
    setWindowIcon(wsApp->normalIcon());
    proto_initialize_all_prefixes();
    ui->fieldTreeWidget->setToolTip(ui->fieldLabel->toolTip());
}
void Singleton::f9();{
    if (all_show) {
        // Select "==" if it's present and we have a value, "is present" otherwise
        int row = ui->relationListWidget->count() > 1 && ui->enumListWidget->count() > 0 ? 1 : 0;
        ui->relationListWidget->setCurrentRow(row);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
    return QModelIndex();
QModelIndex DissectorTablesModel::index(int row, int column, const QModelIndex& parent) const
    if (!hasIndex(row, column, parent))
        return QModelIndex();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
    return QModelIndex();
QModelIndex DissectorTablesModel::index(int row, int column, const QModelIndex& parent) const
    if (!hasIndex(row, column, parent))
        return QModelIndex();
}
void Singleton::f2();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f3();{
    tables.string_table = new DissectorTablesItem(tr(STRING_TABLE_NAME), QString(""), root_);
    root_->prependChild(tables.string_table);
    dissector_all_tables_foreach_table(gatherTableNames, &tables, NULL);
    DissectorTablesItem* heuristic_table = new DissectorTablesItem(tr(HEURISTIC_TABLE_NAME), QString(""), root_);
    root_->prependChild(heuristic_table);
}
void Singleton::f4();{
            }
        }
    }
    emit headerDataChanged(Qt::Vertical, 0, 1);
 * Editor modelines
}
void Singleton::f5();{
                shortName_ = tr("Dissector");
            } else if (table.compare(HEURISTIC_TABLE_NAME) == 0) {
                tableName_ = tr("Protocol");
                shortName_ = tr("Short Name");
            }
}
void Singleton::f6();{
    switch (selector_type) {
    case FT_UINT8:
    case FT_UINT16:
    case FT_UINT24:
    case FT_UINT32:
}
void Singleton::f7();{
    if ((!index.isValid()) || (role != Qt::DisplayRole))
        return QVariant();
    DissectorTablesItem* item = static_cast<DissectorTablesItem*>(index.internalPointer());
    if (item == NULL)
        return QVariant();
}
void Singleton::f8();{
    DissectorTablesItem* integer_table;
    DissectorTablesItem* string_table;
static void gatherTableNames(const char *short_name, const char *table_name, gpointer model_ptr)
    struct tables_root* tables = (struct tables_root*)model_ptr;
    if (model_ptr == NULL)
}
void Singleton::f9();{
    if (currentIndex.isValid() && currentIndex.parent().isValid()) {
        QString table;
        if (currentIndex.parent().parent().isValid()) {
            table = data(index(currentIndex.parent().parent().row(), DissectorTablesModel::colTableName), Qt::DisplayRole).toString();
            if ((table.compare(CUSTOM_TABLE_NAME) == 0) ||
}
void Singleton::f10();{
        dt_ti = new DissectorTablesItem(table_name, short_name, tables->string_table);
        tables->string_table->prependChild(dt_ti);
        break;
    case FT_BYTES:
        dt_ti = new DissectorTablesItem(table_name, short_name, tables->custom_table);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
    return QModelIndex();
QModelIndex DissectorTablesModel::index(int row, int column, const QModelIndex& parent) const
    if (!hasIndex(row, column, parent))
        return QModelIndex();
}
void Singleton::f2();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
    return QModelIndex();
QModelIndex DissectorTablesModel::index(int row, int column, const QModelIndex& parent) const
    if (!hasIndex(row, column, parent))
        return QModelIndex();
}
void Singleton::f2();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f3();{
    tables.string_table = new DissectorTablesItem(tr(STRING_TABLE_NAME), QString(""), root_);
    root_->prependChild(tables.string_table);
    dissector_all_tables_foreach_table(gatherTableNames, &tables, NULL);
    DissectorTablesItem* heuristic_table = new DissectorTablesItem(tr(HEURISTIC_TABLE_NAME), QString(""), root_);
    root_->prependChild(heuristic_table);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
    return QModelIndex();
QModelIndex DissectorTablesModel::index(int row, int column, const QModelIndex& parent) const
    if (!hasIndex(row, column, parent))
        return QModelIndex();
}
void Singleton::f2();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f3();{
    tables.string_table = new DissectorTablesItem(tr(STRING_TABLE_NAME), QString(""), root_);
    root_->prependChild(tables.string_table);
    dissector_all_tables_foreach_table(gatherTableNames, &tables, NULL);
    DissectorTablesItem* heuristic_table = new DissectorTablesItem(tr(HEURISTIC_TABLE_NAME), QString(""), root_);
    root_->prependChild(heuristic_table);
}
void Singleton::f4();{
            }
        }
    }
    emit headerDataChanged(Qt::Vertical, 0, 1);
 * Editor modelines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
    return QModelIndex();
QModelIndex DissectorTablesModel::index(int row, int column, const QModelIndex& parent) const
    if (!hasIndex(row, column, parent))
        return QModelIndex();
}
void Singleton::f2();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f3();{
    tables.string_table = new DissectorTablesItem(tr(STRING_TABLE_NAME), QString(""), root_);
    root_->prependChild(tables.string_table);
    dissector_all_tables_foreach_table(gatherTableNames, &tables, NULL);
    DissectorTablesItem* heuristic_table = new DissectorTablesItem(tr(HEURISTIC_TABLE_NAME), QString(""), root_);
    root_->prependChild(heuristic_table);
}
void Singleton::f4();{
            }
        }
    }
    emit headerDataChanged(Qt::Vertical, 0, 1);
 * Editor modelines
}
void Singleton::f5();{
                shortName_ = tr("Dissector");
            } else if (table.compare(HEURISTIC_TABLE_NAME) == 0) {
                tableName_ = tr("Protocol");
                shortName_ = tr("Short Name");
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
    return QModelIndex();
QModelIndex DissectorTablesModel::index(int row, int column, const QModelIndex& parent) const
    if (!hasIndex(row, column, parent))
        return QModelIndex();
}
void Singleton::f2();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f3();{
    tables.string_table = new DissectorTablesItem(tr(STRING_TABLE_NAME), QString(""), root_);
    root_->prependChild(tables.string_table);
    dissector_all_tables_foreach_table(gatherTableNames, &tables, NULL);
    DissectorTablesItem* heuristic_table = new DissectorTablesItem(tr(HEURISTIC_TABLE_NAME), QString(""), root_);
    root_->prependChild(heuristic_table);
}
void Singleton::f4();{
            }
        }
    }
    emit headerDataChanged(Qt::Vertical, 0, 1);
 * Editor modelines
}
void Singleton::f5();{
                shortName_ = tr("Dissector");
            } else if (table.compare(HEURISTIC_TABLE_NAME) == 0) {
                tableName_ = tr("Protocol");
                shortName_ = tr("Short Name");
            }
}
void Singleton::f6();{
    switch (selector_type) {
    case FT_UINT8:
    case FT_UINT16:
    case FT_UINT24:
    case FT_UINT32:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
    return QModelIndex();
QModelIndex DissectorTablesModel::index(int row, int column, const QModelIndex& parent) const
    if (!hasIndex(row, column, parent))
        return QModelIndex();
}
void Singleton::f2();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f3();{
    tables.string_table = new DissectorTablesItem(tr(STRING_TABLE_NAME), QString(""), root_);
    root_->prependChild(tables.string_table);
    dissector_all_tables_foreach_table(gatherTableNames, &tables, NULL);
    DissectorTablesItem* heuristic_table = new DissectorTablesItem(tr(HEURISTIC_TABLE_NAME), QString(""), root_);
    root_->prependChild(heuristic_table);
}
void Singleton::f4();{
            }
        }
    }
    emit headerDataChanged(Qt::Vertical, 0, 1);
 * Editor modelines
}
void Singleton::f5();{
                shortName_ = tr("Dissector");
            } else if (table.compare(HEURISTIC_TABLE_NAME) == 0) {
                tableName_ = tr("Protocol");
                shortName_ = tr("Short Name");
            }
}
void Singleton::f6();{
    switch (selector_type) {
    case FT_UINT8:
    case FT_UINT16:
    case FT_UINT24:
    case FT_UINT32:
}
void Singleton::f7();{
    if ((!index.isValid()) || (role != Qt::DisplayRole))
        return QVariant();
    DissectorTablesItem* item = static_cast<DissectorTablesItem*>(index.internalPointer());
    if (item == NULL)
        return QVariant();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
    return QModelIndex();
QModelIndex DissectorTablesModel::index(int row, int column, const QModelIndex& parent) const
    if (!hasIndex(row, column, parent))
        return QModelIndex();
}
void Singleton::f2();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f3();{
    tables.string_table = new DissectorTablesItem(tr(STRING_TABLE_NAME), QString(""), root_);
    root_->prependChild(tables.string_table);
    dissector_all_tables_foreach_table(gatherTableNames, &tables, NULL);
    DissectorTablesItem* heuristic_table = new DissectorTablesItem(tr(HEURISTIC_TABLE_NAME), QString(""), root_);
    root_->prependChild(heuristic_table);
}
void Singleton::f4();{
            }
        }
    }
    emit headerDataChanged(Qt::Vertical, 0, 1);
 * Editor modelines
}
void Singleton::f5();{
                shortName_ = tr("Dissector");
            } else if (table.compare(HEURISTIC_TABLE_NAME) == 0) {
                tableName_ = tr("Protocol");
                shortName_ = tr("Short Name");
            }
}
void Singleton::f6();{
    switch (selector_type) {
    case FT_UINT8:
    case FT_UINT16:
    case FT_UINT24:
    case FT_UINT32:
}
void Singleton::f7();{
    if ((!index.isValid()) || (role != Qt::DisplayRole))
        return QVariant();
    DissectorTablesItem* item = static_cast<DissectorTablesItem*>(index.internalPointer());
    if (item == NULL)
        return QVariant();
}
void Singleton::f8();{
    DissectorTablesItem* integer_table;
    DissectorTablesItem* string_table;
static void gatherTableNames(const char *short_name, const char *table_name, gpointer model_ptr)
    struct tables_root* tables = (struct tables_root*)model_ptr;
    if (model_ptr == NULL)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
    return QModelIndex();
QModelIndex DissectorTablesModel::index(int row, int column, const QModelIndex& parent) const
    if (!hasIndex(row, column, parent))
        return QModelIndex();
}
void Singleton::f2();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f3();{
    tables.string_table = new DissectorTablesItem(tr(STRING_TABLE_NAME), QString(""), root_);
    root_->prependChild(tables.string_table);
    dissector_all_tables_foreach_table(gatherTableNames, &tables, NULL);
    DissectorTablesItem* heuristic_table = new DissectorTablesItem(tr(HEURISTIC_TABLE_NAME), QString(""), root_);
    root_->prependChild(heuristic_table);
}
void Singleton::f4();{
            }
        }
    }
    emit headerDataChanged(Qt::Vertical, 0, 1);
 * Editor modelines
}
void Singleton::f5();{
                shortName_ = tr("Dissector");
            } else if (table.compare(HEURISTIC_TABLE_NAME) == 0) {
                tableName_ = tr("Protocol");
                shortName_ = tr("Short Name");
            }
}
void Singleton::f6();{
    switch (selector_type) {
    case FT_UINT8:
    case FT_UINT16:
    case FT_UINT24:
    case FT_UINT32:
}
void Singleton::f7();{
    if ((!index.isValid()) || (role != Qt::DisplayRole))
        return QVariant();
    DissectorTablesItem* item = static_cast<DissectorTablesItem*>(index.internalPointer());
    if (item == NULL)
        return QVariant();
}
void Singleton::f8();{
    DissectorTablesItem* integer_table;
    DissectorTablesItem* string_table;
static void gatherTableNames(const char *short_name, const char *table_name, gpointer model_ptr)
    struct tables_root* tables = (struct tables_root*)model_ptr;
    if (model_ptr == NULL)
}
void Singleton::f9();{
    if (currentIndex.isValid() && currentIndex.parent().isValid()) {
        QString table;
        if (currentIndex.parent().parent().isValid()) {
            table = data(index(currentIndex.parent().parent().row(), DissectorTablesModel::colTableName), Qt::DisplayRole).toString();
            if ((table.compare(CUSTOM_TABLE_NAME) == 0) ||
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    {
        childCounter--;
    }
    else if (event->type() == QEvent::ChildPolished)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    {
        childCounter--;
    }
    else if (event->type() == QEvent::ChildPolished)
    {
}
void Singleton::f2();{
        return;
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
}
void Singleton::f3();{
    QToolButton *ext_button = findChild<QToolButton*>();
    if (ext_button) {
        ext_button->setIcon(QIcon());
        ext_button->setText(UTF8_RIGHT_POINTING_DOUBLE_ANGLE_QUOTATION_MARK);
    }
}
void Singleton::f4();{
            {
                bool success = false;
                widget->property(drag_drop_toolbar_action_).toInt(&success);
                if (! success)
                {
}
void Singleton::f5();{
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
        {
}
void Singleton::f6();{
            moveToolbarItems(oldPos, newPos);
            QAction * moveAction = actions().at(oldPos);
            emit actionMoved(moveAction, oldPos, newPos);
        }
        if (event->source() == this) {
}
void Singleton::f7();{
            drag->setMimeData(temd);
            qreal dpr = window()->windowHandle()->devicePixelRatio();
            QPixmap pixmap(lbl->size() * dpr);
            pixmap.setDevicePixelRatio(dpr);
            lbl->render(&pixmap);
}
void Singleton::f8();{
                 > QApplication::startDragDistance())
        {
            if (! qobject_cast<QToolButton *>(elem) || ! elem->property(drag_drop_toolbar_action_).isValid())
                return QToolBar::eventFilter(obj, event);
            WiresharkMimeData * temd = createMimeData(((QToolButton *)elem)->text(), elem->property(drag_drop_toolbar_action_).toInt());
}
void Singleton::f9();{
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        const ToolbarEntryMimeData * data = qobject_cast<const ToolbarEntryMimeData *>(event->mimeData());
        int oldPos = data->position();
        int newPos = -1;
}
void Singleton::f10();{
    // Each QToolBar has a QToolBarExtension button. Its icon looks
    // terrible. We might want to create our own icon, but the double
    // angle quote is a similar, nice-looking shape.
    QToolButton *ext_button = findChild<QToolButton*>();
    if (ext_button) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    {
        childCounter--;
    }
    else if (event->type() == QEvent::ChildPolished)
    {
}
void Singleton::f2();{
        return;
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    {
        childCounter--;
    }
    else if (event->type() == QEvent::ChildPolished)
    {
}
void Singleton::f2();{
        return;
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
}
void Singleton::f3();{
    QToolButton *ext_button = findChild<QToolButton*>();
    if (ext_button) {
        ext_button->setIcon(QIcon());
        ext_button->setText(UTF8_RIGHT_POINTING_DOUBLE_ANGLE_QUOTATION_MARK);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    {
        childCounter--;
    }
    else if (event->type() == QEvent::ChildPolished)
    {
}
void Singleton::f2();{
        return;
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
}
void Singleton::f3();{
    QToolButton *ext_button = findChild<QToolButton*>();
    if (ext_button) {
        ext_button->setIcon(QIcon());
        ext_button->setText(UTF8_RIGHT_POINTING_DOUBLE_ANGLE_QUOTATION_MARK);
    }
}
void Singleton::f4();{
            {
                bool success = false;
                widget->property(drag_drop_toolbar_action_).toInt(&success);
                if (! success)
                {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    {
        childCounter--;
    }
    else if (event->type() == QEvent::ChildPolished)
    {
}
void Singleton::f2();{
        return;
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
}
void Singleton::f3();{
    QToolButton *ext_button = findChild<QToolButton*>();
    if (ext_button) {
        ext_button->setIcon(QIcon());
        ext_button->setText(UTF8_RIGHT_POINTING_DOUBLE_ANGLE_QUOTATION_MARK);
    }
}
void Singleton::f4();{
            {
                bool success = false;
                widget->property(drag_drop_toolbar_action_).toInt(&success);
                if (! success)
                {
}
void Singleton::f5();{
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    {
        childCounter--;
    }
    else if (event->type() == QEvent::ChildPolished)
    {
}
void Singleton::f2();{
        return;
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
}
void Singleton::f3();{
    QToolButton *ext_button = findChild<QToolButton*>();
    if (ext_button) {
        ext_button->setIcon(QIcon());
        ext_button->setText(UTF8_RIGHT_POINTING_DOUBLE_ANGLE_QUOTATION_MARK);
    }
}
void Singleton::f4();{
            {
                bool success = false;
                widget->property(drag_drop_toolbar_action_).toInt(&success);
                if (! success)
                {
}
void Singleton::f5();{
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
        {
}
void Singleton::f6();{
            moveToolbarItems(oldPos, newPos);
            QAction * moveAction = actions().at(oldPos);
            emit actionMoved(moveAction, oldPos, newPos);
        }
        if (event->source() == this) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    {
        childCounter--;
    }
    else if (event->type() == QEvent::ChildPolished)
    {
}
void Singleton::f2();{
        return;
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
}
void Singleton::f3();{
    QToolButton *ext_button = findChild<QToolButton*>();
    if (ext_button) {
        ext_button->setIcon(QIcon());
        ext_button->setText(UTF8_RIGHT_POINTING_DOUBLE_ANGLE_QUOTATION_MARK);
    }
}
void Singleton::f4();{
            {
                bool success = false;
                widget->property(drag_drop_toolbar_action_).toInt(&success);
                if (! success)
                {
}
void Singleton::f5();{
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
        {
}
void Singleton::f6();{
            moveToolbarItems(oldPos, newPos);
            QAction * moveAction = actions().at(oldPos);
            emit actionMoved(moveAction, oldPos, newPos);
        }
        if (event->source() == this) {
}
void Singleton::f7();{
            drag->setMimeData(temd);
            qreal dpr = window()->windowHandle()->devicePixelRatio();
            QPixmap pixmap(lbl->size() * dpr);
            pixmap.setDevicePixelRatio(dpr);
            lbl->render(&pixmap);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    {
        childCounter--;
    }
    else if (event->type() == QEvent::ChildPolished)
    {
}
void Singleton::f2();{
        return;
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
}
void Singleton::f3();{
    QToolButton *ext_button = findChild<QToolButton*>();
    if (ext_button) {
        ext_button->setIcon(QIcon());
        ext_button->setText(UTF8_RIGHT_POINTING_DOUBLE_ANGLE_QUOTATION_MARK);
    }
}
void Singleton::f4();{
            {
                bool success = false;
                widget->property(drag_drop_toolbar_action_).toInt(&success);
                if (! success)
                {
}
void Singleton::f5();{
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
        {
}
void Singleton::f6();{
            moveToolbarItems(oldPos, newPos);
            QAction * moveAction = actions().at(oldPos);
            emit actionMoved(moveAction, oldPos, newPos);
        }
        if (event->source() == this) {
}
void Singleton::f7();{
            drag->setMimeData(temd);
            qreal dpr = window()->windowHandle()->devicePixelRatio();
            QPixmap pixmap(lbl->size() * dpr);
            pixmap.setDevicePixelRatio(dpr);
            lbl->render(&pixmap);
}
void Singleton::f8();{
                 > QApplication::startDragDistance())
        {
            if (! qobject_cast<QToolButton *>(elem) || ! elem->property(drag_drop_toolbar_action_).isValid())
                return QToolBar::eventFilter(obj, event);
            WiresharkMimeData * temd = createMimeData(((QToolButton *)elem)->text(), elem->property(drag_drop_toolbar_action_).toInt());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    {
        childCounter--;
    }
    else if (event->type() == QEvent::ChildPolished)
    {
}
void Singleton::f2();{
        return;
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
}
void Singleton::f3();{
    QToolButton *ext_button = findChild<QToolButton*>();
    if (ext_button) {
        ext_button->setIcon(QIcon());
        ext_button->setText(UTF8_RIGHT_POINTING_DOUBLE_ANGLE_QUOTATION_MARK);
    }
}
void Singleton::f4();{
            {
                bool success = false;
                widget->property(drag_drop_toolbar_action_).toInt(&success);
                if (! success)
                {
}
void Singleton::f5();{
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        QAction * actionAtPos = actionAt(event->pos());
        if (actionAtPos)
        {
}
void Singleton::f6();{
            moveToolbarItems(oldPos, newPos);
            QAction * moveAction = actions().at(oldPos);
            emit actionMoved(moveAction, oldPos, newPos);
        }
        if (event->source() == this) {
}
void Singleton::f7();{
            drag->setMimeData(temd);
            qreal dpr = window()->windowHandle()->devicePixelRatio();
            QPixmap pixmap(lbl->size() * dpr);
            pixmap.setDevicePixelRatio(dpr);
            lbl->render(&pixmap);
}
void Singleton::f8();{
                 > QApplication::startDragDistance())
        {
            if (! qobject_cast<QToolButton *>(elem) || ! elem->property(drag_drop_toolbar_action_).isValid())
                return QToolBar::eventFilter(obj, event);
            WiresharkMimeData * temd = createMimeData(((QToolButton *)elem)->text(), elem->property(drag_drop_toolbar_action_).toInt());
}
void Singleton::f9();{
    if (qobject_cast<const ToolbarEntryMimeData *>(event->mimeData()))
    {
        const ToolbarEntryMimeData * data = qobject_cast<const ToolbarEntryMimeData *>(event->mimeData());
        int oldPos = data->position();
        int newPos = -1;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                    reportSeq(y-seqLen, x+y-seqLen, seqLen, pSource1, pSource2, outFile, outStatsFile);
                    blocks++;
                }
                seqLen=0;
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                    reportSeq(y-seqLen, x+y-seqLen, seqLen, pSource1, pSource2, outFile, outStatsFile);
                    blocks++;
                }
                seqLen=0;
            }
}
void Singleton::f2();{
							  outFile, 
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
}
void Singleton::f3();{
                    blocks++;
                }
                seqLen=0;
            }
        }
}
void Singleton::f4();{
			 bool Xml,
			 std::string strStatsFilename):
    m_listFileName(listFileName),
	m_strStatsFilename(strStatsFilename),
    m_minBlockSize(minBlockSize),
}
void Singleton::f5();{
        outfile << "  Number of files: " << files << std::endl;
        outfile << "  Minimal block size: " << m_minBlockSize << std::endl;
        outfile << "  Minimal characters in line: " << m_minChars << std::endl;
		outfile << "  Max distance: " << m_maxDistance << std::endl;
		outfile << "  Use Levenshtein distance: " << m_levenshtein << std::endl;
}
void Singleton::f6();{
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
					blocks++;
}
void Singleton::f7();{
	// Compare each file with each other
	for(int i=0;i<(int)sourceFiles.size();i++){
		// print out the filename for the console for the 
		// basic statistics
		// (**)
}
void Singleton::f8();{
		for(int y=0; y<maxY; y++){
            if(m_pMatrix[x+y+n*y] == MATCH){
                seqLen++;
            } else {
                if(seqLen >= m_minBlockSize){
}
void Singleton::f9();{
                m_pMatrix[x+n*y] = MATCH;
            }
        }
    }
	int blocks=0;
}
void Singleton::f10();{
				
				// the actual comparison is done in the Duplo::process method
				blocks += process(sourceFiles[i], 
								  sourceFiles[j], 
								  outfile,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                    reportSeq(y-seqLen, x+y-seqLen, seqLen, pSource1, pSource2, outFile, outStatsFile);
                    blocks++;
                }
                seqLen=0;
            }
}
void Singleton::f2();{
							  outFile, 
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                    reportSeq(y-seqLen, x+y-seqLen, seqLen, pSource1, pSource2, outFile, outStatsFile);
                    blocks++;
                }
                seqLen=0;
            }
}
void Singleton::f2();{
							  outFile, 
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
}
void Singleton::f3();{
                    blocks++;
                }
                seqLen=0;
            }
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                    reportSeq(y-seqLen, x+y-seqLen, seqLen, pSource1, pSource2, outFile, outStatsFile);
                    blocks++;
                }
                seqLen=0;
            }
}
void Singleton::f2();{
							  outFile, 
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
}
void Singleton::f3();{
                    blocks++;
                }
                seqLen=0;
            }
        }
}
void Singleton::f4();{
			 bool Xml,
			 std::string strStatsFilename):
    m_listFileName(listFileName),
	m_strStatsFilename(strStatsFilename),
    m_minBlockSize(minBlockSize),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                    reportSeq(y-seqLen, x+y-seqLen, seqLen, pSource1, pSource2, outFile, outStatsFile);
                    blocks++;
                }
                seqLen=0;
            }
}
void Singleton::f2();{
							  outFile, 
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
}
void Singleton::f3();{
                    blocks++;
                }
                seqLen=0;
            }
        }
}
void Singleton::f4();{
			 bool Xml,
			 std::string strStatsFilename):
    m_listFileName(listFileName),
	m_strStatsFilename(strStatsFilename),
    m_minBlockSize(minBlockSize),
}
void Singleton::f5();{
        outfile << "  Number of files: " << files << std::endl;
        outfile << "  Minimal block size: " << m_minBlockSize << std::endl;
        outfile << "  Minimal characters in line: " << m_minChars << std::endl;
		outfile << "  Max distance: " << m_maxDistance << std::endl;
		outfile << "  Use Levenshtein distance: " << m_levenshtein << std::endl;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                    reportSeq(y-seqLen, x+y-seqLen, seqLen, pSource1, pSource2, outFile, outStatsFile);
                    blocks++;
                }
                seqLen=0;
            }
}
void Singleton::f2();{
							  outFile, 
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
}
void Singleton::f3();{
                    blocks++;
                }
                seqLen=0;
            }
        }
}
void Singleton::f4();{
			 bool Xml,
			 std::string strStatsFilename):
    m_listFileName(listFileName),
	m_strStatsFilename(strStatsFilename),
    m_minBlockSize(minBlockSize),
}
void Singleton::f5();{
        outfile << "  Number of files: " << files << std::endl;
        outfile << "  Minimal block size: " << m_minBlockSize << std::endl;
        outfile << "  Minimal characters in line: " << m_minChars << std::endl;
		outfile << "  Max distance: " << m_maxDistance << std::endl;
		outfile << "  Use Levenshtein distance: " << m_levenshtein << std::endl;
}
void Singleton::f6();{
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
					blocks++;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                    reportSeq(y-seqLen, x+y-seqLen, seqLen, pSource1, pSource2, outFile, outStatsFile);
                    blocks++;
                }
                seqLen=0;
            }
}
void Singleton::f2();{
							  outFile, 
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
}
void Singleton::f3();{
                    blocks++;
                }
                seqLen=0;
            }
        }
}
void Singleton::f4();{
			 bool Xml,
			 std::string strStatsFilename):
    m_listFileName(listFileName),
	m_strStatsFilename(strStatsFilename),
    m_minBlockSize(minBlockSize),
}
void Singleton::f5();{
        outfile << "  Number of files: " << files << std::endl;
        outfile << "  Minimal block size: " << m_minBlockSize << std::endl;
        outfile << "  Minimal characters in line: " << m_minChars << std::endl;
		outfile << "  Max distance: " << m_maxDistance << std::endl;
		outfile << "  Use Levenshtein distance: " << m_levenshtein << std::endl;
}
void Singleton::f6();{
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
					blocks++;
}
void Singleton::f7();{
	// Compare each file with each other
	for(int i=0;i<(int)sourceFiles.size();i++){
		// print out the filename for the console for the 
		// basic statistics
		// (**)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                    reportSeq(y-seqLen, x+y-seqLen, seqLen, pSource1, pSource2, outFile, outStatsFile);
                    blocks++;
                }
                seqLen=0;
            }
}
void Singleton::f2();{
							  outFile, 
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
}
void Singleton::f3();{
                    blocks++;
                }
                seqLen=0;
            }
        }
}
void Singleton::f4();{
			 bool Xml,
			 std::string strStatsFilename):
    m_listFileName(listFileName),
	m_strStatsFilename(strStatsFilename),
    m_minBlockSize(minBlockSize),
}
void Singleton::f5();{
        outfile << "  Number of files: " << files << std::endl;
        outfile << "  Minimal block size: " << m_minBlockSize << std::endl;
        outfile << "  Minimal characters in line: " << m_minChars << std::endl;
		outfile << "  Max distance: " << m_maxDistance << std::endl;
		outfile << "  Use Levenshtein distance: " << m_levenshtein << std::endl;
}
void Singleton::f6();{
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
					blocks++;
}
void Singleton::f7();{
	// Compare each file with each other
	for(int i=0;i<(int)sourceFiles.size();i++){
		// print out the filename for the console for the 
		// basic statistics
		// (**)
}
void Singleton::f8();{
		for(int y=0; y<maxY; y++){
            if(m_pMatrix[x+y+n*y] == MATCH){
                seqLen++;
            } else {
                if(seqLen >= m_minBlockSize){
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                    reportSeq(y-seqLen, x+y-seqLen, seqLen, pSource1, pSource2, outFile, outStatsFile);
                    blocks++;
                }
                seqLen=0;
            }
}
void Singleton::f2();{
							  outFile, 
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
}
void Singleton::f3();{
                    blocks++;
                }
                seqLen=0;
            }
        }
}
void Singleton::f4();{
			 bool Xml,
			 std::string strStatsFilename):
    m_listFileName(listFileName),
	m_strStatsFilename(strStatsFilename),
    m_minBlockSize(minBlockSize),
}
void Singleton::f5();{
        outfile << "  Number of files: " << files << std::endl;
        outfile << "  Minimal block size: " << m_minBlockSize << std::endl;
        outfile << "  Minimal characters in line: " << m_minChars << std::endl;
		outfile << "  Max distance: " << m_maxDistance << std::endl;
		outfile << "  Use Levenshtein distance: " << m_levenshtein << std::endl;
}
void Singleton::f6();{
							  outStatsFile);
					
					// increase the counter of blocks in the source file
					// this information is later reported to the console
					blocks++;
}
void Singleton::f7();{
	// Compare each file with each other
	for(int i=0;i<(int)sourceFiles.size();i++){
		// print out the filename for the console for the 
		// basic statistics
		// (**)
}
void Singleton::f8();{
		for(int y=0; y<maxY; y++){
            if(m_pMatrix[x+y+n*y] == MATCH){
                seqLen++;
            } else {
                if(seqLen >= m_minBlockSize){
}
void Singleton::f9();{
                m_pMatrix[x+n*y] = MATCH;
            }
        }
    }
	int blocks=0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                      contentsRect().top());
    file_dialog_button_->setMinimumHeight(contentsRect().height());
    file_dialog_button_->setMaximumHeight(contentsRect().height());
void EditorFileDialog::applyFilename()
    QString file;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                      contentsRect().top());
    file_dialog_button_->setMinimumHeight(contentsRect().height());
    file_dialog_button_->setMaximumHeight(contentsRect().height());
void EditorFileDialog::applyFilename()
    QString file;
}
void Singleton::f2();{
// we've been created. We need to install our own event filter after that
// happens so that we can steal tab keypresses.
void EditorFileDialog::focusInEvent(QFocusEvent *event)
    installEventFilter(this);
    QLineEdit::focusInEvent(event);
}
void Singleton::f3();{
    connect(file_dialog_button_, &QPushButton::clicked, this, &EditorFileDialog::applyFilename);
void EditorFileDialog::setOption(QFileDialog::Option option, bool on)
    if (on)
    {
        options_ |= option;
}
void Singleton::f4();{
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
        }
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    if (event->type() == QEvent::KeyPress) {
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
}
void Singleton::f7();{
        options_ |= option;
    }
    else
    {
        options_ &= (~option);
}
void Singleton::f8();{
    connect(file_dialog_button_, &QPushButton::clicked, this, &EditorFileDialog::applyFilename);
void EditorFileDialog::setOption(QFileDialog::Option option, bool on)
    if (on)
    {
        options_ |= option;
}
void Singleton::f9();{
    {
        file = WiresharkFileDialog::getOpenFileName(this, caption_, directory_, filter_, NULL, options_);
    }
    if (!file.isEmpty())
    {
}
void Singleton::f10();{
    }
    if (!file.isEmpty())
    {
        setText(file);
        emit acceptEdit(index_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                      contentsRect().top());
    file_dialog_button_->setMinimumHeight(contentsRect().height());
    file_dialog_button_->setMaximumHeight(contentsRect().height());
void EditorFileDialog::applyFilename()
    QString file;
}
void Singleton::f2();{
// we've been created. We need to install our own event filter after that
// happens so that we can steal tab keypresses.
void EditorFileDialog::focusInEvent(QFocusEvent *event)
    installEventFilter(this);
    QLineEdit::focusInEvent(event);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                      contentsRect().top());
    file_dialog_button_->setMinimumHeight(contentsRect().height());
    file_dialog_button_->setMaximumHeight(contentsRect().height());
void EditorFileDialog::applyFilename()
    QString file;
}
void Singleton::f2();{
// we've been created. We need to install our own event filter after that
// happens so that we can steal tab keypresses.
void EditorFileDialog::focusInEvent(QFocusEvent *event)
    installEventFilter(this);
    QLineEdit::focusInEvent(event);
}
void Singleton::f3();{
    connect(file_dialog_button_, &QPushButton::clicked, this, &EditorFileDialog::applyFilename);
void EditorFileDialog::setOption(QFileDialog::Option option, bool on)
    if (on)
    {
        options_ |= option;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                      contentsRect().top());
    file_dialog_button_->setMinimumHeight(contentsRect().height());
    file_dialog_button_->setMaximumHeight(contentsRect().height());
void EditorFileDialog::applyFilename()
    QString file;
}
void Singleton::f2();{
// we've been created. We need to install our own event filter after that
// happens so that we can steal tab keypresses.
void EditorFileDialog::focusInEvent(QFocusEvent *event)
    installEventFilter(this);
    QLineEdit::focusInEvent(event);
}
void Singleton::f3();{
    connect(file_dialog_button_, &QPushButton::clicked, this, &EditorFileDialog::applyFilename);
void EditorFileDialog::setOption(QFileDialog::Option option, bool on)
    if (on)
    {
        options_ |= option;
}
void Singleton::f4();{
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                      contentsRect().top());
    file_dialog_button_->setMinimumHeight(contentsRect().height());
    file_dialog_button_->setMaximumHeight(contentsRect().height());
void EditorFileDialog::applyFilename()
    QString file;
}
void Singleton::f2();{
// we've been created. We need to install our own event filter after that
// happens so that we can steal tab keypresses.
void EditorFileDialog::focusInEvent(QFocusEvent *event)
    installEventFilter(this);
    QLineEdit::focusInEvent(event);
}
void Singleton::f3();{
    connect(file_dialog_button_, &QPushButton::clicked, this, &EditorFileDialog::applyFilename);
void EditorFileDialog::setOption(QFileDialog::Option option, bool on)
    if (on)
    {
        options_ |= option;
}
void Singleton::f4();{
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
        }
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                      contentsRect().top());
    file_dialog_button_->setMinimumHeight(contentsRect().height());
    file_dialog_button_->setMaximumHeight(contentsRect().height());
void EditorFileDialog::applyFilename()
    QString file;
}
void Singleton::f2();{
// we've been created. We need to install our own event filter after that
// happens so that we can steal tab keypresses.
void EditorFileDialog::focusInEvent(QFocusEvent *event)
    installEventFilter(this);
    QLineEdit::focusInEvent(event);
}
void Singleton::f3();{
    connect(file_dialog_button_, &QPushButton::clicked, this, &EditorFileDialog::applyFilename);
void EditorFileDialog::setOption(QFileDialog::Option option, bool on)
    if (on)
    {
        options_ |= option;
}
void Singleton::f4();{
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
        }
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    if (event->type() == QEvent::KeyPress) {
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                      contentsRect().top());
    file_dialog_button_->setMinimumHeight(contentsRect().height());
    file_dialog_button_->setMaximumHeight(contentsRect().height());
void EditorFileDialog::applyFilename()
    QString file;
}
void Singleton::f2();{
// we've been created. We need to install our own event filter after that
// happens so that we can steal tab keypresses.
void EditorFileDialog::focusInEvent(QFocusEvent *event)
    installEventFilter(this);
    QLineEdit::focusInEvent(event);
}
void Singleton::f3();{
    connect(file_dialog_button_, &QPushButton::clicked, this, &EditorFileDialog::applyFilename);
void EditorFileDialog::setOption(QFileDialog::Option option, bool on)
    if (on)
    {
        options_ |= option;
}
void Singleton::f4();{
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
        }
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    if (event->type() == QEvent::KeyPress) {
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
}
void Singleton::f7();{
        options_ |= option;
    }
    else
    {
        options_ &= (~option);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                      contentsRect().top());
    file_dialog_button_->setMinimumHeight(contentsRect().height());
    file_dialog_button_->setMaximumHeight(contentsRect().height());
void EditorFileDialog::applyFilename()
    QString file;
}
void Singleton::f2();{
// we've been created. We need to install our own event filter after that
// happens so that we can steal tab keypresses.
void EditorFileDialog::focusInEvent(QFocusEvent *event)
    installEventFilter(this);
    QLineEdit::focusInEvent(event);
}
void Singleton::f3();{
    connect(file_dialog_button_, &QPushButton::clicked, this, &EditorFileDialog::applyFilename);
void EditorFileDialog::setOption(QFileDialog::Option option, bool on)
    if (on)
    {
        options_ |= option;
}
void Singleton::f4();{
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
        }
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    if (event->type() == QEvent::KeyPress) {
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
}
void Singleton::f7();{
        options_ |= option;
    }
    else
    {
        options_ &= (~option);
}
void Singleton::f8();{
    connect(file_dialog_button_, &QPushButton::clicked, this, &EditorFileDialog::applyFilename);
void EditorFileDialog::setOption(QFileDialog::Option option, bool on)
    if (on)
    {
        options_ |= option;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                      contentsRect().top());
    file_dialog_button_->setMinimumHeight(contentsRect().height());
    file_dialog_button_->setMaximumHeight(contentsRect().height());
void EditorFileDialog::applyFilename()
    QString file;
}
void Singleton::f2();{
// we've been created. We need to install our own event filter after that
// happens so that we can steal tab keypresses.
void EditorFileDialog::focusInEvent(QFocusEvent *event)
    installEventFilter(this);
    QLineEdit::focusInEvent(event);
}
void Singleton::f3();{
    connect(file_dialog_button_, &QPushButton::clicked, this, &EditorFileDialog::applyFilename);
void EditorFileDialog::setOption(QFileDialog::Option option, bool on)
    if (on)
    {
        options_ |= option;
}
void Singleton::f4();{
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
        }
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    if (event->type() == QEvent::KeyPress) {
        QKeyEvent* key = static_cast<QKeyEvent*>(event);
        if ((key->key() == Qt::Key_Tab) && !file_dialog_button_->hasFocus()) {
            file_dialog_button_->setFocus();
            return true;
}
void Singleton::f7();{
        options_ |= option;
    }
    else
    {
        options_ &= (~option);
}
void Singleton::f8();{
    connect(file_dialog_button_, &QPushButton::clicked, this, &EditorFileDialog::applyFilename);
void EditorFileDialog::setOption(QFileDialog::Option option, bool on)
    if (on)
    {
        options_ |= option;
}
void Singleton::f9();{
    {
        file = WiresharkFileDialog::getOpenFileName(this, caption_, directory_, filter_, NULL, options_);
    }
    if (!file.isEmpty())
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f2();{
void EnabledProtocolsDialog::on_enable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Enable);
    ui->protocol_tree_->expandAll();
void EnabledProtocolsDialog::on_disable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Disable);
}
void Singleton::f3();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f4();{
    GeometryStateDialog(parent),
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
}
void Singleton::f5();{
    searchFilterChange();
void EnabledProtocolsDialog::on_cmbProtocolType_currentIndexChanged(int)
    searchFilterChange();
void EnabledProtocolsDialog::on_buttonBox_accepted()
    enabled_protocols_model_->applyChanges();
}
void Singleton::f6();{
void EnabledProtocolsDialog::on_buttonBox_accepted()
    enabled_protocols_model_->applyChanges();
void EnabledProtocolsDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_ENABLED_PROTOCOLS_DIALOG);
 * Editor modelines
}
void Singleton::f7();{
    wsApp->helpTopicAction(HELP_ENABLED_PROTOCOLS_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f8();{
    ui->cmbSearchType->addItem(tr("Only Protocols"), QVariant::fromValue(EnabledProtocolsProxyModel::OnlyProtocol));
    ui->cmbSearchType->addItem(tr("Only Description"), QVariant::fromValue(EnabledProtocolsProxyModel::OnlyDescription));
    ui->cmbSearchType->addItem(tr("Only enabled protocols"), QVariant::fromValue(EnabledProtocolsProxyModel::EnabledItems));
    ui->cmbSearchType->addItem(tr("Only disabled protocols"), QVariant::fromValue(EnabledProtocolsProxyModel::DisabledItems));
    ui->cmbProtocolType->addItem(tr("any protocol"), QVariant::fromValue(EnabledProtocolItem::Any));
}
void Singleton::f9();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f10();{
    enabled_protocols_model_->applyChanges();
void EnabledProtocolsDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_ENABLED_PROTOCOLS_DIALOG);
 * Editor modelines
 * Local Variables:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f2();{
void EnabledProtocolsDialog::on_enable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Enable);
    ui->protocol_tree_->expandAll();
void EnabledProtocolsDialog::on_disable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Disable);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f2();{
void EnabledProtocolsDialog::on_enable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Enable);
    ui->protocol_tree_->expandAll();
void EnabledProtocolsDialog::on_disable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Disable);
}
void Singleton::f3();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f2();{
void EnabledProtocolsDialog::on_enable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Enable);
    ui->protocol_tree_->expandAll();
void EnabledProtocolsDialog::on_disable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Disable);
}
void Singleton::f3();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f4();{
    GeometryStateDialog(parent),
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f2();{
void EnabledProtocolsDialog::on_enable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Enable);
    ui->protocol_tree_->expandAll();
void EnabledProtocolsDialog::on_disable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Disable);
}
void Singleton::f3();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f4();{
    GeometryStateDialog(parent),
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
}
void Singleton::f5();{
    searchFilterChange();
void EnabledProtocolsDialog::on_cmbProtocolType_currentIndexChanged(int)
    searchFilterChange();
void EnabledProtocolsDialog::on_buttonBox_accepted()
    enabled_protocols_model_->applyChanges();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f2();{
void EnabledProtocolsDialog::on_enable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Enable);
    ui->protocol_tree_->expandAll();
void EnabledProtocolsDialog::on_disable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Disable);
}
void Singleton::f3();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f4();{
    GeometryStateDialog(parent),
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
}
void Singleton::f5();{
    searchFilterChange();
void EnabledProtocolsDialog::on_cmbProtocolType_currentIndexChanged(int)
    searchFilterChange();
void EnabledProtocolsDialog::on_buttonBox_accepted()
    enabled_protocols_model_->applyChanges();
}
void Singleton::f6();{
void EnabledProtocolsDialog::on_buttonBox_accepted()
    enabled_protocols_model_->applyChanges();
void EnabledProtocolsDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_ENABLED_PROTOCOLS_DIALOG);
 * Editor modelines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f2();{
void EnabledProtocolsDialog::on_enable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Enable);
    ui->protocol_tree_->expandAll();
void EnabledProtocolsDialog::on_disable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Disable);
}
void Singleton::f3();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f4();{
    GeometryStateDialog(parent),
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
}
void Singleton::f5();{
    searchFilterChange();
void EnabledProtocolsDialog::on_cmbProtocolType_currentIndexChanged(int)
    searchFilterChange();
void EnabledProtocolsDialog::on_buttonBox_accepted()
    enabled_protocols_model_->applyChanges();
}
void Singleton::f6();{
void EnabledProtocolsDialog::on_buttonBox_accepted()
    enabled_protocols_model_->applyChanges();
void EnabledProtocolsDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_ENABLED_PROTOCOLS_DIALOG);
 * Editor modelines
}
void Singleton::f7();{
    wsApp->helpTopicAction(HELP_ENABLED_PROTOCOLS_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f2();{
void EnabledProtocolsDialog::on_enable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Enable);
    ui->protocol_tree_->expandAll();
void EnabledProtocolsDialog::on_disable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Disable);
}
void Singleton::f3();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f4();{
    GeometryStateDialog(parent),
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
}
void Singleton::f5();{
    searchFilterChange();
void EnabledProtocolsDialog::on_cmbProtocolType_currentIndexChanged(int)
    searchFilterChange();
void EnabledProtocolsDialog::on_buttonBox_accepted()
    enabled_protocols_model_->applyChanges();
}
void Singleton::f6();{
void EnabledProtocolsDialog::on_buttonBox_accepted()
    enabled_protocols_model_->applyChanges();
void EnabledProtocolsDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_ENABLED_PROTOCOLS_DIALOG);
 * Editor modelines
}
void Singleton::f7();{
    wsApp->helpTopicAction(HELP_ENABLED_PROTOCOLS_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f8();{
    ui->cmbSearchType->addItem(tr("Only Protocols"), QVariant::fromValue(EnabledProtocolsProxyModel::OnlyProtocol));
    ui->cmbSearchType->addItem(tr("Only Description"), QVariant::fromValue(EnabledProtocolsProxyModel::OnlyDescription));
    ui->cmbSearchType->addItem(tr("Only enabled protocols"), QVariant::fromValue(EnabledProtocolsProxyModel::EnabledItems));
    ui->cmbSearchType->addItem(tr("Only disabled protocols"), QVariant::fromValue(EnabledProtocolsProxyModel::DisabledItems));
    ui->cmbProtocolType->addItem(tr("any protocol"), QVariant::fromValue(EnabledProtocolItem::Any));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f2();{
void EnabledProtocolsDialog::on_enable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Enable);
    ui->protocol_tree_->expandAll();
void EnabledProtocolsDialog::on_disable_all_button__clicked()
    proxyModel_->setItemsEnable(EnabledProtocolsProxyModel::Disable);
}
void Singleton::f3();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}
void Singleton::f4();{
    GeometryStateDialog(parent),
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
}
void Singleton::f5();{
    searchFilterChange();
void EnabledProtocolsDialog::on_cmbProtocolType_currentIndexChanged(int)
    searchFilterChange();
void EnabledProtocolsDialog::on_buttonBox_accepted()
    enabled_protocols_model_->applyChanges();
}
void Singleton::f6();{
void EnabledProtocolsDialog::on_buttonBox_accepted()
    enabled_protocols_model_->applyChanges();
void EnabledProtocolsDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_ENABLED_PROTOCOLS_DIALOG);
 * Editor modelines
}
void Singleton::f7();{
    wsApp->helpTopicAction(HELP_ENABLED_PROTOCOLS_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f8();{
    ui->cmbSearchType->addItem(tr("Only Protocols"), QVariant::fromValue(EnabledProtocolsProxyModel::OnlyProtocol));
    ui->cmbSearchType->addItem(tr("Only Description"), QVariant::fromValue(EnabledProtocolsProxyModel::OnlyDescription));
    ui->cmbSearchType->addItem(tr("Only enabled protocols"), QVariant::fromValue(EnabledProtocolsProxyModel::EnabledItems));
    ui->cmbSearchType->addItem(tr("Only disabled protocols"), QVariant::fromValue(EnabledProtocolsProxyModel::DisabledItems));
    ui->cmbProtocolType->addItem(tr("any protocol"), QVariant::fromValue(EnabledProtocolItem::Any));
}
void Singleton::f9();{
    ui(new Ui::EnabledProtocolsDialog),
    enabled_protocols_model_(new EnabledProtocolsModel()),
    proxyModel_(new EnabledProtocolsProxyModel(this))
    ui->setupUi(this);
    loadGeometry();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    item->setEnabled(value == Qt::Checked ? true : false);
    QVector<int> roles;
    roles << role;
    emit dataChanged(index, index, roles);
    return true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    item->setEnabled(value == Qt::Checked ? true : false);
    QVector<int> roles;
    roles << role;
    emit dataChanged(index, index, roles);
    return true;
}
void Singleton::f2();{
EnabledProtocolsModel::~EnabledProtocolsModel()
    delete root_;
int EnabledProtocolsModel::rowCount(const QModelIndex &parent) const
   EnabledProtocolItem *parent_item;
    if (parent.column() > 0)
}
void Singleton::f3();{
            return true;
    }
    return false;
Qt::ItemFlags EnabledProtocolsProxyModel::flags(const QModelIndex &index) const
    Qt::ItemFlags flags = Qt::NoItemFlags;
}
void Singleton::f4();{
    heur_dtbl_entry_t *heuristic_table_;
EnabledProtocolItem::EnabledProtocolItem(QString name, QString description, bool enabled, EnabledProtocolItem* parent) :
    ModelHelperTreeItem<EnabledProtocolItem>(parent),
    name_(name),
    description_(description),
}
void Singleton::f5();{
    return colLast;
QVariant EnabledProtocolsModel::headerData(int section, Qt::Orientation orientation, int role) const
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum EnabledProtocolsColumn)section) {
        case colProtocol:
}
void Singleton::f6();{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    switch(index.column())
    {
    case colProtocol:
        flags |= Qt::ItemIsUserCheckable;
}
void Singleton::f7();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f8();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f9();{
        redissect |= proto->applyValue();
        for (int heur_index = 0; heur_index < proto->childCount(); heur_index++) {
            EnabledProtocolItem* heur = proto->child(heur_index);
            redissect |= heur->applyValue();
        }
}
void Singleton::f10();{
        }
        else
            return true;
    }
    else if (type_ == EnabledProtocolsProxyModel::EnabledItems && item->enabled())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    item->setEnabled(value == Qt::Checked ? true : false);
    QVector<int> roles;
    roles << role;
    emit dataChanged(index, index, roles);
    return true;
}
void Singleton::f2();{
EnabledProtocolsModel::~EnabledProtocolsModel()
    delete root_;
int EnabledProtocolsModel::rowCount(const QModelIndex &parent) const
   EnabledProtocolItem *parent_item;
    if (parent.column() > 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    item->setEnabled(value == Qt::Checked ? true : false);
    QVector<int> roles;
    roles << role;
    emit dataChanged(index, index, roles);
    return true;
}
void Singleton::f2();{
EnabledProtocolsModel::~EnabledProtocolsModel()
    delete root_;
int EnabledProtocolsModel::rowCount(const QModelIndex &parent) const
   EnabledProtocolItem *parent_item;
    if (parent.column() > 0)
}
void Singleton::f3();{
            return true;
    }
    return false;
Qt::ItemFlags EnabledProtocolsProxyModel::flags(const QModelIndex &index) const
    Qt::ItemFlags flags = Qt::NoItemFlags;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    item->setEnabled(value == Qt::Checked ? true : false);
    QVector<int> roles;
    roles << role;
    emit dataChanged(index, index, roles);
    return true;
}
void Singleton::f2();{
EnabledProtocolsModel::~EnabledProtocolsModel()
    delete root_;
int EnabledProtocolsModel::rowCount(const QModelIndex &parent) const
   EnabledProtocolItem *parent_item;
    if (parent.column() > 0)
}
void Singleton::f3();{
            return true;
    }
    return false;
Qt::ItemFlags EnabledProtocolsProxyModel::flags(const QModelIndex &index) const
    Qt::ItemFlags flags = Qt::NoItemFlags;
}
void Singleton::f4();{
    heur_dtbl_entry_t *heuristic_table_;
EnabledProtocolItem::EnabledProtocolItem(QString name, QString description, bool enabled, EnabledProtocolItem* parent) :
    ModelHelperTreeItem<EnabledProtocolItem>(parent),
    name_(name),
    description_(description),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    item->setEnabled(value == Qt::Checked ? true : false);
    QVector<int> roles;
    roles << role;
    emit dataChanged(index, index, roles);
    return true;
}
void Singleton::f2();{
EnabledProtocolsModel::~EnabledProtocolsModel()
    delete root_;
int EnabledProtocolsModel::rowCount(const QModelIndex &parent) const
   EnabledProtocolItem *parent_item;
    if (parent.column() > 0)
}
void Singleton::f3();{
            return true;
    }
    return false;
Qt::ItemFlags EnabledProtocolsProxyModel::flags(const QModelIndex &index) const
    Qt::ItemFlags flags = Qt::NoItemFlags;
}
void Singleton::f4();{
    heur_dtbl_entry_t *heuristic_table_;
EnabledProtocolItem::EnabledProtocolItem(QString name, QString description, bool enabled, EnabledProtocolItem* parent) :
    ModelHelperTreeItem<EnabledProtocolItem>(parent),
    name_(name),
    description_(description),
}
void Singleton::f5();{
    return colLast;
QVariant EnabledProtocolsModel::headerData(int section, Qt::Orientation orientation, int role) const
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum EnabledProtocolsColumn)section) {
        case colProtocol:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    item->setEnabled(value == Qt::Checked ? true : false);
    QVector<int> roles;
    roles << role;
    emit dataChanged(index, index, roles);
    return true;
}
void Singleton::f2();{
EnabledProtocolsModel::~EnabledProtocolsModel()
    delete root_;
int EnabledProtocolsModel::rowCount(const QModelIndex &parent) const
   EnabledProtocolItem *parent_item;
    if (parent.column() > 0)
}
void Singleton::f3();{
            return true;
    }
    return false;
Qt::ItemFlags EnabledProtocolsProxyModel::flags(const QModelIndex &index) const
    Qt::ItemFlags flags = Qt::NoItemFlags;
}
void Singleton::f4();{
    heur_dtbl_entry_t *heuristic_table_;
EnabledProtocolItem::EnabledProtocolItem(QString name, QString description, bool enabled, EnabledProtocolItem* parent) :
    ModelHelperTreeItem<EnabledProtocolItem>(parent),
    name_(name),
    description_(description),
}
void Singleton::f5();{
    return colLast;
QVariant EnabledProtocolsModel::headerData(int section, Qt::Orientation orientation, int role) const
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum EnabledProtocolsColumn)section) {
        case colProtocol:
}
void Singleton::f6();{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    switch(index.column())
    {
    case colProtocol:
        flags |= Qt::ItemIsUserCheckable;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    item->setEnabled(value == Qt::Checked ? true : false);
    QVector<int> roles;
    roles << role;
    emit dataChanged(index, index, roles);
    return true;
}
void Singleton::f2();{
EnabledProtocolsModel::~EnabledProtocolsModel()
    delete root_;
int EnabledProtocolsModel::rowCount(const QModelIndex &parent) const
   EnabledProtocolItem *parent_item;
    if (parent.column() > 0)
}
void Singleton::f3();{
            return true;
    }
    return false;
Qt::ItemFlags EnabledProtocolsProxyModel::flags(const QModelIndex &index) const
    Qt::ItemFlags flags = Qt::NoItemFlags;
}
void Singleton::f4();{
    heur_dtbl_entry_t *heuristic_table_;
EnabledProtocolItem::EnabledProtocolItem(QString name, QString description, bool enabled, EnabledProtocolItem* parent) :
    ModelHelperTreeItem<EnabledProtocolItem>(parent),
    name_(name),
    description_(description),
}
void Singleton::f5();{
    return colLast;
QVariant EnabledProtocolsModel::headerData(int section, Qt::Orientation orientation, int role) const
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum EnabledProtocolsColumn)section) {
        case colProtocol:
}
void Singleton::f6();{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    switch(index.column())
    {
    case colProtocol:
        flags |= Qt::ItemIsUserCheckable;
}
void Singleton::f7();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    item->setEnabled(value == Qt::Checked ? true : false);
    QVector<int> roles;
    roles << role;
    emit dataChanged(index, index, roles);
    return true;
}
void Singleton::f2();{
EnabledProtocolsModel::~EnabledProtocolsModel()
    delete root_;
int EnabledProtocolsModel::rowCount(const QModelIndex &parent) const
   EnabledProtocolItem *parent_item;
    if (parent.column() > 0)
}
void Singleton::f3();{
            return true;
    }
    return false;
Qt::ItemFlags EnabledProtocolsProxyModel::flags(const QModelIndex &index) const
    Qt::ItemFlags flags = Qt::NoItemFlags;
}
void Singleton::f4();{
    heur_dtbl_entry_t *heuristic_table_;
EnabledProtocolItem::EnabledProtocolItem(QString name, QString description, bool enabled, EnabledProtocolItem* parent) :
    ModelHelperTreeItem<EnabledProtocolItem>(parent),
    name_(name),
    description_(description),
}
void Singleton::f5();{
    return colLast;
QVariant EnabledProtocolsModel::headerData(int section, Qt::Orientation orientation, int role) const
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum EnabledProtocolsColumn)section) {
        case colProtocol:
}
void Singleton::f6();{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    switch(index.column())
    {
    case colProtocol:
        flags |= Qt::ItemIsUserCheckable;
}
void Singleton::f7();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f8();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    item->setEnabled(value == Qt::Checked ? true : false);
    QVector<int> roles;
    roles << role;
    emit dataChanged(index, index, roles);
    return true;
}
void Singleton::f2();{
EnabledProtocolsModel::~EnabledProtocolsModel()
    delete root_;
int EnabledProtocolsModel::rowCount(const QModelIndex &parent) const
   EnabledProtocolItem *parent_item;
    if (parent.column() > 0)
}
void Singleton::f3();{
            return true;
    }
    return false;
Qt::ItemFlags EnabledProtocolsProxyModel::flags(const QModelIndex &index) const
    Qt::ItemFlags flags = Qt::NoItemFlags;
}
void Singleton::f4();{
    heur_dtbl_entry_t *heuristic_table_;
EnabledProtocolItem::EnabledProtocolItem(QString name, QString description, bool enabled, EnabledProtocolItem* parent) :
    ModelHelperTreeItem<EnabledProtocolItem>(parent),
    name_(name),
    description_(description),
}
void Singleton::f5();{
    return colLast;
QVariant EnabledProtocolsModel::headerData(int section, Qt::Orientation orientation, int role) const
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum EnabledProtocolsColumn)section) {
        case colProtocol:
}
void Singleton::f6();{
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    switch(index.column())
    {
    case colProtocol:
        flags |= Qt::ItemIsUserCheckable;
}
void Singleton::f7();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f8();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f9();{
        redissect |= proto->applyValue();
        for (int heur_index = 0; heur_index < proto->childCount(); heur_index++) {
            EnabledProtocolItem* heur = proto->child(heur_index);
            redissect |= heur->applyValue();
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        close_bt->setDefault(true);
    }
    updateWidgets();
//    currentTabChanged();
    cap_file_.delayedRetapPackets();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        close_bt->setDefault(true);
    }
    updateWidgets();
//    currentTabChanged();
    cap_file_.delayedRetapPackets();
}
void Singleton::f2();{
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
}
void Singleton::f3();{
        filter_utf8 = filter_.toUtf8();
        filter = filter_utf8.constData();
    }
    endp_tree->trafficTreeHash()->user_data = endp_tree;
    registerTapListener(proto_get_protocol_filter_name(proto_id), endp_tree->trafficTreeHash(), filter, 0,
}
void Singleton::f4();{
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
    QPushButton *close_bt = buttonBox()->button(QDialogButtonBox::Close);
}
void Singleton::f5();{
            }
            return QVariant();
        case ENDP_COLUMN_GEO_AS_ORG:
            if (mmdb_lookup && mmdb_lookup->as_org) {
                return QVariant(mmdb_lookup->as_org);
}
void Singleton::f6();{
    // QTabWidget selects the first item by default.
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
}
void Singleton::f7();{
        }
        case ENDP_COLUMN_GEO_AS_NUM:
        {
            // Valid values first, similar to strings above.
            bool ok;
}
void Singleton::f8();{
    }
    updateItems();
EndpointTreeWidget::~EndpointTreeWidget()
    reset_hostlist_table_data(&hash_);
void EndpointTreeWidget::tapReset(void *conv_hash_ptr)
}
void Singleton::f9();{
        }
        ++it;
    }
    if (hosts_arr->len == 0) {
        QMessageBox::warning(this, tr("Map file error"), tr("No endpoints available to map"));
}
void Singleton::f10();{
        conv_array_(conv_array),
        conv_idx_(conv_idx),
        resolve_names_ptr_(resolve_names_ptr)
    {}
    hostlist_talker_t *hostlistTalker() {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        close_bt->setDefault(true);
    }
    updateWidgets();
//    currentTabChanged();
    cap_file_.delayedRetapPackets();
}
void Singleton::f2();{
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        close_bt->setDefault(true);
    }
    updateWidgets();
//    currentTabChanged();
    cap_file_.delayedRetapPackets();
}
void Singleton::f2();{
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
}
void Singleton::f3();{
        filter_utf8 = filter_.toUtf8();
        filter = filter_utf8.constData();
    }
    endp_tree->trafficTreeHash()->user_data = endp_tree;
    registerTapListener(proto_get_protocol_filter_name(proto_id), endp_tree->trafficTreeHash(), filter, 0,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        close_bt->setDefault(true);
    }
    updateWidgets();
//    currentTabChanged();
    cap_file_.delayedRetapPackets();
}
void Singleton::f2();{
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
}
void Singleton::f3();{
        filter_utf8 = filter_.toUtf8();
        filter = filter_utf8.constData();
    }
    endp_tree->trafficTreeHash()->user_data = endp_tree;
    registerTapListener(proto_get_protocol_filter_name(proto_id), endp_tree->trafficTreeHash(), filter, 0,
}
void Singleton::f4();{
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
    QPushButton *close_bt = buttonBox()->button(QDialogButtonBox::Close);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        close_bt->setDefault(true);
    }
    updateWidgets();
//    currentTabChanged();
    cap_file_.delayedRetapPackets();
}
void Singleton::f2();{
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
}
void Singleton::f3();{
        filter_utf8 = filter_.toUtf8();
        filter = filter_utf8.constData();
    }
    endp_tree->trafficTreeHash()->user_data = endp_tree;
    registerTapListener(proto_get_protocol_filter_name(proto_id), endp_tree->trafficTreeHash(), filter, 0,
}
void Singleton::f4();{
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
    QPushButton *close_bt = buttonBox()->button(QDialogButtonBox::Close);
}
void Singleton::f5();{
            }
            return QVariant();
        case ENDP_COLUMN_GEO_AS_ORG:
            if (mmdb_lookup && mmdb_lookup->as_org) {
                return QVariant(mmdb_lookup->as_org);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        close_bt->setDefault(true);
    }
    updateWidgets();
//    currentTabChanged();
    cap_file_.delayedRetapPackets();
}
void Singleton::f2();{
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
}
void Singleton::f3();{
        filter_utf8 = filter_.toUtf8();
        filter = filter_utf8.constData();
    }
    endp_tree->trafficTreeHash()->user_data = endp_tree;
    registerTapListener(proto_get_protocol_filter_name(proto_id), endp_tree->trafficTreeHash(), filter, 0,
}
void Singleton::f4();{
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
    QPushButton *close_bt = buttonBox()->button(QDialogButtonBox::Close);
}
void Singleton::f5();{
            }
            return QVariant();
        case ENDP_COLUMN_GEO_AS_ORG:
            if (mmdb_lookup && mmdb_lookup->as_org) {
                return QVariant(mmdb_lookup->as_org);
}
void Singleton::f6();{
    // QTabWidget selects the first item by default.
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        close_bt->setDefault(true);
    }
    updateWidgets();
//    currentTabChanged();
    cap_file_.delayedRetapPackets();
}
void Singleton::f2();{
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
}
void Singleton::f3();{
        filter_utf8 = filter_.toUtf8();
        filter = filter_utf8.constData();
    }
    endp_tree->trafficTreeHash()->user_data = endp_tree;
    registerTapListener(proto_get_protocol_filter_name(proto_id), endp_tree->trafficTreeHash(), filter, 0,
}
void Singleton::f4();{
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
    QPushButton *close_bt = buttonBox()->button(QDialogButtonBox::Close);
}
void Singleton::f5();{
            }
            return QVariant();
        case ENDP_COLUMN_GEO_AS_ORG:
            if (mmdb_lookup && mmdb_lookup->as_org) {
                return QVariant(mmdb_lookup->as_org);
}
void Singleton::f6();{
    // QTabWidget selects the first item by default.
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
}
void Singleton::f7();{
        }
        case ENDP_COLUMN_GEO_AS_NUM:
        {
            // Valid values first, similar to strings above.
            bool ok;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        close_bt->setDefault(true);
    }
    updateWidgets();
//    currentTabChanged();
    cap_file_.delayedRetapPackets();
}
void Singleton::f2();{
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
}
void Singleton::f3();{
        filter_utf8 = filter_.toUtf8();
        filter = filter_utf8.constData();
    }
    endp_tree->trafficTreeHash()->user_data = endp_tree;
    registerTapListener(proto_get_protocol_filter_name(proto_id), endp_tree->trafficTreeHash(), filter, 0,
}
void Singleton::f4();{
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
    QPushButton *close_bt = buttonBox()->button(QDialogButtonBox::Close);
}
void Singleton::f5();{
            }
            return QVariant();
        case ENDP_COLUMN_GEO_AS_ORG:
            if (mmdb_lookup && mmdb_lookup->as_org) {
                return QVariant(mmdb_lookup->as_org);
}
void Singleton::f6();{
    // QTabWidget selects the first item by default.
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
}
void Singleton::f7();{
        }
        case ENDP_COLUMN_GEO_AS_NUM:
        {
            // Valid values first, similar to strings above.
            bool ok;
}
void Singleton::f8();{
    }
    updateItems();
EndpointTreeWidget::~EndpointTreeWidget()
    reset_hostlist_table_data(&hash_);
void EndpointTreeWidget::tapReset(void *conv_hash_ptr)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        close_bt->setDefault(true);
    }
    updateWidgets();
//    currentTabChanged();
    cap_file_.delayedRetapPackets();
}
void Singleton::f2();{
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
}
void Singleton::f3();{
        filter_utf8 = filter_.toUtf8();
        filter = filter_utf8.constData();
    }
    endp_tree->trafficTreeHash()->user_data = endp_tree;
    registerTapListener(proto_get_protocol_filter_name(proto_id), endp_tree->trafficTreeHash(), filter, 0,
}
void Singleton::f4();{
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
    QPushButton *close_bt = buttonBox()->button(QDialogButtonBox::Close);
}
void Singleton::f5();{
            }
            return QVariant();
        case ENDP_COLUMN_GEO_AS_ORG:
            if (mmdb_lookup && mmdb_lookup->as_org) {
                return QVariant(mmdb_lookup->as_org);
}
void Singleton::f6();{
    // QTabWidget selects the first item by default.
    foreach (int endp_proto, endp_protos) {
        addTrafficTable(get_conversation_by_proto_id(endp_proto));
    }
    fillTypeMenu(endp_protos);
}
void Singleton::f7();{
        }
        case ENDP_COLUMN_GEO_AS_NUM:
        {
            // Valid values first, similar to strings above.
            bool ok;
}
void Singleton::f8();{
    }
    updateItems();
EndpointTreeWidget::~EndpointTreeWidget()
    reset_hostlist_table_data(&hash_);
void EndpointTreeWidget::tapReset(void *conv_hash_ptr)
}
void Singleton::f9();{
        }
        ++it;
    }
    if (hosts_arr->len == 0) {
        QMessageBox::warning(this, tr("Map file error"), tr("No endpoints available to map"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    ui->severitiesPushButton->setMenu(ui->menuShowExpert);
    ui->expertInfoTreeView->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(ui->expertInfoTreeView, SIGNAL(customContextMenuRequested(QPoint)),
                SLOT(showExpertInfoMenu(QPoint)));
    QMenu *submenu;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    ui->severitiesPushButton->setMenu(ui->menuShowExpert);
    ui->expertInfoTreeView->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(ui->expertInfoTreeView, SIGNAL(customContextMenuRequested(QPoint)),
                SLOT(showExpertInfoMenu(QPoint)));
    QMenu *submenu;
}
void Singleton::f2();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f3();{
void ExpertInfoDialog::on_actionShowChat_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_CHAT, !checked);
    updateWidgets();
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
}
void Singleton::f4();{
    connect(collapse, SIGNAL(triggered()), this, SLOT(collapseTree()));
    QAction *expand = new QAction(tr("Expand All"), this);
    ctx_menu_.addAction(expand);
    connect(expand, SIGNAL(triggered()), this, SLOT(expandTree()));
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f5();{
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
    updateWidgets();
void ExpertInfoDialog::showExpertInfoMenu(QPoint pos)
    bool enable = true;
}
void Singleton::f6();{
    bool enable = true;
    QModelIndex expertIndex = ui->expertInfoTreeView->indexAt(pos);
    if (!expertIndex.isValid()) {
        return;
    }
}
void Singleton::f7();{
//   down to one item, make sure it uses a single (or a few) base color(s), and generate
//   icons on the fly.
ExpertInfoDialog::ExpertInfoDialog(QWidget &parent, CaptureFile &capture_file) :
    WiresharkDialog(parent, capture_file),
    ui(new Ui::ExpertInfoDialog),
}
void Singleton::f8();{
        enable = false;
    }
    foreach (QMenu *submenu, ctx_menu_.findChildren<QMenu*>()) {
        submenu->setEnabled(enable && !file_closed_);
    }
}
void Singleton::f9();{
    ui->expertInfoTreeView->setModel(proxyModel_);
    setWindowSubtitle(tr("Expert Information"));
    // Clicking on an item jumps to its associated packet. Make the dialog
    // narrow so that we avoid obscuring the packet list.
    int dlg_width = parent.width() * 3 / 5;
}
void Singleton::f10();{
            break;
        default:
            break;
        }
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    ui->severitiesPushButton->setMenu(ui->menuShowExpert);
    ui->expertInfoTreeView->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(ui->expertInfoTreeView, SIGNAL(customContextMenuRequested(QPoint)),
                SLOT(showExpertInfoMenu(QPoint)));
    QMenu *submenu;
}
void Singleton::f2();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    ui->severitiesPushButton->setMenu(ui->menuShowExpert);
    ui->expertInfoTreeView->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(ui->expertInfoTreeView, SIGNAL(customContextMenuRequested(QPoint)),
                SLOT(showExpertInfoMenu(QPoint)));
    QMenu *submenu;
}
void Singleton::f2();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f3();{
void ExpertInfoDialog::on_actionShowChat_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_CHAT, !checked);
    updateWidgets();
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    ui->severitiesPushButton->setMenu(ui->menuShowExpert);
    ui->expertInfoTreeView->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(ui->expertInfoTreeView, SIGNAL(customContextMenuRequested(QPoint)),
                SLOT(showExpertInfoMenu(QPoint)));
    QMenu *submenu;
}
void Singleton::f2();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f3();{
void ExpertInfoDialog::on_actionShowChat_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_CHAT, !checked);
    updateWidgets();
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
}
void Singleton::f4();{
    connect(collapse, SIGNAL(triggered()), this, SLOT(collapseTree()));
    QAction *expand = new QAction(tr("Expand All"), this);
    ctx_menu_.addAction(expand);
    connect(expand, SIGNAL(triggered()), this, SLOT(expandTree()));
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    ui->severitiesPushButton->setMenu(ui->menuShowExpert);
    ui->expertInfoTreeView->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(ui->expertInfoTreeView, SIGNAL(customContextMenuRequested(QPoint)),
                SLOT(showExpertInfoMenu(QPoint)));
    QMenu *submenu;
}
void Singleton::f2();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f3();{
void ExpertInfoDialog::on_actionShowChat_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_CHAT, !checked);
    updateWidgets();
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
}
void Singleton::f4();{
    connect(collapse, SIGNAL(triggered()), this, SLOT(collapseTree()));
    QAction *expand = new QAction(tr("Expand All"), this);
    ctx_menu_.addAction(expand);
    connect(expand, SIGNAL(triggered()), this, SLOT(expandTree()));
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f5();{
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
    updateWidgets();
void ExpertInfoDialog::showExpertInfoMenu(QPoint pos)
    bool enable = true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    ui->severitiesPushButton->setMenu(ui->menuShowExpert);
    ui->expertInfoTreeView->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(ui->expertInfoTreeView, SIGNAL(customContextMenuRequested(QPoint)),
                SLOT(showExpertInfoMenu(QPoint)));
    QMenu *submenu;
}
void Singleton::f2();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f3();{
void ExpertInfoDialog::on_actionShowChat_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_CHAT, !checked);
    updateWidgets();
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
}
void Singleton::f4();{
    connect(collapse, SIGNAL(triggered()), this, SLOT(collapseTree()));
    QAction *expand = new QAction(tr("Expand All"), this);
    ctx_menu_.addAction(expand);
    connect(expand, SIGNAL(triggered()), this, SLOT(expandTree()));
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f5();{
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
    updateWidgets();
void ExpertInfoDialog::showExpertInfoMenu(QPoint pos)
    bool enable = true;
}
void Singleton::f6();{
    bool enable = true;
    QModelIndex expertIndex = ui->expertInfoTreeView->indexAt(pos);
    if (!expertIndex.isValid()) {
        return;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    ui->severitiesPushButton->setMenu(ui->menuShowExpert);
    ui->expertInfoTreeView->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(ui->expertInfoTreeView, SIGNAL(customContextMenuRequested(QPoint)),
                SLOT(showExpertInfoMenu(QPoint)));
    QMenu *submenu;
}
void Singleton::f2();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f3();{
void ExpertInfoDialog::on_actionShowChat_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_CHAT, !checked);
    updateWidgets();
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
}
void Singleton::f4();{
    connect(collapse, SIGNAL(triggered()), this, SLOT(collapseTree()));
    QAction *expand = new QAction(tr("Expand All"), this);
    ctx_menu_.addAction(expand);
    connect(expand, SIGNAL(triggered()), this, SLOT(expandTree()));
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f5();{
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
    updateWidgets();
void ExpertInfoDialog::showExpertInfoMenu(QPoint pos)
    bool enable = true;
}
void Singleton::f6();{
    bool enable = true;
    QModelIndex expertIndex = ui->expertInfoTreeView->indexAt(pos);
    if (!expertIndex.isValid()) {
        return;
    }
}
void Singleton::f7();{
//   down to one item, make sure it uses a single (or a few) base color(s), and generate
//   icons on the fly.
ExpertInfoDialog::ExpertInfoDialog(QWidget &parent, CaptureFile &capture_file) :
    WiresharkDialog(parent, capture_file),
    ui(new Ui::ExpertInfoDialog),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    ui->severitiesPushButton->setMenu(ui->menuShowExpert);
    ui->expertInfoTreeView->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(ui->expertInfoTreeView, SIGNAL(customContextMenuRequested(QPoint)),
                SLOT(showExpertInfoMenu(QPoint)));
    QMenu *submenu;
}
void Singleton::f2();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f3();{
void ExpertInfoDialog::on_actionShowChat_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_CHAT, !checked);
    updateWidgets();
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
}
void Singleton::f4();{
    connect(collapse, SIGNAL(triggered()), this, SLOT(collapseTree()));
    QAction *expand = new QAction(tr("Expand All"), this);
    ctx_menu_.addAction(expand);
    connect(expand, SIGNAL(triggered()), this, SLOT(expandTree()));
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f5();{
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
    updateWidgets();
void ExpertInfoDialog::showExpertInfoMenu(QPoint pos)
    bool enable = true;
}
void Singleton::f6();{
    bool enable = true;
    QModelIndex expertIndex = ui->expertInfoTreeView->indexAt(pos);
    if (!expertIndex.isValid()) {
        return;
    }
}
void Singleton::f7();{
//   down to one item, make sure it uses a single (or a few) base color(s), and generate
//   icons on the fly.
ExpertInfoDialog::ExpertInfoDialog(QWidget &parent, CaptureFile &capture_file) :
    WiresharkDialog(parent, capture_file),
    ui(new Ui::ExpertInfoDialog),
}
void Singleton::f8();{
        enable = false;
    }
    foreach (QMenu *submenu, ctx_menu_.findChildren<QMenu*>()) {
        submenu->setEnabled(enable && !file_closed_);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    ui->severitiesPushButton->setMenu(ui->menuShowExpert);
    ui->expertInfoTreeView->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(ui->expertInfoTreeView, SIGNAL(customContextMenuRequested(QPoint)),
                SLOT(showExpertInfoMenu(QPoint)));
    QMenu *submenu;
}
void Singleton::f2();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f3();{
void ExpertInfoDialog::on_actionShowChat_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_CHAT, !checked);
    updateWidgets();
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
}
void Singleton::f4();{
    connect(collapse, SIGNAL(triggered()), this, SLOT(collapseTree()));
    QAction *expand = new QAction(tr("Expand All"), this);
    ctx_menu_.addAction(expand);
    connect(expand, SIGNAL(triggered()), this, SLOT(expandTree()));
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f5();{
void ExpertInfoDialog::on_actionShowComment_toggled(bool checked)
    proxyModel_->setSeverityFilter(PI_COMMENT, !checked);
    updateWidgets();
void ExpertInfoDialog::showExpertInfoMenu(QPoint pos)
    bool enable = true;
}
void Singleton::f6();{
    bool enable = true;
    QModelIndex expertIndex = ui->expertInfoTreeView->indexAt(pos);
    if (!expertIndex.isValid()) {
        return;
    }
}
void Singleton::f7();{
//   down to one item, make sure it uses a single (or a few) base color(s), and generate
//   icons on the fly.
ExpertInfoDialog::ExpertInfoDialog(QWidget &parent, CaptureFile &capture_file) :
    WiresharkDialog(parent, capture_file),
    ui(new Ui::ExpertInfoDialog),
}
void Singleton::f8();{
        enable = false;
    }
    foreach (QMenu *submenu, ctx_menu_.findChildren<QMenu*>()) {
        submenu->setEnabled(enable && !file_closed_);
    }
}
void Singleton::f9();{
    ui->expertInfoTreeView->setModel(proxyModel_);
    setWindowSubtitle(tr("Expert Information"));
    // Clicking on an item jumps to its associated packet. Make the dialog
    // narrow so that we avoid obscuring the packet list.
    int dlg_width = parent.width() * 3 / 5;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        return item->hfId();
    default:
        break;
    }
    return QVariant();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        return item->hfId();
    default:
        break;
    }
    return QVariant();
}
void Singleton::f2();{
    return 0;
ExpertPacketItem* ExpertPacketItem::parentItem()
    return parentItem_;
ExpertInfoModel::ExpertInfoModel(CaptureFile& capture_file, QObject *parent) :
    QAbstractItemModel(parent),
}
void Singleton::f3();{
        parent_item = root_;
    else
        parent_item = static_cast<ExpertPacketItem*>(parent.internalPointer());
    if (group_by_summary_) {
        int row_count = 0;
}
void Singleton::f4();{
    packet_num_(expert_info.packet_num),
    group_(expert_info.group),
    severity_(expert_info.severity),
    hf_id_(expert_info.hf_index),
    protocol_(expert_info.protocol),
}
void Singleton::f5();{
            return QModelIndex();
        return createIndex(parent_item->row(), 0, parent_item);
    }
    return QModelIndex();
Qt::ItemFlags ExpertInfoModel::flags(const QModelIndex &index) const
}
void Singleton::f6();{
    static const char* rootName = "ROOT";
    static expert_info_t root_expert = { 0, -1, -1, -1, rootName, (gchar*)rootName, NULL };
    return new ExpertPacketItem(root_expert, NULL, NULL);
int ExpertInfoModel::numEvents(enum ExpertSeverity severity)
    return eventCounts_[severity];
}
void Singleton::f7();{
        root_->appendChild(new_item, groupKey);
        expert_root = new_item;
    }
    ExpertPacketItem *expert = new ExpertPacketItem(expert_info, &(capture_file_.capFile()->cinfo), expert_root);
    expert_root->appendChild(expert, groupKey);
}
void Singleton::f8();{
    default:
        break;
    }
    return QVariant();
//GUI helpers
}
void Singleton::f9();{
        if (parent_item == root_)
            return QModelIndex();
        return createIndex(parent_item->row(), 0, parent_item);
    }
    return QModelIndex();
}
void Singleton::f10();{
    group_by_summary_ = group_by_summary;
    emit endResetModel();
int ExpertInfoModel::rowCount(const QModelIndex &parent) const
    ExpertPacketItem *parent_item;
    if (parent.column() > 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        return item->hfId();
    default:
        break;
    }
    return QVariant();
}
void Singleton::f2();{
    return 0;
ExpertPacketItem* ExpertPacketItem::parentItem()
    return parentItem_;
ExpertInfoModel::ExpertInfoModel(CaptureFile& capture_file, QObject *parent) :
    QAbstractItemModel(parent),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        return item->hfId();
    default:
        break;
    }
    return QVariant();
}
void Singleton::f2();{
    return 0;
ExpertPacketItem* ExpertPacketItem::parentItem()
    return parentItem_;
ExpertInfoModel::ExpertInfoModel(CaptureFile& capture_file, QObject *parent) :
    QAbstractItemModel(parent),
}
void Singleton::f3();{
        parent_item = root_;
    else
        parent_item = static_cast<ExpertPacketItem*>(parent.internalPointer());
    if (group_by_summary_) {
        int row_count = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        return item->hfId();
    default:
        break;
    }
    return QVariant();
}
void Singleton::f2();{
    return 0;
ExpertPacketItem* ExpertPacketItem::parentItem()
    return parentItem_;
ExpertInfoModel::ExpertInfoModel(CaptureFile& capture_file, QObject *parent) :
    QAbstractItemModel(parent),
}
void Singleton::f3();{
        parent_item = root_;
    else
        parent_item = static_cast<ExpertPacketItem*>(parent.internalPointer());
    if (group_by_summary_) {
        int row_count = 0;
}
void Singleton::f4();{
    packet_num_(expert_info.packet_num),
    group_(expert_info.group),
    severity_(expert_info.severity),
    hf_id_(expert_info.hf_index),
    protocol_(expert_info.protocol),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        return item->hfId();
    default:
        break;
    }
    return QVariant();
}
void Singleton::f2();{
    return 0;
ExpertPacketItem* ExpertPacketItem::parentItem()
    return parentItem_;
ExpertInfoModel::ExpertInfoModel(CaptureFile& capture_file, QObject *parent) :
    QAbstractItemModel(parent),
}
void Singleton::f3();{
        parent_item = root_;
    else
        parent_item = static_cast<ExpertPacketItem*>(parent.internalPointer());
    if (group_by_summary_) {
        int row_count = 0;
}
void Singleton::f4();{
    packet_num_(expert_info.packet_num),
    group_(expert_info.group),
    severity_(expert_info.severity),
    hf_id_(expert_info.hf_index),
    protocol_(expert_info.protocol),
}
void Singleton::f5();{
            return QModelIndex();
        return createIndex(parent_item->row(), 0, parent_item);
    }
    return QModelIndex();
Qt::ItemFlags ExpertInfoModel::flags(const QModelIndex &index) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        return item->hfId();
    default:
        break;
    }
    return QVariant();
}
void Singleton::f2();{
    return 0;
ExpertPacketItem* ExpertPacketItem::parentItem()
    return parentItem_;
ExpertInfoModel::ExpertInfoModel(CaptureFile& capture_file, QObject *parent) :
    QAbstractItemModel(parent),
}
void Singleton::f3();{
        parent_item = root_;
    else
        parent_item = static_cast<ExpertPacketItem*>(parent.internalPointer());
    if (group_by_summary_) {
        int row_count = 0;
}
void Singleton::f4();{
    packet_num_(expert_info.packet_num),
    group_(expert_info.group),
    severity_(expert_info.severity),
    hf_id_(expert_info.hf_index),
    protocol_(expert_info.protocol),
}
void Singleton::f5();{
            return QModelIndex();
        return createIndex(parent_item->row(), 0, parent_item);
    }
    return QModelIndex();
Qt::ItemFlags ExpertInfoModel::flags(const QModelIndex &index) const
}
void Singleton::f6();{
    static const char* rootName = "ROOT";
    static expert_info_t root_expert = { 0, -1, -1, -1, rootName, (gchar*)rootName, NULL };
    return new ExpertPacketItem(root_expert, NULL, NULL);
int ExpertInfoModel::numEvents(enum ExpertSeverity severity)
    return eventCounts_[severity];
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        return item->hfId();
    default:
        break;
    }
    return QVariant();
}
void Singleton::f2();{
    return 0;
ExpertPacketItem* ExpertPacketItem::parentItem()
    return parentItem_;
ExpertInfoModel::ExpertInfoModel(CaptureFile& capture_file, QObject *parent) :
    QAbstractItemModel(parent),
}
void Singleton::f3();{
        parent_item = root_;
    else
        parent_item = static_cast<ExpertPacketItem*>(parent.internalPointer());
    if (group_by_summary_) {
        int row_count = 0;
}
void Singleton::f4();{
    packet_num_(expert_info.packet_num),
    group_(expert_info.group),
    severity_(expert_info.severity),
    hf_id_(expert_info.hf_index),
    protocol_(expert_info.protocol),
}
void Singleton::f5();{
            return QModelIndex();
        return createIndex(parent_item->row(), 0, parent_item);
    }
    return QModelIndex();
Qt::ItemFlags ExpertInfoModel::flags(const QModelIndex &index) const
}
void Singleton::f6();{
    static const char* rootName = "ROOT";
    static expert_info_t root_expert = { 0, -1, -1, -1, rootName, (gchar*)rootName, NULL };
    return new ExpertPacketItem(root_expert, NULL, NULL);
int ExpertInfoModel::numEvents(enum ExpertSeverity severity)
    return eventCounts_[severity];
}
void Singleton::f7();{
        root_->appendChild(new_item, groupKey);
        expert_root = new_item;
    }
    ExpertPacketItem *expert = new ExpertPacketItem(expert_info, &(capture_file_.capFile()->cinfo), expert_root);
    expert_root->appendChild(expert, groupKey);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        return item->hfId();
    default:
        break;
    }
    return QVariant();
}
void Singleton::f2();{
    return 0;
ExpertPacketItem* ExpertPacketItem::parentItem()
    return parentItem_;
ExpertInfoModel::ExpertInfoModel(CaptureFile& capture_file, QObject *parent) :
    QAbstractItemModel(parent),
}
void Singleton::f3();{
        parent_item = root_;
    else
        parent_item = static_cast<ExpertPacketItem*>(parent.internalPointer());
    if (group_by_summary_) {
        int row_count = 0;
}
void Singleton::f4();{
    packet_num_(expert_info.packet_num),
    group_(expert_info.group),
    severity_(expert_info.severity),
    hf_id_(expert_info.hf_index),
    protocol_(expert_info.protocol),
}
void Singleton::f5();{
            return QModelIndex();
        return createIndex(parent_item->row(), 0, parent_item);
    }
    return QModelIndex();
Qt::ItemFlags ExpertInfoModel::flags(const QModelIndex &index) const
}
void Singleton::f6();{
    static const char* rootName = "ROOT";
    static expert_info_t root_expert = { 0, -1, -1, -1, rootName, (gchar*)rootName, NULL };
    return new ExpertPacketItem(root_expert, NULL, NULL);
int ExpertInfoModel::numEvents(enum ExpertSeverity severity)
    return eventCounts_[severity];
}
void Singleton::f7();{
        root_->appendChild(new_item, groupKey);
        expert_root = new_item;
    }
    ExpertPacketItem *expert = new ExpertPacketItem(expert_info, &(capture_file_.capFile()->cinfo), expert_root);
    expert_root->appendChild(expert, groupKey);
}
void Singleton::f8();{
    default:
        break;
    }
    return QVariant();
//GUI helpers
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        return item->hfId();
    default:
        break;
    }
    return QVariant();
}
void Singleton::f2();{
    return 0;
ExpertPacketItem* ExpertPacketItem::parentItem()
    return parentItem_;
ExpertInfoModel::ExpertInfoModel(CaptureFile& capture_file, QObject *parent) :
    QAbstractItemModel(parent),
}
void Singleton::f3();{
        parent_item = root_;
    else
        parent_item = static_cast<ExpertPacketItem*>(parent.internalPointer());
    if (group_by_summary_) {
        int row_count = 0;
}
void Singleton::f4();{
    packet_num_(expert_info.packet_num),
    group_(expert_info.group),
    severity_(expert_info.severity),
    hf_id_(expert_info.hf_index),
    protocol_(expert_info.protocol),
}
void Singleton::f5();{
            return QModelIndex();
        return createIndex(parent_item->row(), 0, parent_item);
    }
    return QModelIndex();
Qt::ItemFlags ExpertInfoModel::flags(const QModelIndex &index) const
}
void Singleton::f6();{
    static const char* rootName = "ROOT";
    static expert_info_t root_expert = { 0, -1, -1, -1, rootName, (gchar*)rootName, NULL };
    return new ExpertPacketItem(root_expert, NULL, NULL);
int ExpertInfoModel::numEvents(enum ExpertSeverity severity)
    return eventCounts_[severity];
}
void Singleton::f7();{
        root_->appendChild(new_item, groupKey);
        expert_root = new_item;
    }
    ExpertPacketItem *expert = new ExpertPacketItem(expert_info, &(capture_file_.capFile()->cinfo), expert_root);
    expert_root->appendChild(expert, groupKey);
}
void Singleton::f8();{
    default:
        break;
    }
    return QVariant();
//GUI helpers
}
void Singleton::f9();{
        if (parent_item == root_)
            return QModelIndex();
        return createIndex(parent_item->row(), 0, parent_item);
    }
    return QModelIndex();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
    else
    {
        hidden_severities_.removeOne(severity);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
    else
    {
        hidden_severities_.removeOne(severity);
    }
}
void Singleton::f2();{
            if (severityMode_ == Packet)
                return tr("Packet");
            else
                return tr("Severity");
        case colProxySummary:
}
void Singleton::f3();{
        if (!source_index.isValid() || source_index.parent().isValid())
            return QVariant();
        ExpertPacketItem* item = static_cast<ExpertPacketItem*>(source_index.internalPointer());
        if (item == NULL)
            return QVariant();
}
void Singleton::f4();{
            }
            checkPacketNumber = true;
            break;
        case colProxySummary:
            compare_ret = left_item->summary().compare(right_item->summary());
}
void Singleton::f5();{
            return tr("Protocol");
        case colProxyCount:
            return tr("Count");
        default:
            break;
}
void Singleton::f6();{
        }
    }
    // fallback to string cmp on other fields
    return QSortFilterProxyModel::lessThan(source_left, source_right);
QVariant ExpertInfoProxyModel::data(const QModelIndex &proxy_index, int role) const
}
void Singleton::f7();{
            return Qt::AlignRight;
        default:
            break;
        }
        return Qt::AlignLeft;
}
void Singleton::f8();{
ExpertInfoProxyModel::ExpertInfoProxyModel(QObject *parent) : QSortFilterProxyModel(parent),
    severityMode_(Group)
bool ExpertInfoProxyModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    ExpertPacketItem *left_item,
                     *right_item;
}
void Singleton::f9();{
    return QSortFilterProxyModel::data(proxy_index, role);
QVariant ExpertInfoProxyModel::headerData(int section, Qt::Orientation orientation, int role) const
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum ExpertProxyColumn)section) {
        case colProxySeverity:
}
void Singleton::f10();{
                unsigned int count = 0;
                ExpertPacketItem *child_item,
                                 *item = static_cast<ExpertPacketItem*>(source_index.internalPointer());
                for (int row = 0; row < item->childCount(); row++) {
                    child_item = item->child(row);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
    else
    {
        hidden_severities_.removeOne(severity);
    }
}
void Singleton::f2();{
            if (severityMode_ == Packet)
                return tr("Packet");
            else
                return tr("Severity");
        case colProxySummary:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
    else
    {
        hidden_severities_.removeOne(severity);
    }
}
void Singleton::f2();{
            if (severityMode_ == Packet)
                return tr("Packet");
            else
                return tr("Severity");
        case colProxySummary:
}
void Singleton::f3();{
        if (!source_index.isValid() || source_index.parent().isValid())
            return QVariant();
        ExpertPacketItem* item = static_cast<ExpertPacketItem*>(source_index.internalPointer());
        if (item == NULL)
            return QVariant();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
    else
    {
        hidden_severities_.removeOne(severity);
    }
}
void Singleton::f2();{
            if (severityMode_ == Packet)
                return tr("Packet");
            else
                return tr("Severity");
        case colProxySummary:
}
void Singleton::f3();{
        if (!source_index.isValid() || source_index.parent().isValid())
            return QVariant();
        ExpertPacketItem* item = static_cast<ExpertPacketItem*>(source_index.internalPointer());
        if (item == NULL)
            return QVariant();
}
void Singleton::f4();{
            }
            checkPacketNumber = true;
            break;
        case colProxySummary:
            compare_ret = left_item->summary().compare(right_item->summary());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
    else
    {
        hidden_severities_.removeOne(severity);
    }
}
void Singleton::f2();{
            if (severityMode_ == Packet)
                return tr("Packet");
            else
                return tr("Severity");
        case colProxySummary:
}
void Singleton::f3();{
        if (!source_index.isValid() || source_index.parent().isValid())
            return QVariant();
        ExpertPacketItem* item = static_cast<ExpertPacketItem*>(source_index.internalPointer());
        if (item == NULL)
            return QVariant();
}
void Singleton::f4();{
            }
            checkPacketNumber = true;
            break;
        case colProxySummary:
            compare_ret = left_item->summary().compare(right_item->summary());
}
void Singleton::f5();{
            return tr("Protocol");
        case colProxyCount:
            return tr("Count");
        default:
            break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
    else
    {
        hidden_severities_.removeOne(severity);
    }
}
void Singleton::f2();{
            if (severityMode_ == Packet)
                return tr("Packet");
            else
                return tr("Severity");
        case colProxySummary:
}
void Singleton::f3();{
        if (!source_index.isValid() || source_index.parent().isValid())
            return QVariant();
        ExpertPacketItem* item = static_cast<ExpertPacketItem*>(source_index.internalPointer());
        if (item == NULL)
            return QVariant();
}
void Singleton::f4();{
            }
            checkPacketNumber = true;
            break;
        case colProxySummary:
            compare_ret = left_item->summary().compare(right_item->summary());
}
void Singleton::f5();{
            return tr("Protocol");
        case colProxyCount:
            return tr("Count");
        default:
            break;
}
void Singleton::f6();{
        }
    }
    // fallback to string cmp on other fields
    return QSortFilterProxyModel::lessThan(source_left, source_right);
QVariant ExpertInfoProxyModel::data(const QModelIndex &proxy_index, int role) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
    else
    {
        hidden_severities_.removeOne(severity);
    }
}
void Singleton::f2();{
            if (severityMode_ == Packet)
                return tr("Packet");
            else
                return tr("Severity");
        case colProxySummary:
}
void Singleton::f3();{
        if (!source_index.isValid() || source_index.parent().isValid())
            return QVariant();
        ExpertPacketItem* item = static_cast<ExpertPacketItem*>(source_index.internalPointer());
        if (item == NULL)
            return QVariant();
}
void Singleton::f4();{
            }
            checkPacketNumber = true;
            break;
        case colProxySummary:
            compare_ret = left_item->summary().compare(right_item->summary());
}
void Singleton::f5();{
            return tr("Protocol");
        case colProxyCount:
            return tr("Count");
        default:
            break;
}
void Singleton::f6();{
        }
    }
    // fallback to string cmp on other fields
    return QSortFilterProxyModel::lessThan(source_left, source_right);
QVariant ExpertInfoProxyModel::data(const QModelIndex &proxy_index, int role) const
}
void Singleton::f7();{
            return Qt::AlignRight;
        default:
            break;
        }
        return Qt::AlignLeft;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
    else
    {
        hidden_severities_.removeOne(severity);
    }
}
void Singleton::f2();{
            if (severityMode_ == Packet)
                return tr("Packet");
            else
                return tr("Severity");
        case colProxySummary:
}
void Singleton::f3();{
        if (!source_index.isValid() || source_index.parent().isValid())
            return QVariant();
        ExpertPacketItem* item = static_cast<ExpertPacketItem*>(source_index.internalPointer());
        if (item == NULL)
            return QVariant();
}
void Singleton::f4();{
            }
            checkPacketNumber = true;
            break;
        case colProxySummary:
            compare_ret = left_item->summary().compare(right_item->summary());
}
void Singleton::f5();{
            return tr("Protocol");
        case colProxyCount:
            return tr("Count");
        default:
            break;
}
void Singleton::f6();{
        }
    }
    // fallback to string cmp on other fields
    return QSortFilterProxyModel::lessThan(source_left, source_right);
QVariant ExpertInfoProxyModel::data(const QModelIndex &proxy_index, int role) const
}
void Singleton::f7();{
            return Qt::AlignRight;
        default:
            break;
        }
        return Qt::AlignLeft;
}
void Singleton::f8();{
ExpertInfoProxyModel::ExpertInfoProxyModel(QObject *parent) : QSortFilterProxyModel(parent),
    severityMode_(Group)
bool ExpertInfoProxyModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    ExpertPacketItem *left_item,
                     *right_item;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
    else
    {
        hidden_severities_.removeOne(severity);
    }
}
void Singleton::f2();{
            if (severityMode_ == Packet)
                return tr("Packet");
            else
                return tr("Severity");
        case colProxySummary:
}
void Singleton::f3();{
        if (!source_index.isValid() || source_index.parent().isValid())
            return QVariant();
        ExpertPacketItem* item = static_cast<ExpertPacketItem*>(source_index.internalPointer());
        if (item == NULL)
            return QVariant();
}
void Singleton::f4();{
            }
            checkPacketNumber = true;
            break;
        case colProxySummary:
            compare_ret = left_item->summary().compare(right_item->summary());
}
void Singleton::f5();{
            return tr("Protocol");
        case colProxyCount:
            return tr("Count");
        default:
            break;
}
void Singleton::f6();{
        }
    }
    // fallback to string cmp on other fields
    return QSortFilterProxyModel::lessThan(source_left, source_right);
QVariant ExpertInfoProxyModel::data(const QModelIndex &proxy_index, int role) const
}
void Singleton::f7();{
            return Qt::AlignRight;
        default:
            break;
        }
        return Qt::AlignLeft;
}
void Singleton::f8();{
ExpertInfoProxyModel::ExpertInfoProxyModel(QObject *parent) : QSortFilterProxyModel(parent),
    severityMode_(Group)
bool ExpertInfoProxyModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    ExpertPacketItem *left_item,
                     *right_item;
}
void Singleton::f9();{
    return QSortFilterProxyModel::data(proxy_index, role);
QVariant ExpertInfoProxyModel::headerData(int section, Qt::Orientation orientation, int role) const
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum ExpertProxyColumn)section) {
        case colProxySeverity:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f2();{
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
        if (prefs.gui_fileopen_dir[0] != '\0')
            setDirectory(prefs.gui_fileopen_dir);
}
void Singleton::f3();{
        print_args_.print_col_headings  = TRUE;
        print_args_.print_dissections   = print_dissections_as_displayed;
        print_args_.print_hex           = FALSE;
        print_args_.print_formfeed      = FALSE;
        switch (export_type_) {
}
void Singleton::f4();{
            print_args_.stream = print_stream_text_new(TRUE, print_args_.file);
            if (print_args_.stream == NULL) {
                open_failure_alert_box(print_args_.file, errno, TRUE);
                return;
            }
}
void Singleton::f5();{
ExportDissectionDialog::ExportDissectionDialog(QWidget *parent, capture_file *cap_file, export_type_e export_type, QString selRange):
    WiresharkFileDialog(parent),
    export_type_(export_type),
    cap_file_(cap_file)
    , save_bt_(NULL)
}
void Singleton::f6();{
    case FO_STYLE_SPECIFIED:
        /* The user has specified that we should always start out in a
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
}
void Singleton::f7();{
            }
            status = cf_print_packets(cap_file_, &print_args_, TRUE);
            break;
        case export_type_csv:       /* CSV */
            status = cf_write_csv_packets(cap_file_, &print_args_);
}
void Singleton::f8();{
    }
    QDialogButtonBox *button_box = findChild<QDialogButtonBox *>();
    // Add extra widgets
    setOption(QFileDialog::DontUseNativeDialog, true);
    QGridLayout *fd_grid = qobject_cast<QGridLayout*>(layout());
}
void Singleton::f9();{
    if (button_box) {
        button_box->addButton(QDialogButtonBox::Help);
        connect(button_box, SIGNAL(helpRequested()), this, SLOT(on_buttonBox_helpRequested()));
        save_bt_ = button_box->button(QDialogButtonBox::Save);
    }
}
void Singleton::f10();{
    setOption(QFileDialog::DontUseNativeDialog, true);
    QGridLayout *fd_grid = qobject_cast<QGridLayout*>(layout());
    QHBoxLayout *h_box = new QHBoxLayout();
    QStringList name_filters;
    int last_row;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f2();{
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
        if (prefs.gui_fileopen_dir[0] != '\0')
            setDirectory(prefs.gui_fileopen_dir);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f2();{
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
        if (prefs.gui_fileopen_dir[0] != '\0')
            setDirectory(prefs.gui_fileopen_dir);
}
void Singleton::f3();{
        print_args_.print_col_headings  = TRUE;
        print_args_.print_dissections   = print_dissections_as_displayed;
        print_args_.print_hex           = FALSE;
        print_args_.print_formfeed      = FALSE;
        switch (export_type_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f2();{
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
        if (prefs.gui_fileopen_dir[0] != '\0')
            setDirectory(prefs.gui_fileopen_dir);
}
void Singleton::f3();{
        print_args_.print_col_headings  = TRUE;
        print_args_.print_dissections   = print_dissections_as_displayed;
        print_args_.print_hex           = FALSE;
        print_args_.print_formfeed      = FALSE;
        switch (export_type_) {
}
void Singleton::f4();{
            print_args_.stream = print_stream_text_new(TRUE, print_args_.file);
            if (print_args_.stream == NULL) {
                open_failure_alert_box(print_args_.file, errno, TRUE);
                return;
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f2();{
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
        if (prefs.gui_fileopen_dir[0] != '\0')
            setDirectory(prefs.gui_fileopen_dir);
}
void Singleton::f3();{
        print_args_.print_col_headings  = TRUE;
        print_args_.print_dissections   = print_dissections_as_displayed;
        print_args_.print_hex           = FALSE;
        print_args_.print_formfeed      = FALSE;
        switch (export_type_) {
}
void Singleton::f4();{
            print_args_.stream = print_stream_text_new(TRUE, print_args_.file);
            if (print_args_.stream == NULL) {
                open_failure_alert_box(print_args_.file, errno, TRUE);
                return;
            }
}
void Singleton::f5();{
ExportDissectionDialog::ExportDissectionDialog(QWidget *parent, capture_file *cap_file, export_type_e export_type, QString selRange):
    WiresharkFileDialog(parent),
    export_type_(export_type),
    cap_file_(cap_file)
    , save_bt_(NULL)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f2();{
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
        if (prefs.gui_fileopen_dir[0] != '\0')
            setDirectory(prefs.gui_fileopen_dir);
}
void Singleton::f3();{
        print_args_.print_col_headings  = TRUE;
        print_args_.print_dissections   = print_dissections_as_displayed;
        print_args_.print_hex           = FALSE;
        print_args_.print_formfeed      = FALSE;
        switch (export_type_) {
}
void Singleton::f4();{
            print_args_.stream = print_stream_text_new(TRUE, print_args_.file);
            if (print_args_.stream == NULL) {
                open_failure_alert_box(print_args_.file, errno, TRUE);
                return;
            }
}
void Singleton::f5();{
ExportDissectionDialog::ExportDissectionDialog(QWidget *parent, capture_file *cap_file, export_type_e export_type, QString selRange):
    WiresharkFileDialog(parent),
    export_type_(export_type),
    cap_file_(cap_file)
    , save_bt_(NULL)
}
void Singleton::f6();{
    case FO_STYLE_SPECIFIED:
        /* The user has specified that we should always start out in a
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f2();{
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
        if (prefs.gui_fileopen_dir[0] != '\0')
            setDirectory(prefs.gui_fileopen_dir);
}
void Singleton::f3();{
        print_args_.print_col_headings  = TRUE;
        print_args_.print_dissections   = print_dissections_as_displayed;
        print_args_.print_hex           = FALSE;
        print_args_.print_formfeed      = FALSE;
        switch (export_type_) {
}
void Singleton::f4();{
            print_args_.stream = print_stream_text_new(TRUE, print_args_.file);
            if (print_args_.stream == NULL) {
                open_failure_alert_box(print_args_.file, errno, TRUE);
                return;
            }
}
void Singleton::f5();{
ExportDissectionDialog::ExportDissectionDialog(QWidget *parent, capture_file *cap_file, export_type_e export_type, QString selRange):
    WiresharkFileDialog(parent),
    export_type_(export_type),
    cap_file_(cap_file)
    , save_bt_(NULL)
}
void Singleton::f6();{
    case FO_STYLE_SPECIFIED:
        /* The user has specified that we should always start out in a
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
}
void Singleton::f7();{
            }
            status = cf_print_packets(cap_file_, &print_args_, TRUE);
            break;
        case export_type_csv:       /* CSV */
            status = cf_write_csv_packets(cap_file_, &print_args_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f2();{
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
        if (prefs.gui_fileopen_dir[0] != '\0')
            setDirectory(prefs.gui_fileopen_dir);
}
void Singleton::f3();{
        print_args_.print_col_headings  = TRUE;
        print_args_.print_dissections   = print_dissections_as_displayed;
        print_args_.print_hex           = FALSE;
        print_args_.print_formfeed      = FALSE;
        switch (export_type_) {
}
void Singleton::f4();{
            print_args_.stream = print_stream_text_new(TRUE, print_args_.file);
            if (print_args_.stream == NULL) {
                open_failure_alert_box(print_args_.file, errno, TRUE);
                return;
            }
}
void Singleton::f5();{
ExportDissectionDialog::ExportDissectionDialog(QWidget *parent, capture_file *cap_file, export_type_e export_type, QString selRange):
    WiresharkFileDialog(parent),
    export_type_(export_type),
    cap_file_(cap_file)
    , save_bt_(NULL)
}
void Singleton::f6();{
    case FO_STYLE_SPECIFIED:
        /* The user has specified that we should always start out in a
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
}
void Singleton::f7();{
            }
            status = cf_print_packets(cap_file_, &print_args_, TRUE);
            break;
        case export_type_csv:       /* CSV */
            status = cf_write_csv_packets(cap_file_, &print_args_);
}
void Singleton::f8();{
    }
    QDialogButtonBox *button_box = findChild<QDialogButtonBox *>();
    // Add extra widgets
    setOption(QFileDialog::DontUseNativeDialog, true);
    QGridLayout *fd_grid = qobject_cast<QGridLayout*>(layout());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f2();{
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
        if (prefs.gui_fileopen_dir[0] != '\0')
            setDirectory(prefs.gui_fileopen_dir);
}
void Singleton::f3();{
        print_args_.print_col_headings  = TRUE;
        print_args_.print_dissections   = print_dissections_as_displayed;
        print_args_.print_hex           = FALSE;
        print_args_.print_formfeed      = FALSE;
        switch (export_type_) {
}
void Singleton::f4();{
            print_args_.stream = print_stream_text_new(TRUE, print_args_.file);
            if (print_args_.stream == NULL) {
                open_failure_alert_box(print_args_.file, errno, TRUE);
                return;
            }
}
void Singleton::f5();{
ExportDissectionDialog::ExportDissectionDialog(QWidget *parent, capture_file *cap_file, export_type_e export_type, QString selRange):
    WiresharkFileDialog(parent),
    export_type_(export_type),
    cap_file_(cap_file)
    , save_bt_(NULL)
}
void Singleton::f6();{
    case FO_STYLE_SPECIFIED:
        /* The user has specified that we should always start out in a
         * specified directory; if they've specified that directory,
         * start out by showing the files in that dir.
         */
}
void Singleton::f7();{
            }
            status = cf_print_packets(cap_file_, &print_args_, TRUE);
            break;
        case export_type_csv:       /* CSV */
            status = cf_write_csv_packets(cap_file_, &print_args_);
}
void Singleton::f8();{
    }
    QDialogButtonBox *button_box = findChild<QDialogButtonBox *>();
    // Add extra widgets
    setOption(QFileDialog::DontUseNativeDialog, true);
    QGridLayout *fd_grid = qobject_cast<QGridLayout*>(layout());
}
void Singleton::f9();{
    if (button_box) {
        button_box->addButton(QDialogButtonBox::Help);
        connect(button_box, SIGNAL(helpRequested()), this, SLOT(on_buttonBox_helpRequested()));
        save_bt_ = button_box->button(QDialogButtonBox::Save);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    objects_.append(VariantPointer<export_object_entry_t>::asQVariant(entry));
    endInsertRows();
export_object_entry_t* ExportObjectModel::objectEntry(int row)
    return VariantPointer<export_object_entry_t>::asPtr(objects_.value(row));
bool ExportObjectModel::saveEntry(QModelIndex &index, QString filename)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    objects_.append(VariantPointer<export_object_entry_t>::asQVariant(entry));
    endInsertRows();
export_object_entry_t* ExportObjectModel::objectEntry(int row)
    return VariantPointer<export_object_entry_t>::asPtr(objects_.value(row));
bool ExportObjectModel::saveEntry(QModelIndex &index, QString filename)
}
void Singleton::f2();{
                          *right_entry = VariantPointer<export_object_entry_t>::asPtr(sourceModel()->data(source_right, Qt::UserRole));
    if ((left_entry != NULL) && (right_entry != NULL))
    {
        switch (source_left.column())
        {
}
void Singleton::f3();{
        return QVariant();
    switch (section) {
    case colPacket:
        return tr("Packet");
    case colHostname:
}
void Singleton::f4();{
        case ExportObjectModel::colFilename:
            break;
        }
    }
    return QSortFilterProxyModel::lessThan(source_left, source_right);
}
void Singleton::f5();{
        return object_list->model->objectEntry(row);
    return NULL;
} // extern "C"
ExportObjectModel::ExportObjectModel(register_eo_t* eo, QObject *parent) :
    QAbstractTableModel(parent),
}
void Singleton::f6();{
            return left_entry->pkt_num < right_entry->pkt_num;
        case ExportObjectModel::colSize:
            return left_entry->payload_len < right_entry->payload_len;
        case ExportObjectModel::colFilename:
            break;
}
void Singleton::f7();{
                g_snprintf(generic_name, sizeof(generic_name),
                    "object%u%s%s", entry->pkt_num, ext ? "." : "",
                    ext ? ext : "");
                safe_filename = eo_massage_str(generic_name,
                    EXPORT_OBJECT_MAXFILELEN, count);
}
void Singleton::f8();{
        QModelIndex idx = sourceModel()->index(source_row, ExportObjectModel::colContent);
        if (!idx.isValid())
            return false;
        if (contentFilter_.compare(idx.data().toString()) != 0)
            return false;
}
void Singleton::f9();{
    return colExportObjectMax;
void ExportObjectModel::addObjectEntry(export_object_entry_t *entry)
    if (entry == NULL)
        return;
    int count = objects_.count();
}
void Singleton::f10();{
            break;
        }
    }
    return QSortFilterProxyModel::lessThan(source_left, source_right);
void ExportObjectProxyModel::setContentFilterString(QString filter_)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    objects_.append(VariantPointer<export_object_entry_t>::asQVariant(entry));
    endInsertRows();
export_object_entry_t* ExportObjectModel::objectEntry(int row)
    return VariantPointer<export_object_entry_t>::asPtr(objects_.value(row));
bool ExportObjectModel::saveEntry(QModelIndex &index, QString filename)
}
void Singleton::f2();{
                          *right_entry = VariantPointer<export_object_entry_t>::asPtr(sourceModel()->data(source_right, Qt::UserRole));
    if ((left_entry != NULL) && (right_entry != NULL))
    {
        switch (source_left.column())
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    objects_.append(VariantPointer<export_object_entry_t>::asQVariant(entry));
    endInsertRows();
export_object_entry_t* ExportObjectModel::objectEntry(int row)
    return VariantPointer<export_object_entry_t>::asPtr(objects_.value(row));
bool ExportObjectModel::saveEntry(QModelIndex &index, QString filename)
}
void Singleton::f2();{
                          *right_entry = VariantPointer<export_object_entry_t>::asPtr(sourceModel()->data(source_right, Qt::UserRole));
    if ((left_entry != NULL) && (right_entry != NULL))
    {
        switch (source_left.column())
        {
}
void Singleton::f3();{
        return QVariant();
    switch (section) {
    case colPacket:
        return tr("Packet");
    case colHostname:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    objects_.append(VariantPointer<export_object_entry_t>::asQVariant(entry));
    endInsertRows();
export_object_entry_t* ExportObjectModel::objectEntry(int row)
    return VariantPointer<export_object_entry_t>::asPtr(objects_.value(row));
bool ExportObjectModel::saveEntry(QModelIndex &index, QString filename)
}
void Singleton::f2();{
                          *right_entry = VariantPointer<export_object_entry_t>::asPtr(sourceModel()->data(source_right, Qt::UserRole));
    if ((left_entry != NULL) && (right_entry != NULL))
    {
        switch (source_left.column())
        {
}
void Singleton::f3();{
        return QVariant();
    switch (section) {
    case colPacket:
        return tr("Packet");
    case colHostname:
}
void Singleton::f4();{
        case ExportObjectModel::colFilename:
            break;
        }
    }
    return QSortFilterProxyModel::lessThan(source_left, source_right);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    objects_.append(VariantPointer<export_object_entry_t>::asQVariant(entry));
    endInsertRows();
export_object_entry_t* ExportObjectModel::objectEntry(int row)
    return VariantPointer<export_object_entry_t>::asPtr(objects_.value(row));
bool ExportObjectModel::saveEntry(QModelIndex &index, QString filename)
}
void Singleton::f2();{
                          *right_entry = VariantPointer<export_object_entry_t>::asPtr(sourceModel()->data(source_right, Qt::UserRole));
    if ((left_entry != NULL) && (right_entry != NULL))
    {
        switch (source_left.column())
        {
}
void Singleton::f3();{
        return QVariant();
    switch (section) {
    case colPacket:
        return tr("Packet");
    case colHostname:
}
void Singleton::f4();{
        case ExportObjectModel::colFilename:
            break;
        }
    }
    return QSortFilterProxyModel::lessThan(source_left, source_right);
}
void Singleton::f5();{
        return object_list->model->objectEntry(row);
    return NULL;
} // extern "C"
ExportObjectModel::ExportObjectModel(register_eo_t* eo, QObject *parent) :
    QAbstractTableModel(parent),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    objects_.append(VariantPointer<export_object_entry_t>::asQVariant(entry));
    endInsertRows();
export_object_entry_t* ExportObjectModel::objectEntry(int row)
    return VariantPointer<export_object_entry_t>::asPtr(objects_.value(row));
bool ExportObjectModel::saveEntry(QModelIndex &index, QString filename)
}
void Singleton::f2();{
                          *right_entry = VariantPointer<export_object_entry_t>::asPtr(sourceModel()->data(source_right, Qt::UserRole));
    if ((left_entry != NULL) && (right_entry != NULL))
    {
        switch (source_left.column())
        {
}
void Singleton::f3();{
        return QVariant();
    switch (section) {
    case colPacket:
        return tr("Packet");
    case colHostname:
}
void Singleton::f4();{
        case ExportObjectModel::colFilename:
            break;
        }
    }
    return QSortFilterProxyModel::lessThan(source_left, source_right);
}
void Singleton::f5();{
        return object_list->model->objectEntry(row);
    return NULL;
} // extern "C"
ExportObjectModel::ExportObjectModel(register_eo_t* eo, QObject *parent) :
    QAbstractTableModel(parent),
}
void Singleton::f6();{
            return left_entry->pkt_num < right_entry->pkt_num;
        case ExportObjectModel::colSize:
            return left_entry->payload_len < right_entry->payload_len;
        case ExportObjectModel::colFilename:
            break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    objects_.append(VariantPointer<export_object_entry_t>::asQVariant(entry));
    endInsertRows();
export_object_entry_t* ExportObjectModel::objectEntry(int row)
    return VariantPointer<export_object_entry_t>::asPtr(objects_.value(row));
bool ExportObjectModel::saveEntry(QModelIndex &index, QString filename)
}
void Singleton::f2();{
                          *right_entry = VariantPointer<export_object_entry_t>::asPtr(sourceModel()->data(source_right, Qt::UserRole));
    if ((left_entry != NULL) && (right_entry != NULL))
    {
        switch (source_left.column())
        {
}
void Singleton::f3();{
        return QVariant();
    switch (section) {
    case colPacket:
        return tr("Packet");
    case colHostname:
}
void Singleton::f4();{
        case ExportObjectModel::colFilename:
            break;
        }
    }
    return QSortFilterProxyModel::lessThan(source_left, source_right);
}
void Singleton::f5();{
        return object_list->model->objectEntry(row);
    return NULL;
} // extern "C"
ExportObjectModel::ExportObjectModel(register_eo_t* eo, QObject *parent) :
    QAbstractTableModel(parent),
}
void Singleton::f6();{
            return left_entry->pkt_num < right_entry->pkt_num;
        case ExportObjectModel::colSize:
            return left_entry->payload_len < right_entry->payload_len;
        case ExportObjectModel::colFilename:
            break;
}
void Singleton::f7();{
                g_snprintf(generic_name, sizeof(generic_name),
                    "object%u%s%s", entry->pkt_num, ext ? "." : "",
                    ext ? ext : "");
                safe_filename = eo_massage_str(generic_name,
                    EXPORT_OBJECT_MAXFILELEN, count);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    objects_.append(VariantPointer<export_object_entry_t>::asQVariant(entry));
    endInsertRows();
export_object_entry_t* ExportObjectModel::objectEntry(int row)
    return VariantPointer<export_object_entry_t>::asPtr(objects_.value(row));
bool ExportObjectModel::saveEntry(QModelIndex &index, QString filename)
}
void Singleton::f2();{
                          *right_entry = VariantPointer<export_object_entry_t>::asPtr(sourceModel()->data(source_right, Qt::UserRole));
    if ((left_entry != NULL) && (right_entry != NULL))
    {
        switch (source_left.column())
        {
}
void Singleton::f3();{
        return QVariant();
    switch (section) {
    case colPacket:
        return tr("Packet");
    case colHostname:
}
void Singleton::f4();{
        case ExportObjectModel::colFilename:
            break;
        }
    }
    return QSortFilterProxyModel::lessThan(source_left, source_right);
}
void Singleton::f5();{
        return object_list->model->objectEntry(row);
    return NULL;
} // extern "C"
ExportObjectModel::ExportObjectModel(register_eo_t* eo, QObject *parent) :
    QAbstractTableModel(parent),
}
void Singleton::f6();{
            return left_entry->pkt_num < right_entry->pkt_num;
        case ExportObjectModel::colSize:
            return left_entry->payload_len < right_entry->payload_len;
        case ExportObjectModel::colFilename:
            break;
}
void Singleton::f7();{
                g_snprintf(generic_name, sizeof(generic_name),
                    "object%u%s%s", entry->pkt_num, ext ? "." : "",
                    ext ? ext : "");
                safe_filename = eo_massage_str(generic_name,
                    EXPORT_OBJECT_MAXFILELEN, count);
}
void Singleton::f8();{
        QModelIndex idx = sourceModel()->index(source_row, ExportObjectModel::colContent);
        if (!idx.isValid())
            return false;
        if (contentFilter_.compare(idx.data().toString()) != 0)
            return false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    objects_.append(VariantPointer<export_object_entry_t>::asQVariant(entry));
    endInsertRows();
export_object_entry_t* ExportObjectModel::objectEntry(int row)
    return VariantPointer<export_object_entry_t>::asPtr(objects_.value(row));
bool ExportObjectModel::saveEntry(QModelIndex &index, QString filename)
}
void Singleton::f2();{
                          *right_entry = VariantPointer<export_object_entry_t>::asPtr(sourceModel()->data(source_right, Qt::UserRole));
    if ((left_entry != NULL) && (right_entry != NULL))
    {
        switch (source_left.column())
        {
}
void Singleton::f3();{
        return QVariant();
    switch (section) {
    case colPacket:
        return tr("Packet");
    case colHostname:
}
void Singleton::f4();{
        case ExportObjectModel::colFilename:
            break;
        }
    }
    return QSortFilterProxyModel::lessThan(source_left, source_right);
}
void Singleton::f5();{
        return object_list->model->objectEntry(row);
    return NULL;
} // extern "C"
ExportObjectModel::ExportObjectModel(register_eo_t* eo, QObject *parent) :
    QAbstractTableModel(parent),
}
void Singleton::f6();{
            return left_entry->pkt_num < right_entry->pkt_num;
        case ExportObjectModel::colSize:
            return left_entry->payload_len < right_entry->payload_len;
        case ExportObjectModel::colFilename:
            break;
}
void Singleton::f7();{
                g_snprintf(generic_name, sizeof(generic_name),
                    "object%u%s%s", entry->pkt_num, ext ? "." : "",
                    ext ? ext : "");
                safe_filename = eo_massage_str(generic_name,
                    EXPORT_OBJECT_MAXFILELEN, count);
}
void Singleton::f8();{
        QModelIndex idx = sourceModel()->index(source_row, ExportObjectModel::colContent);
        if (!idx.isValid())
            return false;
        if (contentFilter_.compare(idx.data().toString()) != 0)
            return false;
}
void Singleton::f9();{
    return colExportObjectMax;
void ExportObjectModel::addObjectEntry(export_object_entry_t *entry)
    if (entry == NULL)
        return;
    int count = objects_.count();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    bool enabled = (model_.rowCount() > 0);
    if (save_bt_) save_bt_->setEnabled(enabled);
    if (save_all_bt_) save_all_bt_->setEnabled(enabled);
    for (int row = from; row <= to; row++)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    bool enabled = (model_.rowCount() > 0);
    if (save_bt_) save_bt_->setEnabled(enabled);
    if (save_all_bt_) save_all_bt_->setEnabled(enabled);
    for (int row = from; row <= to; row++)
    {
}
void Singleton::f2();{
        if (idx.isValid())
        {
            QString dataType = idx.data().toString();
            if (dataType.length() > 0 && ! contentTypes.contains(dataType))
            {
}
void Singleton::f3();{
        eo_ui_->objectTree->resizeColumnToContents(i);
    eo_ui_->objectTree->sortByColumn(ExportObjectModel::colPacket, Qt::AscendingOrder);
void ExportObjectDialog::keyPressEvent(QKeyEvent *evt)
    if(evt->key() == Qt::Key_Enter || evt->key() == Qt::Key_Return)
        return;
}
void Singleton::f4();{
        open->setText(tr("Preview"));
        open->setEnabled(false);
    }
    contentTypes << tr("All Content-Types");
    eo_ui_->cmbContentType->addItems(contentTypes);
}
void Singleton::f5();{
    // to drop files for all the objects, not a file name.
    //
    // XXX - what we *really* want is something that asks the user
    // for an existing directory *but* lets them create a new
    // directory in the process.  That's what we get on macOS,
}
void Singleton::f6();{
    model_.saveEntry(current, file_name);
void ExportObjectDialog::saveAllEntries()
    QDir save_in_dir(wsApp->lastOpenDir());
    QString save_in_path;
    //
}
void Singleton::f7();{
                eo_ui_->cmbContentType->addItems(contentTypes);
                if (contentTypes.contains(selType) )
                    eo_ui_->cmbContentType->setCurrentText(selType);
            }
        }
}
void Singleton::f8();{
void ExportObjectDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (eo_ui_->buttonBox->standardButton(button)) {
    case QDialogButtonBox::Save:
        saveCurrentEntry();
        break;
}
void Singleton::f9();{
        }
    }
void ExportObjectDialog::modelRowsReset()
    contentTypes.clear();
    contentTypes << tr("All Content-Types");
}
void Singleton::f10();{
    proxyModel_.setFilterCaseSensitivity(Qt::CaseInsensitive);
    proxyModel_.setFilterKeyColumn(-1);
    eo_ui_->progressLabel->setAttribute(Qt::WA_MacSmallSize, true);
    eo_ui_->progressBar->setAttribute(Qt::WA_MacSmallSize, true);
    connect(&model_, SIGNAL(rowsInserted(QModelIndex,int,int)),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    bool enabled = (model_.rowCount() > 0);
    if (save_bt_) save_bt_->setEnabled(enabled);
    if (save_all_bt_) save_all_bt_->setEnabled(enabled);
    for (int row = from; row <= to; row++)
    {
}
void Singleton::f2();{
        if (idx.isValid())
        {
            QString dataType = idx.data().toString();
            if (dataType.length() > 0 && ! contentTypes.contains(dataType))
            {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    bool enabled = (model_.rowCount() > 0);
    if (save_bt_) save_bt_->setEnabled(enabled);
    if (save_all_bt_) save_all_bt_->setEnabled(enabled);
    for (int row = from; row <= to; row++)
    {
}
void Singleton::f2();{
        if (idx.isValid())
        {
            QString dataType = idx.data().toString();
            if (dataType.length() > 0 && ! contentTypes.contains(dataType))
            {
}
void Singleton::f3();{
        eo_ui_->objectTree->resizeColumnToContents(i);
    eo_ui_->objectTree->sortByColumn(ExportObjectModel::colPacket, Qt::AscendingOrder);
void ExportObjectDialog::keyPressEvent(QKeyEvent *evt)
    if(evt->key() == Qt::Key_Enter || evt->key() == Qt::Key_Return)
        return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    bool enabled = (model_.rowCount() > 0);
    if (save_bt_) save_bt_->setEnabled(enabled);
    if (save_all_bt_) save_all_bt_->setEnabled(enabled);
    for (int row = from; row <= to; row++)
    {
}
void Singleton::f2();{
        if (idx.isValid())
        {
            QString dataType = idx.data().toString();
            if (dataType.length() > 0 && ! contentTypes.contains(dataType))
            {
}
void Singleton::f3();{
        eo_ui_->objectTree->resizeColumnToContents(i);
    eo_ui_->objectTree->sortByColumn(ExportObjectModel::colPacket, Qt::AscendingOrder);
void ExportObjectDialog::keyPressEvent(QKeyEvent *evt)
    if(evt->key() == Qt::Key_Enter || evt->key() == Qt::Key_Return)
        return;
}
void Singleton::f4();{
        open->setText(tr("Preview"));
        open->setEnabled(false);
    }
    contentTypes << tr("All Content-Types");
    eo_ui_->cmbContentType->addItems(contentTypes);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    bool enabled = (model_.rowCount() > 0);
    if (save_bt_) save_bt_->setEnabled(enabled);
    if (save_all_bt_) save_all_bt_->setEnabled(enabled);
    for (int row = from; row <= to; row++)
    {
}
void Singleton::f2();{
        if (idx.isValid())
        {
            QString dataType = idx.data().toString();
            if (dataType.length() > 0 && ! contentTypes.contains(dataType))
            {
}
void Singleton::f3();{
        eo_ui_->objectTree->resizeColumnToContents(i);
    eo_ui_->objectTree->sortByColumn(ExportObjectModel::colPacket, Qt::AscendingOrder);
void ExportObjectDialog::keyPressEvent(QKeyEvent *evt)
    if(evt->key() == Qt::Key_Enter || evt->key() == Qt::Key_Return)
        return;
}
void Singleton::f4();{
        open->setText(tr("Preview"));
        open->setEnabled(false);
    }
    contentTypes << tr("All Content-Types");
    eo_ui_->cmbContentType->addItems(contentTypes);
}
void Singleton::f5();{
    // to drop files for all the objects, not a file name.
    //
    // XXX - what we *really* want is something that asks the user
    // for an existing directory *but* lets them create a new
    // directory in the process.  That's what we get on macOS,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    bool enabled = (model_.rowCount() > 0);
    if (save_bt_) save_bt_->setEnabled(enabled);
    if (save_all_bt_) save_all_bt_->setEnabled(enabled);
    for (int row = from; row <= to; row++)
    {
}
void Singleton::f2();{
        if (idx.isValid())
        {
            QString dataType = idx.data().toString();
            if (dataType.length() > 0 && ! contentTypes.contains(dataType))
            {
}
void Singleton::f3();{
        eo_ui_->objectTree->resizeColumnToContents(i);
    eo_ui_->objectTree->sortByColumn(ExportObjectModel::colPacket, Qt::AscendingOrder);
void ExportObjectDialog::keyPressEvent(QKeyEvent *evt)
    if(evt->key() == Qt::Key_Enter || evt->key() == Qt::Key_Return)
        return;
}
void Singleton::f4();{
        open->setText(tr("Preview"));
        open->setEnabled(false);
    }
    contentTypes << tr("All Content-Types");
    eo_ui_->cmbContentType->addItems(contentTypes);
}
void Singleton::f5();{
    // to drop files for all the objects, not a file name.
    //
    // XXX - what we *really* want is something that asks the user
    // for an existing directory *but* lets them create a new
    // directory in the process.  That's what we get on macOS,
}
void Singleton::f6();{
    model_.saveEntry(current, file_name);
void ExportObjectDialog::saveAllEntries()
    QDir save_in_dir(wsApp->lastOpenDir());
    QString save_in_path;
    //
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    bool enabled = (model_.rowCount() > 0);
    if (save_bt_) save_bt_->setEnabled(enabled);
    if (save_all_bt_) save_all_bt_->setEnabled(enabled);
    for (int row = from; row <= to; row++)
    {
}
void Singleton::f2();{
        if (idx.isValid())
        {
            QString dataType = idx.data().toString();
            if (dataType.length() > 0 && ! contentTypes.contains(dataType))
            {
}
void Singleton::f3();{
        eo_ui_->objectTree->resizeColumnToContents(i);
    eo_ui_->objectTree->sortByColumn(ExportObjectModel::colPacket, Qt::AscendingOrder);
void ExportObjectDialog::keyPressEvent(QKeyEvent *evt)
    if(evt->key() == Qt::Key_Enter || evt->key() == Qt::Key_Return)
        return;
}
void Singleton::f4();{
        open->setText(tr("Preview"));
        open->setEnabled(false);
    }
    contentTypes << tr("All Content-Types");
    eo_ui_->cmbContentType->addItems(contentTypes);
}
void Singleton::f5();{
    // to drop files for all the objects, not a file name.
    //
    // XXX - what we *really* want is something that asks the user
    // for an existing directory *but* lets them create a new
    // directory in the process.  That's what we get on macOS,
}
void Singleton::f6();{
    model_.saveEntry(current, file_name);
void ExportObjectDialog::saveAllEntries()
    QDir save_in_dir(wsApp->lastOpenDir());
    QString save_in_path;
    //
}
void Singleton::f7();{
                eo_ui_->cmbContentType->addItems(contentTypes);
                if (contentTypes.contains(selType) )
                    eo_ui_->cmbContentType->setCurrentText(selType);
            }
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    bool enabled = (model_.rowCount() > 0);
    if (save_bt_) save_bt_->setEnabled(enabled);
    if (save_all_bt_) save_all_bt_->setEnabled(enabled);
    for (int row = from; row <= to; row++)
    {
}
void Singleton::f2();{
        if (idx.isValid())
        {
            QString dataType = idx.data().toString();
            if (dataType.length() > 0 && ! contentTypes.contains(dataType))
            {
}
void Singleton::f3();{
        eo_ui_->objectTree->resizeColumnToContents(i);
    eo_ui_->objectTree->sortByColumn(ExportObjectModel::colPacket, Qt::AscendingOrder);
void ExportObjectDialog::keyPressEvent(QKeyEvent *evt)
    if(evt->key() == Qt::Key_Enter || evt->key() == Qt::Key_Return)
        return;
}
void Singleton::f4();{
        open->setText(tr("Preview"));
        open->setEnabled(false);
    }
    contentTypes << tr("All Content-Types");
    eo_ui_->cmbContentType->addItems(contentTypes);
}
void Singleton::f5();{
    // to drop files for all the objects, not a file name.
    //
    // XXX - what we *really* want is something that asks the user
    // for an existing directory *but* lets them create a new
    // directory in the process.  That's what we get on macOS,
}
void Singleton::f6();{
    model_.saveEntry(current, file_name);
void ExportObjectDialog::saveAllEntries()
    QDir save_in_dir(wsApp->lastOpenDir());
    QString save_in_path;
    //
}
void Singleton::f7();{
                eo_ui_->cmbContentType->addItems(contentTypes);
                if (contentTypes.contains(selType) )
                    eo_ui_->cmbContentType->setCurrentText(selType);
            }
        }
}
void Singleton::f8();{
void ExportObjectDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (eo_ui_->buttonBox->standardButton(button)) {
    case QDialogButtonBox::Save:
        saveCurrentEntry();
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    bool enabled = (model_.rowCount() > 0);
    if (save_bt_) save_bt_->setEnabled(enabled);
    if (save_all_bt_) save_all_bt_->setEnabled(enabled);
    for (int row = from; row <= to; row++)
    {
}
void Singleton::f2();{
        if (idx.isValid())
        {
            QString dataType = idx.data().toString();
            if (dataType.length() > 0 && ! contentTypes.contains(dataType))
            {
}
void Singleton::f3();{
        eo_ui_->objectTree->resizeColumnToContents(i);
    eo_ui_->objectTree->sortByColumn(ExportObjectModel::colPacket, Qt::AscendingOrder);
void ExportObjectDialog::keyPressEvent(QKeyEvent *evt)
    if(evt->key() == Qt::Key_Enter || evt->key() == Qt::Key_Return)
        return;
}
void Singleton::f4();{
        open->setText(tr("Preview"));
        open->setEnabled(false);
    }
    contentTypes << tr("All Content-Types");
    eo_ui_->cmbContentType->addItems(contentTypes);
}
void Singleton::f5();{
    // to drop files for all the objects, not a file name.
    //
    // XXX - what we *really* want is something that asks the user
    // for an existing directory *but* lets them create a new
    // directory in the process.  That's what we get on macOS,
}
void Singleton::f6();{
    model_.saveEntry(current, file_name);
void ExportObjectDialog::saveAllEntries()
    QDir save_in_dir(wsApp->lastOpenDir());
    QString save_in_path;
    //
}
void Singleton::f7();{
                eo_ui_->cmbContentType->addItems(contentTypes);
                if (contentTypes.contains(selType) )
                    eo_ui_->cmbContentType->setCurrentText(selType);
            }
        }
}
void Singleton::f8();{
void ExportObjectDialog::on_buttonBox_clicked(QAbstractButton *button)
    switch (eo_ui_->buttonBox->standardButton(button)) {
    case QDialogButtonBox::Save:
        saveCurrentEntry();
        break;
}
void Singleton::f9();{
        }
    }
void ExportObjectDialog::modelRowsReset()
    contentTypes.clear();
    contentTypes << tr("All Content-Types");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    QString text = defaultValue();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        QString storeValue(*_argument->pref_valptr);
        if (storeValue.length() > 0 && storeValue.compare(text) != 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    QString text = defaultValue();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        QString storeValue(*_argument->pref_valptr);
        if (storeValue.length() > 0 && storeValue.compare(text) != 0)
}
void Singleton::f2();{
    if (_label == 0)
        _label = new QLabel(text, parent);
    else
        _label->setText(text);
    _label->setProperty("isRequired", QString(isRequired() ? "true" : "false"));
}
void Singleton::f3();{
            ++iter;
        }
        if (selected > -1 && selected < boxSelection->count())
            boxSelection->setCurrentIndex(selected);
    }
}
void Singleton::f4();{
        reloadButton->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Preferred);
        boxSelection->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::Preferred);
        connect(reloadButton, SIGNAL(clicked()), this, SLOT(onReloadTriggered()));
    }
    connect (boxSelection, SIGNAL(currentIndexChanged(int)), SLOT(onIntChanged(int)));
}
void Singleton::f5();{
    else if (argument->arg_type == EXTCAP_ARG_FILESELECT)
        result = new ExtcapArgumentFileSelection(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_MULTICHECK)
        result = new ExtArgMultiSelect(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_TIMESTAMP)
}
void Singleton::f6();{
QString ExtArgBool::prefValue()
    if (boolBox == NULL)
        return QString("false");
    return QString(boolBox->checkState() == Qt::Checked ? "true" : "false");
bool ExtArgBool::isValid()
}
void Singleton::f7();{
    return QString();
bool ExtcapArgument::isRequired()
    if (_argument != NULL)
        return _argument->is_required;
    return FALSE;
}
void Singleton::f8();{
     * maximum values, a value that's larger than the maximum but has
     * the same number of digits as the maximum is "intermediate" rather
     * than "invalid", so the user will be able to cause that value to
     * be passed to the extcap module; see bug 16510.
     *
}
void Singleton::f9();{
    callStrings = new QList<QString>();
    if (values.length() > 0  )
    {
        ExtcapValueList::const_iterator iter = values.constBegin();
        while (iter != values.constEnd())
}
void Singleton::f10();{
                else
                    val = (gint)tmp;
            }
            textValidator->setTop(val);
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    QString text = defaultValue();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        QString storeValue(*_argument->pref_valptr);
        if (storeValue.length() > 0 && storeValue.compare(text) != 0)
}
void Singleton::f2();{
    if (_label == 0)
        _label = new QLabel(text, parent);
    else
        _label->setText(text);
    _label->setProperty("isRequired", QString(isRequired() ? "true" : "false"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    QString text = defaultValue();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        QString storeValue(*_argument->pref_valptr);
        if (storeValue.length() > 0 && storeValue.compare(text) != 0)
}
void Singleton::f2();{
    if (_label == 0)
        _label = new QLabel(text, parent);
    else
        _label->setText(text);
    _label->setProperty("isRequired", QString(isRequired() ? "true" : "false"));
}
void Singleton::f3();{
            ++iter;
        }
        if (selected > -1 && selected < boxSelection->count())
            boxSelection->setCurrentIndex(selected);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    QString text = defaultValue();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        QString storeValue(*_argument->pref_valptr);
        if (storeValue.length() > 0 && storeValue.compare(text) != 0)
}
void Singleton::f2();{
    if (_label == 0)
        _label = new QLabel(text, parent);
    else
        _label->setText(text);
    _label->setProperty("isRequired", QString(isRequired() ? "true" : "false"));
}
void Singleton::f3();{
            ++iter;
        }
        if (selected > -1 && selected < boxSelection->count())
            boxSelection->setCurrentIndex(selected);
    }
}
void Singleton::f4();{
        reloadButton->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Preferred);
        boxSelection->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::Preferred);
        connect(reloadButton, SIGNAL(clicked()), this, SLOT(onReloadTriggered()));
    }
    connect (boxSelection, SIGNAL(currentIndexChanged(int)), SLOT(onIntChanged(int)));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    QString text = defaultValue();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        QString storeValue(*_argument->pref_valptr);
        if (storeValue.length() > 0 && storeValue.compare(text) != 0)
}
void Singleton::f2();{
    if (_label == 0)
        _label = new QLabel(text, parent);
    else
        _label->setText(text);
    _label->setProperty("isRequired", QString(isRequired() ? "true" : "false"));
}
void Singleton::f3();{
            ++iter;
        }
        if (selected > -1 && selected < boxSelection->count())
            boxSelection->setCurrentIndex(selected);
    }
}
void Singleton::f4();{
        reloadButton->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Preferred);
        boxSelection->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::Preferred);
        connect(reloadButton, SIGNAL(clicked()), this, SLOT(onReloadTriggered()));
    }
    connect (boxSelection, SIGNAL(currentIndexChanged(int)), SLOT(onIntChanged(int)));
}
void Singleton::f5();{
    else if (argument->arg_type == EXTCAP_ARG_FILESELECT)
        result = new ExtcapArgumentFileSelection(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_MULTICHECK)
        result = new ExtArgMultiSelect(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_TIMESTAMP)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    QString text = defaultValue();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        QString storeValue(*_argument->pref_valptr);
        if (storeValue.length() > 0 && storeValue.compare(text) != 0)
}
void Singleton::f2();{
    if (_label == 0)
        _label = new QLabel(text, parent);
    else
        _label->setText(text);
    _label->setProperty("isRequired", QString(isRequired() ? "true" : "false"));
}
void Singleton::f3();{
            ++iter;
        }
        if (selected > -1 && selected < boxSelection->count())
            boxSelection->setCurrentIndex(selected);
    }
}
void Singleton::f4();{
        reloadButton->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Preferred);
        boxSelection->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::Preferred);
        connect(reloadButton, SIGNAL(clicked()), this, SLOT(onReloadTriggered()));
    }
    connect (boxSelection, SIGNAL(currentIndexChanged(int)), SLOT(onIntChanged(int)));
}
void Singleton::f5();{
    else if (argument->arg_type == EXTCAP_ARG_FILESELECT)
        result = new ExtcapArgumentFileSelection(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_MULTICHECK)
        result = new ExtArgMultiSelect(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_TIMESTAMP)
}
void Singleton::f6();{
QString ExtArgBool::prefValue()
    if (boolBox == NULL)
        return QString("false");
    return QString(boolBox->checkState() == Qt::Checked ? "true" : "false");
bool ExtArgBool::isValid()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    QString text = defaultValue();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        QString storeValue(*_argument->pref_valptr);
        if (storeValue.length() > 0 && storeValue.compare(text) != 0)
}
void Singleton::f2();{
    if (_label == 0)
        _label = new QLabel(text, parent);
    else
        _label->setText(text);
    _label->setProperty("isRequired", QString(isRequired() ? "true" : "false"));
}
void Singleton::f3();{
            ++iter;
        }
        if (selected > -1 && selected < boxSelection->count())
            boxSelection->setCurrentIndex(selected);
    }
}
void Singleton::f4();{
        reloadButton->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Preferred);
        boxSelection->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::Preferred);
        connect(reloadButton, SIGNAL(clicked()), this, SLOT(onReloadTriggered()));
    }
    connect (boxSelection, SIGNAL(currentIndexChanged(int)), SLOT(onIntChanged(int)));
}
void Singleton::f5();{
    else if (argument->arg_type == EXTCAP_ARG_FILESELECT)
        result = new ExtcapArgumentFileSelection(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_MULTICHECK)
        result = new ExtArgMultiSelect(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_TIMESTAMP)
}
void Singleton::f6();{
QString ExtArgBool::prefValue()
    if (boolBox == NULL)
        return QString("false");
    return QString(boolBox->checkState() == Qt::Checked ? "true" : "false");
bool ExtArgBool::isValid()
}
void Singleton::f7();{
    return QString();
bool ExtcapArgument::isRequired()
    if (_argument != NULL)
        return _argument->is_required;
    return FALSE;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    QString text = defaultValue();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        QString storeValue(*_argument->pref_valptr);
        if (storeValue.length() > 0 && storeValue.compare(text) != 0)
}
void Singleton::f2();{
    if (_label == 0)
        _label = new QLabel(text, parent);
    else
        _label->setText(text);
    _label->setProperty("isRequired", QString(isRequired() ? "true" : "false"));
}
void Singleton::f3();{
            ++iter;
        }
        if (selected > -1 && selected < boxSelection->count())
            boxSelection->setCurrentIndex(selected);
    }
}
void Singleton::f4();{
        reloadButton->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Preferred);
        boxSelection->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::Preferred);
        connect(reloadButton, SIGNAL(clicked()), this, SLOT(onReloadTriggered()));
    }
    connect (boxSelection, SIGNAL(currentIndexChanged(int)), SLOT(onIntChanged(int)));
}
void Singleton::f5();{
    else if (argument->arg_type == EXTCAP_ARG_FILESELECT)
        result = new ExtcapArgumentFileSelection(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_MULTICHECK)
        result = new ExtArgMultiSelect(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_TIMESTAMP)
}
void Singleton::f6();{
QString ExtArgBool::prefValue()
    if (boolBox == NULL)
        return QString("false");
    return QString(boolBox->checkState() == Qt::Checked ? "true" : "false");
bool ExtArgBool::isValid()
}
void Singleton::f7();{
    return QString();
bool ExtcapArgument::isRequired()
    if (_argument != NULL)
        return _argument->is_required;
    return FALSE;
}
void Singleton::f8();{
     * maximum values, a value that's larger than the maximum but has
     * the same number of digits as the maximum is "intermediate" rather
     * than "invalid", so the user will be able to cause that value to
     * be passed to the extcap module; see bug 16510.
     *
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    QString text = defaultValue();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        QString storeValue(*_argument->pref_valptr);
        if (storeValue.length() > 0 && storeValue.compare(text) != 0)
}
void Singleton::f2();{
    if (_label == 0)
        _label = new QLabel(text, parent);
    else
        _label->setText(text);
    _label->setProperty("isRequired", QString(isRequired() ? "true" : "false"));
}
void Singleton::f3();{
            ++iter;
        }
        if (selected > -1 && selected < boxSelection->count())
            boxSelection->setCurrentIndex(selected);
    }
}
void Singleton::f4();{
        reloadButton->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Preferred);
        boxSelection->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::Preferred);
        connect(reloadButton, SIGNAL(clicked()), this, SLOT(onReloadTriggered()));
    }
    connect (boxSelection, SIGNAL(currentIndexChanged(int)), SLOT(onIntChanged(int)));
}
void Singleton::f5();{
    else if (argument->arg_type == EXTCAP_ARG_FILESELECT)
        result = new ExtcapArgumentFileSelection(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_MULTICHECK)
        result = new ExtArgMultiSelect(argument, parent);
    else if (argument->arg_type == EXTCAP_ARG_TIMESTAMP)
}
void Singleton::f6();{
QString ExtArgBool::prefValue()
    if (boolBox == NULL)
        return QString("false");
    return QString(boolBox->checkState() == Qt::Checked ? "true" : "false");
bool ExtArgBool::isValid()
}
void Singleton::f7();{
    return QString();
bool ExtcapArgument::isRequired()
    if (_argument != NULL)
        return _argument->is_required;
    return FALSE;
}
void Singleton::f8();{
     * maximum values, a value that's larger than the maximum but has
     * the same number of digits as the maximum is "intermediate" rather
     * than "invalid", so the user will be able to cause that value to
     * be passed to the extcap module; see bug 16510.
     *
}
void Singleton::f9();{
    callStrings = new QList<QString>();
    if (values.length() > 0  )
    {
        ExtcapValueList::const_iterator iter = values.constBegin();
        while (iter != values.constEnd())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    if (textBox != NULL)
        delete textBox;
QWidget * ExtcapArgumentFileSelection::createEditor(QWidget * parent)
    QString text = defaultValue();
    QString buttonText(UTF8_HORIZONTAL_ELLIPSIS);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    if (textBox != NULL)
        delete textBox;
QWidget * ExtcapArgumentFileSelection::createEditor(QWidget * parent)
    QString text = defaultValue();
    QString buttonText(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f2();{
    if (_argument->tooltip != NULL)
    {
        textBox->setToolTip(QString().fromUtf8(_argument->tooltip));
        buttonSelect->setToolTip(QString().fromUtf8(_argument->tooltip));
    }
}
void Singleton::f3();{
/* opens the file dialog */
void ExtcapArgumentFileSelection::openFileDialog()
    QString filename = textBox->text();
    QDir workingDir = QDir::currentPath();
    if (QFileInfo(filename).exists())
}
void Singleton::f4();{
    connect(buttonSelect, SIGNAL(clicked()), (QObject *)this, SLOT(openFileDialog()));
    connect(buttonClear, SIGNAL(clicked()), (QObject *)this, SLOT(clearFilename()));
    editLayout->addWidget(textBox);
    editLayout->addWidget(buttonSelect);
    editLayout->addWidget(buttonClear);
}
void Singleton::f5();{
    QPushButton * buttonClear = new QPushButton(buttonClearText, fileWidget);
    textBox = new QLineEdit(text, parent);
    textBox->setReadOnly(true);
    const char *prefval = _argument->pref_valptr ? *_argument->pref_valptr : NULL;
    if (prefval)
}
void Singleton::f6();{
        QString givenExt = QString().fromUtf8(_argument->fileextension);
        if (givenExt.length() != 0)
            fileExt.prepend(";;").prepend(givenExt);
    }
    if (fileExists())
}
void Singleton::f7();{
        /* File might or might not exist. Actual overwrite handling is extcap specific
         * (e.g. boolflag argument if user wants to always overwrite the file)
         */
        filename = WiresharkFileDialog::getSaveFileName((QWidget*)(textBox->parent()),
            QString().fromUtf8(_argument->display) + " " + tr("Select File"),
}
void Singleton::f8();{
        else
            valid = true;
    }
    else if (! isRequired())
        valid = true;
}
void Singleton::f9();{
    editLayout->addWidget(textBox);
    editLayout->addWidget(buttonSelect);
    editLayout->addWidget(buttonClear);
    fileWidget->setLayout(editLayout);
    return fileWidget;
}
void Singleton::f10();{
        textBox->setText(filename);
        emit valueChanged();
    }
void ExtcapArgumentFileSelection::clearFilename()
    textBox->clear();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    if (textBox != NULL)
        delete textBox;
QWidget * ExtcapArgumentFileSelection::createEditor(QWidget * parent)
    QString text = defaultValue();
    QString buttonText(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f2();{
    if (_argument->tooltip != NULL)
    {
        textBox->setToolTip(QString().fromUtf8(_argument->tooltip));
        buttonSelect->setToolTip(QString().fromUtf8(_argument->tooltip));
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    if (textBox != NULL)
        delete textBox;
QWidget * ExtcapArgumentFileSelection::createEditor(QWidget * parent)
    QString text = defaultValue();
    QString buttonText(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f2();{
    if (_argument->tooltip != NULL)
    {
        textBox->setToolTip(QString().fromUtf8(_argument->tooltip));
        buttonSelect->setToolTip(QString().fromUtf8(_argument->tooltip));
    }
}
void Singleton::f3();{
/* opens the file dialog */
void ExtcapArgumentFileSelection::openFileDialog()
    QString filename = textBox->text();
    QDir workingDir = QDir::currentPath();
    if (QFileInfo(filename).exists())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    if (textBox != NULL)
        delete textBox;
QWidget * ExtcapArgumentFileSelection::createEditor(QWidget * parent)
    QString text = defaultValue();
    QString buttonText(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f2();{
    if (_argument->tooltip != NULL)
    {
        textBox->setToolTip(QString().fromUtf8(_argument->tooltip));
        buttonSelect->setToolTip(QString().fromUtf8(_argument->tooltip));
    }
}
void Singleton::f3();{
/* opens the file dialog */
void ExtcapArgumentFileSelection::openFileDialog()
    QString filename = textBox->text();
    QDir workingDir = QDir::currentPath();
    if (QFileInfo(filename).exists())
}
void Singleton::f4();{
    connect(buttonSelect, SIGNAL(clicked()), (QObject *)this, SLOT(openFileDialog()));
    connect(buttonClear, SIGNAL(clicked()), (QObject *)this, SLOT(clearFilename()));
    editLayout->addWidget(textBox);
    editLayout->addWidget(buttonSelect);
    editLayout->addWidget(buttonClear);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    if (textBox != NULL)
        delete textBox;
QWidget * ExtcapArgumentFileSelection::createEditor(QWidget * parent)
    QString text = defaultValue();
    QString buttonText(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f2();{
    if (_argument->tooltip != NULL)
    {
        textBox->setToolTip(QString().fromUtf8(_argument->tooltip));
        buttonSelect->setToolTip(QString().fromUtf8(_argument->tooltip));
    }
}
void Singleton::f3();{
/* opens the file dialog */
void ExtcapArgumentFileSelection::openFileDialog()
    QString filename = textBox->text();
    QDir workingDir = QDir::currentPath();
    if (QFileInfo(filename).exists())
}
void Singleton::f4();{
    connect(buttonSelect, SIGNAL(clicked()), (QObject *)this, SLOT(openFileDialog()));
    connect(buttonClear, SIGNAL(clicked()), (QObject *)this, SLOT(clearFilename()));
    editLayout->addWidget(textBox);
    editLayout->addWidget(buttonSelect);
    editLayout->addWidget(buttonClear);
}
void Singleton::f5();{
    QPushButton * buttonClear = new QPushButton(buttonClearText, fileWidget);
    textBox = new QLineEdit(text, parent);
    textBox->setReadOnly(true);
    const char *prefval = _argument->pref_valptr ? *_argument->pref_valptr : NULL;
    if (prefval)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    if (textBox != NULL)
        delete textBox;
QWidget * ExtcapArgumentFileSelection::createEditor(QWidget * parent)
    QString text = defaultValue();
    QString buttonText(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f2();{
    if (_argument->tooltip != NULL)
    {
        textBox->setToolTip(QString().fromUtf8(_argument->tooltip));
        buttonSelect->setToolTip(QString().fromUtf8(_argument->tooltip));
    }
}
void Singleton::f3();{
/* opens the file dialog */
void ExtcapArgumentFileSelection::openFileDialog()
    QString filename = textBox->text();
    QDir workingDir = QDir::currentPath();
    if (QFileInfo(filename).exists())
}
void Singleton::f4();{
    connect(buttonSelect, SIGNAL(clicked()), (QObject *)this, SLOT(openFileDialog()));
    connect(buttonClear, SIGNAL(clicked()), (QObject *)this, SLOT(clearFilename()));
    editLayout->addWidget(textBox);
    editLayout->addWidget(buttonSelect);
    editLayout->addWidget(buttonClear);
}
void Singleton::f5();{
    QPushButton * buttonClear = new QPushButton(buttonClearText, fileWidget);
    textBox = new QLineEdit(text, parent);
    textBox->setReadOnly(true);
    const char *prefval = _argument->pref_valptr ? *_argument->pref_valptr : NULL;
    if (prefval)
}
void Singleton::f6();{
        QString givenExt = QString().fromUtf8(_argument->fileextension);
        if (givenExt.length() != 0)
            fileExt.prepend(";;").prepend(givenExt);
    }
    if (fileExists())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    if (textBox != NULL)
        delete textBox;
QWidget * ExtcapArgumentFileSelection::createEditor(QWidget * parent)
    QString text = defaultValue();
    QString buttonText(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f2();{
    if (_argument->tooltip != NULL)
    {
        textBox->setToolTip(QString().fromUtf8(_argument->tooltip));
        buttonSelect->setToolTip(QString().fromUtf8(_argument->tooltip));
    }
}
void Singleton::f3();{
/* opens the file dialog */
void ExtcapArgumentFileSelection::openFileDialog()
    QString filename = textBox->text();
    QDir workingDir = QDir::currentPath();
    if (QFileInfo(filename).exists())
}
void Singleton::f4();{
    connect(buttonSelect, SIGNAL(clicked()), (QObject *)this, SLOT(openFileDialog()));
    connect(buttonClear, SIGNAL(clicked()), (QObject *)this, SLOT(clearFilename()));
    editLayout->addWidget(textBox);
    editLayout->addWidget(buttonSelect);
    editLayout->addWidget(buttonClear);
}
void Singleton::f5();{
    QPushButton * buttonClear = new QPushButton(buttonClearText, fileWidget);
    textBox = new QLineEdit(text, parent);
    textBox->setReadOnly(true);
    const char *prefval = _argument->pref_valptr ? *_argument->pref_valptr : NULL;
    if (prefval)
}
void Singleton::f6();{
        QString givenExt = QString().fromUtf8(_argument->fileextension);
        if (givenExt.length() != 0)
            fileExt.prepend(";;").prepend(givenExt);
    }
    if (fileExists())
}
void Singleton::f7();{
        /* File might or might not exist. Actual overwrite handling is extcap specific
         * (e.g. boolflag argument if user wants to always overwrite the file)
         */
        filename = WiresharkFileDialog::getSaveFileName((QWidget*)(textBox->parent()),
            QString().fromUtf8(_argument->display) + " " + tr("Select File"),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    if (textBox != NULL)
        delete textBox;
QWidget * ExtcapArgumentFileSelection::createEditor(QWidget * parent)
    QString text = defaultValue();
    QString buttonText(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f2();{
    if (_argument->tooltip != NULL)
    {
        textBox->setToolTip(QString().fromUtf8(_argument->tooltip));
        buttonSelect->setToolTip(QString().fromUtf8(_argument->tooltip));
    }
}
void Singleton::f3();{
/* opens the file dialog */
void ExtcapArgumentFileSelection::openFileDialog()
    QString filename = textBox->text();
    QDir workingDir = QDir::currentPath();
    if (QFileInfo(filename).exists())
}
void Singleton::f4();{
    connect(buttonSelect, SIGNAL(clicked()), (QObject *)this, SLOT(openFileDialog()));
    connect(buttonClear, SIGNAL(clicked()), (QObject *)this, SLOT(clearFilename()));
    editLayout->addWidget(textBox);
    editLayout->addWidget(buttonSelect);
    editLayout->addWidget(buttonClear);
}
void Singleton::f5();{
    QPushButton * buttonClear = new QPushButton(buttonClearText, fileWidget);
    textBox = new QLineEdit(text, parent);
    textBox->setReadOnly(true);
    const char *prefval = _argument->pref_valptr ? *_argument->pref_valptr : NULL;
    if (prefval)
}
void Singleton::f6();{
        QString givenExt = QString().fromUtf8(_argument->fileextension);
        if (givenExt.length() != 0)
            fileExt.prepend(";;").prepend(givenExt);
    }
    if (fileExists())
}
void Singleton::f7();{
        /* File might or might not exist. Actual overwrite handling is extcap specific
         * (e.g. boolflag argument if user wants to always overwrite the file)
         */
        filename = WiresharkFileDialog::getSaveFileName((QWidget*)(textBox->parent()),
            QString().fromUtf8(_argument->display) + " " + tr("Select File"),
}
void Singleton::f8();{
        else
            valid = true;
    }
    else if (! isRequired())
        valid = true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    if (textBox != NULL)
        delete textBox;
QWidget * ExtcapArgumentFileSelection::createEditor(QWidget * parent)
    QString text = defaultValue();
    QString buttonText(UTF8_HORIZONTAL_ELLIPSIS);
}
void Singleton::f2();{
    if (_argument->tooltip != NULL)
    {
        textBox->setToolTip(QString().fromUtf8(_argument->tooltip));
        buttonSelect->setToolTip(QString().fromUtf8(_argument->tooltip));
    }
}
void Singleton::f3();{
/* opens the file dialog */
void ExtcapArgumentFileSelection::openFileDialog()
    QString filename = textBox->text();
    QDir workingDir = QDir::currentPath();
    if (QFileInfo(filename).exists())
}
void Singleton::f4();{
    connect(buttonSelect, SIGNAL(clicked()), (QObject *)this, SLOT(openFileDialog()));
    connect(buttonClear, SIGNAL(clicked()), (QObject *)this, SLOT(clearFilename()));
    editLayout->addWidget(textBox);
    editLayout->addWidget(buttonSelect);
    editLayout->addWidget(buttonClear);
}
void Singleton::f5();{
    QPushButton * buttonClear = new QPushButton(buttonClearText, fileWidget);
    textBox = new QLineEdit(text, parent);
    textBox->setReadOnly(true);
    const char *prefval = _argument->pref_valptr ? *_argument->pref_valptr : NULL;
    if (prefval)
}
void Singleton::f6();{
        QString givenExt = QString().fromUtf8(_argument->fileextension);
        if (givenExt.length() != 0)
            fileExt.prepend(";;").prepend(givenExt);
    }
    if (fileExists())
}
void Singleton::f7();{
        /* File might or might not exist. Actual overwrite handling is extcap specific
         * (e.g. boolflag argument if user wants to always overwrite the file)
         */
        filename = WiresharkFileDialog::getSaveFileName((QWidget*)(textBox->parent()),
            QString().fromUtf8(_argument->display) + " " + tr("Select File"),
}
void Singleton::f8();{
        else
            valid = true;
    }
    else if (! isRequired())
        valid = true;
}
void Singleton::f9();{
    editLayout->addWidget(textBox);
    editLayout->addWidget(buttonSelect);
    editLayout->addWidget(buttonClear);
    fileWidget->setLayout(editLayout);
    return fileWidget;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ExtArgMultiSelect::ExtArgMultiSelect(extcap_arg * argument, QObject *parent) :
        ExtcapArgument(argument, parent), treeView(0), viewModel(0) {}
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ExtArgMultiSelect::ExtArgMultiSelect(extcap_arg * argument, QObject *parent) :
        ExtcapArgument(argument, parent), treeView(0), viewModel(0) {}
}
void Singleton::f2();{
    {
        ((QStandardItemModel *)viewModel)->appendRow((*iter));
        ++iter;
    }
    treeView = new QTreeView(parent);
}
void Singleton::f3();{
        item->setData((*iter).call(), Qt::UserRole);
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
}
void Singleton::f4();{
        items << item;
        ++iter;
    }
    return items;
void ExtArgMultiSelect::checkItemsWalker(QStandardItem * item, QStringList defaults)
}
void Singleton::f5();{
        return new QWidget();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        checked = QString(*_argument->pref_valptr).split(",", Qt::SkipEmptyParts);
        checked = QString(*_argument->pref_valptr).split(",", QString::SkipEmptyParts);
}
void Singleton::f6();{
        item->setSelectable(false);
        item->setEditable(false);
        QList<QStandardItem *> childs = valueWalker((*iter).children(), defaults);
        if (childs.length() > 0)
            item->appendRows(childs);
}
void Singleton::f7();{
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
        QList<QStandardItem *> childs = valueWalker((*iter).children(), defaults);
}
void Singleton::f8();{
    QModelIndexList results;
    QModelIndex index;
    if (item->hasChildren())
    {
        for (int row = 0; row < item->rowCount(); row++)
}
void Singleton::f9();{
    {
        checked = QString(*_argument->pref_valptr).split(",", Qt::SkipEmptyParts);
        checked = QString(*_argument->pref_valptr).split(",", QString::SkipEmptyParts);
    }
    viewModel = new QStandardItemModel();
}
void Singleton::f10();{
    }
    viewModel = new QStandardItemModel();
    QList<QStandardItem *>::const_iterator iter = items.constBegin();
    while (iter != items.constEnd())
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ExtArgMultiSelect::ExtArgMultiSelect(extcap_arg * argument, QObject *parent) :
        ExtcapArgument(argument, parent), treeView(0), viewModel(0) {}
}
void Singleton::f2();{
    {
        ((QStandardItemModel *)viewModel)->appendRow((*iter));
        ++iter;
    }
    treeView = new QTreeView(parent);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ExtArgMultiSelect::ExtArgMultiSelect(extcap_arg * argument, QObject *parent) :
        ExtcapArgument(argument, parent), treeView(0), viewModel(0) {}
}
void Singleton::f2();{
    {
        ((QStandardItemModel *)viewModel)->appendRow((*iter));
        ++iter;
    }
    treeView = new QTreeView(parent);
}
void Singleton::f3();{
        item->setData((*iter).call(), Qt::UserRole);
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ExtArgMultiSelect::ExtArgMultiSelect(extcap_arg * argument, QObject *parent) :
        ExtcapArgument(argument, parent), treeView(0), viewModel(0) {}
}
void Singleton::f2();{
    {
        ((QStandardItemModel *)viewModel)->appendRow((*iter));
        ++iter;
    }
    treeView = new QTreeView(parent);
}
void Singleton::f3();{
        item->setData((*iter).call(), Qt::UserRole);
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
}
void Singleton::f4();{
        items << item;
        ++iter;
    }
    return items;
void ExtArgMultiSelect::checkItemsWalker(QStandardItem * item, QStringList defaults)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ExtArgMultiSelect::ExtArgMultiSelect(extcap_arg * argument, QObject *parent) :
        ExtcapArgument(argument, parent), treeView(0), viewModel(0) {}
}
void Singleton::f2();{
    {
        ((QStandardItemModel *)viewModel)->appendRow((*iter));
        ++iter;
    }
    treeView = new QTreeView(parent);
}
void Singleton::f3();{
        item->setData((*iter).call(), Qt::UserRole);
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
}
void Singleton::f4();{
        items << item;
        ++iter;
    }
    return items;
void ExtArgMultiSelect::checkItemsWalker(QStandardItem * item, QStringList defaults)
}
void Singleton::f5();{
        return new QWidget();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        checked = QString(*_argument->pref_valptr).split(",", Qt::SkipEmptyParts);
        checked = QString(*_argument->pref_valptr).split(",", QString::SkipEmptyParts);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ExtArgMultiSelect::ExtArgMultiSelect(extcap_arg * argument, QObject *parent) :
        ExtcapArgument(argument, parent), treeView(0), viewModel(0) {}
}
void Singleton::f2();{
    {
        ((QStandardItemModel *)viewModel)->appendRow((*iter));
        ++iter;
    }
    treeView = new QTreeView(parent);
}
void Singleton::f3();{
        item->setData((*iter).call(), Qt::UserRole);
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
}
void Singleton::f4();{
        items << item;
        ++iter;
    }
    return items;
void ExtArgMultiSelect::checkItemsWalker(QStandardItem * item, QStringList defaults)
}
void Singleton::f5();{
        return new QWidget();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        checked = QString(*_argument->pref_valptr).split(",", Qt::SkipEmptyParts);
        checked = QString(*_argument->pref_valptr).split(",", QString::SkipEmptyParts);
}
void Singleton::f6();{
        item->setSelectable(false);
        item->setEditable(false);
        QList<QStandardItem *> childs = valueWalker((*iter).children(), defaults);
        if (childs.length() > 0)
            item->appendRows(childs);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ExtArgMultiSelect::ExtArgMultiSelect(extcap_arg * argument, QObject *parent) :
        ExtcapArgument(argument, parent), treeView(0), viewModel(0) {}
}
void Singleton::f2();{
    {
        ((QStandardItemModel *)viewModel)->appendRow((*iter));
        ++iter;
    }
    treeView = new QTreeView(parent);
}
void Singleton::f3();{
        item->setData((*iter).call(), Qt::UserRole);
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
}
void Singleton::f4();{
        items << item;
        ++iter;
    }
    return items;
void ExtArgMultiSelect::checkItemsWalker(QStandardItem * item, QStringList defaults)
}
void Singleton::f5();{
        return new QWidget();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        checked = QString(*_argument->pref_valptr).split(",", Qt::SkipEmptyParts);
        checked = QString(*_argument->pref_valptr).split(",", QString::SkipEmptyParts);
}
void Singleton::f6();{
        item->setSelectable(false);
        item->setEditable(false);
        QList<QStandardItem *> childs = valueWalker((*iter).children(), defaults);
        if (childs.length() > 0)
            item->appendRows(childs);
}
void Singleton::f7();{
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
        QList<QStandardItem *> childs = valueWalker((*iter).children(), defaults);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ExtArgMultiSelect::ExtArgMultiSelect(extcap_arg * argument, QObject *parent) :
        ExtcapArgument(argument, parent), treeView(0), viewModel(0) {}
}
void Singleton::f2();{
    {
        ((QStandardItemModel *)viewModel)->appendRow((*iter));
        ++iter;
    }
    treeView = new QTreeView(parent);
}
void Singleton::f3();{
        item->setData((*iter).call(), Qt::UserRole);
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
}
void Singleton::f4();{
        items << item;
        ++iter;
    }
    return items;
void ExtArgMultiSelect::checkItemsWalker(QStandardItem * item, QStringList defaults)
}
void Singleton::f5();{
        return new QWidget();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        checked = QString(*_argument->pref_valptr).split(",", Qt::SkipEmptyParts);
        checked = QString(*_argument->pref_valptr).split(",", QString::SkipEmptyParts);
}
void Singleton::f6();{
        item->setSelectable(false);
        item->setEditable(false);
        QList<QStandardItem *> childs = valueWalker((*iter).children(), defaults);
        if (childs.length() > 0)
            item->appendRows(childs);
}
void Singleton::f7();{
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
        QList<QStandardItem *> childs = valueWalker((*iter).children(), defaults);
}
void Singleton::f8();{
    QModelIndexList results;
    QModelIndex index;
    if (item->hasChildren())
    {
        for (int row = 0; row < item->rowCount(); row++)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
ExtArgMultiSelect::ExtArgMultiSelect(extcap_arg * argument, QObject *parent) :
        ExtcapArgument(argument, parent), treeView(0), viewModel(0) {}
}
void Singleton::f2();{
    {
        ((QStandardItemModel *)viewModel)->appendRow((*iter));
        ++iter;
    }
    treeView = new QTreeView(parent);
}
void Singleton::f3();{
        item->setData((*iter).call(), Qt::UserRole);
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
}
void Singleton::f4();{
        items << item;
        ++iter;
    }
    return items;
void ExtArgMultiSelect::checkItemsWalker(QStandardItem * item, QStringList defaults)
}
void Singleton::f5();{
        return new QWidget();
    if (_argument->pref_valptr && *_argument->pref_valptr)
    {
        checked = QString(*_argument->pref_valptr).split(",", Qt::SkipEmptyParts);
        checked = QString(*_argument->pref_valptr).split(",", QString::SkipEmptyParts);
}
void Singleton::f6();{
        item->setSelectable(false);
        item->setEditable(false);
        QList<QStandardItem *> childs = valueWalker((*iter).children(), defaults);
        if (childs.length() > 0)
            item->appendRows(childs);
}
void Singleton::f7();{
        if ((*iter).isDefault())
            defaults << (*iter).call();
        item->setSelectable(false);
        item->setEditable(false);
        QList<QStandardItem *> childs = valueWalker((*iter).children(), defaults);
}
void Singleton::f8();{
    QModelIndexList results;
    QModelIndex index;
    if (item->hasChildren())
    {
        for (int row = 0; row < item->rowCount(); row++)
}
void Singleton::f9();{
    {
        checked = QString(*_argument->pref_valptr).split(",", Qt::SkipEmptyParts);
        checked = QString(*_argument->pref_valptr).split(",", QString::SkipEmptyParts);
    }
    viewModel = new QStandardItemModel();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        g_hash_table_insert(ret_args, call_string, value_string);
    }
    if (device->external_cap_args_settings != NULL)
      g_hash_table_unref(device->external_cap_args_settings);
    device->external_cap_args_settings = ret_args;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        g_hash_table_insert(ret_args, call_string, value_string);
    }
    if (device->external_cap_args_settings != NULL)
      g_hash_table_unref(device->external_cap_args_settings);
    device->external_cap_args_settings = ret_args;
}
void Singleton::f2();{
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
        return;
    extcapArguments.clear();
    arguments = g_list_first(extcap_get_if_configuration(device_name.toUtf8().constData()));
}
void Singleton::f3();{
                                    delete child;
                                    delete oldItem;
                                }
                            }
                            doStore = true;
}
void Singleton::f4();{
        argument = (ExtcapArgument *)(*iter);
        QString groupKey = argument->group();
        if (groupKey.length() > 0)
        {
            if (! groups.values().contains(groupKey))
}
void Singleton::f5();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(allowStart);
void ExtcapOptionsDialog::loadArguments()
    GList * arguments = Q_NULLPTR, * walker = Q_NULLPTR, * item = Q_NULLPTR;
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
}
void Singleton::f6();{
                    QVariant prop = child->property(QString("extcap").toLocal8Bit());
                    if (prop.isValid())
                    {
                        arg = VariantPointer<ExtcapArgument>::asPtr(prop);
                        /* value<> can fail */
}
void Singleton::f7();{
    if (count > 0)
    {
        QList<QLayout *> layouts;
        if (qobject_cast<QTabWidget *>(ui->verticalLayout->itemAt(0)->widget()))
        {
}
void Singleton::f8();{
        {
            gchar * val = g_strdup(value.toStdString().c_str());
            g_hash_table_insert(entries, g_strdup(key.toStdString().c_str()), val);
        }
    }
}
void Singleton::f9();{
        extcapArguments << optional;
    /* argument items are now owned by ExtcapArgument. Only free the lists */
    extcap_free_if_configuration(arguments, FALSE);
void ExtcapOptionsDialog::updateWidgets()
    QWidget * lblWidget = NULL, *editWidget = NULL;
}
void Singleton::f10();{
        QList<QString> keys = layouts.keys();
        foreach (QString key, keys)
            delete(layouts[key]);
    }
// Not sure why we have to do this manually.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        g_hash_table_insert(ret_args, call_string, value_string);
    }
    if (device->external_cap_args_settings != NULL)
      g_hash_table_unref(device->external_cap_args_settings);
    device->external_cap_args_settings = ret_args;
}
void Singleton::f2();{
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
        return;
    extcapArguments.clear();
    arguments = g_list_first(extcap_get_if_configuration(device_name.toUtf8().constData()));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        g_hash_table_insert(ret_args, call_string, value_string);
    }
    if (device->external_cap_args_settings != NULL)
      g_hash_table_unref(device->external_cap_args_settings);
    device->external_cap_args_settings = ret_args;
}
void Singleton::f2();{
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
        return;
    extcapArguments.clear();
    arguments = g_list_first(extcap_get_if_configuration(device_name.toUtf8().constData()));
}
void Singleton::f3();{
                                    delete child;
                                    delete oldItem;
                                }
                            }
                            doStore = true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        g_hash_table_insert(ret_args, call_string, value_string);
    }
    if (device->external_cap_args_settings != NULL)
      g_hash_table_unref(device->external_cap_args_settings);
    device->external_cap_args_settings = ret_args;
}
void Singleton::f2();{
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
        return;
    extcapArguments.clear();
    arguments = g_list_first(extcap_get_if_configuration(device_name.toUtf8().constData()));
}
void Singleton::f3();{
                                    delete child;
                                    delete oldItem;
                                }
                            }
                            doStore = true;
}
void Singleton::f4();{
        argument = (ExtcapArgument *)(*iter);
        QString groupKey = argument->group();
        if (groupKey.length() > 0)
        {
            if (! groups.values().contains(groupKey))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        g_hash_table_insert(ret_args, call_string, value_string);
    }
    if (device->external_cap_args_settings != NULL)
      g_hash_table_unref(device->external_cap_args_settings);
    device->external_cap_args_settings = ret_args;
}
void Singleton::f2();{
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
        return;
    extcapArguments.clear();
    arguments = g_list_first(extcap_get_if_configuration(device_name.toUtf8().constData()));
}
void Singleton::f3();{
                                    delete child;
                                    delete oldItem;
                                }
                            }
                            doStore = true;
}
void Singleton::f4();{
        argument = (ExtcapArgument *)(*iter);
        QString groupKey = argument->group();
        if (groupKey.length() > 0)
        {
            if (! groups.values().contains(groupKey))
}
void Singleton::f5();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(allowStart);
void ExtcapOptionsDialog::loadArguments()
    GList * arguments = Q_NULLPTR, * walker = Q_NULLPTR, * item = Q_NULLPTR;
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        g_hash_table_insert(ret_args, call_string, value_string);
    }
    if (device->external_cap_args_settings != NULL)
      g_hash_table_unref(device->external_cap_args_settings);
    device->external_cap_args_settings = ret_args;
}
void Singleton::f2();{
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
        return;
    extcapArguments.clear();
    arguments = g_list_first(extcap_get_if_configuration(device_name.toUtf8().constData()));
}
void Singleton::f3();{
                                    delete child;
                                    delete oldItem;
                                }
                            }
                            doStore = true;
}
void Singleton::f4();{
        argument = (ExtcapArgument *)(*iter);
        QString groupKey = argument->group();
        if (groupKey.length() > 0)
        {
            if (! groups.values().contains(groupKey))
}
void Singleton::f5();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(allowStart);
void ExtcapOptionsDialog::loadArguments()
    GList * arguments = Q_NULLPTR, * walker = Q_NULLPTR, * item = Q_NULLPTR;
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
}
void Singleton::f6();{
                    QVariant prop = child->property(QString("extcap").toLocal8Bit());
                    if (prop.isValid())
                    {
                        arg = VariantPointer<ExtcapArgument>::asPtr(prop);
                        /* value<> can fail */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        g_hash_table_insert(ret_args, call_string, value_string);
    }
    if (device->external_cap_args_settings != NULL)
      g_hash_table_unref(device->external_cap_args_settings);
    device->external_cap_args_settings = ret_args;
}
void Singleton::f2();{
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
        return;
    extcapArguments.clear();
    arguments = g_list_first(extcap_get_if_configuration(device_name.toUtf8().constData()));
}
void Singleton::f3();{
                                    delete child;
                                    delete oldItem;
                                }
                            }
                            doStore = true;
}
void Singleton::f4();{
        argument = (ExtcapArgument *)(*iter);
        QString groupKey = argument->group();
        if (groupKey.length() > 0)
        {
            if (! groups.values().contains(groupKey))
}
void Singleton::f5();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(allowStart);
void ExtcapOptionsDialog::loadArguments()
    GList * arguments = Q_NULLPTR, * walker = Q_NULLPTR, * item = Q_NULLPTR;
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
}
void Singleton::f6();{
                    QVariant prop = child->property(QString("extcap").toLocal8Bit());
                    if (prop.isValid())
                    {
                        arg = VariantPointer<ExtcapArgument>::asPtr(prop);
                        /* value<> can fail */
}
void Singleton::f7();{
    if (count > 0)
    {
        QList<QLayout *> layouts;
        if (qobject_cast<QTabWidget *>(ui->verticalLayout->itemAt(0)->widget()))
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        g_hash_table_insert(ret_args, call_string, value_string);
    }
    if (device->external_cap_args_settings != NULL)
      g_hash_table_unref(device->external_cap_args_settings);
    device->external_cap_args_settings = ret_args;
}
void Singleton::f2();{
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
        return;
    extcapArguments.clear();
    arguments = g_list_first(extcap_get_if_configuration(device_name.toUtf8().constData()));
}
void Singleton::f3();{
                                    delete child;
                                    delete oldItem;
                                }
                            }
                            doStore = true;
}
void Singleton::f4();{
        argument = (ExtcapArgument *)(*iter);
        QString groupKey = argument->group();
        if (groupKey.length() > 0)
        {
            if (! groups.values().contains(groupKey))
}
void Singleton::f5();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(allowStart);
void ExtcapOptionsDialog::loadArguments()
    GList * arguments = Q_NULLPTR, * walker = Q_NULLPTR, * item = Q_NULLPTR;
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
}
void Singleton::f6();{
                    QVariant prop = child->property(QString("extcap").toLocal8Bit());
                    if (prop.isValid())
                    {
                        arg = VariantPointer<ExtcapArgument>::asPtr(prop);
                        /* value<> can fail */
}
void Singleton::f7();{
    if (count > 0)
    {
        QList<QLayout *> layouts;
        if (qobject_cast<QTabWidget *>(ui->verticalLayout->itemAt(0)->widget()))
        {
}
void Singleton::f8();{
        {
            gchar * val = g_strdup(value.toStdString().c_str());
            g_hash_table_insert(entries, g_strdup(key.toStdString().c_str()), val);
        }
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        g_hash_table_insert(ret_args, call_string, value_string);
    }
    if (device->external_cap_args_settings != NULL)
      g_hash_table_unref(device->external_cap_args_settings);
    device->external_cap_args_settings = ret_args;
}
void Singleton::f2();{
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
        return;
    extcapArguments.clear();
    arguments = g_list_first(extcap_get_if_configuration(device_name.toUtf8().constData()));
}
void Singleton::f3();{
                                    delete child;
                                    delete oldItem;
                                }
                            }
                            doStore = true;
}
void Singleton::f4();{
        argument = (ExtcapArgument *)(*iter);
        QString groupKey = argument->group();
        if (groupKey.length() > 0)
        {
            if (! groups.values().contains(groupKey))
}
void Singleton::f5();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(allowStart);
void ExtcapOptionsDialog::loadArguments()
    GList * arguments = Q_NULLPTR, * walker = Q_NULLPTR, * item = Q_NULLPTR;
    ExtcapArgument * argument = Q_NULLPTR;
    if (device_name.length() == 0  )
}
void Singleton::f6();{
                    QVariant prop = child->property(QString("extcap").toLocal8Bit());
                    if (prop.isValid())
                    {
                        arg = VariantPointer<ExtcapArgument>::asPtr(prop);
                        /* value<> can fail */
}
void Singleton::f7();{
    if (count > 0)
    {
        QList<QLayout *> layouts;
        if (qobject_cast<QTabWidget *>(ui->verticalLayout->itemAt(0)->widget()))
        {
}
void Singleton::f8();{
        {
            gchar * val = g_strdup(value.toStdString().c_str());
            g_hash_table_insert(entries, g_strdup(key.toStdString().c_str()), val);
        }
    }
}
void Singleton::f9();{
        extcapArguments << optional;
    /* argument items are now owned by ExtcapArgument. Only free the lists */
    extcap_free_if_configuration(arguments, FALSE);
void ExtcapOptionsDialog::updateWidgets()
    QWidget * lblWidget = NULL, *editWidget = NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    setCompletionTokenChars(fld_abbrev_chars_);
    setDefaultPlaceholderText();
    //   DFCombo
    //     Bookmark
    //     DisplayFilterEdit
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    setCompletionTokenChars(fld_abbrev_chars_);
    setDefaultPlaceholderText();
    //   DFCombo
    //     Bookmark
    //     DisplayFilterEdit
}
void Singleton::f2();{
    //     DisplayFilterEdit
    //     Clear button
    //     Apply (right arrow)
    //     Combo drop-down
    connect(this, &FieldFilterEdit::textChanged, this,
}
void Singleton::f3();{
        default:
            break;
        }
    }
    SyntaxLineEdit::changeEvent(event);
}
void Singleton::f4();{
            const char *fw_utf8 = fw_ba.constData();
            gsize fw_len = (gsize) strlen(fw_utf8);
            for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo; hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
                if (hfinfo->same_name_prev_id != -1) continue; // Ignore duplicate names.
                if (!g_ascii_strncasecmp(fw_utf8, hfinfo->abbrev, fw_len)) {
}
void Singleton::f5();{
    }
    QString new_filter = text();
    emit filterPackets(new_filter, true);
void FieldFilterEdit::changeEvent(QEvent* event)
    if (0 != event)
}
void Singleton::f6();{
    if (!pa || pa->data().toString().isEmpty()) return;
    setText(pa->data().toString());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f7();{
// proto.c:fld_abbrev_chars
static const QString fld_abbrev_chars_ = "-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
FieldFilterEdit::FieldFilterEdit(QWidget *parent) :
    SyntaxLineEdit(parent),
    save_action_(NULL),
}
void Singleton::f8();{
void FieldFilterEdit::applyDisplayFilter()
    if (syntaxState() == Invalid) {
        return;
    }
    QString new_filter = text();
}
void Singleton::f9();{
    }
    case Invalid:
    {
        QString invalidMsg(tr("Invalid filter: "));
        invalidMsg.append(syntaxErrorMessage());
}
void Singleton::f10();{
        completion_model_->setStringList(QStringList());
        return;
    }
    void *proto_cookie;
    QStringList field_list;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    setCompletionTokenChars(fld_abbrev_chars_);
    setDefaultPlaceholderText();
    //   DFCombo
    //     Bookmark
    //     DisplayFilterEdit
}
void Singleton::f2();{
    //     DisplayFilterEdit
    //     Clear button
    //     Apply (right arrow)
    //     Combo drop-down
    connect(this, &FieldFilterEdit::textChanged, this,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    setCompletionTokenChars(fld_abbrev_chars_);
    setDefaultPlaceholderText();
    //   DFCombo
    //     Bookmark
    //     DisplayFilterEdit
}
void Singleton::f2();{
    //     DisplayFilterEdit
    //     Clear button
    //     Apply (right arrow)
    //     Combo drop-down
    connect(this, &FieldFilterEdit::textChanged, this,
}
void Singleton::f3();{
        default:
            break;
        }
    }
    SyntaxLineEdit::changeEvent(event);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    setCompletionTokenChars(fld_abbrev_chars_);
    setDefaultPlaceholderText();
    //   DFCombo
    //     Bookmark
    //     DisplayFilterEdit
}
void Singleton::f2();{
    //     DisplayFilterEdit
    //     Clear button
    //     Apply (right arrow)
    //     Combo drop-down
    connect(this, &FieldFilterEdit::textChanged, this,
}
void Singleton::f3();{
        default:
            break;
        }
    }
    SyntaxLineEdit::changeEvent(event);
}
void Singleton::f4();{
            const char *fw_utf8 = fw_ba.constData();
            gsize fw_len = (gsize) strlen(fw_utf8);
            for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo; hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
                if (hfinfo->same_name_prev_id != -1) continue; // Ignore duplicate names.
                if (!g_ascii_strncasecmp(fw_utf8, hfinfo->abbrev, fw_len)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    setCompletionTokenChars(fld_abbrev_chars_);
    setDefaultPlaceholderText();
    //   DFCombo
    //     Bookmark
    //     DisplayFilterEdit
}
void Singleton::f2();{
    //     DisplayFilterEdit
    //     Clear button
    //     Apply (right arrow)
    //     Combo drop-down
    connect(this, &FieldFilterEdit::textChanged, this,
}
void Singleton::f3();{
        default:
            break;
        }
    }
    SyntaxLineEdit::changeEvent(event);
}
void Singleton::f4();{
            const char *fw_utf8 = fw_ba.constData();
            gsize fw_len = (gsize) strlen(fw_utf8);
            for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo; hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
                if (hfinfo->same_name_prev_id != -1) continue; // Ignore duplicate names.
                if (!g_ascii_strncasecmp(fw_utf8, hfinfo->abbrev, fw_len)) {
}
void Singleton::f5();{
    }
    QString new_filter = text();
    emit filterPackets(new_filter, true);
void FieldFilterEdit::changeEvent(QEvent* event)
    if (0 != event)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    setCompletionTokenChars(fld_abbrev_chars_);
    setDefaultPlaceholderText();
    //   DFCombo
    //     Bookmark
    //     DisplayFilterEdit
}
void Singleton::f2();{
    //     DisplayFilterEdit
    //     Clear button
    //     Apply (right arrow)
    //     Combo drop-down
    connect(this, &FieldFilterEdit::textChanged, this,
}
void Singleton::f3();{
        default:
            break;
        }
    }
    SyntaxLineEdit::changeEvent(event);
}
void Singleton::f4();{
            const char *fw_utf8 = fw_ba.constData();
            gsize fw_len = (gsize) strlen(fw_utf8);
            for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo; hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
                if (hfinfo->same_name_prev_id != -1) continue; // Ignore duplicate names.
                if (!g_ascii_strncasecmp(fw_utf8, hfinfo->abbrev, fw_len)) {
}
void Singleton::f5();{
    }
    QString new_filter = text();
    emit filterPackets(new_filter, true);
void FieldFilterEdit::changeEvent(QEvent* event)
    if (0 != event)
}
void Singleton::f6();{
    if (!pa || pa->data().toString().isEmpty()) return;
    setText(pa->data().toString());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    setCompletionTokenChars(fld_abbrev_chars_);
    setDefaultPlaceholderText();
    //   DFCombo
    //     Bookmark
    //     DisplayFilterEdit
}
void Singleton::f2();{
    //     DisplayFilterEdit
    //     Clear button
    //     Apply (right arrow)
    //     Combo drop-down
    connect(this, &FieldFilterEdit::textChanged, this,
}
void Singleton::f3();{
        default:
            break;
        }
    }
    SyntaxLineEdit::changeEvent(event);
}
void Singleton::f4();{
            const char *fw_utf8 = fw_ba.constData();
            gsize fw_len = (gsize) strlen(fw_utf8);
            for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo; hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
                if (hfinfo->same_name_prev_id != -1) continue; // Ignore duplicate names.
                if (!g_ascii_strncasecmp(fw_utf8, hfinfo->abbrev, fw_len)) {
}
void Singleton::f5();{
    }
    QString new_filter = text();
    emit filterPackets(new_filter, true);
void FieldFilterEdit::changeEvent(QEvent* event)
    if (0 != event)
}
void Singleton::f6();{
    if (!pa || pa->data().toString().isEmpty()) return;
    setText(pa->data().toString());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f7();{
// proto.c:fld_abbrev_chars
static const QString fld_abbrev_chars_ = "-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
FieldFilterEdit::FieldFilterEdit(QWidget *parent) :
    SyntaxLineEdit(parent),
    save_action_(NULL),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    setCompletionTokenChars(fld_abbrev_chars_);
    setDefaultPlaceholderText();
    //   DFCombo
    //     Bookmark
    //     DisplayFilterEdit
}
void Singleton::f2();{
    //     DisplayFilterEdit
    //     Clear button
    //     Apply (right arrow)
    //     Combo drop-down
    connect(this, &FieldFilterEdit::textChanged, this,
}
void Singleton::f3();{
        default:
            break;
        }
    }
    SyntaxLineEdit::changeEvent(event);
}
void Singleton::f4();{
            const char *fw_utf8 = fw_ba.constData();
            gsize fw_len = (gsize) strlen(fw_utf8);
            for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo; hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
                if (hfinfo->same_name_prev_id != -1) continue; // Ignore duplicate names.
                if (!g_ascii_strncasecmp(fw_utf8, hfinfo->abbrev, fw_len)) {
}
void Singleton::f5();{
    }
    QString new_filter = text();
    emit filterPackets(new_filter, true);
void FieldFilterEdit::changeEvent(QEvent* event)
    if (0 != event)
}
void Singleton::f6();{
    if (!pa || pa->data().toString().isEmpty()) return;
    setText(pa->data().toString());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f7();{
// proto.c:fld_abbrev_chars
static const QString fld_abbrev_chars_ = "-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
FieldFilterEdit::FieldFilterEdit(QWidget *parent) :
    SyntaxLineEdit(parent),
    save_action_(NULL),
}
void Singleton::f8();{
void FieldFilterEdit::applyDisplayFilter()
    if (syntaxState() == Invalid) {
        return;
    }
    QString new_filter = text();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    setCompletionTokenChars(fld_abbrev_chars_);
    setDefaultPlaceholderText();
    //   DFCombo
    //     Bookmark
    //     DisplayFilterEdit
}
void Singleton::f2();{
    //     DisplayFilterEdit
    //     Clear button
    //     Apply (right arrow)
    //     Combo drop-down
    connect(this, &FieldFilterEdit::textChanged, this,
}
void Singleton::f3();{
        default:
            break;
        }
    }
    SyntaxLineEdit::changeEvent(event);
}
void Singleton::f4();{
            const char *fw_utf8 = fw_ba.constData();
            gsize fw_len = (gsize) strlen(fw_utf8);
            for (header_field_info *hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo; hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie)) {
                if (hfinfo->same_name_prev_id != -1) continue; // Ignore duplicate names.
                if (!g_ascii_strncasecmp(fw_utf8, hfinfo->abbrev, fw_len)) {
}
void Singleton::f5();{
    }
    QString new_filter = text();
    emit filterPackets(new_filter, true);
void FieldFilterEdit::changeEvent(QEvent* event)
    if (0 != event)
}
void Singleton::f6();{
    if (!pa || pa->data().toString().isEmpty()) return;
    setText(pa->data().toString());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f7();{
// proto.c:fld_abbrev_chars
static const QString fld_abbrev_chars_ = "-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
FieldFilterEdit::FieldFilterEdit(QWidget *parent) :
    SyntaxLineEdit(parent),
    save_action_(NULL),
}
void Singleton::f8();{
void FieldFilterEdit::applyDisplayFilter()
    if (syntaxState() == Invalid) {
        return;
    }
    QString new_filter = text();
}
void Singleton::f9();{
    }
    case Invalid:
    {
        QString invalidMsg(tr("Invalid filter: "));
        invalidMsg.append(syntaxErrorMessage());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    parent_fi_ = par_fi;
int FieldInformation::treeType()
    if (fi_) {
        Q_ASSERT(fi_->tree_type >= -1 && fi_->tree_type < num_tree_types);
        return fi_->tree_type;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    parent_fi_ = par_fi;
int FieldInformation::treeType()
    if (fi_) {
        Q_ASSERT(fi_->tree_type >= -1 && fi_->tree_type < num_tree_types);
        return fi_->tree_type;
}
void Singleton::f2();{
    fi_ = fi;
    parent_fi_ = NULL;
FieldInformation::FieldInformation(proto_node *node, QObject * parent)
:QObject(parent)
    fi_ = NULL;
}
void Singleton::f3();{
            ret = QString((fi_->hfinfo->name)).length() > 0;
        }
    }
    return ret;
bool FieldInformation::isLink() const
}
void Singleton::f4();{
        data = QByteArray::fromRawData((char *)dataSet, length);
    }
    return data;
 * Editor modelines
 * Local Variables:
}
void Singleton::f5();{
        header.id = fi_->hfinfo->id;
    }
    else
    {
        header.name = "";
}
void Singleton::f6();{
        }
        wmem_free(NULL, url_str);
    }
    return url;
FieldInformation::Position FieldInformation::position() const
}
void Singleton::f7();{
        if (pos.start < 0 || pos.length < 0 || pos.start >= len)
        {
            if (fi_->appendix_start >= 0 && fi_->appendix_length > 0 && fi_->appendix_start < len)
            {
                pos.start = fi_->appendix_start;
}
void Singleton::f8();{
    return pos;
FieldInformation::Position FieldInformation::appendix() const
    Position pos = {-1, -1};
    if (fi_ && fi_->ds_tvb)
    {
}
void Singleton::f9();{
    }
    return module_name;
QString FieldInformation::url()
    QString url;
    if (flag(FI_URL) && headerInfo().isValid && IS_FT_STRING(fi_->hfinfo->type)) {
}
void Singleton::f10();{
        return fi_->tree_type;
    }
    return -1;
field_info * FieldInformation::fieldInfo() const
    return fi_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    parent_fi_ = par_fi;
int FieldInformation::treeType()
    if (fi_) {
        Q_ASSERT(fi_->tree_type >= -1 && fi_->tree_type < num_tree_types);
        return fi_->tree_type;
}
void Singleton::f2();{
    fi_ = fi;
    parent_fi_ = NULL;
FieldInformation::FieldInformation(proto_node *node, QObject * parent)
:QObject(parent)
    fi_ = NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    parent_fi_ = par_fi;
int FieldInformation::treeType()
    if (fi_) {
        Q_ASSERT(fi_->tree_type >= -1 && fi_->tree_type < num_tree_types);
        return fi_->tree_type;
}
void Singleton::f2();{
    fi_ = fi;
    parent_fi_ = NULL;
FieldInformation::FieldInformation(proto_node *node, QObject * parent)
:QObject(parent)
    fi_ = NULL;
}
void Singleton::f3();{
            ret = QString((fi_->hfinfo->name)).length() > 0;
        }
    }
    return ret;
bool FieldInformation::isLink() const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    parent_fi_ = par_fi;
int FieldInformation::treeType()
    if (fi_) {
        Q_ASSERT(fi_->tree_type >= -1 && fi_->tree_type < num_tree_types);
        return fi_->tree_type;
}
void Singleton::f2();{
    fi_ = fi;
    parent_fi_ = NULL;
FieldInformation::FieldInformation(proto_node *node, QObject * parent)
:QObject(parent)
    fi_ = NULL;
}
void Singleton::f3();{
            ret = QString((fi_->hfinfo->name)).length() > 0;
        }
    }
    return ret;
bool FieldInformation::isLink() const
}
void Singleton::f4();{
        data = QByteArray::fromRawData((char *)dataSet, length);
    }
    return data;
 * Editor modelines
 * Local Variables:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    parent_fi_ = par_fi;
int FieldInformation::treeType()
    if (fi_) {
        Q_ASSERT(fi_->tree_type >= -1 && fi_->tree_type < num_tree_types);
        return fi_->tree_type;
}
void Singleton::f2();{
    fi_ = fi;
    parent_fi_ = NULL;
FieldInformation::FieldInformation(proto_node *node, QObject * parent)
:QObject(parent)
    fi_ = NULL;
}
void Singleton::f3();{
            ret = QString((fi_->hfinfo->name)).length() > 0;
        }
    }
    return ret;
bool FieldInformation::isLink() const
}
void Singleton::f4();{
        data = QByteArray::fromRawData((char *)dataSet, length);
    }
    return data;
 * Editor modelines
 * Local Variables:
}
void Singleton::f5();{
        header.id = fi_->hfinfo->id;
    }
    else
    {
        header.name = "";
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    parent_fi_ = par_fi;
int FieldInformation::treeType()
    if (fi_) {
        Q_ASSERT(fi_->tree_type >= -1 && fi_->tree_type < num_tree_types);
        return fi_->tree_type;
}
void Singleton::f2();{
    fi_ = fi;
    parent_fi_ = NULL;
FieldInformation::FieldInformation(proto_node *node, QObject * parent)
:QObject(parent)
    fi_ = NULL;
}
void Singleton::f3();{
            ret = QString((fi_->hfinfo->name)).length() > 0;
        }
    }
    return ret;
bool FieldInformation::isLink() const
}
void Singleton::f4();{
        data = QByteArray::fromRawData((char *)dataSet, length);
    }
    return data;
 * Editor modelines
 * Local Variables:
}
void Singleton::f5();{
        header.id = fi_->hfinfo->id;
    }
    else
    {
        header.name = "";
}
void Singleton::f6();{
        }
        wmem_free(NULL, url_str);
    }
    return url;
FieldInformation::Position FieldInformation::position() const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    parent_fi_ = par_fi;
int FieldInformation::treeType()
    if (fi_) {
        Q_ASSERT(fi_->tree_type >= -1 && fi_->tree_type < num_tree_types);
        return fi_->tree_type;
}
void Singleton::f2();{
    fi_ = fi;
    parent_fi_ = NULL;
FieldInformation::FieldInformation(proto_node *node, QObject * parent)
:QObject(parent)
    fi_ = NULL;
}
void Singleton::f3();{
            ret = QString((fi_->hfinfo->name)).length() > 0;
        }
    }
    return ret;
bool FieldInformation::isLink() const
}
void Singleton::f4();{
        data = QByteArray::fromRawData((char *)dataSet, length);
    }
    return data;
 * Editor modelines
 * Local Variables:
}
void Singleton::f5();{
        header.id = fi_->hfinfo->id;
    }
    else
    {
        header.name = "";
}
void Singleton::f6();{
        }
        wmem_free(NULL, url_str);
    }
    return url;
FieldInformation::Position FieldInformation::position() const
}
void Singleton::f7();{
        if (pos.start < 0 || pos.length < 0 || pos.start >= len)
        {
            if (fi_->appendix_start >= 0 && fi_->appendix_length > 0 && fi_->appendix_start < len)
            {
                pos.start = fi_->appendix_start;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    parent_fi_ = par_fi;
int FieldInformation::treeType()
    if (fi_) {
        Q_ASSERT(fi_->tree_type >= -1 && fi_->tree_type < num_tree_types);
        return fi_->tree_type;
}
void Singleton::f2();{
    fi_ = fi;
    parent_fi_ = NULL;
FieldInformation::FieldInformation(proto_node *node, QObject * parent)
:QObject(parent)
    fi_ = NULL;
}
void Singleton::f3();{
            ret = QString((fi_->hfinfo->name)).length() > 0;
        }
    }
    return ret;
bool FieldInformation::isLink() const
}
void Singleton::f4();{
        data = QByteArray::fromRawData((char *)dataSet, length);
    }
    return data;
 * Editor modelines
 * Local Variables:
}
void Singleton::f5();{
        header.id = fi_->hfinfo->id;
    }
    else
    {
        header.name = "";
}
void Singleton::f6();{
        }
        wmem_free(NULL, url_str);
    }
    return url;
FieldInformation::Position FieldInformation::position() const
}
void Singleton::f7();{
        if (pos.start < 0 || pos.length < 0 || pos.start >= len)
        {
            if (fi_->appendix_start >= 0 && fi_->appendix_length > 0 && fi_->appendix_start < len)
            {
                pos.start = fi_->appendix_start;
}
void Singleton::f8();{
    return pos;
FieldInformation::Position FieldInformation::appendix() const
    Position pos = {-1, -1};
    if (fi_ && fi_->ds_tvb)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    parent_fi_ = par_fi;
int FieldInformation::treeType()
    if (fi_) {
        Q_ASSERT(fi_->tree_type >= -1 && fi_->tree_type < num_tree_types);
        return fi_->tree_type;
}
void Singleton::f2();{
    fi_ = fi;
    parent_fi_ = NULL;
FieldInformation::FieldInformation(proto_node *node, QObject * parent)
:QObject(parent)
    fi_ = NULL;
}
void Singleton::f3();{
            ret = QString((fi_->hfinfo->name)).length() > 0;
        }
    }
    return ret;
bool FieldInformation::isLink() const
}
void Singleton::f4();{
        data = QByteArray::fromRawData((char *)dataSet, length);
    }
    return data;
 * Editor modelines
 * Local Variables:
}
void Singleton::f5();{
        header.id = fi_->hfinfo->id;
    }
    else
    {
        header.name = "";
}
void Singleton::f6();{
        }
        wmem_free(NULL, url_str);
    }
    return url;
FieldInformation::Position FieldInformation::position() const
}
void Singleton::f7();{
        if (pos.start < 0 || pos.length < 0 || pos.start >= len)
        {
            if (fi_->appendix_start >= 0 && fi_->appendix_length > 0 && fi_->appendix_start < len)
            {
                pos.start = fi_->appendix_start;
}
void Singleton::f8();{
    return pos;
FieldInformation::Position FieldInformation::appendix() const
    Position pos = {-1, -1};
    if (fi_ && fi_->ds_tvb)
    {
}
void Singleton::f9();{
    }
    return module_name;
QString FieldInformation::url()
    QString url;
    if (flag(FI_URL) && headerInfo().isValid && IS_FT_STRING(fi_->hfinfo->type)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        return QString(tr("Open this capture file"));
    } else if (role == Qt::TextAlignmentRole) {
        switch (index.column()) {
        case Size:
            // Not perfect but better than nothing.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        return QString(tr("Open this capture file"));
    } else if (role == Qt::TextAlignmentRole) {
        switch (index.column()) {
        case Size:
            // Not perfect but better than nothing.
}
void Singleton::f2();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}
void Singleton::f3();{
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
        switch (index.column()) {
        case Name:
            return QString(entry->name);
}
void Singleton::f4();{
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
        return QModelIndex();
}
void Singleton::f5();{
 * SPDX-License-Identifier: GPL-2.0-or-later
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
}
void Singleton::f6();{
                } else {
                    created = UTF8_EM_DASH;
                }
            }
            return created;
}
void Singleton::f7();{
QVariant FilesetEntryModel::headerData(int section, Qt::Orientation, int role) const
    if (role != Qt::DisplayRole) return QVariant();
    switch (section) {
    case Name:
        return tr("Filename");
}
void Singleton::f8();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}
void Singleton::f9();{
int FilesetEntryModel::rowCount(const QModelIndex &) const
    return entries_.count();
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
}
void Singleton::f10();{
                 * macOS provides 0 if the file system doesn't support the
                 * creation time; FreeBSD provides -1.
                 *
                 * If this OS doesn't provide the creation time with stat(),
                 * it will be 0.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        return QString(tr("Open this capture file"));
    } else if (role == Qt::TextAlignmentRole) {
        switch (index.column()) {
        case Size:
            // Not perfect but better than nothing.
}
void Singleton::f2();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        return QString(tr("Open this capture file"));
    } else if (role == Qt::TextAlignmentRole) {
        switch (index.column()) {
        case Size:
            // Not perfect but better than nothing.
}
void Singleton::f2();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}
void Singleton::f3();{
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
        switch (index.column()) {
        case Name:
            return QString(entry->name);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        return QString(tr("Open this capture file"));
    } else if (role == Qt::TextAlignmentRole) {
        switch (index.column()) {
        case Size:
            // Not perfect but better than nothing.
}
void Singleton::f2();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}
void Singleton::f3();{
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
        switch (index.column()) {
        case Name:
            return QString(entry->name);
}
void Singleton::f4();{
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
        return QModelIndex();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        return QString(tr("Open this capture file"));
    } else if (role == Qt::TextAlignmentRole) {
        switch (index.column()) {
        case Size:
            // Not perfect but better than nothing.
}
void Singleton::f2();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}
void Singleton::f3();{
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
        switch (index.column()) {
        case Name:
            return QString(entry->name);
}
void Singleton::f4();{
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
        return QModelIndex();
}
void Singleton::f5();{
 * SPDX-License-Identifier: GPL-2.0-or-later
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        return QString(tr("Open this capture file"));
    } else if (role == Qt::TextAlignmentRole) {
        switch (index.column()) {
        case Size:
            // Not perfect but better than nothing.
}
void Singleton::f2();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}
void Singleton::f3();{
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
        switch (index.column()) {
        case Name:
            return QString(entry->name);
}
void Singleton::f4();{
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
        return QModelIndex();
}
void Singleton::f5();{
 * SPDX-License-Identifier: GPL-2.0-or-later
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
}
void Singleton::f6();{
                } else {
                    created = UTF8_EM_DASH;
                }
            }
            return created;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        return QString(tr("Open this capture file"));
    } else if (role == Qt::TextAlignmentRole) {
        switch (index.column()) {
        case Size:
            // Not perfect but better than nothing.
}
void Singleton::f2();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}
void Singleton::f3();{
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
        switch (index.column()) {
        case Name:
            return QString(entry->name);
}
void Singleton::f4();{
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
        return QModelIndex();
}
void Singleton::f5();{
 * SPDX-License-Identifier: GPL-2.0-or-later
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
}
void Singleton::f6();{
                } else {
                    created = UTF8_EM_DASH;
                }
            }
            return created;
}
void Singleton::f7();{
QVariant FilesetEntryModel::headerData(int section, Qt::Orientation, int role) const
    if (role != Qt::DisplayRole) return QVariant();
    switch (section) {
    case Name:
        return tr("Filename");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        return QString(tr("Open this capture file"));
    } else if (role == Qt::TextAlignmentRole) {
        switch (index.column()) {
        case Size:
            // Not perfect but better than nothing.
}
void Singleton::f2();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}
void Singleton::f3();{
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
        switch (index.column()) {
        case Name:
            return QString(entry->name);
}
void Singleton::f4();{
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
        return QModelIndex();
}
void Singleton::f5();{
 * SPDX-License-Identifier: GPL-2.0-or-later
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
}
void Singleton::f6();{
                } else {
                    created = UTF8_EM_DASH;
                }
            }
            return created;
}
void Singleton::f7();{
QVariant FilesetEntryModel::headerData(int section, Qt::Orientation, int role) const
    if (role != Qt::DisplayRole) return QVariant();
    switch (section) {
    case Name:
        return tr("Filename");
}
void Singleton::f8();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        return QString(tr("Open this capture file"));
    } else if (role == Qt::TextAlignmentRole) {
        switch (index.column()) {
        case Size:
            // Not perfect but better than nothing.
}
void Singleton::f2();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}
void Singleton::f3();{
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
        switch (index.column()) {
        case Name:
            return QString(entry->name);
}
void Singleton::f4();{
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
        return QModelIndex();
}
void Singleton::f5();{
 * SPDX-License-Identifier: GPL-2.0-or-later
FilesetEntryModel::FilesetEntryModel(QObject * parent) :
    QAbstractItemModel(parent)
QModelIndex FilesetEntryModel::index(int row, int column, const QModelIndex &) const
    if (row >= entries_.count() || row < 0 || column > ColumnCount) {
}
void Singleton::f6();{
                } else {
                    created = UTF8_EM_DASH;
                }
            }
            return created;
}
void Singleton::f7();{
QVariant FilesetEntryModel::headerData(int section, Qt::Orientation, int role) const
    if (role != Qt::DisplayRole) return QVariant();
    switch (section) {
    case Name:
        return tr("Filename");
}
void Singleton::f8();{
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
    const fileset_entry *entry = static_cast<fileset_entry*>(index.internalPointer());
    if (role == Qt::DisplayRole && entry) {
}
void Singleton::f9();{
int FilesetEntryModel::rowCount(const QModelIndex &) const
    return entries_.count();
QVariant FilesetEntryModel::data(const QModelIndex &index, int role) const
    if (! index.isValid() || index.row() >= rowCount())
        return QVariant();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    QString dir_name = fileset_get_dirname();
    fs_ui_->directoryLabel->setText(dir_name);
    fs_ui_->directoryLabel->setUrl(QUrl::fromLocalFile(dir_name).toString());
    fs_ui_->directoryLabel->setEnabled(true);
    if (cur_idx_ >= 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    QString dir_name = fileset_get_dirname();
    fs_ui_->directoryLabel->setText(dir_name);
    fs_ui_->directoryLabel->setUrl(QUrl::fromLocalFile(dir_name).toString());
    fs_ui_->directoryLabel->setEnabled(true);
    if (cur_idx_ >= 0) {
}
void Singleton::f2();{
    beginAddFile();
    addFile();
    endAddFile();
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
}
void Singleton::f3();{
// - We might want to rename this to FilesetDialog / fileset_dialog.{cpp,h}.
void
fileset_dlg_begin_add_file(void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->beginAddFile();
}
void Singleton::f4();{
/* This file is a part of the current file set. Add it to our model. */
void
fileset_dlg_add_file(fileset_entry *entry, void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->addFile(entry);
}
void Singleton::f5();{
    }
void FileSetDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILESET_DIALOG);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    setWindowTitle(wsApp->windowTitleString(tr("No files in Set")));
    fs_ui_->directoryLabel->setText(tr("No capture loaded"));
    fs_ui_->directoryLabel->setEnabled(false);
void FileSetDialog::endAddFile()
    if (fileset_entry_model_->entryCount() > 0) {
}
void Singleton::f7();{
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
    delete fs_ui_;
/* a new capture file was opened, browse the dir and look for files matching the given file set */
void FileSetDialog::fileOpened(const capture_file *cf) {
}
void Singleton::f8();{
// To do:
// - We might want to rename this to FilesetDialog / fileset_dialog.{cpp,h}.
void
fileset_dlg_begin_add_file(void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
}
void Singleton::f9();{
/* fileset_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f10();{
    fileset_add_dir(cf->filename, this);
/* the capture file was closed */
void FileSetDialog::fileClosed() {
    fileset_entry_model_->clear();
void FileSetDialog::addFile(fileset_entry *entry) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    QString dir_name = fileset_get_dirname();
    fs_ui_->directoryLabel->setText(dir_name);
    fs_ui_->directoryLabel->setUrl(QUrl::fromLocalFile(dir_name).toString());
    fs_ui_->directoryLabel->setEnabled(true);
    if (cur_idx_ >= 0) {
}
void Singleton::f2();{
    beginAddFile();
    addFile();
    endAddFile();
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    QString dir_name = fileset_get_dirname();
    fs_ui_->directoryLabel->setText(dir_name);
    fs_ui_->directoryLabel->setUrl(QUrl::fromLocalFile(dir_name).toString());
    fs_ui_->directoryLabel->setEnabled(true);
    if (cur_idx_ >= 0) {
}
void Singleton::f2();{
    beginAddFile();
    addFile();
    endAddFile();
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
}
void Singleton::f3();{
// - We might want to rename this to FilesetDialog / fileset_dialog.{cpp,h}.
void
fileset_dlg_begin_add_file(void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->beginAddFile();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    QString dir_name = fileset_get_dirname();
    fs_ui_->directoryLabel->setText(dir_name);
    fs_ui_->directoryLabel->setUrl(QUrl::fromLocalFile(dir_name).toString());
    fs_ui_->directoryLabel->setEnabled(true);
    if (cur_idx_ >= 0) {
}
void Singleton::f2();{
    beginAddFile();
    addFile();
    endAddFile();
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
}
void Singleton::f3();{
// - We might want to rename this to FilesetDialog / fileset_dialog.{cpp,h}.
void
fileset_dlg_begin_add_file(void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->beginAddFile();
}
void Singleton::f4();{
/* This file is a part of the current file set. Add it to our model. */
void
fileset_dlg_add_file(fileset_entry *entry, void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->addFile(entry);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    QString dir_name = fileset_get_dirname();
    fs_ui_->directoryLabel->setText(dir_name);
    fs_ui_->directoryLabel->setUrl(QUrl::fromLocalFile(dir_name).toString());
    fs_ui_->directoryLabel->setEnabled(true);
    if (cur_idx_ >= 0) {
}
void Singleton::f2();{
    beginAddFile();
    addFile();
    endAddFile();
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
}
void Singleton::f3();{
// - We might want to rename this to FilesetDialog / fileset_dialog.{cpp,h}.
void
fileset_dlg_begin_add_file(void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->beginAddFile();
}
void Singleton::f4();{
/* This file is a part of the current file set. Add it to our model. */
void
fileset_dlg_add_file(fileset_entry *entry, void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->addFile(entry);
}
void Singleton::f5();{
    }
void FileSetDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILESET_DIALOG);
 * Editor modelines
 * Local Variables:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    QString dir_name = fileset_get_dirname();
    fs_ui_->directoryLabel->setText(dir_name);
    fs_ui_->directoryLabel->setUrl(QUrl::fromLocalFile(dir_name).toString());
    fs_ui_->directoryLabel->setEnabled(true);
    if (cur_idx_ >= 0) {
}
void Singleton::f2();{
    beginAddFile();
    addFile();
    endAddFile();
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
}
void Singleton::f3();{
// - We might want to rename this to FilesetDialog / fileset_dialog.{cpp,h}.
void
fileset_dlg_begin_add_file(void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->beginAddFile();
}
void Singleton::f4();{
/* This file is a part of the current file set. Add it to our model. */
void
fileset_dlg_add_file(fileset_entry *entry, void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->addFile(entry);
}
void Singleton::f5();{
    }
void FileSetDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILESET_DIALOG);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    setWindowTitle(wsApp->windowTitleString(tr("No files in Set")));
    fs_ui_->directoryLabel->setText(tr("No capture loaded"));
    fs_ui_->directoryLabel->setEnabled(false);
void FileSetDialog::endAddFile()
    if (fileset_entry_model_->entryCount() > 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    QString dir_name = fileset_get_dirname();
    fs_ui_->directoryLabel->setText(dir_name);
    fs_ui_->directoryLabel->setUrl(QUrl::fromLocalFile(dir_name).toString());
    fs_ui_->directoryLabel->setEnabled(true);
    if (cur_idx_ >= 0) {
}
void Singleton::f2();{
    beginAddFile();
    addFile();
    endAddFile();
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
}
void Singleton::f3();{
// - We might want to rename this to FilesetDialog / fileset_dialog.{cpp,h}.
void
fileset_dlg_begin_add_file(void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->beginAddFile();
}
void Singleton::f4();{
/* This file is a part of the current file set. Add it to our model. */
void
fileset_dlg_add_file(fileset_entry *entry, void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->addFile(entry);
}
void Singleton::f5();{
    }
void FileSetDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILESET_DIALOG);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    setWindowTitle(wsApp->windowTitleString(tr("No files in Set")));
    fs_ui_->directoryLabel->setText(tr("No capture loaded"));
    fs_ui_->directoryLabel->setEnabled(false);
void FileSetDialog::endAddFile()
    if (fileset_entry_model_->entryCount() > 0) {
}
void Singleton::f7();{
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
    delete fs_ui_;
/* a new capture file was opened, browse the dir and look for files matching the given file set */
void FileSetDialog::fileOpened(const capture_file *cf) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    QString dir_name = fileset_get_dirname();
    fs_ui_->directoryLabel->setText(dir_name);
    fs_ui_->directoryLabel->setUrl(QUrl::fromLocalFile(dir_name).toString());
    fs_ui_->directoryLabel->setEnabled(true);
    if (cur_idx_ >= 0) {
}
void Singleton::f2();{
    beginAddFile();
    addFile();
    endAddFile();
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
}
void Singleton::f3();{
// - We might want to rename this to FilesetDialog / fileset_dialog.{cpp,h}.
void
fileset_dlg_begin_add_file(void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->beginAddFile();
}
void Singleton::f4();{
/* This file is a part of the current file set. Add it to our model. */
void
fileset_dlg_add_file(fileset_entry *entry, void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->addFile(entry);
}
void Singleton::f5();{
    }
void FileSetDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILESET_DIALOG);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    setWindowTitle(wsApp->windowTitleString(tr("No files in Set")));
    fs_ui_->directoryLabel->setText(tr("No capture loaded"));
    fs_ui_->directoryLabel->setEnabled(false);
void FileSetDialog::endAddFile()
    if (fileset_entry_model_->entryCount() > 0) {
}
void Singleton::f7();{
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
    delete fs_ui_;
/* a new capture file was opened, browse the dir and look for files matching the given file set */
void FileSetDialog::fileOpened(const capture_file *cf) {
}
void Singleton::f8();{
// To do:
// - We might want to rename this to FilesetDialog / fileset_dialog.{cpp,h}.
void
fileset_dlg_begin_add_file(void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    QString dir_name = fileset_get_dirname();
    fs_ui_->directoryLabel->setText(dir_name);
    fs_ui_->directoryLabel->setUrl(QUrl::fromLocalFile(dir_name).toString());
    fs_ui_->directoryLabel->setEnabled(true);
    if (cur_idx_ >= 0) {
}
void Singleton::f2();{
    beginAddFile();
    addFile();
    endAddFile();
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
}
void Singleton::f3();{
// - We might want to rename this to FilesetDialog / fileset_dialog.{cpp,h}.
void
fileset_dlg_begin_add_file(void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->beginAddFile();
}
void Singleton::f4();{
/* This file is a part of the current file set. Add it to our model. */
void
fileset_dlg_add_file(fileset_entry *entry, void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
    if (fs_dlg) fs_dlg->addFile(entry);
}
void Singleton::f5();{
    }
void FileSetDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_FILESET_DIALOG);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    setWindowTitle(wsApp->windowTitleString(tr("No files in Set")));
    fs_ui_->directoryLabel->setText(tr("No capture loaded"));
    fs_ui_->directoryLabel->setEnabled(false);
void FileSetDialog::endAddFile()
    if (fileset_entry_model_->entryCount() > 0) {
}
void Singleton::f7();{
FileSetDialog::~FileSetDialog()
    fileset_entry_model_->clear();
    delete fs_ui_;
/* a new capture file was opened, browse the dir and look for files matching the given file set */
void FileSetDialog::fileOpened(const capture_file *cf) {
}
void Singleton::f8();{
// To do:
// - We might want to rename this to FilesetDialog / fileset_dialog.{cpp,h}.
void
fileset_dlg_begin_add_file(void *window) {
    FileSetDialog *fs_dlg = static_cast<FileSetDialog *>(window);
}
void Singleton::f9();{
/* fileset_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            FilterAction::Action act = sender()->property("filterAction").value<FilterAction::Action>();
            FilterAction::ActionType type = action->property("filterType").value<FilterAction::ActionType>();
            QString filter = sender()->property("filter").toString();
            QWidget * mainWin = wsApp->mainWindow();
            if (qobject_cast<MainWindow *>(mainWin))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            FilterAction::Action act = sender()->property("filterAction").value<FilterAction::Action>();
            FilterAction::ActionType type = action->property("filterType").value<FilterAction::ActionType>();
            QString filter = sender()->property("filter").toString();
            QWidget * mainWin = wsApp->mainWindow();
            if (qobject_cast<MainWindow *>(mainWin))
}
void Singleton::f2();{
    switch (action) {
    case ActionApply:
        return QObject::tr("Apply as Filter");
        break;
    case ActionPrepare:
}
void Singleton::f3();{
    action->setProperty("filterType", FilterAction::ActionTypeAnd);
    action->setEnabled(!filterEmpty);
    action = group->addAction(tr(UTF8_HORIZONTAL_ELLIPSIS "or Selected"));
    action->setProperty("filterType", FilterAction::ActionTypeOr);
    action->setEnabled(!filterEmpty);
}
void Singleton::f4();{
    switch (filter_action) {
    case ActionFind:
    case ActionColorize:
        return simple_action_types_;
    default:
}
void Singleton::f5();{
        return QObject::tr("Find");
        break;
    case ActionColorize:
        return QObject::tr("Colorize");
        break;
}
void Singleton::f6();{
    submenu->addActions(group->actions());
    return submenu;
void FilterAction::groupTriggered(QAction * action)
    if (action && wsApp)
    {
}
void Singleton::f7();{
    case ActionDirectionAToFromB:
        return QObject::tr("A " UTF8_LEFT_RIGHT_ARROW " B");
        break;
    case ActionDirectionAToB:
        return QObject::tr("A " UTF8_RIGHTWARDS_ARROW " B");
}
void Singleton::f8();{
        return QObject::tr("UNKNOWN");
        break;
    }
QActionGroup * FilterAction::createFilterGroup(QString filter, bool prepare, bool enabled, QWidget * parent)
    if (filter.isEmpty())
}
void Singleton::f9();{
    bool prepare = (act == FilterAction::ActionApply) ? false : true;
    QMenu * submenu = new QMenu(title, par);
    if (filter.length() > 0)
    {
        QAction * comment = submenu->addAction(QString("%1: %2").arg(title).arg(filter));
}
void Singleton::f10();{
            << ActionDirectionAnyFromB;
    return action_directions_;
const QString FilterAction::actionDirectionName(ActionDirection direction) {
    switch (direction) {
    case ActionDirectionAToFromB:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            FilterAction::Action act = sender()->property("filterAction").value<FilterAction::Action>();
            FilterAction::ActionType type = action->property("filterType").value<FilterAction::ActionType>();
            QString filter = sender()->property("filter").toString();
            QWidget * mainWin = wsApp->mainWindow();
            if (qobject_cast<MainWindow *>(mainWin))
}
void Singleton::f2();{
    switch (action) {
    case ActionApply:
        return QObject::tr("Apply as Filter");
        break;
    case ActionPrepare:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            FilterAction::Action act = sender()->property("filterAction").value<FilterAction::Action>();
            FilterAction::ActionType type = action->property("filterType").value<FilterAction::ActionType>();
            QString filter = sender()->property("filter").toString();
            QWidget * mainWin = wsApp->mainWindow();
            if (qobject_cast<MainWindow *>(mainWin))
}
void Singleton::f2();{
    switch (action) {
    case ActionApply:
        return QObject::tr("Apply as Filter");
        break;
    case ActionPrepare:
}
void Singleton::f3();{
    action->setProperty("filterType", FilterAction::ActionTypeAnd);
    action->setEnabled(!filterEmpty);
    action = group->addAction(tr(UTF8_HORIZONTAL_ELLIPSIS "or Selected"));
    action->setProperty("filterType", FilterAction::ActionTypeOr);
    action->setEnabled(!filterEmpty);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            FilterAction::Action act = sender()->property("filterAction").value<FilterAction::Action>();
            FilterAction::ActionType type = action->property("filterType").value<FilterAction::ActionType>();
            QString filter = sender()->property("filter").toString();
            QWidget * mainWin = wsApp->mainWindow();
            if (qobject_cast<MainWindow *>(mainWin))
}
void Singleton::f2();{
    switch (action) {
    case ActionApply:
        return QObject::tr("Apply as Filter");
        break;
    case ActionPrepare:
}
void Singleton::f3();{
    action->setProperty("filterType", FilterAction::ActionTypeAnd);
    action->setEnabled(!filterEmpty);
    action = group->addAction(tr(UTF8_HORIZONTAL_ELLIPSIS "or Selected"));
    action->setProperty("filterType", FilterAction::ActionTypeOr);
    action->setEnabled(!filterEmpty);
}
void Singleton::f4();{
    switch (filter_action) {
    case ActionFind:
    case ActionColorize:
        return simple_action_types_;
    default:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            FilterAction::Action act = sender()->property("filterAction").value<FilterAction::Action>();
            FilterAction::ActionType type = action->property("filterType").value<FilterAction::ActionType>();
            QString filter = sender()->property("filter").toString();
            QWidget * mainWin = wsApp->mainWindow();
            if (qobject_cast<MainWindow *>(mainWin))
}
void Singleton::f2();{
    switch (action) {
    case ActionApply:
        return QObject::tr("Apply as Filter");
        break;
    case ActionPrepare:
}
void Singleton::f3();{
    action->setProperty("filterType", FilterAction::ActionTypeAnd);
    action->setEnabled(!filterEmpty);
    action = group->addAction(tr(UTF8_HORIZONTAL_ELLIPSIS "or Selected"));
    action->setProperty("filterType", FilterAction::ActionTypeOr);
    action->setEnabled(!filterEmpty);
}
void Singleton::f4();{
    switch (filter_action) {
    case ActionFind:
    case ActionColorize:
        return simple_action_types_;
    default:
}
void Singleton::f5();{
        return QObject::tr("Find");
        break;
    case ActionColorize:
        return QObject::tr("Colorize");
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            FilterAction::Action act = sender()->property("filterAction").value<FilterAction::Action>();
            FilterAction::ActionType type = action->property("filterType").value<FilterAction::ActionType>();
            QString filter = sender()->property("filter").toString();
            QWidget * mainWin = wsApp->mainWindow();
            if (qobject_cast<MainWindow *>(mainWin))
}
void Singleton::f2();{
    switch (action) {
    case ActionApply:
        return QObject::tr("Apply as Filter");
        break;
    case ActionPrepare:
}
void Singleton::f3();{
    action->setProperty("filterType", FilterAction::ActionTypeAnd);
    action->setEnabled(!filterEmpty);
    action = group->addAction(tr(UTF8_HORIZONTAL_ELLIPSIS "or Selected"));
    action->setProperty("filterType", FilterAction::ActionTypeOr);
    action->setEnabled(!filterEmpty);
}
void Singleton::f4();{
    switch (filter_action) {
    case ActionFind:
    case ActionColorize:
        return simple_action_types_;
    default:
}
void Singleton::f5();{
        return QObject::tr("Find");
        break;
    case ActionColorize:
        return QObject::tr("Colorize");
        break;
}
void Singleton::f6();{
    submenu->addActions(group->actions());
    return submenu;
void FilterAction::groupTriggered(QAction * action)
    if (action && wsApp)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            FilterAction::Action act = sender()->property("filterAction").value<FilterAction::Action>();
            FilterAction::ActionType type = action->property("filterType").value<FilterAction::ActionType>();
            QString filter = sender()->property("filter").toString();
            QWidget * mainWin = wsApp->mainWindow();
            if (qobject_cast<MainWindow *>(mainWin))
}
void Singleton::f2();{
    switch (action) {
    case ActionApply:
        return QObject::tr("Apply as Filter");
        break;
    case ActionPrepare:
}
void Singleton::f3();{
    action->setProperty("filterType", FilterAction::ActionTypeAnd);
    action->setEnabled(!filterEmpty);
    action = group->addAction(tr(UTF8_HORIZONTAL_ELLIPSIS "or Selected"));
    action->setProperty("filterType", FilterAction::ActionTypeOr);
    action->setEnabled(!filterEmpty);
}
void Singleton::f4();{
    switch (filter_action) {
    case ActionFind:
    case ActionColorize:
        return simple_action_types_;
    default:
}
void Singleton::f5();{
        return QObject::tr("Find");
        break;
    case ActionColorize:
        return QObject::tr("Colorize");
        break;
}
void Singleton::f6();{
    submenu->addActions(group->actions());
    return submenu;
void FilterAction::groupTriggered(QAction * action)
    if (action && wsApp)
    {
}
void Singleton::f7();{
    case ActionDirectionAToFromB:
        return QObject::tr("A " UTF8_LEFT_RIGHT_ARROW " B");
        break;
    case ActionDirectionAToB:
        return QObject::tr("A " UTF8_RIGHTWARDS_ARROW " B");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            FilterAction::Action act = sender()->property("filterAction").value<FilterAction::Action>();
            FilterAction::ActionType type = action->property("filterType").value<FilterAction::ActionType>();
            QString filter = sender()->property("filter").toString();
            QWidget * mainWin = wsApp->mainWindow();
            if (qobject_cast<MainWindow *>(mainWin))
}
void Singleton::f2();{
    switch (action) {
    case ActionApply:
        return QObject::tr("Apply as Filter");
        break;
    case ActionPrepare:
}
void Singleton::f3();{
    action->setProperty("filterType", FilterAction::ActionTypeAnd);
    action->setEnabled(!filterEmpty);
    action = group->addAction(tr(UTF8_HORIZONTAL_ELLIPSIS "or Selected"));
    action->setProperty("filterType", FilterAction::ActionTypeOr);
    action->setEnabled(!filterEmpty);
}
void Singleton::f4();{
    switch (filter_action) {
    case ActionFind:
    case ActionColorize:
        return simple_action_types_;
    default:
}
void Singleton::f5();{
        return QObject::tr("Find");
        break;
    case ActionColorize:
        return QObject::tr("Colorize");
        break;
}
void Singleton::f6();{
    submenu->addActions(group->actions());
    return submenu;
void FilterAction::groupTriggered(QAction * action)
    if (action && wsApp)
    {
}
void Singleton::f7();{
    case ActionDirectionAToFromB:
        return QObject::tr("A " UTF8_LEFT_RIGHT_ARROW " B");
        break;
    case ActionDirectionAToB:
        return QObject::tr("A " UTF8_RIGHTWARDS_ARROW " B");
}
void Singleton::f8();{
        return QObject::tr("UNKNOWN");
        break;
    }
QActionGroup * FilterAction::createFilterGroup(QString filter, bool prepare, bool enabled, QWidget * parent)
    if (filter.isEmpty())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            FilterAction::Action act = sender()->property("filterAction").value<FilterAction::Action>();
            FilterAction::ActionType type = action->property("filterType").value<FilterAction::ActionType>();
            QString filter = sender()->property("filter").toString();
            QWidget * mainWin = wsApp->mainWindow();
            if (qobject_cast<MainWindow *>(mainWin))
}
void Singleton::f2();{
    switch (action) {
    case ActionApply:
        return QObject::tr("Apply as Filter");
        break;
    case ActionPrepare:
}
void Singleton::f3();{
    action->setProperty("filterType", FilterAction::ActionTypeAnd);
    action->setEnabled(!filterEmpty);
    action = group->addAction(tr(UTF8_HORIZONTAL_ELLIPSIS "or Selected"));
    action->setProperty("filterType", FilterAction::ActionTypeOr);
    action->setEnabled(!filterEmpty);
}
void Singleton::f4();{
    switch (filter_action) {
    case ActionFind:
    case ActionColorize:
        return simple_action_types_;
    default:
}
void Singleton::f5();{
        return QObject::tr("Find");
        break;
    case ActionColorize:
        return QObject::tr("Colorize");
        break;
}
void Singleton::f6();{
    submenu->addActions(group->actions());
    return submenu;
void FilterAction::groupTriggered(QAction * action)
    if (action && wsApp)
    {
}
void Singleton::f7();{
    case ActionDirectionAToFromB:
        return QObject::tr("A " UTF8_LEFT_RIGHT_ARROW " B");
        break;
    case ActionDirectionAToB:
        return QObject::tr("A " UTF8_RIGHTWARDS_ARROW " B");
}
void Singleton::f8();{
        return QObject::tr("UNKNOWN");
        break;
    }
QActionGroup * FilterAction::createFilterGroup(QString filter, bool prepare, bool enabled, QWidget * parent)
    if (filter.isEmpty())
}
void Singleton::f9();{
    bool prepare = (act == FilterAction::ActionApply) ? false : true;
    QMenu * submenu = new QMenu(title, par);
    if (filter.length() > 0)
    {
        QAction * comment = submenu->addAction(QString("%1: %2").arg(title).arg(filter));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    QStringList invalidKeys = QStringList() << "\"";
    if (input.length() <= 0)
        return QValidator::Intermediate;
    foreach (QString key, invalidKeys)
        if (input.indexOf(key) >= 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    QStringList invalidKeys = QStringList() << "\"";
    if (input.length() <= 0)
        return QValidator::Intermediate;
    foreach (QString key, invalidKeys)
        if (input.indexOf(key) >= 0)
}
void Singleton::f2();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
FilterDialog::FilterDialog(QWidget *parent, FilterType filter_type, QString new_filter_) :
    GeometryStateDialog(parent),
}
void Singleton::f3();{
    QString newFilterText;
    if (filter_type == CaptureFilter) {
        setWindowTitle(wsApp->windowTitleString(tr("Capture Filters")));
        filename = CFILTER_FILE_NAME;
        newFilterText = tr("New capture filter");
}
void Singleton::f4();{
    ui->pathLabel->setAttribute(Qt::WA_MacSmallSize, true);
    ui->filterTreeWidget->setDragEnabled(true);
    ui->filterTreeWidget->viewport()->setAcceptDrops(true);
    ui->filterTreeWidget->setDropIndicatorShown(true);
    ui->filterTreeWidget->setDragDropMode(QAbstractItemView::InternalMove);
}
void Singleton::f5();{
        model_ = new FilterListModel(FilterListModel::Display, this);
    }
    if (new_filter_.length() > 0)
        model_->addFilter(newFilterText, new_filter_);
    ui->filterTreeView->setModel(model_);
}
void Singleton::f6();{
    if (qobject_cast<QLineEdit *>(editor))
        qobject_cast<QLineEdit *>(editor)->setText(index.data().toString());
QValidator::State FilterValidator::validate(QString & input, int & /*pos*/) const
    /* Making this a list to be able to easily add additional values in the future */
    QStringList invalidKeys = QStringList() << "\"";
}
void Singleton::f7();{
    filter_tree_delegate_(new FilterTreeDelegate(this, filter_type))
    ui->setupUi(this);
    if (parent) loadGeometry(parent->width() * 2 / 3, parent->height() * 2 / 3);
    setWindowIcon(wsApp->normalIcon());
    ui->newToolButton->setStockIcon("list-add");
}
void Singleton::f8();{
void FilterDialog::on_copyToolButton_clicked()
    QModelIndexList selected = ui->filterTreeView->selectionModel()->selectedRows();
    if (selected.count() <= 0)
        return;
    int rowNr = selected.at(0).row();
}
void Singleton::f9();{
    return QValidator::Acceptable;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f10();{
QValidator::State FilterValidator::validate(QString & input, int & /*pos*/) const
    /* Making this a list to be able to easily add additional values in the future */
    QStringList invalidKeys = QStringList() << "\"";
    if (input.length() <= 0)
        return QValidator::Intermediate;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    QStringList invalidKeys = QStringList() << "\"";
    if (input.length() <= 0)
        return QValidator::Intermediate;
    foreach (QString key, invalidKeys)
        if (input.indexOf(key) >= 0)
}
void Singleton::f2();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
FilterDialog::FilterDialog(QWidget *parent, FilterType filter_type, QString new_filter_) :
    GeometryStateDialog(parent),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    QStringList invalidKeys = QStringList() << "\"";
    if (input.length() <= 0)
        return QValidator::Intermediate;
    foreach (QString key, invalidKeys)
        if (input.indexOf(key) >= 0)
}
void Singleton::f2();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
FilterDialog::FilterDialog(QWidget *parent, FilterType filter_type, QString new_filter_) :
    GeometryStateDialog(parent),
}
void Singleton::f3();{
    QString newFilterText;
    if (filter_type == CaptureFilter) {
        setWindowTitle(wsApp->windowTitleString(tr("Capture Filters")));
        filename = CFILTER_FILE_NAME;
        newFilterText = tr("New capture filter");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    QStringList invalidKeys = QStringList() << "\"";
    if (input.length() <= 0)
        return QValidator::Intermediate;
    foreach (QString key, invalidKeys)
        if (input.indexOf(key) >= 0)
}
void Singleton::f2();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
FilterDialog::FilterDialog(QWidget *parent, FilterType filter_type, QString new_filter_) :
    GeometryStateDialog(parent),
}
void Singleton::f3();{
    QString newFilterText;
    if (filter_type == CaptureFilter) {
        setWindowTitle(wsApp->windowTitleString(tr("Capture Filters")));
        filename = CFILTER_FILE_NAME;
        newFilterText = tr("New capture filter");
}
void Singleton::f4();{
    ui->pathLabel->setAttribute(Qt::WA_MacSmallSize, true);
    ui->filterTreeWidget->setDragEnabled(true);
    ui->filterTreeWidget->viewport()->setAcceptDrops(true);
    ui->filterTreeWidget->setDropIndicatorShown(true);
    ui->filterTreeWidget->setDragDropMode(QAbstractItemView::InternalMove);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    QStringList invalidKeys = QStringList() << "\"";
    if (input.length() <= 0)
        return QValidator::Intermediate;
    foreach (QString key, invalidKeys)
        if (input.indexOf(key) >= 0)
}
void Singleton::f2();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
FilterDialog::FilterDialog(QWidget *parent, FilterType filter_type, QString new_filter_) :
    GeometryStateDialog(parent),
}
void Singleton::f3();{
    QString newFilterText;
    if (filter_type == CaptureFilter) {
        setWindowTitle(wsApp->windowTitleString(tr("Capture Filters")));
        filename = CFILTER_FILE_NAME;
        newFilterText = tr("New capture filter");
}
void Singleton::f4();{
    ui->pathLabel->setAttribute(Qt::WA_MacSmallSize, true);
    ui->filterTreeWidget->setDragEnabled(true);
    ui->filterTreeWidget->viewport()->setAcceptDrops(true);
    ui->filterTreeWidget->setDropIndicatorShown(true);
    ui->filterTreeWidget->setDragDropMode(QAbstractItemView::InternalMove);
}
void Singleton::f5();{
        model_ = new FilterListModel(FilterListModel::Display, this);
    }
    if (new_filter_.length() > 0)
        model_->addFilter(newFilterText, new_filter_);
    ui->filterTreeView->setModel(model_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    QStringList invalidKeys = QStringList() << "\"";
    if (input.length() <= 0)
        return QValidator::Intermediate;
    foreach (QString key, invalidKeys)
        if (input.indexOf(key) >= 0)
}
void Singleton::f2();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
FilterDialog::FilterDialog(QWidget *parent, FilterType filter_type, QString new_filter_) :
    GeometryStateDialog(parent),
}
void Singleton::f3();{
    QString newFilterText;
    if (filter_type == CaptureFilter) {
        setWindowTitle(wsApp->windowTitleString(tr("Capture Filters")));
        filename = CFILTER_FILE_NAME;
        newFilterText = tr("New capture filter");
}
void Singleton::f4();{
    ui->pathLabel->setAttribute(Qt::WA_MacSmallSize, true);
    ui->filterTreeWidget->setDragEnabled(true);
    ui->filterTreeWidget->viewport()->setAcceptDrops(true);
    ui->filterTreeWidget->setDropIndicatorShown(true);
    ui->filterTreeWidget->setDragDropMode(QAbstractItemView::InternalMove);
}
void Singleton::f5();{
        model_ = new FilterListModel(FilterListModel::Display, this);
    }
    if (new_filter_.length() > 0)
        model_->addFilter(newFilterText, new_filter_);
    ui->filterTreeView->setModel(model_);
}
void Singleton::f6();{
    if (qobject_cast<QLineEdit *>(editor))
        qobject_cast<QLineEdit *>(editor)->setText(index.data().toString());
QValidator::State FilterValidator::validate(QString & input, int & /*pos*/) const
    /* Making this a list to be able to easily add additional values in the future */
    QStringList invalidKeys = QStringList() << "\"";
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    QStringList invalidKeys = QStringList() << "\"";
    if (input.length() <= 0)
        return QValidator::Intermediate;
    foreach (QString key, invalidKeys)
        if (input.indexOf(key) >= 0)
}
void Singleton::f2();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
FilterDialog::FilterDialog(QWidget *parent, FilterType filter_type, QString new_filter_) :
    GeometryStateDialog(parent),
}
void Singleton::f3();{
    QString newFilterText;
    if (filter_type == CaptureFilter) {
        setWindowTitle(wsApp->windowTitleString(tr("Capture Filters")));
        filename = CFILTER_FILE_NAME;
        newFilterText = tr("New capture filter");
}
void Singleton::f4();{
    ui->pathLabel->setAttribute(Qt::WA_MacSmallSize, true);
    ui->filterTreeWidget->setDragEnabled(true);
    ui->filterTreeWidget->viewport()->setAcceptDrops(true);
    ui->filterTreeWidget->setDropIndicatorShown(true);
    ui->filterTreeWidget->setDragDropMode(QAbstractItemView::InternalMove);
}
void Singleton::f5();{
        model_ = new FilterListModel(FilterListModel::Display, this);
    }
    if (new_filter_.length() > 0)
        model_->addFilter(newFilterText, new_filter_);
    ui->filterTreeView->setModel(model_);
}
void Singleton::f6();{
    if (qobject_cast<QLineEdit *>(editor))
        qobject_cast<QLineEdit *>(editor)->setText(index.data().toString());
QValidator::State FilterValidator::validate(QString & input, int & /*pos*/) const
    /* Making this a list to be able to easily add additional values in the future */
    QStringList invalidKeys = QStringList() << "\"";
}
void Singleton::f7();{
    filter_tree_delegate_(new FilterTreeDelegate(this, filter_type))
    ui->setupUi(this);
    if (parent) loadGeometry(parent->width() * 2 / 3, parent->height() * 2 / 3);
    setWindowIcon(wsApp->normalIcon());
    ui->newToolButton->setStockIcon("list-add");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    QStringList invalidKeys = QStringList() << "\"";
    if (input.length() <= 0)
        return QValidator::Intermediate;
    foreach (QString key, invalidKeys)
        if (input.indexOf(key) >= 0)
}
void Singleton::f2();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
FilterDialog::FilterDialog(QWidget *parent, FilterType filter_type, QString new_filter_) :
    GeometryStateDialog(parent),
}
void Singleton::f3();{
    QString newFilterText;
    if (filter_type == CaptureFilter) {
        setWindowTitle(wsApp->windowTitleString(tr("Capture Filters")));
        filename = CFILTER_FILE_NAME;
        newFilterText = tr("New capture filter");
}
void Singleton::f4();{
    ui->pathLabel->setAttribute(Qt::WA_MacSmallSize, true);
    ui->filterTreeWidget->setDragEnabled(true);
    ui->filterTreeWidget->viewport()->setAcceptDrops(true);
    ui->filterTreeWidget->setDropIndicatorShown(true);
    ui->filterTreeWidget->setDragDropMode(QAbstractItemView::InternalMove);
}
void Singleton::f5();{
        model_ = new FilterListModel(FilterListModel::Display, this);
    }
    if (new_filter_.length() > 0)
        model_->addFilter(newFilterText, new_filter_);
    ui->filterTreeView->setModel(model_);
}
void Singleton::f6();{
    if (qobject_cast<QLineEdit *>(editor))
        qobject_cast<QLineEdit *>(editor)->setText(index.data().toString());
QValidator::State FilterValidator::validate(QString & input, int & /*pos*/) const
    /* Making this a list to be able to easily add additional values in the future */
    QStringList invalidKeys = QStringList() << "\"";
}
void Singleton::f7();{
    filter_tree_delegate_(new FilterTreeDelegate(this, filter_type))
    ui->setupUi(this);
    if (parent) loadGeometry(parent->width() * 2 / 3, parent->height() * 2 / 3);
    setWindowIcon(wsApp->normalIcon());
    ui->newToolButton->setStockIcon("list-add");
}
void Singleton::f8();{
void FilterDialog::on_copyToolButton_clicked()
    QModelIndexList selected = ui->filterTreeView->selectionModel()->selectedRows();
    if (selected.count() <= 0)
        return;
    int rowNr = selected.at(0).row();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    QStringList invalidKeys = QStringList() << "\"";
    if (input.length() <= 0)
        return QValidator::Intermediate;
    foreach (QString key, invalidKeys)
        if (input.indexOf(key) >= 0)
}
void Singleton::f2();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
FilterDialog::FilterDialog(QWidget *parent, FilterType filter_type, QString new_filter_) :
    GeometryStateDialog(parent),
}
void Singleton::f3();{
    QString newFilterText;
    if (filter_type == CaptureFilter) {
        setWindowTitle(wsApp->windowTitleString(tr("Capture Filters")));
        filename = CFILTER_FILE_NAME;
        newFilterText = tr("New capture filter");
}
void Singleton::f4();{
    ui->pathLabel->setAttribute(Qt::WA_MacSmallSize, true);
    ui->filterTreeWidget->setDragEnabled(true);
    ui->filterTreeWidget->viewport()->setAcceptDrops(true);
    ui->filterTreeWidget->setDropIndicatorShown(true);
    ui->filterTreeWidget->setDragDropMode(QAbstractItemView::InternalMove);
}
void Singleton::f5();{
        model_ = new FilterListModel(FilterListModel::Display, this);
    }
    if (new_filter_.length() > 0)
        model_->addFilter(newFilterText, new_filter_);
    ui->filterTreeView->setModel(model_);
}
void Singleton::f6();{
    if (qobject_cast<QLineEdit *>(editor))
        qobject_cast<QLineEdit *>(editor)->setText(index.data().toString());
QValidator::State FilterValidator::validate(QString & input, int & /*pos*/) const
    /* Making this a list to be able to easily add additional values in the future */
    QStringList invalidKeys = QStringList() << "\"";
}
void Singleton::f7();{
    filter_tree_delegate_(new FilterTreeDelegate(this, filter_type))
    ui->setupUi(this);
    if (parent) loadGeometry(parent->width() * 2 / 3, parent->height() * 2 / 3);
    setWindowIcon(wsApp->normalIcon());
    ui->newToolButton->setStockIcon("list-add");
}
void Singleton::f8();{
void FilterDialog::on_copyToolButton_clicked()
    QModelIndexList selected = ui->filterTreeView->selectionModel()->selectedRows();
    if (selected.count() <= 0)
        return;
    int rowNr = selected.at(0).row();
}
void Singleton::f9();{
    return QValidator::Acceptable;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
        return;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
        return;
    }
}
void Singleton::f2();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(ok_enable);
void FilterExpressionFrame::on_filterExpressionPreferencesPushButton_clicked()
    on_buttonBox_rejected();
    emit showPreferencesDialog(PrefsModel::typeToString(PrefsModel::FilterButtons));
void FilterExpressionFrame::on_labelLineEdit_textChanged(const QString)
}
void Singleton::f3();{
FilterExpressionFrame::~FilterExpressionFrame()
    delete ui;
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
}
void Singleton::f4();{
// To do:
// - Add the ability to edit current expressions.
FilterExpressionFrame::FilterExpressionFrame(QWidget *parent) :
    AccordionFrame(parent),
    ui(new Ui::FilterExpressionFrame)
}
void Singleton::f5();{
    ui->labelLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 1), Qt::DisplayRole).toString());
    ui->displayFilterLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 2), Qt::DisplayRole).toString());
    ui->commentLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 3), Qt::DisplayRole).toString());
    delete(uatModel);
    if (! isVisible())
}
void Singleton::f6();{
    ui->labelLineEdit->setFocus();
    ui->labelLineEdit->selectAll();
    AccordionFrame::showEvent(event);
void FilterExpressionFrame::updateWidgets()
    bool ok_enable = true;
}
void Singleton::f7();{
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing label."));
            } else if (ui->displayFilterLineEdit->syntaxState() == SyntaxLineEdit::Empty) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing filter expression."));
            } else if (ui->displayFilterLineEdit->syntaxState() != SyntaxLineEdit::Valid) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Invalid filter expression."));
}
void Singleton::f8();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f9();{
// To do:
// - Add the ability to edit current expressions.
FilterExpressionFrame::FilterExpressionFrame(QWidget *parent) :
    AccordionFrame(parent),
    ui(new Ui::FilterExpressionFrame)
}
void Singleton::f10();{
void FilterExpressionFrame::showEvent(QShowEvent *event)
    ui->labelLineEdit->setFocus();
    ui->labelLineEdit->selectAll();
    AccordionFrame::showEvent(event);
void FilterExpressionFrame::updateWidgets()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
        return;
    }
}
void Singleton::f2();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(ok_enable);
void FilterExpressionFrame::on_filterExpressionPreferencesPushButton_clicked()
    on_buttonBox_rejected();
    emit showPreferencesDialog(PrefsModel::typeToString(PrefsModel::FilterButtons));
void FilterExpressionFrame::on_labelLineEdit_textChanged(const QString)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
        return;
    }
}
void Singleton::f2();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(ok_enable);
void FilterExpressionFrame::on_filterExpressionPreferencesPushButton_clicked()
    on_buttonBox_rejected();
    emit showPreferencesDialog(PrefsModel::typeToString(PrefsModel::FilterButtons));
void FilterExpressionFrame::on_labelLineEdit_textChanged(const QString)
}
void Singleton::f3();{
FilterExpressionFrame::~FilterExpressionFrame()
    delete ui;
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
        return;
    }
}
void Singleton::f2();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(ok_enable);
void FilterExpressionFrame::on_filterExpressionPreferencesPushButton_clicked()
    on_buttonBox_rejected();
    emit showPreferencesDialog(PrefsModel::typeToString(PrefsModel::FilterButtons));
void FilterExpressionFrame::on_labelLineEdit_textChanged(const QString)
}
void Singleton::f3();{
FilterExpressionFrame::~FilterExpressionFrame()
    delete ui;
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
}
void Singleton::f4();{
// To do:
// - Add the ability to edit current expressions.
FilterExpressionFrame::FilterExpressionFrame(QWidget *parent) :
    AccordionFrame(parent),
    ui(new Ui::FilterExpressionFrame)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
        return;
    }
}
void Singleton::f2();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(ok_enable);
void FilterExpressionFrame::on_filterExpressionPreferencesPushButton_clicked()
    on_buttonBox_rejected();
    emit showPreferencesDialog(PrefsModel::typeToString(PrefsModel::FilterButtons));
void FilterExpressionFrame::on_labelLineEdit_textChanged(const QString)
}
void Singleton::f3();{
FilterExpressionFrame::~FilterExpressionFrame()
    delete ui;
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
}
void Singleton::f4();{
// To do:
// - Add the ability to edit current expressions.
FilterExpressionFrame::FilterExpressionFrame(QWidget *parent) :
    AccordionFrame(parent),
    ui(new Ui::FilterExpressionFrame)
}
void Singleton::f5();{
    ui->labelLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 1), Qt::DisplayRole).toString());
    ui->displayFilterLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 2), Qt::DisplayRole).toString());
    ui->commentLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 3), Qt::DisplayRole).toString());
    delete(uatModel);
    if (! isVisible())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
        return;
    }
}
void Singleton::f2();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(ok_enable);
void FilterExpressionFrame::on_filterExpressionPreferencesPushButton_clicked()
    on_buttonBox_rejected();
    emit showPreferencesDialog(PrefsModel::typeToString(PrefsModel::FilterButtons));
void FilterExpressionFrame::on_labelLineEdit_textChanged(const QString)
}
void Singleton::f3();{
FilterExpressionFrame::~FilterExpressionFrame()
    delete ui;
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
}
void Singleton::f4();{
// To do:
// - Add the ability to edit current expressions.
FilterExpressionFrame::FilterExpressionFrame(QWidget *parent) :
    AccordionFrame(parent),
    ui(new Ui::FilterExpressionFrame)
}
void Singleton::f5();{
    ui->labelLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 1), Qt::DisplayRole).toString());
    ui->displayFilterLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 2), Qt::DisplayRole).toString());
    ui->commentLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 3), Qt::DisplayRole).toString());
    delete(uatModel);
    if (! isVisible())
}
void Singleton::f6();{
    ui->labelLineEdit->setFocus();
    ui->labelLineEdit->selectAll();
    AccordionFrame::showEvent(event);
void FilterExpressionFrame::updateWidgets()
    bool ok_enable = true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
        return;
    }
}
void Singleton::f2();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(ok_enable);
void FilterExpressionFrame::on_filterExpressionPreferencesPushButton_clicked()
    on_buttonBox_rejected();
    emit showPreferencesDialog(PrefsModel::typeToString(PrefsModel::FilterButtons));
void FilterExpressionFrame::on_labelLineEdit_textChanged(const QString)
}
void Singleton::f3();{
FilterExpressionFrame::~FilterExpressionFrame()
    delete ui;
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
}
void Singleton::f4();{
// To do:
// - Add the ability to edit current expressions.
FilterExpressionFrame::FilterExpressionFrame(QWidget *parent) :
    AccordionFrame(parent),
    ui(new Ui::FilterExpressionFrame)
}
void Singleton::f5();{
    ui->labelLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 1), Qt::DisplayRole).toString());
    ui->displayFilterLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 2), Qt::DisplayRole).toString());
    ui->commentLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 3), Qt::DisplayRole).toString());
    delete(uatModel);
    if (! isVisible())
}
void Singleton::f6();{
    ui->labelLineEdit->setFocus();
    ui->labelLineEdit->selectAll();
    AccordionFrame::showEvent(event);
void FilterExpressionFrame::updateWidgets()
    bool ok_enable = true;
}
void Singleton::f7();{
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing label."));
            } else if (ui->displayFilterLineEdit->syntaxState() == SyntaxLineEdit::Empty) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing filter expression."));
            } else if (ui->displayFilterLineEdit->syntaxState() != SyntaxLineEdit::Valid) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Invalid filter expression."));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
        return;
    }
}
void Singleton::f2();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(ok_enable);
void FilterExpressionFrame::on_filterExpressionPreferencesPushButton_clicked()
    on_buttonBox_rejected();
    emit showPreferencesDialog(PrefsModel::typeToString(PrefsModel::FilterButtons));
void FilterExpressionFrame::on_labelLineEdit_textChanged(const QString)
}
void Singleton::f3();{
FilterExpressionFrame::~FilterExpressionFrame()
    delete ui;
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
}
void Singleton::f4();{
// To do:
// - Add the ability to edit current expressions.
FilterExpressionFrame::FilterExpressionFrame(QWidget *parent) :
    AccordionFrame(parent),
    ui(new Ui::FilterExpressionFrame)
}
void Singleton::f5();{
    ui->labelLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 1), Qt::DisplayRole).toString());
    ui->displayFilterLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 2), Qt::DisplayRole).toString());
    ui->commentLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 3), Qt::DisplayRole).toString());
    delete(uatModel);
    if (! isVisible())
}
void Singleton::f6();{
    ui->labelLineEdit->setFocus();
    ui->labelLineEdit->selectAll();
    AccordionFrame::showEvent(event);
void FilterExpressionFrame::updateWidgets()
    bool ok_enable = true;
}
void Singleton::f7();{
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing label."));
            } else if (ui->displayFilterLineEdit->syntaxState() == SyntaxLineEdit::Empty) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing filter expression."));
            } else if (ui->displayFilterLineEdit->syntaxState() != SyntaxLineEdit::Valid) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Invalid filter expression."));
}
void Singleton::f8();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
        return;
    }
}
void Singleton::f2();{
    ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(ok_enable);
void FilterExpressionFrame::on_filterExpressionPreferencesPushButton_clicked()
    on_buttonBox_rejected();
    emit showPreferencesDialog(PrefsModel::typeToString(PrefsModel::FilterButtons));
void FilterExpressionFrame::on_labelLineEdit_textChanged(const QString)
}
void Singleton::f3();{
FilterExpressionFrame::~FilterExpressionFrame()
    delete ui;
void FilterExpressionFrame::addExpression(const QString filter_text)
    if (isVisible()) {
        on_buttonBox_rejected();
}
void Singleton::f4();{
// To do:
// - Add the ability to edit current expressions.
FilterExpressionFrame::FilterExpressionFrame(QWidget *parent) :
    AccordionFrame(parent),
    ui(new Ui::FilterExpressionFrame)
}
void Singleton::f5();{
    ui->labelLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 1), Qt::DisplayRole).toString());
    ui->displayFilterLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 2), Qt::DisplayRole).toString());
    ui->commentLineEdit->setText(uatModel->data(uatModel->index(exprIdx, 3), Qt::DisplayRole).toString());
    delete(uatModel);
    if (! isVisible())
}
void Singleton::f6();{
    ui->labelLineEdit->setFocus();
    ui->labelLineEdit->selectAll();
    AccordionFrame::showEvent(event);
void FilterExpressionFrame::updateWidgets()
    bool ok_enable = true;
}
void Singleton::f7();{
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing label."));
            } else if (ui->displayFilterLineEdit->syntaxState() == SyntaxLineEdit::Empty) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Missing filter expression."));
            } else if (ui->displayFilterLineEdit->syntaxState() != SyntaxLineEdit::Valid) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Invalid filter expression."));
}
void Singleton::f8();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f9();{
// To do:
// - Add the ability to edit current expressions.
FilterExpressionFrame::FilterExpressionFrame(QWidget *parent) :
    AccordionFrame(parent),
    ui(new Ui::FilterExpressionFrame)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        menuButton->setPopupMode(QToolButton::InstantPopup);
        QMenu * parentMenu = new QMenu(menuButton);
        parentMenu->installEventFilter(data->toolbar);
        parentMenu->setProperty(dfe_menu_, QVariant::fromValue(true));
        menuButton->setMenu(parentMenu);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        menuButton->setPopupMode(QToolButton::InstantPopup);
        QMenu * parentMenu = new QMenu(menuButton);
        parentMenu->installEventFilter(data->toolbar);
        parentMenu->setProperty(dfe_menu_, QVariant::fromValue(true));
        menuButton->setMenu(parentMenu);
}
void Singleton::f2();{
    struct filter_expression_data* data = (filter_expression_data*)user_data;
    if (!fe->enabled)
        return FALSE;
    QString label = QString(fe->label);
    /* Search for parent menu and create if not found */
}
void Singleton::f3();{
    // work correctly in some cases. See bug 14121 for details.
    clear();
    setUpdatesEnabled(false);
    hide();
    // XXX Add a context menu for removing and changing buttons.
}
void Singleton::f4();{
        break;
    }
    return DragDropToolBar::event(event);
void FilterExpressionToolBar::onCustomMenuHandler(const QPoint& pos)
    QAction * filterAction = actionAt(pos);
}
void Singleton::f5();{
                    return findParentMenu(tree.mid(1), fed_data, entry->menu());
            }
            /* Submenu not found, creating */
            QMenu * subMenu = new QMenu(menuName);
            subMenu->installEventFilter(data->toolbar);
}
void Singleton::f6();{
        actEdit->setProperty(dfe_property_label_, filterAction->property(dfe_property_label_));
        actEdit->setProperty(dfe_property_expression_, filterAction->property(dfe_property_expression_));
        actEdit->setData(filterAction->data());
        QAction * actDisable = filterMenu->addAction(tr("Disable"));
        connect(actDisable, &QAction::triggered, target, &FilterExpressionToolBar::disableFilter);
}
void Singleton::f7();{
    else
    {
        rowIndex = uatModel->findRowForColumnContent(((QAction *)sender())->data(), 2);
    }
    if (rowIndex.isValid())
}
void Singleton::f8();{
    if (!filterText.isEmpty())
    {
        filterMenu->addMenu(FilterAction::createFilterMenu(FilterAction::ActionApply, filterText, true, target));
        filterMenu->addMenu(FilterAction::createFilterMenu(FilterAction::ActionPrepare, filterText, true, target));
        filterMenu->addSeparator();
}
void Singleton::f9();{
        return FALSE;
    QString label = QString(fe->label);
    /* Search for parent menu and create if not found */
    QStringList tree = label.split(PARENT_SEPARATOR);
    if (!tree.isEmpty())
}
void Singleton::f10();{
    QString expr = ((QAction *)sender())->property(dfe_property_expression_).toString();
    int idx = uatRowIndexForFilter(label, expr);
    QModelIndex rowIndex = uatModel->index(idx, 0);
    if (rowIndex.isValid()) {
        uatModel->removeRow(rowIndex.row());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        menuButton->setPopupMode(QToolButton::InstantPopup);
        QMenu * parentMenu = new QMenu(menuButton);
        parentMenu->installEventFilter(data->toolbar);
        parentMenu->setProperty(dfe_menu_, QVariant::fromValue(true));
        menuButton->setMenu(parentMenu);
}
void Singleton::f2();{
    struct filter_expression_data* data = (filter_expression_data*)user_data;
    if (!fe->enabled)
        return FALSE;
    QString label = QString(fe->label);
    /* Search for parent menu and create if not found */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        menuButton->setPopupMode(QToolButton::InstantPopup);
        QMenu * parentMenu = new QMenu(menuButton);
        parentMenu->installEventFilter(data->toolbar);
        parentMenu->setProperty(dfe_menu_, QVariant::fromValue(true));
        menuButton->setMenu(parentMenu);
}
void Singleton::f2();{
    struct filter_expression_data* data = (filter_expression_data*)user_data;
    if (!fe->enabled)
        return FALSE;
    QString label = QString(fe->label);
    /* Search for parent menu and create if not found */
}
void Singleton::f3();{
    // work correctly in some cases. See bug 14121 for details.
    clear();
    setUpdatesEnabled(false);
    hide();
    // XXX Add a context menu for removing and changing buttons.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        menuButton->setPopupMode(QToolButton::InstantPopup);
        QMenu * parentMenu = new QMenu(menuButton);
        parentMenu->installEventFilter(data->toolbar);
        parentMenu->setProperty(dfe_menu_, QVariant::fromValue(true));
        menuButton->setMenu(parentMenu);
}
void Singleton::f2();{
    struct filter_expression_data* data = (filter_expression_data*)user_data;
    if (!fe->enabled)
        return FALSE;
    QString label = QString(fe->label);
    /* Search for parent menu and create if not found */
}
void Singleton::f3();{
    // work correctly in some cases. See bug 14121 for details.
    clear();
    setUpdatesEnabled(false);
    hide();
    // XXX Add a context menu for removing and changing buttons.
}
void Singleton::f4();{
        break;
    }
    return DragDropToolBar::event(event);
void FilterExpressionToolBar::onCustomMenuHandler(const QPoint& pos)
    QAction * filterAction = actionAt(pos);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        menuButton->setPopupMode(QToolButton::InstantPopup);
        QMenu * parentMenu = new QMenu(menuButton);
        parentMenu->installEventFilter(data->toolbar);
        parentMenu->setProperty(dfe_menu_, QVariant::fromValue(true));
        menuButton->setMenu(parentMenu);
}
void Singleton::f2();{
    struct filter_expression_data* data = (filter_expression_data*)user_data;
    if (!fe->enabled)
        return FALSE;
    QString label = QString(fe->label);
    /* Search for parent menu and create if not found */
}
void Singleton::f3();{
    // work correctly in some cases. See bug 14121 for details.
    clear();
    setUpdatesEnabled(false);
    hide();
    // XXX Add a context menu for removing and changing buttons.
}
void Singleton::f4();{
        break;
    }
    return DragDropToolBar::event(event);
void FilterExpressionToolBar::onCustomMenuHandler(const QPoint& pos)
    QAction * filterAction = actionAt(pos);
}
void Singleton::f5();{
                    return findParentMenu(tree.mid(1), fed_data, entry->menu());
            }
            /* Submenu not found, creating */
            QMenu * subMenu = new QMenu(menuName);
            subMenu->installEventFilter(data->toolbar);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        menuButton->setPopupMode(QToolButton::InstantPopup);
        QMenu * parentMenu = new QMenu(menuButton);
        parentMenu->installEventFilter(data->toolbar);
        parentMenu->setProperty(dfe_menu_, QVariant::fromValue(true));
        menuButton->setMenu(parentMenu);
}
void Singleton::f2();{
    struct filter_expression_data* data = (filter_expression_data*)user_data;
    if (!fe->enabled)
        return FALSE;
    QString label = QString(fe->label);
    /* Search for parent menu and create if not found */
}
void Singleton::f3();{
    // work correctly in some cases. See bug 14121 for details.
    clear();
    setUpdatesEnabled(false);
    hide();
    // XXX Add a context menu for removing and changing buttons.
}
void Singleton::f4();{
        break;
    }
    return DragDropToolBar::event(event);
void FilterExpressionToolBar::onCustomMenuHandler(const QPoint& pos)
    QAction * filterAction = actionAt(pos);
}
void Singleton::f5();{
                    return findParentMenu(tree.mid(1), fed_data, entry->menu());
            }
            /* Submenu not found, creating */
            QMenu * subMenu = new QMenu(menuName);
            subMenu->installEventFilter(data->toolbar);
}
void Singleton::f6();{
        actEdit->setProperty(dfe_property_label_, filterAction->property(dfe_property_label_));
        actEdit->setProperty(dfe_property_expression_, filterAction->property(dfe_property_expression_));
        actEdit->setData(filterAction->data());
        QAction * actDisable = filterMenu->addAction(tr("Disable"));
        connect(actDisable, &QAction::triggered, target, &FilterExpressionToolBar::disableFilter);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        menuButton->setPopupMode(QToolButton::InstantPopup);
        QMenu * parentMenu = new QMenu(menuButton);
        parentMenu->installEventFilter(data->toolbar);
        parentMenu->setProperty(dfe_menu_, QVariant::fromValue(true));
        menuButton->setMenu(parentMenu);
}
void Singleton::f2();{
    struct filter_expression_data* data = (filter_expression_data*)user_data;
    if (!fe->enabled)
        return FALSE;
    QString label = QString(fe->label);
    /* Search for parent menu and create if not found */
}
void Singleton::f3();{
    // work correctly in some cases. See bug 14121 for details.
    clear();
    setUpdatesEnabled(false);
    hide();
    // XXX Add a context menu for removing and changing buttons.
}
void Singleton::f4();{
        break;
    }
    return DragDropToolBar::event(event);
void FilterExpressionToolBar::onCustomMenuHandler(const QPoint& pos)
    QAction * filterAction = actionAt(pos);
}
void Singleton::f5();{
                    return findParentMenu(tree.mid(1), fed_data, entry->menu());
            }
            /* Submenu not found, creating */
            QMenu * subMenu = new QMenu(menuName);
            subMenu->installEventFilter(data->toolbar);
}
void Singleton::f6();{
        actEdit->setProperty(dfe_property_label_, filterAction->property(dfe_property_label_));
        actEdit->setProperty(dfe_property_expression_, filterAction->property(dfe_property_expression_));
        actEdit->setData(filterAction->data());
        QAction * actDisable = filterMenu->addAction(tr("Disable"));
        connect(actDisable, &QAction::triggered, target, &FilterExpressionToolBar::disableFilter);
}
void Singleton::f7();{
    else
    {
        rowIndex = uatModel->findRowForColumnContent(((QAction *)sender())->data(), 2);
    }
    if (rowIndex.isValid())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        menuButton->setPopupMode(QToolButton::InstantPopup);
        QMenu * parentMenu = new QMenu(menuButton);
        parentMenu->installEventFilter(data->toolbar);
        parentMenu->setProperty(dfe_menu_, QVariant::fromValue(true));
        menuButton->setMenu(parentMenu);
}
void Singleton::f2();{
    struct filter_expression_data* data = (filter_expression_data*)user_data;
    if (!fe->enabled)
        return FALSE;
    QString label = QString(fe->label);
    /* Search for parent menu and create if not found */
}
void Singleton::f3();{
    // work correctly in some cases. See bug 14121 for details.
    clear();
    setUpdatesEnabled(false);
    hide();
    // XXX Add a context menu for removing and changing buttons.
}
void Singleton::f4();{
        break;
    }
    return DragDropToolBar::event(event);
void FilterExpressionToolBar::onCustomMenuHandler(const QPoint& pos)
    QAction * filterAction = actionAt(pos);
}
void Singleton::f5();{
                    return findParentMenu(tree.mid(1), fed_data, entry->menu());
            }
            /* Submenu not found, creating */
            QMenu * subMenu = new QMenu(menuName);
            subMenu->installEventFilter(data->toolbar);
}
void Singleton::f6();{
        actEdit->setProperty(dfe_property_label_, filterAction->property(dfe_property_label_));
        actEdit->setProperty(dfe_property_expression_, filterAction->property(dfe_property_expression_));
        actEdit->setData(filterAction->data());
        QAction * actDisable = filterMenu->addAction(tr("Disable"));
        connect(actDisable, &QAction::triggered, target, &FilterExpressionToolBar::disableFilter);
}
void Singleton::f7();{
    else
    {
        rowIndex = uatModel->findRowForColumnContent(((QAction *)sender())->data(), 2);
    }
    if (rowIndex.isValid())
}
void Singleton::f8();{
    if (!filterText.isEmpty())
    {
        filterMenu->addMenu(FilterAction::createFilterMenu(FilterAction::ActionApply, filterText, true, target));
        filterMenu->addMenu(FilterAction::createFilterMenu(FilterAction::ActionPrepare, filterText, true, target));
        filterMenu->addSeparator();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        menuButton->setPopupMode(QToolButton::InstantPopup);
        QMenu * parentMenu = new QMenu(menuButton);
        parentMenu->installEventFilter(data->toolbar);
        parentMenu->setProperty(dfe_menu_, QVariant::fromValue(true));
        menuButton->setMenu(parentMenu);
}
void Singleton::f2();{
    struct filter_expression_data* data = (filter_expression_data*)user_data;
    if (!fe->enabled)
        return FALSE;
    QString label = QString(fe->label);
    /* Search for parent menu and create if not found */
}
void Singleton::f3();{
    // work correctly in some cases. See bug 14121 for details.
    clear();
    setUpdatesEnabled(false);
    hide();
    // XXX Add a context menu for removing and changing buttons.
}
void Singleton::f4();{
        break;
    }
    return DragDropToolBar::event(event);
void FilterExpressionToolBar::onCustomMenuHandler(const QPoint& pos)
    QAction * filterAction = actionAt(pos);
}
void Singleton::f5();{
                    return findParentMenu(tree.mid(1), fed_data, entry->menu());
            }
            /* Submenu not found, creating */
            QMenu * subMenu = new QMenu(menuName);
            subMenu->installEventFilter(data->toolbar);
}
void Singleton::f6();{
        actEdit->setProperty(dfe_property_label_, filterAction->property(dfe_property_label_));
        actEdit->setProperty(dfe_property_expression_, filterAction->property(dfe_property_expression_));
        actEdit->setData(filterAction->data());
        QAction * actDisable = filterMenu->addAction(tr("Disable"));
        connect(actDisable, &QAction::triggered, target, &FilterExpressionToolBar::disableFilter);
}
void Singleton::f7();{
    else
    {
        rowIndex = uatModel->findRowForColumnContent(((QAction *)sender())->data(), 2);
    }
    if (rowIndex.isValid())
}
void Singleton::f8();{
    if (!filterText.isEmpty())
    {
        filterMenu->addMenu(FilterAction::createFilterMenu(FilterAction::ActionApply, filterText, true, target));
        filterMenu->addMenu(FilterAction::createFilterMenu(FilterAction::ActionPrepare, filterText, true, target));
        filterMenu->addSeparator();
}
void Singleton::f9();{
        return FALSE;
    QString label = QString(fe->label);
    /* Search for parent menu and create if not found */
    QStringList tree = label.split(PARENT_SEPARATOR);
    if (!tree.isEmpty())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
}
void Singleton::f2();{
    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
            continue;
        QRegularExpressionMatch match = rx.match(line);
}
void Singleton::f3();{
QModelIndex FilterListModel::findByName(QString name)
    if (name.length() == 0)
        return QModelIndex();
    for (int cnt = 0; cnt < rowCount(); cnt++)
    {
}
void Singleton::f4();{
    return QModelIndex();
void FilterListModel::removeFilter(QModelIndex idx)
    if (! idx.isValid() || idx.row() >= rowCount())
        return;
    beginRemoveRows(QModelIndex(), idx.row(), idx.row());
}
void Singleton::f5();{
        return QModelIndex();
    beginInsertRows(QModelIndex(), rowCount(), rowCount());
    storage << QString("%1\n%2").arg(name).arg(expression);
    endInsertRows();
    return index(rowCount() - 1, 0);
}
void Singleton::f6();{
            storage.move(strow, storeTo);
            endResetModel();
        }
    }
    return true;
}
void Singleton::f7();{
 * c-basic-offset: 2
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * vi: set shiftwidth=2 tabstop=8 expandtab:
}
void Singleton::f8();{
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
    return QStringList() << WiresharkMimeData::FilterListMimeType;
}
void Singleton::f9();{
    return QModelIndex();
QModelIndex FilterListModel::findByExpression(QString expression)
    if (expression.length() == 0)
        return QModelIndex();
    for (int cnt = 0; cnt < rowCount(); cnt++)
}
void Singleton::f10();{
    }
    mimeData->setData(WiresharkMimeData::FilterListMimeType, rows.join(",").toUtf8());
    return mimeData;
bool FilterListModel::dropMimeData(const QMimeData *data, Qt::DropAction action, int row, int /* column */, const QModelIndex & parent)
    if (action != Qt::MoveAction)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
}
void Singleton::f2();{
    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
            continue;
        QRegularExpressionMatch match = rx.match(line);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
}
void Singleton::f2();{
    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
            continue;
        QRegularExpressionMatch match = rx.match(line);
}
void Singleton::f3();{
QModelIndex FilterListModel::findByName(QString name)
    if (name.length() == 0)
        return QModelIndex();
    for (int cnt = 0; cnt < rowCount(); cnt++)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
}
void Singleton::f2();{
    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
            continue;
        QRegularExpressionMatch match = rx.match(line);
}
void Singleton::f3();{
QModelIndex FilterListModel::findByName(QString name)
    if (name.length() == 0)
        return QModelIndex();
    for (int cnt = 0; cnt < rowCount(); cnt++)
    {
}
void Singleton::f4();{
    return QModelIndex();
void FilterListModel::removeFilter(QModelIndex idx)
    if (! idx.isValid() || idx.row() >= rowCount())
        return;
    beginRemoveRows(QModelIndex(), idx.row(), idx.row());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
}
void Singleton::f2();{
    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
            continue;
        QRegularExpressionMatch match = rx.match(line);
}
void Singleton::f3();{
QModelIndex FilterListModel::findByName(QString name)
    if (name.length() == 0)
        return QModelIndex();
    for (int cnt = 0; cnt < rowCount(); cnt++)
    {
}
void Singleton::f4();{
    return QModelIndex();
void FilterListModel::removeFilter(QModelIndex idx)
    if (! idx.isValid() || idx.row() >= rowCount())
        return;
    beginRemoveRows(QModelIndex(), idx.row(), idx.row());
}
void Singleton::f5();{
        return QModelIndex();
    beginInsertRows(QModelIndex(), rowCount(), rowCount());
    storage << QString("%1\n%2").arg(name).arg(expression);
    endInsertRows();
    return index(rowCount() - 1, 0);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
}
void Singleton::f2();{
    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
            continue;
        QRegularExpressionMatch match = rx.match(line);
}
void Singleton::f3();{
QModelIndex FilterListModel::findByName(QString name)
    if (name.length() == 0)
        return QModelIndex();
    for (int cnt = 0; cnt < rowCount(); cnt++)
    {
}
void Singleton::f4();{
    return QModelIndex();
void FilterListModel::removeFilter(QModelIndex idx)
    if (! idx.isValid() || idx.row() >= rowCount())
        return;
    beginRemoveRows(QModelIndex(), idx.row(), idx.row());
}
void Singleton::f5();{
        return QModelIndex();
    beginInsertRows(QModelIndex(), rowCount(), rowCount());
    storage << QString("%1\n%2").arg(name).arg(expression);
    endInsertRows();
    return index(rowCount() - 1, 0);
}
void Singleton::f6();{
            storage.move(strow, storeTo);
            endResetModel();
        }
    }
    return true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
}
void Singleton::f2();{
    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
            continue;
        QRegularExpressionMatch match = rx.match(line);
}
void Singleton::f3();{
QModelIndex FilterListModel::findByName(QString name)
    if (name.length() == 0)
        return QModelIndex();
    for (int cnt = 0; cnt < rowCount(); cnt++)
    {
}
void Singleton::f4();{
    return QModelIndex();
void FilterListModel::removeFilter(QModelIndex idx)
    if (! idx.isValid() || idx.row() >= rowCount())
        return;
    beginRemoveRows(QModelIndex(), idx.row(), idx.row());
}
void Singleton::f5();{
        return QModelIndex();
    beginInsertRows(QModelIndex(), rowCount(), rowCount());
    storage << QString("%1\n%2").arg(name).arg(expression);
    endInsertRows();
    return index(rowCount() - 1, 0);
}
void Singleton::f6();{
            storage.move(strow, storeTo);
            endResetModel();
        }
    }
    return true;
}
void Singleton::f7();{
 * c-basic-offset: 2
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * vi: set shiftwidth=2 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
}
void Singleton::f2();{
    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
            continue;
        QRegularExpressionMatch match = rx.match(line);
}
void Singleton::f3();{
QModelIndex FilterListModel::findByName(QString name)
    if (name.length() == 0)
        return QModelIndex();
    for (int cnt = 0; cnt < rowCount(); cnt++)
    {
}
void Singleton::f4();{
    return QModelIndex();
void FilterListModel::removeFilter(QModelIndex idx)
    if (! idx.isValid() || idx.row() >= rowCount())
        return;
    beginRemoveRows(QModelIndex(), idx.row(), idx.row());
}
void Singleton::f5();{
        return QModelIndex();
    beginInsertRows(QModelIndex(), rowCount(), rowCount());
    storage << QString("%1\n%2").arg(name).arg(expression);
    endInsertRows();
    return index(rowCount() - 1, 0);
}
void Singleton::f6();{
            storage.move(strow, storeTo);
            endResetModel();
        }
    }
    return true;
}
void Singleton::f7();{
 * c-basic-offset: 2
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * vi: set shiftwidth=2 tabstop=8 expandtab:
}
void Singleton::f8();{
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
    return QStringList() << WiresharkMimeData::FilterListMimeType;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
}
void Singleton::f2();{
    while (!in.atEnd())
    {
        QString line = in.readLine().trimmed();
            continue;
        QRegularExpressionMatch match = rx.match(line);
}
void Singleton::f3();{
QModelIndex FilterListModel::findByName(QString name)
    if (name.length() == 0)
        return QModelIndex();
    for (int cnt = 0; cnt < rowCount(); cnt++)
    {
}
void Singleton::f4();{
    return QModelIndex();
void FilterListModel::removeFilter(QModelIndex idx)
    if (! idx.isValid() || idx.row() >= rowCount())
        return;
    beginRemoveRows(QModelIndex(), idx.row(), idx.row());
}
void Singleton::f5();{
        return QModelIndex();
    beginInsertRows(QModelIndex(), rowCount(), rowCount());
    storage << QString("%1\n%2").arg(name).arg(expression);
    endInsertRows();
    return index(rowCount() - 1, 0);
}
void Singleton::f6();{
            storage.move(strow, storeTo);
            endResetModel();
        }
    }
    return true;
}
void Singleton::f7();{
 * c-basic-offset: 2
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * vi: set shiftwidth=2 tabstop=8 expandtab:
}
void Singleton::f8();{
    file.close();
Qt::DropActions FilterListModel::supportedDropActions() const
    return Qt::MoveAction;
QStringList FilterListModel::mimeTypes() const
    return QStringList() << WiresharkMimeData::FilterListMimeType;
}
void Singleton::f9();{
    return QModelIndex();
QModelIndex FilterListModel::findByExpression(QString expression)
    if (expression.length() == 0)
        return QModelIndex();
    for (int cnt = 0; cnt < rowCount(); cnt++)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    syntax_func mac_func = firewall_product_mac_func(prod_);
    if (v4_func && net_src_.type == AT_IPv4) {
        addRule(tr("IPv4 source address."), v4_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address."), v4_func, &net_dst_, dst_port_);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    syntax_func mac_func = firewall_product_mac_func(prod_);
    if (v4_func && net_src_.type == AT_IPv4) {
        addRule(tr("IPv4 source address."), v4_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address."), v4_func, &net_dst_, dst_port_);
    }
}
void Singleton::f2();{
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address and port."), v4_port_func, &net_dst_, dst_port_);
    }
    if (mac_func && dl_src_.type == AT_ETHER) {
}
void Singleton::f3();{
    int nf_item = 0;
    for (size_t prod = 0; prod < firewall_product_count(); prod++) {
        QString prod_name = firewall_product_name(prod);
        // Default to Netfilter since it's likely the most popular.
        if (prod_name.contains("Netfilter")) nf_item = ui->productComboBox->count();
}
void Singleton::f4();{
void FirewallRulesDialog::on_inboundCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_denyCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_buttonBox_clicked(QAbstractButton *button)
}
void Singleton::f5();{
            QFile save_file(file_name);
            QByteArray rule_text = ui->textBrowser->toPlainText().toUtf8();
            save_file.open(QIODevice::WriteOnly);
            save_file.write(rule_text);
            save_file.close();
}
void Singleton::f6();{
    QString comment_pfx = firewall_product_comment_prefix(prod_);
    QString rule_hint = firewall_product_rule_hint(prod_);
    QString rule_line;
    rule_line = QString("%1 %2 rules for %3, packet %4.")
            .arg(comment_pfx)
}
void Singleton::f7();{
        addRule(tr("Destination port."), port_func, &net_dst_, dst_port_);
    }
    if (v4_port_func && net_src_.type == AT_IPv4 &&
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
}
void Singleton::f8();{
    QString rule_line;
    rule_line = QString("%1 %2 rules for %3, packet %4.")
            .arg(comment_pfx)
            .arg(firewall_product_name(prod_))
            .arg(file_name_)
}
void Singleton::f9();{
            .arg(file_name_)
            .arg(packet_num_);
    if (!rule_hint.isEmpty()) rule_line += " " + rule_hint;
    ui->textBrowser->clear();
    ui->textBrowser->append(rule_line);
}
void Singleton::f10();{
            QByteArray rule_text = ui->textBrowser->toPlainText().toUtf8();
            save_file.open(QIODevice::WriteOnly);
            save_file.write(rule_text);
            save_file.close();
            if (save_file.error() != QFile::NoError) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    syntax_func mac_func = firewall_product_mac_func(prod_);
    if (v4_func && net_src_.type == AT_IPv4) {
        addRule(tr("IPv4 source address."), v4_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address."), v4_func, &net_dst_, dst_port_);
    }
}
void Singleton::f2();{
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address and port."), v4_port_func, &net_dst_, dst_port_);
    }
    if (mac_func && dl_src_.type == AT_ETHER) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    syntax_func mac_func = firewall_product_mac_func(prod_);
    if (v4_func && net_src_.type == AT_IPv4) {
        addRule(tr("IPv4 source address."), v4_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address."), v4_func, &net_dst_, dst_port_);
    }
}
void Singleton::f2();{
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address and port."), v4_port_func, &net_dst_, dst_port_);
    }
    if (mac_func && dl_src_.type == AT_ETHER) {
}
void Singleton::f3();{
    int nf_item = 0;
    for (size_t prod = 0; prod < firewall_product_count(); prod++) {
        QString prod_name = firewall_product_name(prod);
        // Default to Netfilter since it's likely the most popular.
        if (prod_name.contains("Netfilter")) nf_item = ui->productComboBox->count();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    syntax_func mac_func = firewall_product_mac_func(prod_);
    if (v4_func && net_src_.type == AT_IPv4) {
        addRule(tr("IPv4 source address."), v4_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address."), v4_func, &net_dst_, dst_port_);
    }
}
void Singleton::f2();{
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address and port."), v4_port_func, &net_dst_, dst_port_);
    }
    if (mac_func && dl_src_.type == AT_ETHER) {
}
void Singleton::f3();{
    int nf_item = 0;
    for (size_t prod = 0; prod < firewall_product_count(); prod++) {
        QString prod_name = firewall_product_name(prod);
        // Default to Netfilter since it's likely the most popular.
        if (prod_name.contains("Netfilter")) nf_item = ui->productComboBox->count();
}
void Singleton::f4();{
void FirewallRulesDialog::on_inboundCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_denyCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_buttonBox_clicked(QAbstractButton *button)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    syntax_func mac_func = firewall_product_mac_func(prod_);
    if (v4_func && net_src_.type == AT_IPv4) {
        addRule(tr("IPv4 source address."), v4_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address."), v4_func, &net_dst_, dst_port_);
    }
}
void Singleton::f2();{
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address and port."), v4_port_func, &net_dst_, dst_port_);
    }
    if (mac_func && dl_src_.type == AT_ETHER) {
}
void Singleton::f3();{
    int nf_item = 0;
    for (size_t prod = 0; prod < firewall_product_count(); prod++) {
        QString prod_name = firewall_product_name(prod);
        // Default to Netfilter since it's likely the most popular.
        if (prod_name.contains("Netfilter")) nf_item = ui->productComboBox->count();
}
void Singleton::f4();{
void FirewallRulesDialog::on_inboundCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_denyCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_buttonBox_clicked(QAbstractButton *button)
}
void Singleton::f5();{
            QFile save_file(file_name);
            QByteArray rule_text = ui->textBrowser->toPlainText().toUtf8();
            save_file.open(QIODevice::WriteOnly);
            save_file.write(rule_text);
            save_file.close();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    syntax_func mac_func = firewall_product_mac_func(prod_);
    if (v4_func && net_src_.type == AT_IPv4) {
        addRule(tr("IPv4 source address."), v4_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address."), v4_func, &net_dst_, dst_port_);
    }
}
void Singleton::f2();{
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address and port."), v4_port_func, &net_dst_, dst_port_);
    }
    if (mac_func && dl_src_.type == AT_ETHER) {
}
void Singleton::f3();{
    int nf_item = 0;
    for (size_t prod = 0; prod < firewall_product_count(); prod++) {
        QString prod_name = firewall_product_name(prod);
        // Default to Netfilter since it's likely the most popular.
        if (prod_name.contains("Netfilter")) nf_item = ui->productComboBox->count();
}
void Singleton::f4();{
void FirewallRulesDialog::on_inboundCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_denyCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_buttonBox_clicked(QAbstractButton *button)
}
void Singleton::f5();{
            QFile save_file(file_name);
            QByteArray rule_text = ui->textBrowser->toPlainText().toUtf8();
            save_file.open(QIODevice::WriteOnly);
            save_file.write(rule_text);
            save_file.close();
}
void Singleton::f6();{
    QString comment_pfx = firewall_product_comment_prefix(prod_);
    QString rule_hint = firewall_product_rule_hint(prod_);
    QString rule_line;
    rule_line = QString("%1 %2 rules for %3, packet %4.")
            .arg(comment_pfx)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    syntax_func mac_func = firewall_product_mac_func(prod_);
    if (v4_func && net_src_.type == AT_IPv4) {
        addRule(tr("IPv4 source address."), v4_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address."), v4_func, &net_dst_, dst_port_);
    }
}
void Singleton::f2();{
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address and port."), v4_port_func, &net_dst_, dst_port_);
    }
    if (mac_func && dl_src_.type == AT_ETHER) {
}
void Singleton::f3();{
    int nf_item = 0;
    for (size_t prod = 0; prod < firewall_product_count(); prod++) {
        QString prod_name = firewall_product_name(prod);
        // Default to Netfilter since it's likely the most popular.
        if (prod_name.contains("Netfilter")) nf_item = ui->productComboBox->count();
}
void Singleton::f4();{
void FirewallRulesDialog::on_inboundCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_denyCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_buttonBox_clicked(QAbstractButton *button)
}
void Singleton::f5();{
            QFile save_file(file_name);
            QByteArray rule_text = ui->textBrowser->toPlainText().toUtf8();
            save_file.open(QIODevice::WriteOnly);
            save_file.write(rule_text);
            save_file.close();
}
void Singleton::f6();{
    QString comment_pfx = firewall_product_comment_prefix(prod_);
    QString rule_hint = firewall_product_rule_hint(prod_);
    QString rule_line;
    rule_line = QString("%1 %2 rules for %3, packet %4.")
            .arg(comment_pfx)
}
void Singleton::f7();{
        addRule(tr("Destination port."), port_func, &net_dst_, dst_port_);
    }
    if (v4_port_func && net_src_.type == AT_IPv4 &&
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    syntax_func mac_func = firewall_product_mac_func(prod_);
    if (v4_func && net_src_.type == AT_IPv4) {
        addRule(tr("IPv4 source address."), v4_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address."), v4_func, &net_dst_, dst_port_);
    }
}
void Singleton::f2();{
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address and port."), v4_port_func, &net_dst_, dst_port_);
    }
    if (mac_func && dl_src_.type == AT_ETHER) {
}
void Singleton::f3();{
    int nf_item = 0;
    for (size_t prod = 0; prod < firewall_product_count(); prod++) {
        QString prod_name = firewall_product_name(prod);
        // Default to Netfilter since it's likely the most popular.
        if (prod_name.contains("Netfilter")) nf_item = ui->productComboBox->count();
}
void Singleton::f4();{
void FirewallRulesDialog::on_inboundCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_denyCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_buttonBox_clicked(QAbstractButton *button)
}
void Singleton::f5();{
            QFile save_file(file_name);
            QByteArray rule_text = ui->textBrowser->toPlainText().toUtf8();
            save_file.open(QIODevice::WriteOnly);
            save_file.write(rule_text);
            save_file.close();
}
void Singleton::f6();{
    QString comment_pfx = firewall_product_comment_prefix(prod_);
    QString rule_hint = firewall_product_rule_hint(prod_);
    QString rule_line;
    rule_line = QString("%1 %2 rules for %3, packet %4.")
            .arg(comment_pfx)
}
void Singleton::f7();{
        addRule(tr("Destination port."), port_func, &net_dst_, dst_port_);
    }
    if (v4_port_func && net_src_.type == AT_IPv4 &&
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
}
void Singleton::f8();{
    QString rule_line;
    rule_line = QString("%1 %2 rules for %3, packet %4.")
            .arg(comment_pfx)
            .arg(firewall_product_name(prod_))
            .arg(file_name_)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    syntax_func mac_func = firewall_product_mac_func(prod_);
    if (v4_func && net_src_.type == AT_IPv4) {
        addRule(tr("IPv4 source address."), v4_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address."), v4_func, &net_dst_, dst_port_);
    }
}
void Singleton::f2();{
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
        addRule(tr("IPv4 destination address and port."), v4_port_func, &net_dst_, dst_port_);
    }
    if (mac_func && dl_src_.type == AT_ETHER) {
}
void Singleton::f3();{
    int nf_item = 0;
    for (size_t prod = 0; prod < firewall_product_count(); prod++) {
        QString prod_name = firewall_product_name(prod);
        // Default to Netfilter since it's likely the most popular.
        if (prod_name.contains("Netfilter")) nf_item = ui->productComboBox->count();
}
void Singleton::f4();{
void FirewallRulesDialog::on_inboundCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_denyCheckBox_toggled(bool)
    updateWidgets();
void FirewallRulesDialog::on_buttonBox_clicked(QAbstractButton *button)
}
void Singleton::f5();{
            QFile save_file(file_name);
            QByteArray rule_text = ui->textBrowser->toPlainText().toUtf8();
            save_file.open(QIODevice::WriteOnly);
            save_file.write(rule_text);
            save_file.close();
}
void Singleton::f6();{
    QString comment_pfx = firewall_product_comment_prefix(prod_);
    QString rule_hint = firewall_product_rule_hint(prod_);
    QString rule_line;
    rule_line = QString("%1 %2 rules for %3, packet %4.")
            .arg(comment_pfx)
}
void Singleton::f7();{
        addRule(tr("Destination port."), port_func, &net_dst_, dst_port_);
    }
    if (v4_port_func && net_src_.type == AT_IPv4 &&
            (ptype_ == PT_TCP || ptype_ == PT_UDP)) {
        addRule(tr("IPv4 source address and port."), v4_port_func, &net_src_, src_port_);
}
void Singleton::f8();{
    QString rule_line;
    rule_line = QString("%1 %2 rules for %3, packet %4.")
            .arg(comment_pfx)
            .arg(firewall_product_name(prod_))
            .arg(file_name_)
}
void Singleton::f9();{
            .arg(file_name_)
            .arg(packet_num_);
    if (!rule_hint.isEmpty()) rule_line += " " + rule_hint;
    ui->textBrowser->clear();
    ui->textBrowser->append(rule_line);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    server_packet_count_(0),
    last_packet_(0),
    last_from_server_(0),
    turns_(0),
    use_regex_find_(false),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    server_packet_count_(0),
    last_packet_(0),
    last_from_server_(0),
    turns_(0),
    use_regex_find_(false),
}
void Singleton::f2();{
    QByteArray bytes = ui->teStreamContent->toPlainText().toUtf8();
    if (show_type_ == SHOW_RAW) {
        // The "Raw" format is currently displayed as hex data and needs to be
        // converted to binary data.
        bytes = QByteArray::fromHex(bytes);
}
void Singleton::f3();{
    removeTapListeners();
    hostname0 = address_to_name(&follow_info_.client_ip);
    hostname1 = address_to_name(&follow_info_.server_ip);
    port0 = get_follow_port_to_display(follower_)(NULL, follow_info_.client_port);
    port1 = get_follow_port_to_display(follower_)(NULL, follow_info_.server_port);
}
void Singleton::f4();{
    case FOLLOW_UDP :
    case FOLLOW_HTTP :
    case FOLLOW_HTTP2:
    case FOLLOW_QUIC:
    case FOLLOW_TLS :
}
void Singleton::f5();{
            ui->streamNumberSpinBox->setToolTip(tooltip);
            ui->streamNumberLabel->setToolTip(tooltip);
            WiresharkDialog::captureFileClosing();
    }
 * XXX - the routine pointed to by "print_line_fcn_p" doesn't get handed lines,
}
void Singleton::f6();{
            ui->leFind->selectAll();
        }
        return;
    }
    if (event->key() == Qt::Key_F3 || (event->key() == Qt::Key_N && event->modifiers() & Qt::ControlModifier)) {
}
void Singleton::f7();{
    guint32 global_client_pos = 0, global_server_pos = 0;
    guint32 *global_pos;
    gboolean skip;
    GList* cur;
    frs_return_t frs_return;
}
void Singleton::f8();{
        ui->streamNumberLabel->setToolTip(ui->streamNumberSpinBox->toolTip());
        break;
    }
    case FOLLOW_UDP:
    {
}
void Singleton::f9();{
       same as the previous display filter. */
    emit updateFilter(follow_filter, TRUE);
    removeTapListeners();
    hostname0 = address_to_name(&follow_info_.client_ip);
    hostname1 = address_to_name(&follow_info_.server_ip);
}
void Singleton::f10();{
        if (dialogClosed()) break;
        follow_record = (follow_record_t *)cur->data;
        skip = FALSE;
        if (!follow_record->is_server) {
            global_pos = &global_client_pos;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    server_packet_count_(0),
    last_packet_(0),
    last_from_server_(0),
    turns_(0),
    use_regex_find_(false),
}
void Singleton::f2();{
    QByteArray bytes = ui->teStreamContent->toPlainText().toUtf8();
    if (show_type_ == SHOW_RAW) {
        // The "Raw" format is currently displayed as hex data and needs to be
        // converted to binary data.
        bytes = QByteArray::fromHex(bytes);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    server_packet_count_(0),
    last_packet_(0),
    last_from_server_(0),
    turns_(0),
    use_regex_find_(false),
}
void Singleton::f2();{
    QByteArray bytes = ui->teStreamContent->toPlainText().toUtf8();
    if (show_type_ == SHOW_RAW) {
        // The "Raw" format is currently displayed as hex data and needs to be
        // converted to binary data.
        bytes = QByteArray::fromHex(bytes);
}
void Singleton::f3();{
    removeTapListeners();
    hostname0 = address_to_name(&follow_info_.client_ip);
    hostname1 = address_to_name(&follow_info_.server_ip);
    port0 = get_follow_port_to_display(follower_)(NULL, follow_info_.client_port);
    port1 = get_follow_port_to_display(follower_)(NULL, follow_info_.server_port);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    server_packet_count_(0),
    last_packet_(0),
    last_from_server_(0),
    turns_(0),
    use_regex_find_(false),
}
void Singleton::f2();{
    QByteArray bytes = ui->teStreamContent->toPlainText().toUtf8();
    if (show_type_ == SHOW_RAW) {
        // The "Raw" format is currently displayed as hex data and needs to be
        // converted to binary data.
        bytes = QByteArray::fromHex(bytes);
}
void Singleton::f3();{
    removeTapListeners();
    hostname0 = address_to_name(&follow_info_.client_ip);
    hostname1 = address_to_name(&follow_info_.server_ip);
    port0 = get_follow_port_to_display(follower_)(NULL, follow_info_.client_port);
    port1 = get_follow_port_to_display(follower_)(NULL, follow_info_.server_port);
}
void Singleton::f4();{
    case FOLLOW_UDP :
    case FOLLOW_HTTP :
    case FOLLOW_HTTP2:
    case FOLLOW_QUIC:
    case FOLLOW_TLS :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    server_packet_count_(0),
    last_packet_(0),
    last_from_server_(0),
    turns_(0),
    use_regex_find_(false),
}
void Singleton::f2();{
    QByteArray bytes = ui->teStreamContent->toPlainText().toUtf8();
    if (show_type_ == SHOW_RAW) {
        // The "Raw" format is currently displayed as hex data and needs to be
        // converted to binary data.
        bytes = QByteArray::fromHex(bytes);
}
void Singleton::f3();{
    removeTapListeners();
    hostname0 = address_to_name(&follow_info_.client_ip);
    hostname1 = address_to_name(&follow_info_.server_ip);
    port0 = get_follow_port_to_display(follower_)(NULL, follow_info_.client_port);
    port1 = get_follow_port_to_display(follower_)(NULL, follow_info_.server_port);
}
void Singleton::f4();{
    case FOLLOW_UDP :
    case FOLLOW_HTTP :
    case FOLLOW_HTTP2:
    case FOLLOW_QUIC:
    case FOLLOW_TLS :
}
void Singleton::f5();{
            ui->streamNumberSpinBox->setToolTip(tooltip);
            ui->streamNumberLabel->setToolTip(tooltip);
            WiresharkDialog::captureFileClosing();
    }
 * XXX - the routine pointed to by "print_line_fcn_p" doesn't get handed lines,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    server_packet_count_(0),
    last_packet_(0),
    last_from_server_(0),
    turns_(0),
    use_regex_find_(false),
}
void Singleton::f2();{
    QByteArray bytes = ui->teStreamContent->toPlainText().toUtf8();
    if (show_type_ == SHOW_RAW) {
        // The "Raw" format is currently displayed as hex data and needs to be
        // converted to binary data.
        bytes = QByteArray::fromHex(bytes);
}
void Singleton::f3();{
    removeTapListeners();
    hostname0 = address_to_name(&follow_info_.client_ip);
    hostname1 = address_to_name(&follow_info_.server_ip);
    port0 = get_follow_port_to_display(follower_)(NULL, follow_info_.client_port);
    port1 = get_follow_port_to_display(follower_)(NULL, follow_info_.server_port);
}
void Singleton::f4();{
    case FOLLOW_UDP :
    case FOLLOW_HTTP :
    case FOLLOW_HTTP2:
    case FOLLOW_QUIC:
    case FOLLOW_TLS :
}
void Singleton::f5();{
            ui->streamNumberSpinBox->setToolTip(tooltip);
            ui->streamNumberLabel->setToolTip(tooltip);
            WiresharkDialog::captureFileClosing();
    }
 * XXX - the routine pointed to by "print_line_fcn_p" doesn't get handed lines,
}
void Singleton::f6();{
            ui->leFind->selectAll();
        }
        return;
    }
    if (event->key() == Qt::Key_F3 || (event->key() == Qt::Key_N && event->modifiers() & Qt::ControlModifier)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    server_packet_count_(0),
    last_packet_(0),
    last_from_server_(0),
    turns_(0),
    use_regex_find_(false),
}
void Singleton::f2();{
    QByteArray bytes = ui->teStreamContent->toPlainText().toUtf8();
    if (show_type_ == SHOW_RAW) {
        // The "Raw" format is currently displayed as hex data and needs to be
        // converted to binary data.
        bytes = QByteArray::fromHex(bytes);
}
void Singleton::f3();{
    removeTapListeners();
    hostname0 = address_to_name(&follow_info_.client_ip);
    hostname1 = address_to_name(&follow_info_.server_ip);
    port0 = get_follow_port_to_display(follower_)(NULL, follow_info_.client_port);
    port1 = get_follow_port_to_display(follower_)(NULL, follow_info_.server_port);
}
void Singleton::f4();{
    case FOLLOW_UDP :
    case FOLLOW_HTTP :
    case FOLLOW_HTTP2:
    case FOLLOW_QUIC:
    case FOLLOW_TLS :
}
void Singleton::f5();{
            ui->streamNumberSpinBox->setToolTip(tooltip);
            ui->streamNumberLabel->setToolTip(tooltip);
            WiresharkDialog::captureFileClosing();
    }
 * XXX - the routine pointed to by "print_line_fcn_p" doesn't get handed lines,
}
void Singleton::f6();{
            ui->leFind->selectAll();
        }
        return;
    }
    if (event->key() == Qt::Key_F3 || (event->key() == Qt::Key_N && event->modifiers() & Qt::ControlModifier)) {
}
void Singleton::f7();{
    guint32 global_client_pos = 0, global_server_pos = 0;
    guint32 *global_pos;
    gboolean skip;
    GList* cur;
    frs_return_t frs_return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    server_packet_count_(0),
    last_packet_(0),
    last_from_server_(0),
    turns_(0),
    use_regex_find_(false),
}
void Singleton::f2();{
    QByteArray bytes = ui->teStreamContent->toPlainText().toUtf8();
    if (show_type_ == SHOW_RAW) {
        // The "Raw" format is currently displayed as hex data and needs to be
        // converted to binary data.
        bytes = QByteArray::fromHex(bytes);
}
void Singleton::f3();{
    removeTapListeners();
    hostname0 = address_to_name(&follow_info_.client_ip);
    hostname1 = address_to_name(&follow_info_.server_ip);
    port0 = get_follow_port_to_display(follower_)(NULL, follow_info_.client_port);
    port1 = get_follow_port_to_display(follower_)(NULL, follow_info_.server_port);
}
void Singleton::f4();{
    case FOLLOW_UDP :
    case FOLLOW_HTTP :
    case FOLLOW_HTTP2:
    case FOLLOW_QUIC:
    case FOLLOW_TLS :
}
void Singleton::f5();{
            ui->streamNumberSpinBox->setToolTip(tooltip);
            ui->streamNumberLabel->setToolTip(tooltip);
            WiresharkDialog::captureFileClosing();
    }
 * XXX - the routine pointed to by "print_line_fcn_p" doesn't get handed lines,
}
void Singleton::f6();{
            ui->leFind->selectAll();
        }
        return;
    }
    if (event->key() == Qt::Key_F3 || (event->key() == Qt::Key_N && event->modifiers() & Qt::ControlModifier)) {
}
void Singleton::f7();{
    guint32 global_client_pos = 0, global_server_pos = 0;
    guint32 *global_pos;
    gboolean skip;
    GList* cur;
    frs_return_t frs_return;
}
void Singleton::f8();{
        ui->streamNumberLabel->setToolTip(ui->streamNumberSpinBox->toolTip());
        break;
    }
    case FOLLOW_UDP:
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    server_packet_count_(0),
    last_packet_(0),
    last_from_server_(0),
    turns_(0),
    use_regex_find_(false),
}
void Singleton::f2();{
    QByteArray bytes = ui->teStreamContent->toPlainText().toUtf8();
    if (show_type_ == SHOW_RAW) {
        // The "Raw" format is currently displayed as hex data and needs to be
        // converted to binary data.
        bytes = QByteArray::fromHex(bytes);
}
void Singleton::f3();{
    removeTapListeners();
    hostname0 = address_to_name(&follow_info_.client_ip);
    hostname1 = address_to_name(&follow_info_.server_ip);
    port0 = get_follow_port_to_display(follower_)(NULL, follow_info_.client_port);
    port1 = get_follow_port_to_display(follower_)(NULL, follow_info_.server_port);
}
void Singleton::f4();{
    case FOLLOW_UDP :
    case FOLLOW_HTTP :
    case FOLLOW_HTTP2:
    case FOLLOW_QUIC:
    case FOLLOW_TLS :
}
void Singleton::f5();{
            ui->streamNumberSpinBox->setToolTip(tooltip);
            ui->streamNumberLabel->setToolTip(tooltip);
            WiresharkDialog::captureFileClosing();
    }
 * XXX - the routine pointed to by "print_line_fcn_p" doesn't get handed lines,
}
void Singleton::f6();{
            ui->leFind->selectAll();
        }
        return;
    }
    if (event->key() == Qt::Key_F3 || (event->key() == Qt::Key_N && event->modifiers() & Qt::ControlModifier)) {
}
void Singleton::f7();{
    guint32 global_client_pos = 0, global_server_pos = 0;
    guint32 *global_pos;
    gboolean skip;
    GList* cur;
    frs_return_t frs_return;
}
void Singleton::f8();{
        ui->streamNumberLabel->setToolTip(ui->streamNumberSpinBox->toolTip());
        break;
    }
    case FOLLOW_UDP:
    {
}
void Singleton::f9();{
       same as the previous display filter. */
    emit updateFilter(follow_filter, TRUE);
    removeTapListeners();
    hostname0 = address_to_name(&follow_info_.client_ip);
    hostname1 = address_to_name(&follow_info_.server_ip);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        break;
    case COLOR_STYLE_GRADIENT:
        foreground  = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_fg_, pref_stashed));
        background1 = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_bg_, pref_stashed));
        background2 = QColor::fromRgb(ColorUtils::alphaBlend(foreground, background1, COLOR_STYLE_ALPHA));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        break;
    case COLOR_STYLE_GRADIENT:
        foreground  = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_fg_, pref_stashed));
        background1 = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_bg_, pref_stashed));
        background2 = QColor::fromRgb(ColorUtils::alphaBlend(foreground, background1, COLOR_STYLE_ALPHA));
}
void Singleton::f2();{
    ui->inactiveSampleLineEdit->setStyleSheet(sample_text_ex_ss.arg(
                                                foreground.name(),
                                                background1.name(),
                                                background2.name()));
    ui->inactiveSampleLineEdit->setFont(cur_font_);
}
void Singleton::f3();{
        default_pal = QApplication::palette();
        default_pal.setCurrentColorGroup(QPalette::Active);
        foreground  = default_pal.highlightedText().color();
        background1 = default_pal.highlight().color();
        background2 = default_pal.highlight().color();
}
void Singleton::f4();{
    QString line_edit_ss = QString("QLineEdit { margin-left: %1px; }").arg(margin);
    ui->fontSampleLineEdit->setStyleSheet(line_edit_ss);
    QString color_button_ss =
        "QPushButton {"
        "  border: 1px solid palette(Dark);"
}
void Singleton::f5();{
                                                ColorUtils::fromColorT(prefs_get_color_value(pref_server_bg_, pref_stashed)).name()));
    ui->serverSampleLineEdit->setFont(cur_font_);
    //
    // Sample valid filter
    //
}
void Singleton::f6();{
    pref_inactive_fg_ = prefFromPrefPtr(&prefs.gui_inactive_fg);
    pref_inactive_bg_ = prefFromPrefPtr(&prefs.gui_inactive_bg);
    pref_inactive_style_ = prefFromPrefPtr(&prefs.gui_inactive_style);
    pref_marked_fg_ = prefFromPrefPtr(&prefs.gui_marked_fg);
    pref_marked_bg_ = prefFromPrefPtr(&prefs.gui_marked_bg);
}
void Singleton::f7();{
    new_color.blue = cc.blue() << 8 | cc.blue();
    prefs_set_color_value(pref, new_color, pref_stashed);
    updateWidgets();
void FontColorPreferencesFrame::on_fontPushButton_clicked()
    bool ok;
}
void Singleton::f8();{
    // Make foreground and background colors
    switch (colorstyle)
    {
    case COLOR_STYLE_DEFAULT:
        default_pal = QApplication::palette();
}
void Singleton::f9();{
                                                background1.name(),
                                                background2.name()));
    ui->activeSampleLineEdit->setFont(cur_font_);
    ui->activeStyleComboBox->setCurrentIndex(prefs_get_enum_value(pref_active_style_, pref_stashed));
    // Show or hide the widgets
}
void Singleton::f10();{
    color_dlg->show();
void FontColorPreferencesFrame::colorChanged(pref_t *pref, const QColor &cc)
    color_t new_color;
    new_color.red = cc.red() << 8 | cc.red();
    new_color.green = cc.green() << 8 | cc.green();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        break;
    case COLOR_STYLE_GRADIENT:
        foreground  = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_fg_, pref_stashed));
        background1 = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_bg_, pref_stashed));
        background2 = QColor::fromRgb(ColorUtils::alphaBlend(foreground, background1, COLOR_STYLE_ALPHA));
}
void Singleton::f2();{
    ui->inactiveSampleLineEdit->setStyleSheet(sample_text_ex_ss.arg(
                                                foreground.name(),
                                                background1.name(),
                                                background2.name()));
    ui->inactiveSampleLineEdit->setFont(cur_font_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        break;
    case COLOR_STYLE_GRADIENT:
        foreground  = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_fg_, pref_stashed));
        background1 = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_bg_, pref_stashed));
        background2 = QColor::fromRgb(ColorUtils::alphaBlend(foreground, background1, COLOR_STYLE_ALPHA));
}
void Singleton::f2();{
    ui->inactiveSampleLineEdit->setStyleSheet(sample_text_ex_ss.arg(
                                                foreground.name(),
                                                background1.name(),
                                                background2.name()));
    ui->inactiveSampleLineEdit->setFont(cur_font_);
}
void Singleton::f3();{
        default_pal = QApplication::palette();
        default_pal.setCurrentColorGroup(QPalette::Active);
        foreground  = default_pal.highlightedText().color();
        background1 = default_pal.highlight().color();
        background2 = default_pal.highlight().color();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        break;
    case COLOR_STYLE_GRADIENT:
        foreground  = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_fg_, pref_stashed));
        background1 = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_bg_, pref_stashed));
        background2 = QColor::fromRgb(ColorUtils::alphaBlend(foreground, background1, COLOR_STYLE_ALPHA));
}
void Singleton::f2();{
    ui->inactiveSampleLineEdit->setStyleSheet(sample_text_ex_ss.arg(
                                                foreground.name(),
                                                background1.name(),
                                                background2.name()));
    ui->inactiveSampleLineEdit->setFont(cur_font_);
}
void Singleton::f3();{
        default_pal = QApplication::palette();
        default_pal.setCurrentColorGroup(QPalette::Active);
        foreground  = default_pal.highlightedText().color();
        background1 = default_pal.highlight().color();
        background2 = default_pal.highlight().color();
}
void Singleton::f4();{
    QString line_edit_ss = QString("QLineEdit { margin-left: %1px; }").arg(margin);
    ui->fontSampleLineEdit->setStyleSheet(line_edit_ss);
    QString color_button_ss =
        "QPushButton {"
        "  border: 1px solid palette(Dark);"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        break;
    case COLOR_STYLE_GRADIENT:
        foreground  = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_fg_, pref_stashed));
        background1 = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_bg_, pref_stashed));
        background2 = QColor::fromRgb(ColorUtils::alphaBlend(foreground, background1, COLOR_STYLE_ALPHA));
}
void Singleton::f2();{
    ui->inactiveSampleLineEdit->setStyleSheet(sample_text_ex_ss.arg(
                                                foreground.name(),
                                                background1.name(),
                                                background2.name()));
    ui->inactiveSampleLineEdit->setFont(cur_font_);
}
void Singleton::f3();{
        default_pal = QApplication::palette();
        default_pal.setCurrentColorGroup(QPalette::Active);
        foreground  = default_pal.highlightedText().color();
        background1 = default_pal.highlight().color();
        background2 = default_pal.highlight().color();
}
void Singleton::f4();{
    QString line_edit_ss = QString("QLineEdit { margin-left: %1px; }").arg(margin);
    ui->fontSampleLineEdit->setStyleSheet(line_edit_ss);
    QString color_button_ss =
        "QPushButton {"
        "  border: 1px solid palette(Dark);"
}
void Singleton::f5();{
                                                ColorUtils::fromColorT(prefs_get_color_value(pref_server_bg_, pref_stashed)).name()));
    ui->serverSampleLineEdit->setFont(cur_font_);
    //
    // Sample valid filter
    //
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        break;
    case COLOR_STYLE_GRADIENT:
        foreground  = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_fg_, pref_stashed));
        background1 = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_bg_, pref_stashed));
        background2 = QColor::fromRgb(ColorUtils::alphaBlend(foreground, background1, COLOR_STYLE_ALPHA));
}
void Singleton::f2();{
    ui->inactiveSampleLineEdit->setStyleSheet(sample_text_ex_ss.arg(
                                                foreground.name(),
                                                background1.name(),
                                                background2.name()));
    ui->inactiveSampleLineEdit->setFont(cur_font_);
}
void Singleton::f3();{
        default_pal = QApplication::palette();
        default_pal.setCurrentColorGroup(QPalette::Active);
        foreground  = default_pal.highlightedText().color();
        background1 = default_pal.highlight().color();
        background2 = default_pal.highlight().color();
}
void Singleton::f4();{
    QString line_edit_ss = QString("QLineEdit { margin-left: %1px; }").arg(margin);
    ui->fontSampleLineEdit->setStyleSheet(line_edit_ss);
    QString color_button_ss =
        "QPushButton {"
        "  border: 1px solid palette(Dark);"
}
void Singleton::f5();{
                                                ColorUtils::fromColorT(prefs_get_color_value(pref_server_bg_, pref_stashed)).name()));
    ui->serverSampleLineEdit->setFont(cur_font_);
    //
    // Sample valid filter
    //
}
void Singleton::f6();{
    pref_inactive_fg_ = prefFromPrefPtr(&prefs.gui_inactive_fg);
    pref_inactive_bg_ = prefFromPrefPtr(&prefs.gui_inactive_bg);
    pref_inactive_style_ = prefFromPrefPtr(&prefs.gui_inactive_style);
    pref_marked_fg_ = prefFromPrefPtr(&prefs.gui_marked_fg);
    pref_marked_bg_ = prefFromPrefPtr(&prefs.gui_marked_bg);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        break;
    case COLOR_STYLE_GRADIENT:
        foreground  = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_fg_, pref_stashed));
        background1 = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_bg_, pref_stashed));
        background2 = QColor::fromRgb(ColorUtils::alphaBlend(foreground, background1, COLOR_STYLE_ALPHA));
}
void Singleton::f2();{
    ui->inactiveSampleLineEdit->setStyleSheet(sample_text_ex_ss.arg(
                                                foreground.name(),
                                                background1.name(),
                                                background2.name()));
    ui->inactiveSampleLineEdit->setFont(cur_font_);
}
void Singleton::f3();{
        default_pal = QApplication::palette();
        default_pal.setCurrentColorGroup(QPalette::Active);
        foreground  = default_pal.highlightedText().color();
        background1 = default_pal.highlight().color();
        background2 = default_pal.highlight().color();
}
void Singleton::f4();{
    QString line_edit_ss = QString("QLineEdit { margin-left: %1px; }").arg(margin);
    ui->fontSampleLineEdit->setStyleSheet(line_edit_ss);
    QString color_button_ss =
        "QPushButton {"
        "  border: 1px solid palette(Dark);"
}
void Singleton::f5();{
                                                ColorUtils::fromColorT(prefs_get_color_value(pref_server_bg_, pref_stashed)).name()));
    ui->serverSampleLineEdit->setFont(cur_font_);
    //
    // Sample valid filter
    //
}
void Singleton::f6();{
    pref_inactive_fg_ = prefFromPrefPtr(&prefs.gui_inactive_fg);
    pref_inactive_bg_ = prefFromPrefPtr(&prefs.gui_inactive_bg);
    pref_inactive_style_ = prefFromPrefPtr(&prefs.gui_inactive_style);
    pref_marked_fg_ = prefFromPrefPtr(&prefs.gui_marked_fg);
    pref_marked_bg_ = prefFromPrefPtr(&prefs.gui_marked_bg);
}
void Singleton::f7();{
    new_color.blue = cc.blue() << 8 | cc.blue();
    prefs_set_color_value(pref, new_color, pref_stashed);
    updateWidgets();
void FontColorPreferencesFrame::on_fontPushButton_clicked()
    bool ok;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        break;
    case COLOR_STYLE_GRADIENT:
        foreground  = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_fg_, pref_stashed));
        background1 = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_bg_, pref_stashed));
        background2 = QColor::fromRgb(ColorUtils::alphaBlend(foreground, background1, COLOR_STYLE_ALPHA));
}
void Singleton::f2();{
    ui->inactiveSampleLineEdit->setStyleSheet(sample_text_ex_ss.arg(
                                                foreground.name(),
                                                background1.name(),
                                                background2.name()));
    ui->inactiveSampleLineEdit->setFont(cur_font_);
}
void Singleton::f3();{
        default_pal = QApplication::palette();
        default_pal.setCurrentColorGroup(QPalette::Active);
        foreground  = default_pal.highlightedText().color();
        background1 = default_pal.highlight().color();
        background2 = default_pal.highlight().color();
}
void Singleton::f4();{
    QString line_edit_ss = QString("QLineEdit { margin-left: %1px; }").arg(margin);
    ui->fontSampleLineEdit->setStyleSheet(line_edit_ss);
    QString color_button_ss =
        "QPushButton {"
        "  border: 1px solid palette(Dark);"
}
void Singleton::f5();{
                                                ColorUtils::fromColorT(prefs_get_color_value(pref_server_bg_, pref_stashed)).name()));
    ui->serverSampleLineEdit->setFont(cur_font_);
    //
    // Sample valid filter
    //
}
void Singleton::f6();{
    pref_inactive_fg_ = prefFromPrefPtr(&prefs.gui_inactive_fg);
    pref_inactive_bg_ = prefFromPrefPtr(&prefs.gui_inactive_bg);
    pref_inactive_style_ = prefFromPrefPtr(&prefs.gui_inactive_style);
    pref_marked_fg_ = prefFromPrefPtr(&prefs.gui_marked_fg);
    pref_marked_bg_ = prefFromPrefPtr(&prefs.gui_marked_bg);
}
void Singleton::f7();{
    new_color.blue = cc.blue() << 8 | cc.blue();
    prefs_set_color_value(pref, new_color, pref_stashed);
    updateWidgets();
void FontColorPreferencesFrame::on_fontPushButton_clicked()
    bool ok;
}
void Singleton::f8();{
    // Make foreground and background colors
    switch (colorstyle)
    {
    case COLOR_STYLE_DEFAULT:
        default_pal = QApplication::palette();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        break;
    case COLOR_STYLE_GRADIENT:
        foreground  = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_fg_, pref_stashed));
        background1 = ColorUtils::fromColorT(prefs_get_color_value(pref_inactive_bg_, pref_stashed));
        background2 = QColor::fromRgb(ColorUtils::alphaBlend(foreground, background1, COLOR_STYLE_ALPHA));
}
void Singleton::f2();{
    ui->inactiveSampleLineEdit->setStyleSheet(sample_text_ex_ss.arg(
                                                foreground.name(),
                                                background1.name(),
                                                background2.name()));
    ui->inactiveSampleLineEdit->setFont(cur_font_);
}
void Singleton::f3();{
        default_pal = QApplication::palette();
        default_pal.setCurrentColorGroup(QPalette::Active);
        foreground  = default_pal.highlightedText().color();
        background1 = default_pal.highlight().color();
        background2 = default_pal.highlight().color();
}
void Singleton::f4();{
    QString line_edit_ss = QString("QLineEdit { margin-left: %1px; }").arg(margin);
    ui->fontSampleLineEdit->setStyleSheet(line_edit_ss);
    QString color_button_ss =
        "QPushButton {"
        "  border: 1px solid palette(Dark);"
}
void Singleton::f5();{
                                                ColorUtils::fromColorT(prefs_get_color_value(pref_server_bg_, pref_stashed)).name()));
    ui->serverSampleLineEdit->setFont(cur_font_);
    //
    // Sample valid filter
    //
}
void Singleton::f6();{
    pref_inactive_fg_ = prefFromPrefPtr(&prefs.gui_inactive_fg);
    pref_inactive_bg_ = prefFromPrefPtr(&prefs.gui_inactive_bg);
    pref_inactive_style_ = prefFromPrefPtr(&prefs.gui_inactive_style);
    pref_marked_fg_ = prefFromPrefPtr(&prefs.gui_marked_fg);
    pref_marked_bg_ = prefFromPrefPtr(&prefs.gui_marked_bg);
}
void Singleton::f7();{
    new_color.blue = cc.blue() << 8 | cc.blue();
    prefs_set_color_value(pref, new_color, pref_stashed);
    updateWidgets();
void FontColorPreferencesFrame::on_fontPushButton_clicked()
    bool ok;
}
void Singleton::f8();{
    // Make foreground and background colors
    switch (colorstyle)
    {
    case COLOR_STYLE_DEFAULT:
        default_pal = QApplication::palette();
}
void Singleton::f9();{
                                                background1.name(),
                                                background2.name()));
    ui->activeSampleLineEdit->setFont(cur_font_);
    ui->activeStyleComboBox->setCurrentIndex(prefs_get_enum_value(pref_active_style_, pref_stashed));
    // Show or hide the widgets
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
    epan_dissect_fill_in_columns(edt_, TRUE, TRUE);
FrameInformation::~FrameInformation()
    if (edt_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
    epan_dissect_fill_in_columns(edt_, TRUE, TRUE);
FrameInformation::~FrameInformation()
    if (edt_) {
}
void Singleton::f2();{
    /* proto tree, visible. We need a proto tree if there's custom columns */
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
}
void Singleton::f3();{
const QByteArray FrameInformation::printableData()
    if (!fi_ || !edt_)
        return QByteArray();
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
}
void Singleton::f4();{
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
}
void Singleton::f5();{
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
    return QByteArray(data, length);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    {
        ret = true;
    }
    return ret;
frame_data * FrameInformation::frameData() const
}
void Singleton::f7();{
    }
    return ret;
frame_data * FrameInformation::frameData() const
    return fi_;
int FrameInformation::frameNum() const
}
void Singleton::f8();{
FrameInformation::FrameInformation(CaptureFile * capfile, frame_data * fi, QObject * parent)
:QObject(parent),
 fi_(fi),
 cap_file_(capfile),
 edt_(Q_NULLPTR)
}
void Singleton::f9();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
FrameInformation::FrameInformation(CaptureFile * capfile, frame_data * fi, QObject * parent)
:QObject(parent),
 fi_(fi),
}
void Singleton::f10();{
 edt_(Q_NULLPTR)
    wtap_rec_init(&rec_);
    ws_buffer_init(&buf_, 1514);
    loadFrameTree();
void FrameInformation::loadFrameTree()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
    epan_dissect_fill_in_columns(edt_, TRUE, TRUE);
FrameInformation::~FrameInformation()
    if (edt_) {
}
void Singleton::f2();{
    /* proto tree, visible. We need a proto tree if there's custom columns */
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
    epan_dissect_fill_in_columns(edt_, TRUE, TRUE);
FrameInformation::~FrameInformation()
    if (edt_) {
}
void Singleton::f2();{
    /* proto tree, visible. We need a proto tree if there's custom columns */
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
}
void Singleton::f3();{
const QByteArray FrameInformation::printableData()
    if (!fi_ || !edt_)
        return QByteArray();
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
    epan_dissect_fill_in_columns(edt_, TRUE, TRUE);
FrameInformation::~FrameInformation()
    if (edt_) {
}
void Singleton::f2();{
    /* proto tree, visible. We need a proto tree if there's custom columns */
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
}
void Singleton::f3();{
const QByteArray FrameInformation::printableData()
    if (!fi_ || !edt_)
        return QByteArray();
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
}
void Singleton::f4();{
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
    epan_dissect_fill_in_columns(edt_, TRUE, TRUE);
FrameInformation::~FrameInformation()
    if (edt_) {
}
void Singleton::f2();{
    /* proto tree, visible. We need a proto tree if there's custom columns */
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
}
void Singleton::f3();{
const QByteArray FrameInformation::printableData()
    if (!fi_ || !edt_)
        return QByteArray();
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
}
void Singleton::f4();{
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
}
void Singleton::f5();{
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
    return QByteArray(data, length);
 * Editor modelines
 * Local Variables:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
    epan_dissect_fill_in_columns(edt_, TRUE, TRUE);
FrameInformation::~FrameInformation()
    if (edt_) {
}
void Singleton::f2();{
    /* proto tree, visible. We need a proto tree if there's custom columns */
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
}
void Singleton::f3();{
const QByteArray FrameInformation::printableData()
    if (!fi_ || !edt_)
        return QByteArray();
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
}
void Singleton::f4();{
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
}
void Singleton::f5();{
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
    return QByteArray(data, length);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    {
        ret = true;
    }
    return ret;
frame_data * FrameInformation::frameData() const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
    epan_dissect_fill_in_columns(edt_, TRUE, TRUE);
FrameInformation::~FrameInformation()
    if (edt_) {
}
void Singleton::f2();{
    /* proto tree, visible. We need a proto tree if there's custom columns */
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
}
void Singleton::f3();{
const QByteArray FrameInformation::printableData()
    if (!fi_ || !edt_)
        return QByteArray();
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
}
void Singleton::f4();{
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
}
void Singleton::f5();{
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
    return QByteArray(data, length);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    {
        ret = true;
    }
    return ret;
frame_data * FrameInformation::frameData() const
}
void Singleton::f7();{
    }
    return ret;
frame_data * FrameInformation::frameData() const
    return fi_;
int FrameInformation::frameNum() const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
    epan_dissect_fill_in_columns(edt_, TRUE, TRUE);
FrameInformation::~FrameInformation()
    if (edt_) {
}
void Singleton::f2();{
    /* proto tree, visible. We need a proto tree if there's custom columns */
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
}
void Singleton::f3();{
const QByteArray FrameInformation::printableData()
    if (!fi_ || !edt_)
        return QByteArray();
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
}
void Singleton::f4();{
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
}
void Singleton::f5();{
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
    return QByteArray(data, length);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    {
        ret = true;
    }
    return ret;
frame_data * FrameInformation::frameData() const
}
void Singleton::f7();{
    }
    return ret;
frame_data * FrameInformation::frameData() const
    return fi_;
int FrameInformation::frameNum() const
}
void Singleton::f8();{
FrameInformation::FrameInformation(CaptureFile * capfile, frame_data * fi, QObject * parent)
:QObject(parent),
 fi_(fi),
 cap_file_(capfile),
 edt_(Q_NULLPTR)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
    epan_dissect_fill_in_columns(edt_, TRUE, TRUE);
FrameInformation::~FrameInformation()
    if (edt_) {
}
void Singleton::f2();{
    /* proto tree, visible. We need a proto tree if there's custom columns */
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
}
void Singleton::f3();{
const QByteArray FrameInformation::printableData()
    if (!fi_ || !edt_)
        return QByteArray();
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
}
void Singleton::f4();{
    epan_dissect_init(edt_, cap_file_->capFile()->epan, TRUE, TRUE);
    col_custom_prime_edt(edt_, &(cap_file_->capFile()->cinfo));
    epan_dissect_run(edt_, cap_file_->capFile()->cd_t, &rec_,
                     frame_tvbuff_new_buffer(&cap_file_->capFile()->provider, fi_, &buf_),
                     fi_, &(cap_file_->capFile()->cinfo));
}
void Singleton::f5();{
    int length = tvb_captured_length(edt_->tvb);
    const char *data = (const char *)tvb_get_ptr(edt_->tvb, 0, length);
    return QByteArray(data, length);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
    {
        ret = true;
    }
    return ret;
frame_data * FrameInformation::frameData() const
}
void Singleton::f7();{
    }
    return ret;
frame_data * FrameInformation::frameData() const
    return fi_;
int FrameInformation::frameNum() const
}
void Singleton::f8();{
FrameInformation::FrameInformation(CaptureFile * capfile, frame_data * fi, QObject * parent)
:QObject(parent),
 fi_(fi),
 cap_file_(capfile),
 edt_(Q_NULLPTR)
}
void Singleton::f9();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
FrameInformation::FrameInformation(CaptureFile * capfile, frame_data * fi, QObject * parent)
:QObject(parent),
 fi_(fi),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    funnel_ops_->reload_packets = funnel_statistics_reload_packets;
    funnel_ops_->reload_lua_plugins = funnel_statistics_reload_lua_plugins;
    funnel_ops_->apply_filter = funnel_statistics_apply_filter;
    funnel_ops_->browser_open_url = browser_open_url;
    funnel_ops_->browser_open_data_file = browser_open_data_file;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    funnel_ops_->reload_packets = funnel_statistics_reload_packets;
    funnel_ops_->reload_lua_plugins = funnel_statistics_reload_lua_plugins;
    funnel_ops_->apply_filter = funnel_statistics_apply_filter;
    funnel_ops_->browser_open_url = browser_open_url;
    funnel_ops_->browser_open_data_file = browser_open_data_file;
}
void Singleton::f2();{
    funnel_ops_->destroy_text_window = text_window_destroy;
    funnel_ops_->add_button = text_window_add_button;
    funnel_ops_->new_dialog = string_dialog_new;
    funnel_ops_->close_dialogs = string_dialogs_close;
    funnel_ops_->logger = funnel_statistics_logger;
}
void Singleton::f3();{
            }
        }
    }
void
register_tap_listener_qt_funnel(void)
}
void Singleton::f4();{
            if (funnel_action->callback() == callback) {
                // Must set back to title to find the correct sub-menu in Tools
                funnel_action->setText(funnel_action->title());
                wsApp->removeDynamicMenuGroupItem(group, funnel_action);
                it = funnel_actions_[group].erase(it);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
static gboolean menus_registered = FALSE;
struct _funnel_ops_id_t {
    FunnelStatistics *funnel_statistics;
FunnelStatistics::FunnelStatistics(QObject *parent, CaptureFile &cf) :
    QObject(parent),
}
void Singleton::f7();{
const QString FunnelStatistics::action_name_ = "FunnelStatisticsAction";
static gboolean menus_registered = FALSE;
struct _funnel_ops_id_t {
    FunnelStatistics *funnel_statistics;
FunnelStatistics::FunnelStatistics(QObject *parent, CaptureFile &cf) :
}
void Singleton::f8();{
// - Handle menu paths. Do we create a new path (GTK+) or use the base element?
// - Add a FunnelGraphDialog class?
extern "C" {
static void funnel_statistics_logger(const gchar *, GLogLevelFlags, const gchar *message, gpointer);
static void funnel_statistics_retap_packets(funnel_ops_id_t *ops_id);
}
void Singleton::f9();{
void funnel_statistics_apply_filter(funnel_ops_id_t *ops_id) {
    if (!ops_id || !ops_id->funnel_statistics) return;
    ops_id->funnel_statistics->emitApplyDisplayFilter();
gboolean browser_open_url(const gchar *url) {
    return QDesktopServices::openUrl(QUrl(url)) ? TRUE : FALSE;
}
void Singleton::f10();{
        return false;
    }
private:
    QString title_;
    funnel_menu_callback callback_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    funnel_ops_->reload_packets = funnel_statistics_reload_packets;
    funnel_ops_->reload_lua_plugins = funnel_statistics_reload_lua_plugins;
    funnel_ops_->apply_filter = funnel_statistics_apply_filter;
    funnel_ops_->browser_open_url = browser_open_url;
    funnel_ops_->browser_open_data_file = browser_open_data_file;
}
void Singleton::f2();{
    funnel_ops_->destroy_text_window = text_window_destroy;
    funnel_ops_->add_button = text_window_add_button;
    funnel_ops_->new_dialog = string_dialog_new;
    funnel_ops_->close_dialogs = string_dialogs_close;
    funnel_ops_->logger = funnel_statistics_logger;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    funnel_ops_->reload_packets = funnel_statistics_reload_packets;
    funnel_ops_->reload_lua_plugins = funnel_statistics_reload_lua_plugins;
    funnel_ops_->apply_filter = funnel_statistics_apply_filter;
    funnel_ops_->browser_open_url = browser_open_url;
    funnel_ops_->browser_open_data_file = browser_open_data_file;
}
void Singleton::f2();{
    funnel_ops_->destroy_text_window = text_window_destroy;
    funnel_ops_->add_button = text_window_add_button;
    funnel_ops_->new_dialog = string_dialog_new;
    funnel_ops_->close_dialogs = string_dialogs_close;
    funnel_ops_->logger = funnel_statistics_logger;
}
void Singleton::f3();{
            }
        }
    }
void
register_tap_listener_qt_funnel(void)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    funnel_ops_->reload_packets = funnel_statistics_reload_packets;
    funnel_ops_->reload_lua_plugins = funnel_statistics_reload_lua_plugins;
    funnel_ops_->apply_filter = funnel_statistics_apply_filter;
    funnel_ops_->browser_open_url = browser_open_url;
    funnel_ops_->browser_open_data_file = browser_open_data_file;
}
void Singleton::f2();{
    funnel_ops_->destroy_text_window = text_window_destroy;
    funnel_ops_->add_button = text_window_add_button;
    funnel_ops_->new_dialog = string_dialog_new;
    funnel_ops_->close_dialogs = string_dialogs_close;
    funnel_ops_->logger = funnel_statistics_logger;
}
void Singleton::f3();{
            }
        }
    }
void
register_tap_listener_qt_funnel(void)
}
void Singleton::f4();{
            if (funnel_action->callback() == callback) {
                // Must set back to title to find the correct sub-menu in Tools
                funnel_action->setText(funnel_action->title());
                wsApp->removeDynamicMenuGroupItem(group, funnel_action);
                it = funnel_actions_[group].erase(it);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    funnel_ops_->reload_packets = funnel_statistics_reload_packets;
    funnel_ops_->reload_lua_plugins = funnel_statistics_reload_lua_plugins;
    funnel_ops_->apply_filter = funnel_statistics_apply_filter;
    funnel_ops_->browser_open_url = browser_open_url;
    funnel_ops_->browser_open_data_file = browser_open_data_file;
}
void Singleton::f2();{
    funnel_ops_->destroy_text_window = text_window_destroy;
    funnel_ops_->add_button = text_window_add_button;
    funnel_ops_->new_dialog = string_dialog_new;
    funnel_ops_->close_dialogs = string_dialogs_close;
    funnel_ops_->logger = funnel_statistics_logger;
}
void Singleton::f3();{
            }
        }
    }
void
register_tap_listener_qt_funnel(void)
}
void Singleton::f4();{
            if (funnel_action->callback() == callback) {
                // Must set back to title to find the correct sub-menu in Tools
                funnel_action->setText(funnel_action->title());
                wsApp->removeDynamicMenuGroupItem(group, funnel_action);
                it = funnel_actions_[group].erase(it);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    funnel_ops_->reload_packets = funnel_statistics_reload_packets;
    funnel_ops_->reload_lua_plugins = funnel_statistics_reload_lua_plugins;
    funnel_ops_->apply_filter = funnel_statistics_apply_filter;
    funnel_ops_->browser_open_url = browser_open_url;
    funnel_ops_->browser_open_data_file = browser_open_data_file;
}
void Singleton::f2();{
    funnel_ops_->destroy_text_window = text_window_destroy;
    funnel_ops_->add_button = text_window_add_button;
    funnel_ops_->new_dialog = string_dialog_new;
    funnel_ops_->close_dialogs = string_dialogs_close;
    funnel_ops_->logger = funnel_statistics_logger;
}
void Singleton::f3();{
            }
        }
    }
void
register_tap_listener_qt_funnel(void)
}
void Singleton::f4();{
            if (funnel_action->callback() == callback) {
                // Must set back to title to find the correct sub-menu in Tools
                funnel_action->setText(funnel_action->title());
                wsApp->removeDynamicMenuGroupItem(group, funnel_action);
                it = funnel_actions_[group].erase(it);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
static gboolean menus_registered = FALSE;
struct _funnel_ops_id_t {
    FunnelStatistics *funnel_statistics;
FunnelStatistics::FunnelStatistics(QObject *parent, CaptureFile &cf) :
    QObject(parent),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    funnel_ops_->reload_packets = funnel_statistics_reload_packets;
    funnel_ops_->reload_lua_plugins = funnel_statistics_reload_lua_plugins;
    funnel_ops_->apply_filter = funnel_statistics_apply_filter;
    funnel_ops_->browser_open_url = browser_open_url;
    funnel_ops_->browser_open_data_file = browser_open_data_file;
}
void Singleton::f2();{
    funnel_ops_->destroy_text_window = text_window_destroy;
    funnel_ops_->add_button = text_window_add_button;
    funnel_ops_->new_dialog = string_dialog_new;
    funnel_ops_->close_dialogs = string_dialogs_close;
    funnel_ops_->logger = funnel_statistics_logger;
}
void Singleton::f3();{
            }
        }
    }
void
register_tap_listener_qt_funnel(void)
}
void Singleton::f4();{
            if (funnel_action->callback() == callback) {
                // Must set back to title to find the correct sub-menu in Tools
                funnel_action->setText(funnel_action->title());
                wsApp->removeDynamicMenuGroupItem(group, funnel_action);
                it = funnel_actions_[group].erase(it);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
static gboolean menus_registered = FALSE;
struct _funnel_ops_id_t {
    FunnelStatistics *funnel_statistics;
FunnelStatistics::FunnelStatistics(QObject *parent, CaptureFile &cf) :
    QObject(parent),
}
void Singleton::f7();{
const QString FunnelStatistics::action_name_ = "FunnelStatisticsAction";
static gboolean menus_registered = FALSE;
struct _funnel_ops_id_t {
    FunnelStatistics *funnel_statistics;
FunnelStatistics::FunnelStatistics(QObject *parent, CaptureFile &cf) :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    funnel_ops_->reload_packets = funnel_statistics_reload_packets;
    funnel_ops_->reload_lua_plugins = funnel_statistics_reload_lua_plugins;
    funnel_ops_->apply_filter = funnel_statistics_apply_filter;
    funnel_ops_->browser_open_url = browser_open_url;
    funnel_ops_->browser_open_data_file = browser_open_data_file;
}
void Singleton::f2();{
    funnel_ops_->destroy_text_window = text_window_destroy;
    funnel_ops_->add_button = text_window_add_button;
    funnel_ops_->new_dialog = string_dialog_new;
    funnel_ops_->close_dialogs = string_dialogs_close;
    funnel_ops_->logger = funnel_statistics_logger;
}
void Singleton::f3();{
            }
        }
    }
void
register_tap_listener_qt_funnel(void)
}
void Singleton::f4();{
            if (funnel_action->callback() == callback) {
                // Must set back to title to find the correct sub-menu in Tools
                funnel_action->setText(funnel_action->title());
                wsApp->removeDynamicMenuGroupItem(group, funnel_action);
                it = funnel_actions_[group].erase(it);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
static gboolean menus_registered = FALSE;
struct _funnel_ops_id_t {
    FunnelStatistics *funnel_statistics;
FunnelStatistics::FunnelStatistics(QObject *parent, CaptureFile &cf) :
    QObject(parent),
}
void Singleton::f7();{
const QString FunnelStatistics::action_name_ = "FunnelStatisticsAction";
static gboolean menus_registered = FALSE;
struct _funnel_ops_id_t {
    FunnelStatistics *funnel_statistics;
FunnelStatistics::FunnelStatistics(QObject *parent, CaptureFile &cf) :
}
void Singleton::f8();{
// - Handle menu paths. Do we create a new path (GTK+) or use the base element?
// - Add a FunnelGraphDialog class?
extern "C" {
static void funnel_statistics_logger(const gchar *, GLogLevelFlags, const gchar *message, gpointer);
static void funnel_statistics_retap_packets(funnel_ops_id_t *ops_id);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    funnel_ops_->reload_packets = funnel_statistics_reload_packets;
    funnel_ops_->reload_lua_plugins = funnel_statistics_reload_lua_plugins;
    funnel_ops_->apply_filter = funnel_statistics_apply_filter;
    funnel_ops_->browser_open_url = browser_open_url;
    funnel_ops_->browser_open_data_file = browser_open_data_file;
}
void Singleton::f2();{
    funnel_ops_->destroy_text_window = text_window_destroy;
    funnel_ops_->add_button = text_window_add_button;
    funnel_ops_->new_dialog = string_dialog_new;
    funnel_ops_->close_dialogs = string_dialogs_close;
    funnel_ops_->logger = funnel_statistics_logger;
}
void Singleton::f3();{
            }
        }
    }
void
register_tap_listener_qt_funnel(void)
}
void Singleton::f4();{
            if (funnel_action->callback() == callback) {
                // Must set back to title to find the correct sub-menu in Tools
                funnel_action->setText(funnel_action->title());
                wsApp->removeDynamicMenuGroupItem(group, funnel_action);
                it = funnel_actions_[group].erase(it);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
static gboolean menus_registered = FALSE;
struct _funnel_ops_id_t {
    FunnelStatistics *funnel_statistics;
FunnelStatistics::FunnelStatistics(QObject *parent, CaptureFile &cf) :
    QObject(parent),
}
void Singleton::f7();{
const QString FunnelStatistics::action_name_ = "FunnelStatisticsAction";
static gboolean menus_registered = FALSE;
struct _funnel_ops_id_t {
    FunnelStatistics *funnel_statistics;
FunnelStatistics::FunnelStatistics(QObject *parent, CaptureFile &cf) :
}
void Singleton::f8();{
// - Handle menu paths. Do we create a new path (GTK+) or use the base element?
// - Add a FunnelGraphDialog class?
extern "C" {
static void funnel_statistics_logger(const gchar *, GLogLevelFlags, const gchar *message, gpointer);
static void funnel_statistics_retap_packets(funnel_ops_id_t *ops_id);
}
void Singleton::f9();{
void funnel_statistics_apply_filter(funnel_ops_id_t *ops_id) {
    if (!ops_id || !ops_id->funnel_statistics) return;
    ops_id->funnel_statistics->emitApplyDisplayFilter();
gboolean browser_open_url(const gchar *url) {
    return QDesktopServices::openUrl(QUrl(url)) ? TRUE : FALSE;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        QLabel *field_label = new QLabel(field_name, this);
        ui->stringGridLayout->addWidget(field_label, row, 0);
        QLineEdit *field_edit = new QLineEdit(this);
        field_edit->setMinimumWidth(one_em * min_edit_width_);
        field_edits_ << field_edit;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        QLabel *field_label = new QLabel(field_name, this);
        ui->stringGridLayout->addWidget(field_label, row, 0);
        QLineEdit *field_edit = new QLineEdit(this);
        field_edit->setMinimumWidth(one_em * min_edit_width_);
        field_edits_ << field_edit;
}
void Singleton::f2();{
void FunnelStringDialog::on_buttonBox_accepted()
    if (!dialog_cb_) return;
    GPtrArray* returns = g_ptr_array_new();
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
}
void Singleton::f3();{
FunnelStringDialog::~FunnelStringDialog()
    if (dialog_cb_data_free_) {
        dialog_cb_data_free_(dialog_cb_data_);
    }
    delete ui;
}
void Singleton::f4();{
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
    }
    g_ptr_array_add(returns, NULL);
    gchar **user_input = (gchar **)g_ptr_array_free(returns, FALSE);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    deleteLater();
void FunnelStringDialog::reject()
    QDialog::reject();
    disconnect();
    deleteLater();
}
void Singleton::f7();{
    QDialog(NULL),
    ui(new Ui::FunnelStringDialog),
    dialog_cb_(dialog_cb),
    dialog_cb_data_(dialog_cb_data),
    dialog_cb_data_free_(dialog_data_free_cb)
}
void Singleton::f8();{
    delete ui;
void FunnelStringDialog::accept()
    QDialog::accept();
    disconnect();
    deleteLater();
}
void Singleton::f9();{
        ui->stringGridLayout->addWidget(field_edit, row, 1);
        row++;
    }
FunnelStringDialog::~FunnelStringDialog()
    if (dialog_cb_data_free_) {
}
void Singleton::f10();{
    disconnect();
    deleteLater();
void FunnelStringDialog::reject()
    QDialog::reject();
    disconnect();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        QLabel *field_label = new QLabel(field_name, this);
        ui->stringGridLayout->addWidget(field_label, row, 0);
        QLineEdit *field_edit = new QLineEdit(this);
        field_edit->setMinimumWidth(one_em * min_edit_width_);
        field_edits_ << field_edit;
}
void Singleton::f2();{
void FunnelStringDialog::on_buttonBox_accepted()
    if (!dialog_cb_) return;
    GPtrArray* returns = g_ptr_array_new();
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        QLabel *field_label = new QLabel(field_name, this);
        ui->stringGridLayout->addWidget(field_label, row, 0);
        QLineEdit *field_edit = new QLineEdit(this);
        field_edit->setMinimumWidth(one_em * min_edit_width_);
        field_edits_ << field_edit;
}
void Singleton::f2();{
void FunnelStringDialog::on_buttonBox_accepted()
    if (!dialog_cb_) return;
    GPtrArray* returns = g_ptr_array_new();
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
}
void Singleton::f3();{
FunnelStringDialog::~FunnelStringDialog()
    if (dialog_cb_data_free_) {
        dialog_cb_data_free_(dialog_cb_data_);
    }
    delete ui;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        QLabel *field_label = new QLabel(field_name, this);
        ui->stringGridLayout->addWidget(field_label, row, 0);
        QLineEdit *field_edit = new QLineEdit(this);
        field_edit->setMinimumWidth(one_em * min_edit_width_);
        field_edits_ << field_edit;
}
void Singleton::f2();{
void FunnelStringDialog::on_buttonBox_accepted()
    if (!dialog_cb_) return;
    GPtrArray* returns = g_ptr_array_new();
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
}
void Singleton::f3();{
FunnelStringDialog::~FunnelStringDialog()
    if (dialog_cb_data_free_) {
        dialog_cb_data_free_(dialog_cb_data_);
    }
    delete ui;
}
void Singleton::f4();{
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
    }
    g_ptr_array_add(returns, NULL);
    gchar **user_input = (gchar **)g_ptr_array_free(returns, FALSE);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        QLabel *field_label = new QLabel(field_name, this);
        ui->stringGridLayout->addWidget(field_label, row, 0);
        QLineEdit *field_edit = new QLineEdit(this);
        field_edit->setMinimumWidth(one_em * min_edit_width_);
        field_edits_ << field_edit;
}
void Singleton::f2();{
void FunnelStringDialog::on_buttonBox_accepted()
    if (!dialog_cb_) return;
    GPtrArray* returns = g_ptr_array_new();
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
}
void Singleton::f3();{
FunnelStringDialog::~FunnelStringDialog()
    if (dialog_cb_data_free_) {
        dialog_cb_data_free_(dialog_cb_data_);
    }
    delete ui;
}
void Singleton::f4();{
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
    }
    g_ptr_array_add(returns, NULL);
    gchar **user_input = (gchar **)g_ptr_array_free(returns, FALSE);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        QLabel *field_label = new QLabel(field_name, this);
        ui->stringGridLayout->addWidget(field_label, row, 0);
        QLineEdit *field_edit = new QLineEdit(this);
        field_edit->setMinimumWidth(one_em * min_edit_width_);
        field_edits_ << field_edit;
}
void Singleton::f2();{
void FunnelStringDialog::on_buttonBox_accepted()
    if (!dialog_cb_) return;
    GPtrArray* returns = g_ptr_array_new();
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
}
void Singleton::f3();{
FunnelStringDialog::~FunnelStringDialog()
    if (dialog_cb_data_free_) {
        dialog_cb_data_free_(dialog_cb_data_);
    }
    delete ui;
}
void Singleton::f4();{
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
    }
    g_ptr_array_add(returns, NULL);
    gchar **user_input = (gchar **)g_ptr_array_free(returns, FALSE);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    deleteLater();
void FunnelStringDialog::reject()
    QDialog::reject();
    disconnect();
    deleteLater();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        QLabel *field_label = new QLabel(field_name, this);
        ui->stringGridLayout->addWidget(field_label, row, 0);
        QLineEdit *field_edit = new QLineEdit(this);
        field_edit->setMinimumWidth(one_em * min_edit_width_);
        field_edits_ << field_edit;
}
void Singleton::f2();{
void FunnelStringDialog::on_buttonBox_accepted()
    if (!dialog_cb_) return;
    GPtrArray* returns = g_ptr_array_new();
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
}
void Singleton::f3();{
FunnelStringDialog::~FunnelStringDialog()
    if (dialog_cb_data_free_) {
        dialog_cb_data_free_(dialog_cb_data_);
    }
    delete ui;
}
void Singleton::f4();{
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
    }
    g_ptr_array_add(returns, NULL);
    gchar **user_input = (gchar **)g_ptr_array_free(returns, FALSE);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    deleteLater();
void FunnelStringDialog::reject()
    QDialog::reject();
    disconnect();
    deleteLater();
}
void Singleton::f7();{
    QDialog(NULL),
    ui(new Ui::FunnelStringDialog),
    dialog_cb_(dialog_cb),
    dialog_cb_data_(dialog_cb_data),
    dialog_cb_data_free_(dialog_data_free_cb)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        QLabel *field_label = new QLabel(field_name, this);
        ui->stringGridLayout->addWidget(field_label, row, 0);
        QLineEdit *field_edit = new QLineEdit(this);
        field_edit->setMinimumWidth(one_em * min_edit_width_);
        field_edits_ << field_edit;
}
void Singleton::f2();{
void FunnelStringDialog::on_buttonBox_accepted()
    if (!dialog_cb_) return;
    GPtrArray* returns = g_ptr_array_new();
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
}
void Singleton::f3();{
FunnelStringDialog::~FunnelStringDialog()
    if (dialog_cb_data_free_) {
        dialog_cb_data_free_(dialog_cb_data_);
    }
    delete ui;
}
void Singleton::f4();{
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
    }
    g_ptr_array_add(returns, NULL);
    gchar **user_input = (gchar **)g_ptr_array_free(returns, FALSE);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    deleteLater();
void FunnelStringDialog::reject()
    QDialog::reject();
    disconnect();
    deleteLater();
}
void Singleton::f7();{
    QDialog(NULL),
    ui(new Ui::FunnelStringDialog),
    dialog_cb_(dialog_cb),
    dialog_cb_data_(dialog_cb_data),
    dialog_cb_data_free_(dialog_data_free_cb)
}
void Singleton::f8();{
    delete ui;
void FunnelStringDialog::accept()
    QDialog::accept();
    disconnect();
    deleteLater();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        QLabel *field_label = new QLabel(field_name, this);
        ui->stringGridLayout->addWidget(field_label, row, 0);
        QLineEdit *field_edit = new QLineEdit(this);
        field_edit->setMinimumWidth(one_em * min_edit_width_);
        field_edits_ << field_edit;
}
void Singleton::f2();{
void FunnelStringDialog::on_buttonBox_accepted()
    if (!dialog_cb_) return;
    GPtrArray* returns = g_ptr_array_new();
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
}
void Singleton::f3();{
FunnelStringDialog::~FunnelStringDialog()
    if (dialog_cb_data_free_) {
        dialog_cb_data_free_(dialog_cb_data_);
    }
    delete ui;
}
void Singleton::f4();{
    foreach (QLineEdit *field_edit, field_edits_) {
        g_ptr_array_add(returns, qstring_strdup(field_edit->text()));
    }
    g_ptr_array_add(returns, NULL);
    gchar **user_input = (gchar **)g_ptr_array_free(returns, FALSE);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    deleteLater();
void FunnelStringDialog::reject()
    QDialog::reject();
    disconnect();
    deleteLater();
}
void Singleton::f7();{
    QDialog(NULL),
    ui(new Ui::FunnelStringDialog),
    dialog_cb_(dialog_cb),
    dialog_cb_data_(dialog_cb_data),
    dialog_cb_data_free_(dialog_data_free_cb)
}
void Singleton::f8();{
    delete ui;
void FunnelStringDialog::accept()
    QDialog::accept();
    disconnect();
    deleteLater();
}
void Singleton::f9();{
        ui->stringGridLayout->addWidget(field_edit, row, 1);
        row++;
    }
FunnelStringDialog::~FunnelStringDialog()
    if (dialog_cb_data_free_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
    for (i = text_button_to_funnel_button_.begin(); i != text_button_to_funnel_button_.end(); ++i) {
        funnel_bt_t *funnel_button = i.value();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
    for (i = text_button_to_funnel_button_.begin(); i != text_button_to_funnel_button_.end(); ++i) {
        funnel_bt_t *funnel_button = i.value();
}
void Singleton::f2();{
    QPushButton *button = new QPushButton(label);
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
}
void Singleton::f3();{
    FunnelTextDialog *ftd = new FunnelTextDialog(title);
    ftd->show();
    return &ftd->funnel_text_window_;
void FunnelTextDialog::setText(const QString text)
    ui->textEdit->setText(text);
}
void Singleton::f4();{
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
    if (text_button_to_funnel_button_.contains(sender())) {
}
void Singleton::f5();{
static QHash<QObject *, funnel_bt_t*> text_button_to_funnel_button_;
FunnelTextDialog::FunnelTextDialog(const QString &title) :
    GeometryStateDialog(NULL),
    ui(new Ui::FunnelTextDialog),
    close_cb_(NULL),
}
void Singleton::f6();{
    QDialog::reject();
    if (close_cb_) {
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
}
void Singleton::f7();{
void text_window_prepend(funnel_text_window_t *ftw, const char* text)
    if (ftw) {
        ftw->funnel_text_dialog->prependText(text);
    }
void text_window_clear(funnel_text_window_t* ftw)
}
void Singleton::f8();{
    // Apply new highlighting
    if (!pattern.isEmpty()) {
        int match_pos = 0;
        while ((match_pos = re.indexIn(ui->textEdit->toPlainText(), match_pos)) > -1) {
            csr.setPosition(match_pos, QTextCursor::MoveAnchor);
}
void Singleton::f9();{
    highlight_fmt.setBackground(Qt::yellow);
    QTextCursor csr(ui->textEdit->document());
    int position = csr.position();
    setUpdatesEnabled(false);
    // Reset highlighting
}
void Singleton::f10();{
void text_window_prepend(funnel_text_window_t *ftw, const char* text)
    if (ftw) {
        ftw->funnel_text_dialog->prependText(text);
    }
void text_window_clear(funnel_text_window_t* ftw)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
    for (i = text_button_to_funnel_button_.begin(); i != text_button_to_funnel_button_.end(); ++i) {
        funnel_bt_t *funnel_button = i.value();
}
void Singleton::f2();{
    QPushButton *button = new QPushButton(label);
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
    for (i = text_button_to_funnel_button_.begin(); i != text_button_to_funnel_button_.end(); ++i) {
        funnel_bt_t *funnel_button = i.value();
}
void Singleton::f2();{
    QPushButton *button = new QPushButton(label);
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
}
void Singleton::f3();{
    FunnelTextDialog *ftd = new FunnelTextDialog(title);
    ftd->show();
    return &ftd->funnel_text_window_;
void FunnelTextDialog::setText(const QString text)
    ui->textEdit->setText(text);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
    for (i = text_button_to_funnel_button_.begin(); i != text_button_to_funnel_button_.end(); ++i) {
        funnel_bt_t *funnel_button = i.value();
}
void Singleton::f2();{
    QPushButton *button = new QPushButton(label);
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
}
void Singleton::f3();{
    FunnelTextDialog *ftd = new FunnelTextDialog(title);
    ftd->show();
    return &ftd->funnel_text_window_;
void FunnelTextDialog::setText(const QString text)
    ui->textEdit->setText(text);
}
void Singleton::f4();{
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
    if (text_button_to_funnel_button_.contains(sender())) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
    for (i = text_button_to_funnel_button_.begin(); i != text_button_to_funnel_button_.end(); ++i) {
        funnel_bt_t *funnel_button = i.value();
}
void Singleton::f2();{
    QPushButton *button = new QPushButton(label);
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
}
void Singleton::f3();{
    FunnelTextDialog *ftd = new FunnelTextDialog(title);
    ftd->show();
    return &ftd->funnel_text_window_;
void FunnelTextDialog::setText(const QString text)
    ui->textEdit->setText(text);
}
void Singleton::f4();{
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
    if (text_button_to_funnel_button_.contains(sender())) {
}
void Singleton::f5();{
static QHash<QObject *, funnel_bt_t*> text_button_to_funnel_button_;
FunnelTextDialog::FunnelTextDialog(const QString &title) :
    GeometryStateDialog(NULL),
    ui(new Ui::FunnelTextDialog),
    close_cb_(NULL),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
    for (i = text_button_to_funnel_button_.begin(); i != text_button_to_funnel_button_.end(); ++i) {
        funnel_bt_t *funnel_button = i.value();
}
void Singleton::f2();{
    QPushButton *button = new QPushButton(label);
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
}
void Singleton::f3();{
    FunnelTextDialog *ftd = new FunnelTextDialog(title);
    ftd->show();
    return &ftd->funnel_text_window_;
void FunnelTextDialog::setText(const QString text)
    ui->textEdit->setText(text);
}
void Singleton::f4();{
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
    if (text_button_to_funnel_button_.contains(sender())) {
}
void Singleton::f5();{
static QHash<QObject *, funnel_bt_t*> text_button_to_funnel_button_;
FunnelTextDialog::FunnelTextDialog(const QString &title) :
    GeometryStateDialog(NULL),
    ui(new Ui::FunnelTextDialog),
    close_cb_(NULL),
}
void Singleton::f6();{
    QDialog::reject();
    if (close_cb_) {
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
    for (i = text_button_to_funnel_button_.begin(); i != text_button_to_funnel_button_.end(); ++i) {
        funnel_bt_t *funnel_button = i.value();
}
void Singleton::f2();{
    QPushButton *button = new QPushButton(label);
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
}
void Singleton::f3();{
    FunnelTextDialog *ftd = new FunnelTextDialog(title);
    ftd->show();
    return &ftd->funnel_text_window_;
void FunnelTextDialog::setText(const QString text)
    ui->textEdit->setText(text);
}
void Singleton::f4();{
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
    if (text_button_to_funnel_button_.contains(sender())) {
}
void Singleton::f5();{
static QHash<QObject *, funnel_bt_t*> text_button_to_funnel_button_;
FunnelTextDialog::FunnelTextDialog(const QString &title) :
    GeometryStateDialog(NULL),
    ui(new Ui::FunnelTextDialog),
    close_cb_(NULL),
}
void Singleton::f6();{
    QDialog::reject();
    if (close_cb_) {
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
}
void Singleton::f7();{
void text_window_prepend(funnel_text_window_t *ftw, const char* text)
    if (ftw) {
        ftw->funnel_text_dialog->prependText(text);
    }
void text_window_clear(funnel_text_window_t* ftw)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
    for (i = text_button_to_funnel_button_.begin(); i != text_button_to_funnel_button_.end(); ++i) {
        funnel_bt_t *funnel_button = i.value();
}
void Singleton::f2();{
    QPushButton *button = new QPushButton(label);
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
}
void Singleton::f3();{
    FunnelTextDialog *ftd = new FunnelTextDialog(title);
    ftd->show();
    return &ftd->funnel_text_window_;
void FunnelTextDialog::setText(const QString text)
    ui->textEdit->setText(text);
}
void Singleton::f4();{
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
    if (text_button_to_funnel_button_.contains(sender())) {
}
void Singleton::f5();{
static QHash<QObject *, funnel_bt_t*> text_button_to_funnel_button_;
FunnelTextDialog::FunnelTextDialog(const QString &title) :
    GeometryStateDialog(NULL),
    ui(new Ui::FunnelTextDialog),
    close_cb_(NULL),
}
void Singleton::f6();{
    QDialog::reject();
    if (close_cb_) {
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
}
void Singleton::f7();{
void text_window_prepend(funnel_text_window_t *ftw, const char* text)
    if (ftw) {
        ftw->funnel_text_dialog->prependText(text);
    }
void text_window_clear(funnel_text_window_t* ftw)
}
void Singleton::f8();{
    // Apply new highlighting
    if (!pattern.isEmpty()) {
        int match_pos = 0;
        while ((match_pos = re.indexIn(ui->textEdit->toPlainText(), match_pos)) > -1) {
            csr.setPosition(match_pos, QTextCursor::MoveAnchor);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
    for (i = text_button_to_funnel_button_.begin(); i != text_button_to_funnel_button_.end(); ++i) {
        funnel_bt_t *funnel_button = i.value();
}
void Singleton::f2();{
    QPushButton *button = new QPushButton(label);
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
}
void Singleton::f3();{
    FunnelTextDialog *ftd = new FunnelTextDialog(title);
    ftd->show();
    return &ftd->funnel_text_window_;
void FunnelTextDialog::setText(const QString text)
    ui->textEdit->setText(text);
}
void Singleton::f4();{
    ui->buttonBox->addButton(button, QDialogButtonBox::ActionRole);
    text_button_to_funnel_button_[button] = funnel_button;
    connect(button, SIGNAL(clicked(bool)), this, SLOT(buttonClicked()));
void FunnelTextDialog::buttonClicked()
    if (text_button_to_funnel_button_.contains(sender())) {
}
void Singleton::f5();{
static QHash<QObject *, funnel_bt_t*> text_button_to_funnel_button_;
FunnelTextDialog::FunnelTextDialog(const QString &title) :
    GeometryStateDialog(NULL),
    ui(new Ui::FunnelTextDialog),
    close_cb_(NULL),
}
void Singleton::f6();{
    QDialog::reject();
    if (close_cb_) {
        close_cb_(close_cb_data_);
    }
    QHash<QObject *, funnel_bt_t*>::iterator i;
}
void Singleton::f7();{
void text_window_prepend(funnel_text_window_t *ftw, const char* text)
    if (ftw) {
        ftw->funnel_text_dialog->prependText(text);
    }
void text_window_clear(funnel_text_window_t* ftw)
}
void Singleton::f8();{
    // Apply new highlighting
    if (!pattern.isEmpty()) {
        int match_pos = 0;
        while ((match_pos = re.indexIn(ui->textEdit->toPlainText(), match_pos)) > -1) {
            csr.setPosition(match_pos, QTextCursor::MoveAnchor);
}
void Singleton::f9();{
    highlight_fmt.setBackground(Qt::yellow);
    QTextCursor csr(ui->textEdit->document());
    int position = csr.position();
    setUpdatesEnabled(false);
    // Reset highlighting
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
            txtOut.close();
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
            txtOut.close();
        }
}
void Singleton::f2();{
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
            for (int jj = 0; jj < f64in.size(); ++jj) {
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
}
void Singleton::f3();{
 * [-inf, -maxflt, -1., -minflt, -minden, 0., minden, minflt, 1., maxflt, inf]
template <typename T>
std::vector<T>
generate_input_vector(std::string func)
    std::vector<T> input = {MINDEN,  -MINDEN, MINFLT, -MINFLT, MAXFLT,
}
void Singleton::f4();{
            // Single Precision
            auto f32in = generate_input_vector<float>(umathfunc[ii].name);
            auto f32out = computeTrueVal<float, double>(f32in,
                                                        umathfunc[ii].f32func);
            for (int jj = 0; jj < f32in.size(); ++jj) {
}
void Singleton::f5();{
        append_random_array<T>(input, 1.0, 2.0, 400);
        append_random_array<T>(input, 2.0, MAXFLT, 300);
    }
    // [-INF, INF]
    else {
}
void Singleton::f6();{
            }
            // Double Precision
            auto f64in = generate_input_vector<double>(umathfunc[ii].name);
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
}
void Singleton::f7();{
        append_random_array<T>(input, 1.0, MAXFLT, 200);
    }
    // (-1.0, INF]
    else if (func == "log1p") {
        append_random_array<T>(input, -1.0, 1.0, 200);
}
void Singleton::f8();{
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
}
void Singleton::f9();{
    long double (*f64func)(long double);
    float f32ulp;
    float f64ulp;
template <typename T>
RandomFloat(T a, T b)
}
void Singleton::f10();{
        append_random_array<T>(input, 1.0, MAXFLT, 100);
    }
    // [1.0, INF]
    else if (func == "arccosh") {
        append_random_array<T>(input, 1.0, 2.0, 400);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
            txtOut.close();
        }
}
void Singleton::f2();{
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
            for (int jj = 0; jj < f64in.size(); ++jj) {
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
            txtOut.close();
        }
}
void Singleton::f2();{
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
            for (int jj = 0; jj < f64in.size(); ++jj) {
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
}
void Singleton::f3();{
 * [-inf, -maxflt, -1., -minflt, -minden, 0., minden, minflt, 1., maxflt, inf]
template <typename T>
std::vector<T>
generate_input_vector(std::string func)
    std::vector<T> input = {MINDEN,  -MINDEN, MINFLT, -MINFLT, MAXFLT,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
            txtOut.close();
        }
}
void Singleton::f2();{
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
            for (int jj = 0; jj < f64in.size(); ++jj) {
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
}
void Singleton::f3();{
 * [-inf, -maxflt, -1., -minflt, -minden, 0., minden, minflt, 1., maxflt, inf]
template <typename T>
std::vector<T>
generate_input_vector(std::string func)
    std::vector<T> input = {MINDEN,  -MINDEN, MINFLT, -MINFLT, MAXFLT,
}
void Singleton::f4();{
            // Single Precision
            auto f32in = generate_input_vector<float>(umathfunc[ii].name);
            auto f32out = computeTrueVal<float, double>(f32in,
                                                        umathfunc[ii].f32func);
            for (int jj = 0; jj < f32in.size(); ++jj) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
            txtOut.close();
        }
}
void Singleton::f2();{
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
            for (int jj = 0; jj < f64in.size(); ++jj) {
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
}
void Singleton::f3();{
 * [-inf, -maxflt, -1., -minflt, -minden, 0., minden, minflt, 1., maxflt, inf]
template <typename T>
std::vector<T>
generate_input_vector(std::string func)
    std::vector<T> input = {MINDEN,  -MINDEN, MINFLT, -MINFLT, MAXFLT,
}
void Singleton::f4();{
            // Single Precision
            auto f32in = generate_input_vector<float>(umathfunc[ii].name);
            auto f32out = computeTrueVal<float, double>(f32in,
                                                        umathfunc[ii].f32func);
            for (int jj = 0; jj < f32in.size(); ++jj) {
}
void Singleton::f5();{
        append_random_array<T>(input, 1.0, 2.0, 400);
        append_random_array<T>(input, 2.0, MAXFLT, 300);
    }
    // [-INF, INF]
    else {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
            txtOut.close();
        }
}
void Singleton::f2();{
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
            for (int jj = 0; jj < f64in.size(); ++jj) {
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
}
void Singleton::f3();{
 * [-inf, -maxflt, -1., -minflt, -minden, 0., minden, minflt, 1., maxflt, inf]
template <typename T>
std::vector<T>
generate_input_vector(std::string func)
    std::vector<T> input = {MINDEN,  -MINDEN, MINFLT, -MINFLT, MAXFLT,
}
void Singleton::f4();{
            // Single Precision
            auto f32in = generate_input_vector<float>(umathfunc[ii].name);
            auto f32out = computeTrueVal<float, double>(f32in,
                                                        umathfunc[ii].f32func);
            for (int jj = 0; jj < f32in.size(); ++jj) {
}
void Singleton::f5();{
        append_random_array<T>(input, 1.0, 2.0, 400);
        append_random_array<T>(input, 2.0, MAXFLT, 300);
    }
    // [-INF, INF]
    else {
}
void Singleton::f6();{
            }
            // Double Precision
            auto f64in = generate_input_vector<double>(umathfunc[ii].name);
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
            txtOut.close();
        }
}
void Singleton::f2();{
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
            for (int jj = 0; jj < f64in.size(); ++jj) {
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
}
void Singleton::f3();{
 * [-inf, -maxflt, -1., -minflt, -minden, 0., minden, minflt, 1., maxflt, inf]
template <typename T>
std::vector<T>
generate_input_vector(std::string func)
    std::vector<T> input = {MINDEN,  -MINDEN, MINFLT, -MINFLT, MAXFLT,
}
void Singleton::f4();{
            // Single Precision
            auto f32in = generate_input_vector<float>(umathfunc[ii].name);
            auto f32out = computeTrueVal<float, double>(f32in,
                                                        umathfunc[ii].f32func);
            for (int jj = 0; jj < f32in.size(); ++jj) {
}
void Singleton::f5();{
        append_random_array<T>(input, 1.0, 2.0, 400);
        append_random_array<T>(input, 2.0, MAXFLT, 300);
    }
    // [-INF, INF]
    else {
}
void Singleton::f6();{
            }
            // Double Precision
            auto f64in = generate_input_vector<double>(umathfunc[ii].name);
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
}
void Singleton::f7();{
        append_random_array<T>(input, 1.0, MAXFLT, 200);
    }
    // (-1.0, INF]
    else if (func == "log1p") {
        append_random_array<T>(input, -1.0, 1.0, 200);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
            txtOut.close();
        }
}
void Singleton::f2();{
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
            for (int jj = 0; jj < f64in.size(); ++jj) {
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
}
void Singleton::f3();{
 * [-inf, -maxflt, -1., -minflt, -minden, 0., minden, minflt, 1., maxflt, inf]
template <typename T>
std::vector<T>
generate_input_vector(std::string func)
    std::vector<T> input = {MINDEN,  -MINDEN, MINFLT, -MINFLT, MAXFLT,
}
void Singleton::f4();{
            // Single Precision
            auto f32in = generate_input_vector<float>(umathfunc[ii].name);
            auto f32out = computeTrueVal<float, double>(f32in,
                                                        umathfunc[ii].f32func);
            for (int jj = 0; jj < f32in.size(); ++jj) {
}
void Singleton::f5();{
        append_random_array<T>(input, 1.0, 2.0, 400);
        append_random_array<T>(input, 2.0, MAXFLT, 300);
    }
    // [-INF, INF]
    else {
}
void Singleton::f6();{
            }
            // Double Precision
            auto f64in = generate_input_vector<double>(umathfunc[ii].name);
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
}
void Singleton::f7();{
        append_random_array<T>(input, 1.0, MAXFLT, 200);
    }
    // (-1.0, INF]
    else if (func == "log1p") {
        append_random_array<T>(input, -1.0, 1.0, 200);
}
void Singleton::f8();{
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
            txtOut.close();
        }
}
void Singleton::f2();{
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
            for (int jj = 0; jj < f64in.size(); ++jj) {
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
}
void Singleton::f3();{
 * [-inf, -maxflt, -1., -minflt, -minden, 0., minden, minflt, 1., maxflt, inf]
template <typename T>
std::vector<T>
generate_input_vector(std::string func)
    std::vector<T> input = {MINDEN,  -MINDEN, MINFLT, -MINFLT, MAXFLT,
}
void Singleton::f4();{
            // Single Precision
            auto f32in = generate_input_vector<float>(umathfunc[ii].name);
            auto f32out = computeTrueVal<float, double>(f32in,
                                                        umathfunc[ii].f32func);
            for (int jj = 0; jj < f32in.size(); ++jj) {
}
void Singleton::f5();{
        append_random_array<T>(input, 1.0, 2.0, 400);
        append_random_array<T>(input, 2.0, MAXFLT, 300);
    }
    // [-INF, INF]
    else {
}
void Singleton::f6();{
            }
            // Double Precision
            auto f64in = generate_input_vector<double>(umathfunc[ii].name);
            auto f64out = computeTrueVal<double, long double>(
                    f64in, umathfunc[ii].f64func);
}
void Singleton::f7();{
        append_random_array<T>(input, 1.0, MAXFLT, 200);
    }
    // (-1.0, INF]
    else if (func == "log1p") {
        append_random_array<T>(input, -1.0, 1.0, 200);
}
void Singleton::f8();{
                txtOut << "np.float64" << std::hex << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64in[jj]) << ",0x"
                       << *reinterpret_cast<uint64_t *>(&f64out[jj]) << ","
                       << ceil(umathfunc[ii].f64ulp) << std::endl;
            }
}
void Singleton::f9();{
    long double (*f64func)(long double);
    float f32ulp;
    float f64ulp;
template <typename T>
RandomFloat(T a, T b)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        Types.NestedField nestedField) {
"      int keyId = -1, valueId = -1;"
      if (col.getType().isMapType()) {
        // Get key id and value id for Map type.
        Preconditions.checkState(nestedField.type().isMapType());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        Types.NestedField nestedField) {
"      int keyId = -1, valueId = -1;"
      if (col.getType().isMapType()) {
        // Get key id and value id for Map type.
        Preconditions.checkState(nestedField.type().isMapType());
}
void Singleton::f2();{
"XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);"
   XXH32_hash_t large_len;    /*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) */
}
void Singleton::f3();{
"          ""isRecursive"": False"
        }
"      },"
"      ""dataMaskPolicyItems"": ["
        {
}
void Singleton::f4();{
"                        uint16_t default_port,"
                        std::vector<Sockaddr>* addresses);
// Return true if the given port is likely to need root privileges to bind to.
bool IsPrivilegedPort(uint16_t port);
// Return the local machine's hostname.
}
void Singleton::f5();{
[[prerequisites_and_requirements]]
== Prerequisites and Requirements
.Hardware
- One or more hosts to run Kudu masters. It is recommended to have either one master (no fault
"tolerance), or three masters (can tolerate one failure). The number of masters must be odd."
}
void Singleton::f6();{
    }
"    rpc->table()->AddTask(rpc->tablet_id(), rpc);"
"    WARN_NOT_OK(rpc->Run(), Substitute(""Failed to send  0"", rpc->description()));"
  // 16. Invalidate corresponding entries in the table locations cache.
  if (table_locations_cache_) {
}
void Singleton::f7();{
"      return SetupError(Status::InvalidArgument(""missing table ID or table name""),"
"                        response, MasterErrorPB::UNKNOWN_ERROR);"
    }
"  // If the table doesn't exist, don't attempt to lock it."
  //
}
void Singleton::f8();{
//////////////////////////////
message TabletLocationsPB {
  // DEPRECATED.
  // TODO: new clients should prefer the 'Interned' type below.
  // Remove 'ReplicaPB' when we stop using it internally.
}
void Singleton::f9();{
          CALLBACK_AND_RETURN(
"              Status::IllegalState(""consensus unavailable: tablet not running"", tablet_id));"
        }
        boost::optional<OpId> opt_last_logged_opid = consensus->GetLastOpId(RECEIVED_OPID);
        if (!opt_last_logged_opid) {
}
void Singleton::f10();{
  // Write YAML content to file  {KUDU_CONFIG}/kudurc.
  void PrepareConfigFile(const string& content) {
"    string fname = GetTestPath(""kudurc"");"
    unique_ptr<WritableFile> writable_file;
"    ASSERT_OK(env_->NewWritableFile(fname, &writable_file));"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        Types.NestedField nestedField) {
"      int keyId = -1, valueId = -1;"
      if (col.getType().isMapType()) {
        // Get key id and value id for Map type.
        Preconditions.checkState(nestedField.type().isMapType());
}
void Singleton::f2();{
"XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);"
   XXH32_hash_t large_len;    /*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        Types.NestedField nestedField) {
"      int keyId = -1, valueId = -1;"
      if (col.getType().isMapType()) {
        // Get key id and value id for Map type.
        Preconditions.checkState(nestedField.type().isMapType());
}
void Singleton::f2();{
"XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);"
   XXH32_hash_t large_len;    /*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) */
}
void Singleton::f3();{
"          ""isRecursive"": False"
        }
"      },"
"      ""dataMaskPolicyItems"": ["
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        Types.NestedField nestedField) {
"      int keyId = -1, valueId = -1;"
      if (col.getType().isMapType()) {
        // Get key id and value id for Map type.
        Preconditions.checkState(nestedField.type().isMapType());
}
void Singleton::f2();{
"XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);"
   XXH32_hash_t large_len;    /*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) */
}
void Singleton::f3();{
"          ""isRecursive"": False"
        }
"      },"
"      ""dataMaskPolicyItems"": ["
        {
}
void Singleton::f4();{
"                        uint16_t default_port,"
                        std::vector<Sockaddr>* addresses);
// Return true if the given port is likely to need root privileges to bind to.
bool IsPrivilegedPort(uint16_t port);
// Return the local machine's hostname.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        Types.NestedField nestedField) {
"      int keyId = -1, valueId = -1;"
      if (col.getType().isMapType()) {
        // Get key id and value id for Map type.
        Preconditions.checkState(nestedField.type().isMapType());
}
void Singleton::f2();{
"XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);"
   XXH32_hash_t large_len;    /*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) */
}
void Singleton::f3();{
"          ""isRecursive"": False"
        }
"      },"
"      ""dataMaskPolicyItems"": ["
        {
}
void Singleton::f4();{
"                        uint16_t default_port,"
                        std::vector<Sockaddr>* addresses);
// Return true if the given port is likely to need root privileges to bind to.
bool IsPrivilegedPort(uint16_t port);
// Return the local machine's hostname.
}
void Singleton::f5();{
[[prerequisites_and_requirements]]
== Prerequisites and Requirements
.Hardware
- One or more hosts to run Kudu masters. It is recommended to have either one master (no fault
"tolerance), or three masters (can tolerate one failure). The number of masters must be odd."
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        Types.NestedField nestedField) {
"      int keyId = -1, valueId = -1;"
      if (col.getType().isMapType()) {
        // Get key id and value id for Map type.
        Preconditions.checkState(nestedField.type().isMapType());
}
void Singleton::f2();{
"XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);"
   XXH32_hash_t large_len;    /*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) */
}
void Singleton::f3();{
"          ""isRecursive"": False"
        }
"      },"
"      ""dataMaskPolicyItems"": ["
        {
}
void Singleton::f4();{
"                        uint16_t default_port,"
                        std::vector<Sockaddr>* addresses);
// Return true if the given port is likely to need root privileges to bind to.
bool IsPrivilegedPort(uint16_t port);
// Return the local machine's hostname.
}
void Singleton::f5();{
[[prerequisites_and_requirements]]
== Prerequisites and Requirements
.Hardware
- One or more hosts to run Kudu masters. It is recommended to have either one master (no fault
"tolerance), or three masters (can tolerate one failure). The number of masters must be odd."
}
void Singleton::f6();{
    }
"    rpc->table()->AddTask(rpc->tablet_id(), rpc);"
"    WARN_NOT_OK(rpc->Run(), Substitute(""Failed to send  0"", rpc->description()));"
  // 16. Invalidate corresponding entries in the table locations cache.
  if (table_locations_cache_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        Types.NestedField nestedField) {
"      int keyId = -1, valueId = -1;"
      if (col.getType().isMapType()) {
        // Get key id and value id for Map type.
        Preconditions.checkState(nestedField.type().isMapType());
}
void Singleton::f2();{
"XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);"
   XXH32_hash_t large_len;    /*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) */
}
void Singleton::f3();{
"          ""isRecursive"": False"
        }
"      },"
"      ""dataMaskPolicyItems"": ["
        {
}
void Singleton::f4();{
"                        uint16_t default_port,"
                        std::vector<Sockaddr>* addresses);
// Return true if the given port is likely to need root privileges to bind to.
bool IsPrivilegedPort(uint16_t port);
// Return the local machine's hostname.
}
void Singleton::f5();{
[[prerequisites_and_requirements]]
== Prerequisites and Requirements
.Hardware
- One or more hosts to run Kudu masters. It is recommended to have either one master (no fault
"tolerance), or three masters (can tolerate one failure). The number of masters must be odd."
}
void Singleton::f6();{
    }
"    rpc->table()->AddTask(rpc->tablet_id(), rpc);"
"    WARN_NOT_OK(rpc->Run(), Substitute(""Failed to send  0"", rpc->description()));"
  // 16. Invalidate corresponding entries in the table locations cache.
  if (table_locations_cache_) {
}
void Singleton::f7();{
"      return SetupError(Status::InvalidArgument(""missing table ID or table name""),"
"                        response, MasterErrorPB::UNKNOWN_ERROR);"
    }
"  // If the table doesn't exist, don't attempt to lock it."
  //
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        Types.NestedField nestedField) {
"      int keyId = -1, valueId = -1;"
      if (col.getType().isMapType()) {
        // Get key id and value id for Map type.
        Preconditions.checkState(nestedField.type().isMapType());
}
void Singleton::f2();{
"XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);"
   XXH32_hash_t large_len;    /*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) */
}
void Singleton::f3();{
"          ""isRecursive"": False"
        }
"      },"
"      ""dataMaskPolicyItems"": ["
        {
}
void Singleton::f4();{
"                        uint16_t default_port,"
                        std::vector<Sockaddr>* addresses);
// Return true if the given port is likely to need root privileges to bind to.
bool IsPrivilegedPort(uint16_t port);
// Return the local machine's hostname.
}
void Singleton::f5();{
[[prerequisites_and_requirements]]
== Prerequisites and Requirements
.Hardware
- One or more hosts to run Kudu masters. It is recommended to have either one master (no fault
"tolerance), or three masters (can tolerate one failure). The number of masters must be odd."
}
void Singleton::f6();{
    }
"    rpc->table()->AddTask(rpc->tablet_id(), rpc);"
"    WARN_NOT_OK(rpc->Run(), Substitute(""Failed to send  0"", rpc->description()));"
  // 16. Invalidate corresponding entries in the table locations cache.
  if (table_locations_cache_) {
}
void Singleton::f7();{
"      return SetupError(Status::InvalidArgument(""missing table ID or table name""),"
"                        response, MasterErrorPB::UNKNOWN_ERROR);"
    }
"  // If the table doesn't exist, don't attempt to lock it."
  //
}
void Singleton::f8();{
//////////////////////////////
message TabletLocationsPB {
  // DEPRECATED.
  // TODO: new clients should prefer the 'Interned' type below.
  // Remove 'ReplicaPB' when we stop using it internally.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        Types.NestedField nestedField) {
"      int keyId = -1, valueId = -1;"
      if (col.getType().isMapType()) {
        // Get key id and value id for Map type.
        Preconditions.checkState(nestedField.type().isMapType());
}
void Singleton::f2();{
"XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);"
"XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);"
   XXH32_hash_t large_len;    /*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) */
}
void Singleton::f3();{
"          ""isRecursive"": False"
        }
"      },"
"      ""dataMaskPolicyItems"": ["
        {
}
void Singleton::f4();{
"                        uint16_t default_port,"
                        std::vector<Sockaddr>* addresses);
// Return true if the given port is likely to need root privileges to bind to.
bool IsPrivilegedPort(uint16_t port);
// Return the local machine's hostname.
}
void Singleton::f5();{
[[prerequisites_and_requirements]]
== Prerequisites and Requirements
.Hardware
- One or more hosts to run Kudu masters. It is recommended to have either one master (no fault
"tolerance), or three masters (can tolerate one failure). The number of masters must be odd."
}
void Singleton::f6();{
    }
"    rpc->table()->AddTask(rpc->tablet_id(), rpc);"
"    WARN_NOT_OK(rpc->Run(), Substitute(""Failed to send  0"", rpc->description()));"
  // 16. Invalidate corresponding entries in the table locations cache.
  if (table_locations_cache_) {
}
void Singleton::f7();{
"      return SetupError(Status::InvalidArgument(""missing table ID or table name""),"
"                        response, MasterErrorPB::UNKNOWN_ERROR);"
    }
"  // If the table doesn't exist, don't attempt to lock it."
  //
}
void Singleton::f8();{
//////////////////////////////
message TabletLocationsPB {
  // DEPRECATED.
  // TODO: new clients should prefer the 'Interned' type below.
  // Remove 'ReplicaPB' when we stop using it internally.
}
void Singleton::f9();{
          CALLBACK_AND_RETURN(
"              Status::IllegalState(""consensus unavailable: tablet not running"", tablet_id));"
        }
        boost::optional<OpId> opt_last_logged_opid = consensus->GetLastOpId(RECEIVED_OPID);
        if (!opt_last_logged_opid) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        gsm_map_summary_packet,
        NULL,
        NULL);
    if (err_p != NULL)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        gsm_map_summary_packet,
        NULL,
        NULL);
    if (err_p != NULL)
    {
}
void Singleton::f2();{
    QString format_str = wtap_file_type_subtype_string(summary.file_type);
    const char *compression_type_description = wtap_compression_type_description(summary.compression_type);
    if (compression_type_description != NULL) {
        format_str += QString(" (%1)").arg(compression_type_description);
    }
}
void Singleton::f3();{
    out << table_end;
    // Total Section
    out << section_tmpl.arg(tr("Totals"));
    out << table_begin;
    out << table_row_begin
}
void Singleton::f4();{
            if (elapsed_time/86400)
            {
                elapsed_str = QString("%1 days ").arg(elapsed_time / 86400);
            }
            elapsed_str += QString("%1:%2:%3")
}
void Singleton::f5();{
    for (int i = 0; i < GSM_MAP_MAX_NUM_OPR_CODES; i++) {
        result_count += gsm_map_stat.opr_code_rr[i];
        result_bytes += gsm_map_stat.size_rr[i];
    }
    int total_count = invoke_count + result_count;
}
void Singleton::f6();{
GsmMapSummaryDialog::~GsmMapSummaryDialog()
    delete ui;
// Copied from capture_file_properties_dialog.cpp
QString GsmMapSummaryDialog::summaryToHtml()
    summary_tally summary;
}
void Singleton::f7();{
//        if (refresh_bt) {
//            refresh_bt->setEnabled(false);
//        }
//        ui->commentsTextEdit->setReadOnly(true);
//        if (save_bt) {
}
void Singleton::f8();{
/* gsm_map_summary_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * Wireshark - Network traffic analyzer
}
void Singleton::f9();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", err_p->str);
        g_string_free(err_p, TRUE);
        exit(1);
    }
} // extern "C"
}
void Singleton::f10();{
            }
            elapsed_str += QString("%1:%2:%3")
                    .arg(elapsed_time % 86400 / 3600, 2, 10, QChar('0'))
                    .arg(elapsed_time % 3600 / 60, 2, 10, QChar('0'))
                    .arg(elapsed_time % 60, 2, 10, QChar('0'));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        gsm_map_summary_packet,
        NULL,
        NULL);
    if (err_p != NULL)
    {
}
void Singleton::f2();{
    QString format_str = wtap_file_type_subtype_string(summary.file_type);
    const char *compression_type_description = wtap_compression_type_description(summary.compression_type);
    if (compression_type_description != NULL) {
        format_str += QString(" (%1)").arg(compression_type_description);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        gsm_map_summary_packet,
        NULL,
        NULL);
    if (err_p != NULL)
    {
}
void Singleton::f2();{
    QString format_str = wtap_file_type_subtype_string(summary.file_type);
    const char *compression_type_description = wtap_compression_type_description(summary.compression_type);
    if (compression_type_description != NULL) {
        format_str += QString(" (%1)").arg(compression_type_description);
    }
}
void Singleton::f3();{
    out << table_end;
    // Total Section
    out << section_tmpl.arg(tr("Totals"));
    out << table_begin;
    out << table_row_begin
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        gsm_map_summary_packet,
        NULL,
        NULL);
    if (err_p != NULL)
    {
}
void Singleton::f2();{
    QString format_str = wtap_file_type_subtype_string(summary.file_type);
    const char *compression_type_description = wtap_compression_type_description(summary.compression_type);
    if (compression_type_description != NULL) {
        format_str += QString(" (%1)").arg(compression_type_description);
    }
}
void Singleton::f3();{
    out << table_end;
    // Total Section
    out << section_tmpl.arg(tr("Totals"));
    out << table_begin;
    out << table_row_begin
}
void Singleton::f4();{
            if (elapsed_time/86400)
            {
                elapsed_str = QString("%1 days ").arg(elapsed_time / 86400);
            }
            elapsed_str += QString("%1:%2:%3")
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        gsm_map_summary_packet,
        NULL,
        NULL);
    if (err_p != NULL)
    {
}
void Singleton::f2();{
    QString format_str = wtap_file_type_subtype_string(summary.file_type);
    const char *compression_type_description = wtap_compression_type_description(summary.compression_type);
    if (compression_type_description != NULL) {
        format_str += QString(" (%1)").arg(compression_type_description);
    }
}
void Singleton::f3();{
    out << table_end;
    // Total Section
    out << section_tmpl.arg(tr("Totals"));
    out << table_begin;
    out << table_row_begin
}
void Singleton::f4();{
            if (elapsed_time/86400)
            {
                elapsed_str = QString("%1 days ").arg(elapsed_time / 86400);
            }
            elapsed_str += QString("%1:%2:%3")
}
void Singleton::f5();{
    for (int i = 0; i < GSM_MAP_MAX_NUM_OPR_CODES; i++) {
        result_count += gsm_map_stat.opr_code_rr[i];
        result_bytes += gsm_map_stat.size_rr[i];
    }
    int total_count = invoke_count + result_count;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        gsm_map_summary_packet,
        NULL,
        NULL);
    if (err_p != NULL)
    {
}
void Singleton::f2();{
    QString format_str = wtap_file_type_subtype_string(summary.file_type);
    const char *compression_type_description = wtap_compression_type_description(summary.compression_type);
    if (compression_type_description != NULL) {
        format_str += QString(" (%1)").arg(compression_type_description);
    }
}
void Singleton::f3();{
    out << table_end;
    // Total Section
    out << section_tmpl.arg(tr("Totals"));
    out << table_begin;
    out << table_row_begin
}
void Singleton::f4();{
            if (elapsed_time/86400)
            {
                elapsed_str = QString("%1 days ").arg(elapsed_time / 86400);
            }
            elapsed_str += QString("%1:%2:%3")
}
void Singleton::f5();{
    for (int i = 0; i < GSM_MAP_MAX_NUM_OPR_CODES; i++) {
        result_count += gsm_map_stat.opr_code_rr[i];
        result_bytes += gsm_map_stat.size_rr[i];
    }
    int total_count = invoke_count + result_count;
}
void Singleton::f6();{
GsmMapSummaryDialog::~GsmMapSummaryDialog()
    delete ui;
// Copied from capture_file_properties_dialog.cpp
QString GsmMapSummaryDialog::summaryToHtml()
    summary_tally summary;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        gsm_map_summary_packet,
        NULL,
        NULL);
    if (err_p != NULL)
    {
}
void Singleton::f2();{
    QString format_str = wtap_file_type_subtype_string(summary.file_type);
    const char *compression_type_description = wtap_compression_type_description(summary.compression_type);
    if (compression_type_description != NULL) {
        format_str += QString(" (%1)").arg(compression_type_description);
    }
}
void Singleton::f3();{
    out << table_end;
    // Total Section
    out << section_tmpl.arg(tr("Totals"));
    out << table_begin;
    out << table_row_begin
}
void Singleton::f4();{
            if (elapsed_time/86400)
            {
                elapsed_str = QString("%1 days ").arg(elapsed_time / 86400);
            }
            elapsed_str += QString("%1:%2:%3")
}
void Singleton::f5();{
    for (int i = 0; i < GSM_MAP_MAX_NUM_OPR_CODES; i++) {
        result_count += gsm_map_stat.opr_code_rr[i];
        result_bytes += gsm_map_stat.size_rr[i];
    }
    int total_count = invoke_count + result_count;
}
void Singleton::f6();{
GsmMapSummaryDialog::~GsmMapSummaryDialog()
    delete ui;
// Copied from capture_file_properties_dialog.cpp
QString GsmMapSummaryDialog::summaryToHtml()
    summary_tally summary;
}
void Singleton::f7();{
//        if (refresh_bt) {
//            refresh_bt->setEnabled(false);
//        }
//        ui->commentsTextEdit->setReadOnly(true);
//        if (save_bt) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        gsm_map_summary_packet,
        NULL,
        NULL);
    if (err_p != NULL)
    {
}
void Singleton::f2();{
    QString format_str = wtap_file_type_subtype_string(summary.file_type);
    const char *compression_type_description = wtap_compression_type_description(summary.compression_type);
    if (compression_type_description != NULL) {
        format_str += QString(" (%1)").arg(compression_type_description);
    }
}
void Singleton::f3();{
    out << table_end;
    // Total Section
    out << section_tmpl.arg(tr("Totals"));
    out << table_begin;
    out << table_row_begin
}
void Singleton::f4();{
            if (elapsed_time/86400)
            {
                elapsed_str = QString("%1 days ").arg(elapsed_time / 86400);
            }
            elapsed_str += QString("%1:%2:%3")
}
void Singleton::f5();{
    for (int i = 0; i < GSM_MAP_MAX_NUM_OPR_CODES; i++) {
        result_count += gsm_map_stat.opr_code_rr[i];
        result_bytes += gsm_map_stat.size_rr[i];
    }
    int total_count = invoke_count + result_count;
}
void Singleton::f6();{
GsmMapSummaryDialog::~GsmMapSummaryDialog()
    delete ui;
// Copied from capture_file_properties_dialog.cpp
QString GsmMapSummaryDialog::summaryToHtml()
    summary_tally summary;
}
void Singleton::f7();{
//        if (refresh_bt) {
//            refresh_bt->setEnabled(false);
//        }
//        ui->commentsTextEdit->setReadOnly(true);
//        if (save_bt) {
}
void Singleton::f8();{
/* gsm_map_summary_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * Wireshark - Network traffic analyzer
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        gsm_map_summary_packet,
        NULL,
        NULL);
    if (err_p != NULL)
    {
}
void Singleton::f2();{
    QString format_str = wtap_file_type_subtype_string(summary.file_type);
    const char *compression_type_description = wtap_compression_type_description(summary.compression_type);
    if (compression_type_description != NULL) {
        format_str += QString(" (%1)").arg(compression_type_description);
    }
}
void Singleton::f3();{
    out << table_end;
    // Total Section
    out << section_tmpl.arg(tr("Totals"));
    out << table_begin;
    out << table_row_begin
}
void Singleton::f4();{
            if (elapsed_time/86400)
            {
                elapsed_str = QString("%1 days ").arg(elapsed_time / 86400);
            }
            elapsed_str += QString("%1:%2:%3")
}
void Singleton::f5();{
    for (int i = 0; i < GSM_MAP_MAX_NUM_OPR_CODES; i++) {
        result_count += gsm_map_stat.opr_code_rr[i];
        result_bytes += gsm_map_stat.size_rr[i];
    }
    int total_count = invoke_count + result_count;
}
void Singleton::f6();{
GsmMapSummaryDialog::~GsmMapSummaryDialog()
    delete ui;
// Copied from capture_file_properties_dialog.cpp
QString GsmMapSummaryDialog::summaryToHtml()
    summary_tally summary;
}
void Singleton::f7();{
//        if (refresh_bt) {
//            refresh_bt->setEnabled(false);
//        }
//        ui->commentsTextEdit->setReadOnly(true);
//        if (save_bt) {
}
void Singleton::f8();{
/* gsm_map_summary_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * Wireshark - Network traffic analyzer
}
void Singleton::f9();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", err_p->str);
        g_string_free(err_p, TRUE);
        exit(1);
    }
} // extern "C"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * operation, processing another message block, and updating the
 * context.
void HashUtil::MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen){
    unsigned int i, index, partLen;
    // Compute number of bytes mod 64
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * operation, processing another message block, and updating the
 * context.
void HashUtil::MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen){
    unsigned int i, index, partLen;
    // Compute number of bytes mod 64
}
void Singleton::f2();{
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);
    /* Update number of bits */
    if((context->count[0] += ((unsigned int)inputLen << 3)) < ((unsigned int)inputLen << 3)){
        context->count[1]++;
    }
}
void Singleton::f3();{
    HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
    HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
    HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
}
void Singleton::f4();{
    GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
    GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
    GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
    GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
    /* Round 3 */
}
void Singleton::f5();{
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    // Zeroize sensitive information.
}
void Singleton::f6();{
    MD5_memcpy((unsigned char*)&context->buffer[index], (unsigned char*)&input[i], inputLen-i);
 * MD5 finalization. Ends an MD5 message-digest operation, writing the the message digest and zeroizing the context.
void HashUtil::MD5Final(unsigned char digest[16], MD5_CTX *context){
    unsigned char bits[8];
    unsigned int index, padLen;
}
void Singleton::f7();{
  context->count[0] = context->count[1] = 0;
  // Load magic initialization  ants.
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
}
void Singleton::f8();{
    } else {
        i = 0;
    }
    // Buffer remaining input
    MD5_memcpy((unsigned char*)&context->buffer[index], (unsigned char*)&input[i], inputLen-i);
}
void Singleton::f9();{
 * Note: Replace "for loop" with standard memset if possible.
void HashUtil::MD5_memset(unsigned char* output, int value, unsigned int len){
    for(unsigned int i = 0; i < len; i++){
        ((char *)output)[i] = (char)value;
    }
}
void Singleton::f10();{
    HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
    HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
    /* Round 4 */
    II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
    II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * operation, processing another message block, and updating the
 * context.
void HashUtil::MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen){
    unsigned int i, index, partLen;
    // Compute number of bytes mod 64
}
void Singleton::f2();{
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);
    /* Update number of bits */
    if((context->count[0] += ((unsigned int)inputLen << 3)) < ((unsigned int)inputLen << 3)){
        context->count[1]++;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * operation, processing another message block, and updating the
 * context.
void HashUtil::MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen){
    unsigned int i, index, partLen;
    // Compute number of bytes mod 64
}
void Singleton::f2();{
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);
    /* Update number of bits */
    if((context->count[0] += ((unsigned int)inputLen << 3)) < ((unsigned int)inputLen << 3)){
        context->count[1]++;
    }
}
void Singleton::f3();{
    HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
    HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
    HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * operation, processing another message block, and updating the
 * context.
void HashUtil::MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen){
    unsigned int i, index, partLen;
    // Compute number of bytes mod 64
}
void Singleton::f2();{
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);
    /* Update number of bits */
    if((context->count[0] += ((unsigned int)inputLen << 3)) < ((unsigned int)inputLen << 3)){
        context->count[1]++;
    }
}
void Singleton::f3();{
    HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
    HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
    HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
}
void Singleton::f4();{
    GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
    GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
    GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
    GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
    /* Round 3 */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * operation, processing another message block, and updating the
 * context.
void HashUtil::MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen){
    unsigned int i, index, partLen;
    // Compute number of bytes mod 64
}
void Singleton::f2();{
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);
    /* Update number of bits */
    if((context->count[0] += ((unsigned int)inputLen << 3)) < ((unsigned int)inputLen << 3)){
        context->count[1]++;
    }
}
void Singleton::f3();{
    HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
    HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
    HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
}
void Singleton::f4();{
    GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
    GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
    GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
    GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
    /* Round 3 */
}
void Singleton::f5();{
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    // Zeroize sensitive information.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * operation, processing another message block, and updating the
 * context.
void HashUtil::MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen){
    unsigned int i, index, partLen;
    // Compute number of bytes mod 64
}
void Singleton::f2();{
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);
    /* Update number of bits */
    if((context->count[0] += ((unsigned int)inputLen << 3)) < ((unsigned int)inputLen << 3)){
        context->count[1]++;
    }
}
void Singleton::f3();{
    HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
    HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
    HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
}
void Singleton::f4();{
    GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
    GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
    GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
    GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
    /* Round 3 */
}
void Singleton::f5();{
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    // Zeroize sensitive information.
}
void Singleton::f6();{
    MD5_memcpy((unsigned char*)&context->buffer[index], (unsigned char*)&input[i], inputLen-i);
 * MD5 finalization. Ends an MD5 message-digest operation, writing the the message digest and zeroizing the context.
void HashUtil::MD5Final(unsigned char digest[16], MD5_CTX *context){
    unsigned char bits[8];
    unsigned int index, padLen;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * operation, processing another message block, and updating the
 * context.
void HashUtil::MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen){
    unsigned int i, index, partLen;
    // Compute number of bytes mod 64
}
void Singleton::f2();{
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);
    /* Update number of bits */
    if((context->count[0] += ((unsigned int)inputLen << 3)) < ((unsigned int)inputLen << 3)){
        context->count[1]++;
    }
}
void Singleton::f3();{
    HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
    HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
    HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
}
void Singleton::f4();{
    GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
    GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
    GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
    GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
    /* Round 3 */
}
void Singleton::f5();{
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    // Zeroize sensitive information.
}
void Singleton::f6();{
    MD5_memcpy((unsigned char*)&context->buffer[index], (unsigned char*)&input[i], inputLen-i);
 * MD5 finalization. Ends an MD5 message-digest operation, writing the the message digest and zeroizing the context.
void HashUtil::MD5Final(unsigned char digest[16], MD5_CTX *context){
    unsigned char bits[8];
    unsigned int index, padLen;
}
void Singleton::f7();{
  context->count[0] = context->count[1] = 0;
  // Load magic initialization  ants.
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * operation, processing another message block, and updating the
 * context.
void HashUtil::MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen){
    unsigned int i, index, partLen;
    // Compute number of bytes mod 64
}
void Singleton::f2();{
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);
    /* Update number of bits */
    if((context->count[0] += ((unsigned int)inputLen << 3)) < ((unsigned int)inputLen << 3)){
        context->count[1]++;
    }
}
void Singleton::f3();{
    HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
    HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
    HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
}
void Singleton::f4();{
    GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
    GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
    GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
    GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
    /* Round 3 */
}
void Singleton::f5();{
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    // Zeroize sensitive information.
}
void Singleton::f6();{
    MD5_memcpy((unsigned char*)&context->buffer[index], (unsigned char*)&input[i], inputLen-i);
 * MD5 finalization. Ends an MD5 message-digest operation, writing the the message digest and zeroizing the context.
void HashUtil::MD5Final(unsigned char digest[16], MD5_CTX *context){
    unsigned char bits[8];
    unsigned int index, padLen;
}
void Singleton::f7();{
  context->count[0] = context->count[1] = 0;
  // Load magic initialization  ants.
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
}
void Singleton::f8();{
    } else {
        i = 0;
    }
    // Buffer remaining input
    MD5_memcpy((unsigned char*)&context->buffer[index], (unsigned char*)&input[i], inputLen-i);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * operation, processing another message block, and updating the
 * context.
void HashUtil::MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen){
    unsigned int i, index, partLen;
    // Compute number of bytes mod 64
}
void Singleton::f2();{
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);
    /* Update number of bits */
    if((context->count[0] += ((unsigned int)inputLen << 3)) < ((unsigned int)inputLen << 3)){
        context->count[1]++;
    }
}
void Singleton::f3();{
    HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
    HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
    HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
    HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
    HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
}
void Singleton::f4();{
    GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
    GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
    GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
    GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
    /* Round 3 */
}
void Singleton::f5();{
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    // Zeroize sensitive information.
}
void Singleton::f6();{
    MD5_memcpy((unsigned char*)&context->buffer[index], (unsigned char*)&input[i], inputLen-i);
 * MD5 finalization. Ends an MD5 message-digest operation, writing the the message digest and zeroizing the context.
void HashUtil::MD5Final(unsigned char digest[16], MD5_CTX *context){
    unsigned char bits[8];
    unsigned int index, padLen;
}
void Singleton::f7();{
  context->count[0] = context->count[1] = 0;
  // Load magic initialization  ants.
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
}
void Singleton::f8();{
    } else {
        i = 0;
    }
    // Buffer remaining input
    MD5_memcpy((unsigned char*)&context->buffer[index], (unsigned char*)&input[i], inputLen-i);
}
void Singleton::f9();{
 * Note: Replace "for loop" with standard memset if possible.
void HashUtil::MD5_memset(unsigned char* output, int value, unsigned int len){
    for(unsigned int i = 0; i < len; i++){
        ((char *)output)[i] = (char)value;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
void Iax2AnalysisDialog::on_fJitterCheckBox_toggled(bool checked)
    ui->streamGraph->graph(fwd_jitter_graph_)->setVisible(checked);
    updateGraph();
void Iax2AnalysisDialog::on_fDiffCheckBox_toggled(bool checked)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
void Iax2AnalysisDialog::on_fJitterCheckBox_toggled(bool checked)
    ui->streamGraph->graph(fwd_jitter_graph_)->setVisible(checked);
    updateGraph();
void Iax2AnalysisDialog::on_fDiffCheckBox_toggled(bool checked)
}
void Singleton::f2();{
    if (!iax2_analysis_dialog) return;
    iax2_analysis_dialog->resetStatistics();
tap_packet_status Iax2AnalysisDialog::tapPacket(void *tapinfoptr, packet_info *pinfo, struct epan_dissect *, const void *iax2info_ptr)
    Iax2AnalysisDialog *iax2_analysis_dialog = dynamic_cast<Iax2AnalysisDialog *>((Iax2AnalysisDialog*)tapinfoptr);
    if (!iax2_analysis_dialog) return TAP_PACKET_DONT_REDRAW;
}
void Singleton::f3();{
        setText(length_col_, QString::number(pkt_len_));
        setTextAlignment(packet_col_, Qt::AlignRight);
        setTextAlignment(delta_col_, Qt::AlignRight);
        setTextAlignment(jitter_col_, Qt::AlignRight);
        setTextAlignment(bandwidth_col_, Qt::AlignRight);
}
void Singleton::f4();{
    stream_ctx_menu_.popup(cur_tree->viewport()->mapToGlobal(pos));
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    ui->hintLabel->setText(tr("Saving %1" UTF8_HORIZONTAL_ELLIPSIS).arg(save_file.fileName()));
    ui->progressFrame->showProgress(tr("Analyzing IAX2"), true, true, &stop_flag);
    if	(save_format == save_audio_au_) { /* au format; https://pubs.opengroup.org/external/auformat.html */
        /* First we write the .au header.  All values in the header are
         * 4-byte big-endian values, so we use pntoh32() to copy them
}
void Singleton::f6();{
                }
            }
            save_file.write(values.join(",").toUtf8());
            save_file.write("\n");
        }
}
void Singleton::f7();{
    ui->actionSaveCsv->setEnabled(enable_save_fwd_csv && enable_save_rev_csv);
    ui->actionSaveForwardCsv->setEnabled(enable_save_fwd_csv);
    ui->actionSaveReverseCsv->setEnabled(enable_save_rev_csv);
    ui->tabWidget->setEnabled(enable_tab);
    hint.prepend("<small><i>");
}
void Singleton::f8();{
    case dir_forward_:
        caption = tr("Save forward stream audio");
        break;
    case dir_reverse_:
        caption = tr("Save reverse stream audio");
}
void Singleton::f9();{
                 && ui->forwardTreeWidget->selectedItems().length() > 0)
                || (ui->tabWidget->currentWidget() == ui->reverseTreeWidget
                    && ui->reverseTreeWidget->selectedItems().length() > 0))) {
        enable_nav = true;
    }
}
void Singleton::f10();{
    }
    ui->hintLabel->setText(tr("Saving %1" UTF8_HORIZONTAL_ELLIPSIS).arg(save_file.fileName()));
    ui->progressFrame->showProgress(tr("Analyzing IAX2"), true, true, &stop_flag);
    if	(save_format == save_audio_au_) { /* au format; https://pubs.opengroup.org/external/auformat.html */
        /* First we write the .au header.  All values in the header are
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
void Iax2AnalysisDialog::on_fJitterCheckBox_toggled(bool checked)
    ui->streamGraph->graph(fwd_jitter_graph_)->setVisible(checked);
    updateGraph();
void Iax2AnalysisDialog::on_fDiffCheckBox_toggled(bool checked)
}
void Singleton::f2();{
    if (!iax2_analysis_dialog) return;
    iax2_analysis_dialog->resetStatistics();
tap_packet_status Iax2AnalysisDialog::tapPacket(void *tapinfoptr, packet_info *pinfo, struct epan_dissect *, const void *iax2info_ptr)
    Iax2AnalysisDialog *iax2_analysis_dialog = dynamic_cast<Iax2AnalysisDialog *>((Iax2AnalysisDialog*)tapinfoptr);
    if (!iax2_analysis_dialog) return TAP_PACKET_DONT_REDRAW;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
void Iax2AnalysisDialog::on_fJitterCheckBox_toggled(bool checked)
    ui->streamGraph->graph(fwd_jitter_graph_)->setVisible(checked);
    updateGraph();
void Iax2AnalysisDialog::on_fDiffCheckBox_toggled(bool checked)
}
void Singleton::f2();{
    if (!iax2_analysis_dialog) return;
    iax2_analysis_dialog->resetStatistics();
tap_packet_status Iax2AnalysisDialog::tapPacket(void *tapinfoptr, packet_info *pinfo, struct epan_dissect *, const void *iax2info_ptr)
    Iax2AnalysisDialog *iax2_analysis_dialog = dynamic_cast<Iax2AnalysisDialog *>((Iax2AnalysisDialog*)tapinfoptr);
    if (!iax2_analysis_dialog) return TAP_PACKET_DONT_REDRAW;
}
void Singleton::f3();{
        setText(length_col_, QString::number(pkt_len_));
        setTextAlignment(packet_col_, Qt::AlignRight);
        setTextAlignment(delta_col_, Qt::AlignRight);
        setTextAlignment(jitter_col_, Qt::AlignRight);
        setTextAlignment(bandwidth_col_, Qt::AlignRight);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
void Iax2AnalysisDialog::on_fJitterCheckBox_toggled(bool checked)
    ui->streamGraph->graph(fwd_jitter_graph_)->setVisible(checked);
    updateGraph();
void Iax2AnalysisDialog::on_fDiffCheckBox_toggled(bool checked)
}
void Singleton::f2();{
    if (!iax2_analysis_dialog) return;
    iax2_analysis_dialog->resetStatistics();
tap_packet_status Iax2AnalysisDialog::tapPacket(void *tapinfoptr, packet_info *pinfo, struct epan_dissect *, const void *iax2info_ptr)
    Iax2AnalysisDialog *iax2_analysis_dialog = dynamic_cast<Iax2AnalysisDialog *>((Iax2AnalysisDialog*)tapinfoptr);
    if (!iax2_analysis_dialog) return TAP_PACKET_DONT_REDRAW;
}
void Singleton::f3();{
        setText(length_col_, QString::number(pkt_len_));
        setTextAlignment(packet_col_, Qt::AlignRight);
        setTextAlignment(delta_col_, Qt::AlignRight);
        setTextAlignment(jitter_col_, Qt::AlignRight);
        setTextAlignment(bandwidth_col_, Qt::AlignRight);
}
void Singleton::f4();{
    stream_ctx_menu_.popup(cur_tree->viewport()->mapToGlobal(pos));
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
void Iax2AnalysisDialog::on_fJitterCheckBox_toggled(bool checked)
    ui->streamGraph->graph(fwd_jitter_graph_)->setVisible(checked);
    updateGraph();
void Iax2AnalysisDialog::on_fDiffCheckBox_toggled(bool checked)
}
void Singleton::f2();{
    if (!iax2_analysis_dialog) return;
    iax2_analysis_dialog->resetStatistics();
tap_packet_status Iax2AnalysisDialog::tapPacket(void *tapinfoptr, packet_info *pinfo, struct epan_dissect *, const void *iax2info_ptr)
    Iax2AnalysisDialog *iax2_analysis_dialog = dynamic_cast<Iax2AnalysisDialog *>((Iax2AnalysisDialog*)tapinfoptr);
    if (!iax2_analysis_dialog) return TAP_PACKET_DONT_REDRAW;
}
void Singleton::f3();{
        setText(length_col_, QString::number(pkt_len_));
        setTextAlignment(packet_col_, Qt::AlignRight);
        setTextAlignment(delta_col_, Qt::AlignRight);
        setTextAlignment(jitter_col_, Qt::AlignRight);
        setTextAlignment(bandwidth_col_, Qt::AlignRight);
}
void Singleton::f4();{
    stream_ctx_menu_.popup(cur_tree->viewport()->mapToGlobal(pos));
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    ui->hintLabel->setText(tr("Saving %1" UTF8_HORIZONTAL_ELLIPSIS).arg(save_file.fileName()));
    ui->progressFrame->showProgress(tr("Analyzing IAX2"), true, true, &stop_flag);
    if	(save_format == save_audio_au_) { /* au format; https://pubs.opengroup.org/external/auformat.html */
        /* First we write the .au header.  All values in the header are
         * 4-byte big-endian values, so we use pntoh32() to copy them
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
void Iax2AnalysisDialog::on_fJitterCheckBox_toggled(bool checked)
    ui->streamGraph->graph(fwd_jitter_graph_)->setVisible(checked);
    updateGraph();
void Iax2AnalysisDialog::on_fDiffCheckBox_toggled(bool checked)
}
void Singleton::f2();{
    if (!iax2_analysis_dialog) return;
    iax2_analysis_dialog->resetStatistics();
tap_packet_status Iax2AnalysisDialog::tapPacket(void *tapinfoptr, packet_info *pinfo, struct epan_dissect *, const void *iax2info_ptr)
    Iax2AnalysisDialog *iax2_analysis_dialog = dynamic_cast<Iax2AnalysisDialog *>((Iax2AnalysisDialog*)tapinfoptr);
    if (!iax2_analysis_dialog) return TAP_PACKET_DONT_REDRAW;
}
void Singleton::f3();{
        setText(length_col_, QString::number(pkt_len_));
        setTextAlignment(packet_col_, Qt::AlignRight);
        setTextAlignment(delta_col_, Qt::AlignRight);
        setTextAlignment(jitter_col_, Qt::AlignRight);
        setTextAlignment(bandwidth_col_, Qt::AlignRight);
}
void Singleton::f4();{
    stream_ctx_menu_.popup(cur_tree->viewport()->mapToGlobal(pos));
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    ui->hintLabel->setText(tr("Saving %1" UTF8_HORIZONTAL_ELLIPSIS).arg(save_file.fileName()));
    ui->progressFrame->showProgress(tr("Analyzing IAX2"), true, true, &stop_flag);
    if	(save_format == save_audio_au_) { /* au format; https://pubs.opengroup.org/external/auformat.html */
        /* First we write the .au header.  All values in the header are
         * 4-byte big-endian values, so we use pntoh32() to copy them
}
void Singleton::f6();{
                }
            }
            save_file.write(values.join(",").toUtf8());
            save_file.write("\n");
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
void Iax2AnalysisDialog::on_fJitterCheckBox_toggled(bool checked)
    ui->streamGraph->graph(fwd_jitter_graph_)->setVisible(checked);
    updateGraph();
void Iax2AnalysisDialog::on_fDiffCheckBox_toggled(bool checked)
}
void Singleton::f2();{
    if (!iax2_analysis_dialog) return;
    iax2_analysis_dialog->resetStatistics();
tap_packet_status Iax2AnalysisDialog::tapPacket(void *tapinfoptr, packet_info *pinfo, struct epan_dissect *, const void *iax2info_ptr)
    Iax2AnalysisDialog *iax2_analysis_dialog = dynamic_cast<Iax2AnalysisDialog *>((Iax2AnalysisDialog*)tapinfoptr);
    if (!iax2_analysis_dialog) return TAP_PACKET_DONT_REDRAW;
}
void Singleton::f3();{
        setText(length_col_, QString::number(pkt_len_));
        setTextAlignment(packet_col_, Qt::AlignRight);
        setTextAlignment(delta_col_, Qt::AlignRight);
        setTextAlignment(jitter_col_, Qt::AlignRight);
        setTextAlignment(bandwidth_col_, Qt::AlignRight);
}
void Singleton::f4();{
    stream_ctx_menu_.popup(cur_tree->viewport()->mapToGlobal(pos));
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    ui->hintLabel->setText(tr("Saving %1" UTF8_HORIZONTAL_ELLIPSIS).arg(save_file.fileName()));
    ui->progressFrame->showProgress(tr("Analyzing IAX2"), true, true, &stop_flag);
    if	(save_format == save_audio_au_) { /* au format; https://pubs.opengroup.org/external/auformat.html */
        /* First we write the .au header.  All values in the header are
         * 4-byte big-endian values, so we use pntoh32() to copy them
}
void Singleton::f6();{
                }
            }
            save_file.write(values.join(",").toUtf8());
            save_file.write("\n");
        }
}
void Singleton::f7();{
    ui->actionSaveCsv->setEnabled(enable_save_fwd_csv && enable_save_rev_csv);
    ui->actionSaveForwardCsv->setEnabled(enable_save_fwd_csv);
    ui->actionSaveReverseCsv->setEnabled(enable_save_rev_csv);
    ui->tabWidget->setEnabled(enable_tab);
    hint.prepend("<small><i>");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
void Iax2AnalysisDialog::on_fJitterCheckBox_toggled(bool checked)
    ui->streamGraph->graph(fwd_jitter_graph_)->setVisible(checked);
    updateGraph();
void Iax2AnalysisDialog::on_fDiffCheckBox_toggled(bool checked)
}
void Singleton::f2();{
    if (!iax2_analysis_dialog) return;
    iax2_analysis_dialog->resetStatistics();
tap_packet_status Iax2AnalysisDialog::tapPacket(void *tapinfoptr, packet_info *pinfo, struct epan_dissect *, const void *iax2info_ptr)
    Iax2AnalysisDialog *iax2_analysis_dialog = dynamic_cast<Iax2AnalysisDialog *>((Iax2AnalysisDialog*)tapinfoptr);
    if (!iax2_analysis_dialog) return TAP_PACKET_DONT_REDRAW;
}
void Singleton::f3();{
        setText(length_col_, QString::number(pkt_len_));
        setTextAlignment(packet_col_, Qt::AlignRight);
        setTextAlignment(delta_col_, Qt::AlignRight);
        setTextAlignment(jitter_col_, Qt::AlignRight);
        setTextAlignment(bandwidth_col_, Qt::AlignRight);
}
void Singleton::f4();{
    stream_ctx_menu_.popup(cur_tree->viewport()->mapToGlobal(pos));
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    ui->hintLabel->setText(tr("Saving %1" UTF8_HORIZONTAL_ELLIPSIS).arg(save_file.fileName()));
    ui->progressFrame->showProgress(tr("Analyzing IAX2"), true, true, &stop_flag);
    if	(save_format == save_audio_au_) { /* au format; https://pubs.opengroup.org/external/auformat.html */
        /* First we write the .au header.  All values in the header are
         * 4-byte big-endian values, so we use pntoh32() to copy them
}
void Singleton::f6();{
                }
            }
            save_file.write(values.join(",").toUtf8());
            save_file.write("\n");
        }
}
void Singleton::f7();{
    ui->actionSaveCsv->setEnabled(enable_save_fwd_csv && enable_save_rev_csv);
    ui->actionSaveForwardCsv->setEnabled(enable_save_fwd_csv);
    ui->actionSaveReverseCsv->setEnabled(enable_save_rev_csv);
    ui->tabWidget->setEnabled(enable_tab);
    hint.prepend("<small><i>");
}
void Singleton::f8();{
    case dir_forward_:
        caption = tr("Save forward stream audio");
        break;
    case dir_reverse_:
        caption = tr("Save reverse stream audio");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
void Iax2AnalysisDialog::on_fJitterCheckBox_toggled(bool checked)
    ui->streamGraph->graph(fwd_jitter_graph_)->setVisible(checked);
    updateGraph();
void Iax2AnalysisDialog::on_fDiffCheckBox_toggled(bool checked)
}
void Singleton::f2();{
    if (!iax2_analysis_dialog) return;
    iax2_analysis_dialog->resetStatistics();
tap_packet_status Iax2AnalysisDialog::tapPacket(void *tapinfoptr, packet_info *pinfo, struct epan_dissect *, const void *iax2info_ptr)
    Iax2AnalysisDialog *iax2_analysis_dialog = dynamic_cast<Iax2AnalysisDialog *>((Iax2AnalysisDialog*)tapinfoptr);
    if (!iax2_analysis_dialog) return TAP_PACKET_DONT_REDRAW;
}
void Singleton::f3();{
        setText(length_col_, QString::number(pkt_len_));
        setTextAlignment(packet_col_, Qt::AlignRight);
        setTextAlignment(delta_col_, Qt::AlignRight);
        setTextAlignment(jitter_col_, Qt::AlignRight);
        setTextAlignment(bandwidth_col_, Qt::AlignRight);
}
void Singleton::f4();{
    stream_ctx_menu_.popup(cur_tree->viewport()->mapToGlobal(pos));
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    ui->hintLabel->setText(tr("Saving %1" UTF8_HORIZONTAL_ELLIPSIS).arg(save_file.fileName()));
    ui->progressFrame->showProgress(tr("Analyzing IAX2"), true, true, &stop_flag);
    if	(save_format == save_audio_au_) { /* au format; https://pubs.opengroup.org/external/auformat.html */
        /* First we write the .au header.  All values in the header are
         * 4-byte big-endian values, so we use pntoh32() to copy them
}
void Singleton::f6();{
                }
            }
            save_file.write(values.join(",").toUtf8());
            save_file.write("\n");
        }
}
void Singleton::f7();{
    ui->actionSaveCsv->setEnabled(enable_save_fwd_csv && enable_save_rev_csv);
    ui->actionSaveForwardCsv->setEnabled(enable_save_fwd_csv);
    ui->actionSaveReverseCsv->setEnabled(enable_save_rev_csv);
    ui->tabWidget->setEnabled(enable_tab);
    hint.prepend("<small><i>");
}
void Singleton::f8();{
    case dir_forward_:
        caption = tr("Save forward stream audio");
        break;
    case dir_reverse_:
        caption = tr("Save reverse stream audio");
}
void Singleton::f9();{
                 && ui->forwardTreeWidget->selectedItems().length() > 0)
                || (ui->tabWidget->currentWidget() == ui->reverseTreeWidget
                    && ui->reverseTreeWidget->selectedItems().length() > 0))) {
        enable_nav = true;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    g_free (import_info_.date_timestamp_format);
    g_free (import_info_.payload);
    delete ti_ui_;
QString &ImportTextDialog::capfileName() {
    return capfile_name_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    g_free (import_info_.date_timestamp_format);
    g_free (import_info_.payload);
    delete ti_ui_;
QString &ImportTextDialog::capfileName() {
    return capfile_name_;
}
void Singleton::f2();{
void ImportTextDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_IMPORT_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    ti_ui_->destinationPortLineEdit->setEnabled(port);
    ti_ui_->tagLabel->setEnabled(sctp_tag);
    ti_ui_->tagLineEdit->setEnabled(sctp_tag);
    ti_ui_->ppiLabel->setEnabled(sctp_ppi);
    ti_ui_->ppiLineEdit->setEnabled(sctp_ppi);
}
void Singleton::f4();{
        if (import_info_.encapsulation == WTAP_ENCAP_WIRESHARK_UPPER_PDU) enabled_export_pdu = true;
    }
    enableHeaderWidgets(enabled_ethernet, enabled_export_pdu);
bool ImportTextDialog::checkDateTimeFormat(const QString &time_format)
    const QString valid_code = "aAbBcdDFHIjmMpsSTUwWxXyYzZ%";
}
void Singleton::f5();{
    ti_ui_->payloadLabel->setEnabled(export_pdu);
    ti_ui_->payloadLineEdit->setEnabled(export_pdu);
int ImportTextDialog::exec() {
    QVariant encap_val;
    QDialog::exec();
}
void Singleton::f6();{
        if (conv_ok && *val_ptr <= max_val) {
            syntax_state = SyntaxLineEdit::Valid;
        } else {
            syntax_state = SyntaxLineEdit::Invalid;
            ok_enabled = false;
}
void Singleton::f7();{
    case FO_STYLE_LAST_OPENED:
        /* The user has specified that we should start out in the last directory
           we looked in.  If we've already opened a file, use its containing
           directory, if we could determine it, as the directory, otherwise
           use the "last opened" directory saved in the preferences file if
}
void Singleton::f8();{
    import_info_.import_text_file = ws_fopen(import_info_.import_text_filename, "rb");
    if (!import_info_.import_text_file) {
        open_failure_alert_box(import_info_.import_text_filename, errno, FALSE);
        setResult(QDialog::Rejected);
        return QDialog::Rejected;
}
void Singleton::f9();{
void ImportTextDialog::on_textFileBrowseButton_clicked()
    char *open_dir = NULL;
    switch (prefs.gui_fileopen_style) {
    case FO_STYLE_LAST_OPENED:
        /* The user has specified that we should start out in the last directory
}
void Singleton::f10();{
void ImportTextDialog::on_destinationPortLineEdit_textChanged(const QString &destination_port_str)
    check_line_edit(ti_ui_->destinationPortLineEdit, dest_port_ok_, destination_port_str, 10, 0xffff, true, &import_info_.dst_port);
void ImportTextDialog::on_tagLineEdit_textChanged(const QString &tag_str)
    check_line_edit(ti_ui_->tagLineEdit, tag_ok_, tag_str, 10, 0xffffffff, false, &import_info_.tag);
void ImportTextDialog::on_ppiLineEdit_textChanged(const QString &ppi_str)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    g_free (import_info_.date_timestamp_format);
    g_free (import_info_.payload);
    delete ti_ui_;
QString &ImportTextDialog::capfileName() {
    return capfile_name_;
}
void Singleton::f2();{
void ImportTextDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_IMPORT_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    g_free (import_info_.date_timestamp_format);
    g_free (import_info_.payload);
    delete ti_ui_;
QString &ImportTextDialog::capfileName() {
    return capfile_name_;
}
void Singleton::f2();{
void ImportTextDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_IMPORT_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    ti_ui_->destinationPortLineEdit->setEnabled(port);
    ti_ui_->tagLabel->setEnabled(sctp_tag);
    ti_ui_->tagLineEdit->setEnabled(sctp_tag);
    ti_ui_->ppiLabel->setEnabled(sctp_ppi);
    ti_ui_->ppiLineEdit->setEnabled(sctp_ppi);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    g_free (import_info_.date_timestamp_format);
    g_free (import_info_.payload);
    delete ti_ui_;
QString &ImportTextDialog::capfileName() {
    return capfile_name_;
}
void Singleton::f2();{
void ImportTextDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_IMPORT_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    ti_ui_->destinationPortLineEdit->setEnabled(port);
    ti_ui_->tagLabel->setEnabled(sctp_tag);
    ti_ui_->tagLineEdit->setEnabled(sctp_tag);
    ti_ui_->ppiLabel->setEnabled(sctp_ppi);
    ti_ui_->ppiLineEdit->setEnabled(sctp_ppi);
}
void Singleton::f4();{
        if (import_info_.encapsulation == WTAP_ENCAP_WIRESHARK_UPPER_PDU) enabled_export_pdu = true;
    }
    enableHeaderWidgets(enabled_ethernet, enabled_export_pdu);
bool ImportTextDialog::checkDateTimeFormat(const QString &time_format)
    const QString valid_code = "aAbBcdDFHIjmMpsSTUwWxXyYzZ%";
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    g_free (import_info_.date_timestamp_format);
    g_free (import_info_.payload);
    delete ti_ui_;
QString &ImportTextDialog::capfileName() {
    return capfile_name_;
}
void Singleton::f2();{
void ImportTextDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_IMPORT_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    ti_ui_->destinationPortLineEdit->setEnabled(port);
    ti_ui_->tagLabel->setEnabled(sctp_tag);
    ti_ui_->tagLineEdit->setEnabled(sctp_tag);
    ti_ui_->ppiLabel->setEnabled(sctp_ppi);
    ti_ui_->ppiLineEdit->setEnabled(sctp_ppi);
}
void Singleton::f4();{
        if (import_info_.encapsulation == WTAP_ENCAP_WIRESHARK_UPPER_PDU) enabled_export_pdu = true;
    }
    enableHeaderWidgets(enabled_ethernet, enabled_export_pdu);
bool ImportTextDialog::checkDateTimeFormat(const QString &time_format)
    const QString valid_code = "aAbBcdDFHIjmMpsSTUwWxXyYzZ%";
}
void Singleton::f5();{
    ti_ui_->payloadLabel->setEnabled(export_pdu);
    ti_ui_->payloadLineEdit->setEnabled(export_pdu);
int ImportTextDialog::exec() {
    QVariant encap_val;
    QDialog::exec();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    g_free (import_info_.date_timestamp_format);
    g_free (import_info_.payload);
    delete ti_ui_;
QString &ImportTextDialog::capfileName() {
    return capfile_name_;
}
void Singleton::f2();{
void ImportTextDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_IMPORT_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    ti_ui_->destinationPortLineEdit->setEnabled(port);
    ti_ui_->tagLabel->setEnabled(sctp_tag);
    ti_ui_->tagLineEdit->setEnabled(sctp_tag);
    ti_ui_->ppiLabel->setEnabled(sctp_ppi);
    ti_ui_->ppiLineEdit->setEnabled(sctp_ppi);
}
void Singleton::f4();{
        if (import_info_.encapsulation == WTAP_ENCAP_WIRESHARK_UPPER_PDU) enabled_export_pdu = true;
    }
    enableHeaderWidgets(enabled_ethernet, enabled_export_pdu);
bool ImportTextDialog::checkDateTimeFormat(const QString &time_format)
    const QString valid_code = "aAbBcdDFHIjmMpsSTUwWxXyYzZ%";
}
void Singleton::f5();{
    ti_ui_->payloadLabel->setEnabled(export_pdu);
    ti_ui_->payloadLineEdit->setEnabled(export_pdu);
int ImportTextDialog::exec() {
    QVariant encap_val;
    QDialog::exec();
}
void Singleton::f6();{
        if (conv_ok && *val_ptr <= max_val) {
            syntax_state = SyntaxLineEdit::Valid;
        } else {
            syntax_state = SyntaxLineEdit::Invalid;
            ok_enabled = false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    g_free (import_info_.date_timestamp_format);
    g_free (import_info_.payload);
    delete ti_ui_;
QString &ImportTextDialog::capfileName() {
    return capfile_name_;
}
void Singleton::f2();{
void ImportTextDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_IMPORT_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    ti_ui_->destinationPortLineEdit->setEnabled(port);
    ti_ui_->tagLabel->setEnabled(sctp_tag);
    ti_ui_->tagLineEdit->setEnabled(sctp_tag);
    ti_ui_->ppiLabel->setEnabled(sctp_ppi);
    ti_ui_->ppiLineEdit->setEnabled(sctp_ppi);
}
void Singleton::f4();{
        if (import_info_.encapsulation == WTAP_ENCAP_WIRESHARK_UPPER_PDU) enabled_export_pdu = true;
    }
    enableHeaderWidgets(enabled_ethernet, enabled_export_pdu);
bool ImportTextDialog::checkDateTimeFormat(const QString &time_format)
    const QString valid_code = "aAbBcdDFHIjmMpsSTUwWxXyYzZ%";
}
void Singleton::f5();{
    ti_ui_->payloadLabel->setEnabled(export_pdu);
    ti_ui_->payloadLineEdit->setEnabled(export_pdu);
int ImportTextDialog::exec() {
    QVariant encap_val;
    QDialog::exec();
}
void Singleton::f6();{
        if (conv_ok && *val_ptr <= max_val) {
            syntax_state = SyntaxLineEdit::Valid;
        } else {
            syntax_state = SyntaxLineEdit::Invalid;
            ok_enabled = false;
}
void Singleton::f7();{
    case FO_STYLE_LAST_OPENED:
        /* The user has specified that we should start out in the last directory
           we looked in.  If we've already opened a file, use its containing
           directory, if we could determine it, as the directory, otherwise
           use the "last opened" directory saved in the preferences file if
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    g_free (import_info_.date_timestamp_format);
    g_free (import_info_.payload);
    delete ti_ui_;
QString &ImportTextDialog::capfileName() {
    return capfile_name_;
}
void Singleton::f2();{
void ImportTextDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_IMPORT_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    ti_ui_->destinationPortLineEdit->setEnabled(port);
    ti_ui_->tagLabel->setEnabled(sctp_tag);
    ti_ui_->tagLineEdit->setEnabled(sctp_tag);
    ti_ui_->ppiLabel->setEnabled(sctp_ppi);
    ti_ui_->ppiLineEdit->setEnabled(sctp_ppi);
}
void Singleton::f4();{
        if (import_info_.encapsulation == WTAP_ENCAP_WIRESHARK_UPPER_PDU) enabled_export_pdu = true;
    }
    enableHeaderWidgets(enabled_ethernet, enabled_export_pdu);
bool ImportTextDialog::checkDateTimeFormat(const QString &time_format)
    const QString valid_code = "aAbBcdDFHIjmMpsSTUwWxXyYzZ%";
}
void Singleton::f5();{
    ti_ui_->payloadLabel->setEnabled(export_pdu);
    ti_ui_->payloadLineEdit->setEnabled(export_pdu);
int ImportTextDialog::exec() {
    QVariant encap_val;
    QDialog::exec();
}
void Singleton::f6();{
        if (conv_ok && *val_ptr <= max_val) {
            syntax_state = SyntaxLineEdit::Valid;
        } else {
            syntax_state = SyntaxLineEdit::Invalid;
            ok_enabled = false;
}
void Singleton::f7();{
    case FO_STYLE_LAST_OPENED:
        /* The user has specified that we should start out in the last directory
           we looked in.  If we've already opened a file, use its containing
           directory, if we could determine it, as the directory, otherwise
           use the "last opened" directory saved in the preferences file if
}
void Singleton::f8();{
    import_info_.import_text_file = ws_fopen(import_info_.import_text_filename, "rb");
    if (!import_info_.import_text_file) {
        open_failure_alert_box(import_info_.import_text_filename, errno, FALSE);
        setResult(QDialog::Rejected);
        return QDialog::Rejected;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    g_free (import_info_.date_timestamp_format);
    g_free (import_info_.payload);
    delete ti_ui_;
QString &ImportTextDialog::capfileName() {
    return capfile_name_;
}
void Singleton::f2();{
void ImportTextDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_IMPORT_DIALOG);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    ti_ui_->destinationPortLineEdit->setEnabled(port);
    ti_ui_->tagLabel->setEnabled(sctp_tag);
    ti_ui_->tagLineEdit->setEnabled(sctp_tag);
    ti_ui_->ppiLabel->setEnabled(sctp_ppi);
    ti_ui_->ppiLineEdit->setEnabled(sctp_ppi);
}
void Singleton::f4();{
        if (import_info_.encapsulation == WTAP_ENCAP_WIRESHARK_UPPER_PDU) enabled_export_pdu = true;
    }
    enableHeaderWidgets(enabled_ethernet, enabled_export_pdu);
bool ImportTextDialog::checkDateTimeFormat(const QString &time_format)
    const QString valid_code = "aAbBcdDFHIjmMpsSTUwWxXyYzZ%";
}
void Singleton::f5();{
    ti_ui_->payloadLabel->setEnabled(export_pdu);
    ti_ui_->payloadLineEdit->setEnabled(export_pdu);
int ImportTextDialog::exec() {
    QVariant encap_val;
    QDialog::exec();
}
void Singleton::f6();{
        if (conv_ok && *val_ptr <= max_val) {
            syntax_state = SyntaxLineEdit::Valid;
        } else {
            syntax_state = SyntaxLineEdit::Invalid;
            ok_enabled = false;
}
void Singleton::f7();{
    case FO_STYLE_LAST_OPENED:
        /* The user has specified that we should start out in the last directory
           we looked in.  If we've already opened a file, use its containing
           directory, if we could determine it, as the directory, otherwise
           use the "last opened" directory saved in the preferences file if
}
void Singleton::f8();{
    import_info_.import_text_file = ws_fopen(import_info_.import_text_filename, "rb");
    if (!import_info_.import_text_file) {
        open_failure_alert_box(import_info_.import_text_filename, errno, FALSE);
        setResult(QDialog::Rejected);
        return QDialog::Rejected;
}
void Singleton::f9();{
void ImportTextDialog::on_textFileBrowseButton_clicked()
    char *open_dir = NULL;
    switch (prefs.gui_fileopen_style) {
    case FO_STYLE_LAST_OPENED:
        /* The user has specified that we should start out in the last directory
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    if (! index.isValid())
        return QVariant();
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->data(mapToSource(index), role);
    int ifIdx = index.row() - sourceModel()->rowCount();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    if (! index.isValid())
        return QVariant();
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->data(mapToSource(index), role);
    int ifIdx = index.row() - sourceModel()->rowCount();
}
void Singleton::f2();{
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
    roles << Qt::DisplayRole;
}
void Singleton::f3();{
    if (! infos_.contains(info))
        infos_ << info;
void InfoProxyModel::clearInfos()
    infos_.clear();
int InfoProxyModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f4();{
    if (column_ >= 0) {
        //Notify new column has changed
        emit dataChanged(index(0, column_), index(rowCount(), column_), roles);
    }
 * Editor modelines
}
void Singleton::f5();{
    return QIdentityProxyModel::mapFromSource(fromIndex);
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
}
void Singleton::f6();{
    }
    return QIdentityProxyModel::data(index, role);
Qt::ItemFlags InfoProxyModel::flags(const QModelIndex &index) const
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->flags(mapToSource(index));
}
void Singleton::f7();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
InfoProxyModel::InfoProxyModel(QObject * parent)
 : QIdentityProxyModel(parent),
 column_(-1)
}
void Singleton::f8();{
        return QModelIndex();
    if (proxyIndex.row() >= sourceModel()->rowCount())
        return QModelIndex();
    return QIdentityProxyModel::mapToSource(proxyIndex);
QModelIndex InfoProxyModel::mapFromSource(const QModelIndex &fromIndex) const
}
void Singleton::f9();{
    {
    case Qt::DisplayRole:
        return infos_.at(ifIdx);
        break;
    case Qt::FontRole:
}
void Singleton::f10();{
    QVector<int> roles;
    roles << Qt::DisplayRole;
    if (old_column >= 0) {
        //Notify old column has changed
        emit dataChanged(index(0, old_column), index(rowCount(), old_column), roles);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    if (! index.isValid())
        return QVariant();
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->data(mapToSource(index), role);
    int ifIdx = index.row() - sourceModel()->rowCount();
}
void Singleton::f2();{
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
    roles << Qt::DisplayRole;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    if (! index.isValid())
        return QVariant();
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->data(mapToSource(index), role);
    int ifIdx = index.row() - sourceModel()->rowCount();
}
void Singleton::f2();{
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
    roles << Qt::DisplayRole;
}
void Singleton::f3();{
    if (! infos_.contains(info))
        infos_ << info;
void InfoProxyModel::clearInfos()
    infos_.clear();
int InfoProxyModel::rowCount(const QModelIndex &parent) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    if (! index.isValid())
        return QVariant();
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->data(mapToSource(index), role);
    int ifIdx = index.row() - sourceModel()->rowCount();
}
void Singleton::f2();{
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
    roles << Qt::DisplayRole;
}
void Singleton::f3();{
    if (! infos_.contains(info))
        infos_ << info;
void InfoProxyModel::clearInfos()
    infos_.clear();
int InfoProxyModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f4();{
    if (column_ >= 0) {
        //Notify new column has changed
        emit dataChanged(index(0, column_), index(rowCount(), column_), roles);
    }
 * Editor modelines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    if (! index.isValid())
        return QVariant();
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->data(mapToSource(index), role);
    int ifIdx = index.row() - sourceModel()->rowCount();
}
void Singleton::f2();{
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
    roles << Qt::DisplayRole;
}
void Singleton::f3();{
    if (! infos_.contains(info))
        infos_ << info;
void InfoProxyModel::clearInfos()
    infos_.clear();
int InfoProxyModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f4();{
    if (column_ >= 0) {
        //Notify new column has changed
        emit dataChanged(index(0, column_), index(rowCount(), column_), roles);
    }
 * Editor modelines
}
void Singleton::f5();{
    return QIdentityProxyModel::mapFromSource(fromIndex);
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    if (! index.isValid())
        return QVariant();
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->data(mapToSource(index), role);
    int ifIdx = index.row() - sourceModel()->rowCount();
}
void Singleton::f2();{
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
    roles << Qt::DisplayRole;
}
void Singleton::f3();{
    if (! infos_.contains(info))
        infos_ << info;
void InfoProxyModel::clearInfos()
    infos_.clear();
int InfoProxyModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f4();{
    if (column_ >= 0) {
        //Notify new column has changed
        emit dataChanged(index(0, column_), index(rowCount(), column_), roles);
    }
 * Editor modelines
}
void Singleton::f5();{
    return QIdentityProxyModel::mapFromSource(fromIndex);
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
}
void Singleton::f6();{
    }
    return QIdentityProxyModel::data(index, role);
Qt::ItemFlags InfoProxyModel::flags(const QModelIndex &index) const
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->flags(mapToSource(index));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    if (! index.isValid())
        return QVariant();
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->data(mapToSource(index), role);
    int ifIdx = index.row() - sourceModel()->rowCount();
}
void Singleton::f2();{
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
    roles << Qt::DisplayRole;
}
void Singleton::f3();{
    if (! infos_.contains(info))
        infos_ << info;
void InfoProxyModel::clearInfos()
    infos_.clear();
int InfoProxyModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f4();{
    if (column_ >= 0) {
        //Notify new column has changed
        emit dataChanged(index(0, column_), index(rowCount(), column_), roles);
    }
 * Editor modelines
}
void Singleton::f5();{
    return QIdentityProxyModel::mapFromSource(fromIndex);
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
}
void Singleton::f6();{
    }
    return QIdentityProxyModel::data(index, role);
Qt::ItemFlags InfoProxyModel::flags(const QModelIndex &index) const
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->flags(mapToSource(index));
}
void Singleton::f7();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
InfoProxyModel::InfoProxyModel(QObject * parent)
 : QIdentityProxyModel(parent),
 column_(-1)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    if (! index.isValid())
        return QVariant();
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->data(mapToSource(index), role);
    int ifIdx = index.row() - sourceModel()->rowCount();
}
void Singleton::f2();{
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
    roles << Qt::DisplayRole;
}
void Singleton::f3();{
    if (! infos_.contains(info))
        infos_ << info;
void InfoProxyModel::clearInfos()
    infos_.clear();
int InfoProxyModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f4();{
    if (column_ >= 0) {
        //Notify new column has changed
        emit dataChanged(index(0, column_), index(rowCount(), column_), roles);
    }
 * Editor modelines
}
void Singleton::f5();{
    return QIdentityProxyModel::mapFromSource(fromIndex);
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
}
void Singleton::f6();{
    }
    return QIdentityProxyModel::data(index, role);
Qt::ItemFlags InfoProxyModel::flags(const QModelIndex &index) const
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->flags(mapToSource(index));
}
void Singleton::f7();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
InfoProxyModel::InfoProxyModel(QObject * parent)
 : QIdentityProxyModel(parent),
 column_(-1)
}
void Singleton::f8();{
        return QModelIndex();
    if (proxyIndex.row() >= sourceModel()->rowCount())
        return QModelIndex();
    return QIdentityProxyModel::mapToSource(proxyIndex);
QModelIndex InfoProxyModel::mapFromSource(const QModelIndex &fromIndex) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    if (! index.isValid())
        return QVariant();
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->data(mapToSource(index), role);
    int ifIdx = index.row() - sourceModel()->rowCount();
}
void Singleton::f2();{
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
    roles << Qt::DisplayRole;
}
void Singleton::f3();{
    if (! infos_.contains(info))
        infos_ << info;
void InfoProxyModel::clearInfos()
    infos_.clear();
int InfoProxyModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f4();{
    if (column_ >= 0) {
        //Notify new column has changed
        emit dataChanged(index(0, column_), index(rowCount(), column_), roles);
    }
 * Editor modelines
}
void Singleton::f5();{
    return QIdentityProxyModel::mapFromSource(fromIndex);
void InfoProxyModel::setColumn(int column)
    int old_column = column_;
    column_ = column;
    QVector<int> roles;
}
void Singleton::f6();{
    }
    return QIdentityProxyModel::data(index, role);
Qt::ItemFlags InfoProxyModel::flags(const QModelIndex &index) const
    if (index.row() < sourceModel()->rowCount())
        return sourceModel()->flags(mapToSource(index));
}
void Singleton::f7();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
InfoProxyModel::InfoProxyModel(QObject * parent)
 : QIdentityProxyModel(parent),
 column_(-1)
}
void Singleton::f8();{
        return QModelIndex();
    if (proxyIndex.row() >= sourceModel()->rowCount())
        return QModelIndex();
    return QIdentityProxyModel::mapToSource(proxyIndex);
QModelIndex InfoProxyModel::mapFromSource(const QModelIndex &fromIndex) const
}
void Singleton::f9();{
    {
    case Qt::DisplayRole:
        return infos_.at(ifIdx);
        break;
    case Qt::FontRole:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        this->hProcess = nullptr;
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        this->hProcess = nullptr;
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
}
void Singleton::f2();{
    
    // We wait for the load to finish before proceeding to get the function to actually do the attach.
    std::cout << "Waiting for LoadLibraryA to complete." << std::endl;
    DWORD result = WaitForSingleObject(remoteThread, 5 * 1000);
    
}
void Singleton::f3();{
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
                this->remoteMemorySize = 0;
            }
}
void Singleton::f4();{
 * All we do here is load a dll in a remote program (in a remote thread).
 * Arguments must be the pid and the dll name to run.
 * i.e.: inject_dll.exe <pid> <dll path>
int wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )
    std::cout << "Running executable to inject dll." << std::endl;
}
void Singleton::f5();{
    wcstombs_s(&pathLen, dllPath, argv[2], MAX_PATH);
    
    const bool inheritable = false;
    const HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, inheritable, pid);
    if(hProcess == nullptr || hProcess == INVALID_HANDLE_VALUE){
}
void Singleton::f6();{
    dataToFree.hProcess = hProcess;
    std::cout << "OpenProcess with pid: " << pid << std::endl;
    
    const LPVOID remoteMemoryAddr = VirtualAllocEx(hProcess, nullptr, MAX_PATH_SIZE_PADDED, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if(remoteMemoryAddr == nullptr){
}
void Singleton::f7();{
        if(this->hProcess != nullptr){
            
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
}
void Singleton::f8();{
    } else if(result == WAIT_FAILED) {
        std::cout << "WaitForSingleObject(LoadLibraryA thread) failed. Error code: " << GetLastError() << "." << std::endl;
        return 9;
    }
    
}
void Singleton::f9();{
    memset(&dllPath[0], '\0', MAX_PATH_SIZE_PADDED);
    size_t pathLen = 0;
    wcstombs_s(&pathLen, dllPath, argv[2], MAX_PATH);
    
    const bool inheritable = false;
}
void Singleton::f10();{
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        this->hProcess = nullptr;
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
}
void Singleton::f2();{
    
    // We wait for the load to finish before proceeding to get the function to actually do the attach.
    std::cout << "Waiting for LoadLibraryA to complete." << std::endl;
    DWORD result = WaitForSingleObject(remoteThread, 5 * 1000);
    
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        this->hProcess = nullptr;
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
}
void Singleton::f2();{
    
    // We wait for the load to finish before proceeding to get the function to actually do the attach.
    std::cout << "Waiting for LoadLibraryA to complete." << std::endl;
    DWORD result = WaitForSingleObject(remoteThread, 5 * 1000);
    
}
void Singleton::f3();{
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
                this->remoteMemorySize = 0;
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        this->hProcess = nullptr;
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
}
void Singleton::f2();{
    
    // We wait for the load to finish before proceeding to get the function to actually do the attach.
    std::cout << "Waiting for LoadLibraryA to complete." << std::endl;
    DWORD result = WaitForSingleObject(remoteThread, 5 * 1000);
    
}
void Singleton::f3();{
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
                this->remoteMemorySize = 0;
            }
}
void Singleton::f4();{
 * All we do here is load a dll in a remote program (in a remote thread).
 * Arguments must be the pid and the dll name to run.
 * i.e.: inject_dll.exe <pid> <dll path>
int wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )
    std::cout << "Running executable to inject dll." << std::endl;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        this->hProcess = nullptr;
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
}
void Singleton::f2();{
    
    // We wait for the load to finish before proceeding to get the function to actually do the attach.
    std::cout << "Waiting for LoadLibraryA to complete." << std::endl;
    DWORD result = WaitForSingleObject(remoteThread, 5 * 1000);
    
}
void Singleton::f3();{
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
                this->remoteMemorySize = 0;
            }
}
void Singleton::f4();{
 * All we do here is load a dll in a remote program (in a remote thread).
 * Arguments must be the pid and the dll name to run.
 * i.e.: inject_dll.exe <pid> <dll path>
int wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )
    std::cout << "Running executable to inject dll." << std::endl;
}
void Singleton::f5();{
    wcstombs_s(&pathLen, dllPath, argv[2], MAX_PATH);
    
    const bool inheritable = false;
    const HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, inheritable, pid);
    if(hProcess == nullptr || hProcess == INVALID_HANDLE_VALUE){
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        this->hProcess = nullptr;
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
}
void Singleton::f2();{
    
    // We wait for the load to finish before proceeding to get the function to actually do the attach.
    std::cout << "Waiting for LoadLibraryA to complete." << std::endl;
    DWORD result = WaitForSingleObject(remoteThread, 5 * 1000);
    
}
void Singleton::f3();{
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
                this->remoteMemorySize = 0;
            }
}
void Singleton::f4();{
 * All we do here is load a dll in a remote program (in a remote thread).
 * Arguments must be the pid and the dll name to run.
 * i.e.: inject_dll.exe <pid> <dll path>
int wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )
    std::cout << "Running executable to inject dll." << std::endl;
}
void Singleton::f5();{
    wcstombs_s(&pathLen, dllPath, argv[2], MAX_PATH);
    
    const bool inheritable = false;
    const HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, inheritable, pid);
    if(hProcess == nullptr || hProcess == INVALID_HANDLE_VALUE){
}
void Singleton::f6();{
    dataToFree.hProcess = hProcess;
    std::cout << "OpenProcess with pid: " << pid << std::endl;
    
    const LPVOID remoteMemoryAddr = VirtualAllocEx(hProcess, nullptr, MAX_PATH_SIZE_PADDED, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if(remoteMemoryAddr == nullptr){
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        this->hProcess = nullptr;
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
}
void Singleton::f2();{
    
    // We wait for the load to finish before proceeding to get the function to actually do the attach.
    std::cout << "Waiting for LoadLibraryA to complete." << std::endl;
    DWORD result = WaitForSingleObject(remoteThread, 5 * 1000);
    
}
void Singleton::f3();{
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
                this->remoteMemorySize = 0;
            }
}
void Singleton::f4();{
 * All we do here is load a dll in a remote program (in a remote thread).
 * Arguments must be the pid and the dll name to run.
 * i.e.: inject_dll.exe <pid> <dll path>
int wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )
    std::cout << "Running executable to inject dll." << std::endl;
}
void Singleton::f5();{
    wcstombs_s(&pathLen, dllPath, argv[2], MAX_PATH);
    
    const bool inheritable = false;
    const HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, inheritable, pid);
    if(hProcess == nullptr || hProcess == INVALID_HANDLE_VALUE){
}
void Singleton::f6();{
    dataToFree.hProcess = hProcess;
    std::cout << "OpenProcess with pid: " << pid << std::endl;
    
    const LPVOID remoteMemoryAddr = VirtualAllocEx(hProcess, nullptr, MAX_PATH_SIZE_PADDED, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if(remoteMemoryAddr == nullptr){
}
void Singleton::f7();{
        if(this->hProcess != nullptr){
            
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        this->hProcess = nullptr;
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
}
void Singleton::f2();{
    
    // We wait for the load to finish before proceeding to get the function to actually do the attach.
    std::cout << "Waiting for LoadLibraryA to complete." << std::endl;
    DWORD result = WaitForSingleObject(remoteThread, 5 * 1000);
    
}
void Singleton::f3();{
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
                this->remoteMemorySize = 0;
            }
}
void Singleton::f4();{
 * All we do here is load a dll in a remote program (in a remote thread).
 * Arguments must be the pid and the dll name to run.
 * i.e.: inject_dll.exe <pid> <dll path>
int wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )
    std::cout << "Running executable to inject dll." << std::endl;
}
void Singleton::f5();{
    wcstombs_s(&pathLen, dllPath, argv[2], MAX_PATH);
    
    const bool inheritable = false;
    const HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, inheritable, pid);
    if(hProcess == nullptr || hProcess == INVALID_HANDLE_VALUE){
}
void Singleton::f6();{
    dataToFree.hProcess = hProcess;
    std::cout << "OpenProcess with pid: " << pid << std::endl;
    
    const LPVOID remoteMemoryAddr = VirtualAllocEx(hProcess, nullptr, MAX_PATH_SIZE_PADDED, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if(remoteMemoryAddr == nullptr){
}
void Singleton::f7();{
        if(this->hProcess != nullptr){
            
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
}
void Singleton::f8();{
    } else if(result == WAIT_FAILED) {
        std::cout << "WaitForSingleObject(LoadLibraryA thread) failed. Error code: " << GetLastError() << "." << std::endl;
        return 9;
    }
    
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        this->hProcess = nullptr;
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
}
void Singleton::f2();{
    
    // We wait for the load to finish before proceeding to get the function to actually do the attach.
    std::cout << "Waiting for LoadLibraryA to complete." << std::endl;
    DWORD result = WaitForSingleObject(remoteThread, 5 * 1000);
    
}
void Singleton::f3();{
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
                this->remoteMemorySize = 0;
            }
}
void Singleton::f4();{
 * All we do here is load a dll in a remote program (in a remote thread).
 * Arguments must be the pid and the dll name to run.
 * i.e.: inject_dll.exe <pid> <dll path>
int wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )
    std::cout << "Running executable to inject dll." << std::endl;
}
void Singleton::f5();{
    wcstombs_s(&pathLen, dllPath, argv[2], MAX_PATH);
    
    const bool inheritable = false;
    const HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, inheritable, pid);
    if(hProcess == nullptr || hProcess == INVALID_HANDLE_VALUE){
}
void Singleton::f6();{
    dataToFree.hProcess = hProcess;
    std::cout << "OpenProcess with pid: " << pid << std::endl;
    
    const LPVOID remoteMemoryAddr = VirtualAllocEx(hProcess, nullptr, MAX_PATH_SIZE_PADDED, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if(remoteMemoryAddr == nullptr){
}
void Singleton::f7();{
        if(this->hProcess != nullptr){
            
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
}
void Singleton::f8();{
    } else if(result == WAIT_FAILED) {
        std::cout << "WaitForSingleObject(LoadLibraryA thread) failed. Error code: " << GetLastError() << "." << std::endl;
        return 9;
    }
    
}
void Singleton::f9();{
    memset(&dllPath[0], '\0', MAX_PATH_SIZE_PADDED);
    size_t pathLen = 0;
    wcstombs_s(&pathLen, dllPath, argv[2], MAX_PATH);
    
    const bool inheritable = false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
 * Based on your needs, you can change the following settings:
 * <ul>
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
 * Based on your needs, you can change the following settings:
 * <ul>
}
void Singleton::f2();{
    printer.d(object);
  public static void e(@NonNull String message, @Nullable Object... args) {
    printer.e(null, message, args);
  public static void e(@Nullable Throwable throwable, @NonNull String message, @Nullable Object... args) {
    printer.e(throwable, message, args);
}
void Singleton::f3();{
 * </code></pre>
 * <h3>Json and Xml support (output will be in debug level)</h3>
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
}
void Singleton::f4();{
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
}
void Singleton::f5();{
  public static final int WARN = 5;
  public static final int ERROR = 6;
  public static final int ASSERT = 7;
  @NonNull private static Printer printer = new LoggerPrinter();
  private Logger() {
}
void Singleton::f6();{
   * General log function that accepts all configurations as parameter
   */
  public static void log(int priority, @Nullable String tag, @Nullable String message, @Nullable Throwable throwable) {
    printer.log(priority, tag, message, throwable);
  public static void d(@NonNull String message, @Nullable Object... args) {
}
void Singleton::f7();{
  public static void v(@NonNull String message, @Nullable Object... args) {
    printer.v(message, args);
  public static void w(@NonNull String message, @Nullable Object... args) {
    printer.w(message, args);
  /**
}
void Singleton::f8();{
  public static final int VERBOSE = 2;
  public static final int DEBUG = 3;
  public static final int INFO = 4;
  public static final int WARN = 5;
  public static final int ERROR = 6;
}
void Singleton::f9();{
 *   Logger.e("error");
 *   Logger.w("warning");
 *   Logger.v("verbose");
 *   Logger.i("information");
 *   Logger.wtf("What a Terrible Failure");
}
void Singleton::f10();{
    printer.e(throwable, message, args);
  public static void i(@NonNull String message, @Nullable Object... args) {
    printer.i(message, args);
  public static void v(@NonNull String message, @Nullable Object... args) {
    printer.v(message, args);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
 * Based on your needs, you can change the following settings:
 * <ul>
}
void Singleton::f2();{
    printer.d(object);
  public static void e(@NonNull String message, @Nullable Object... args) {
    printer.e(null, message, args);
  public static void e(@Nullable Throwable throwable, @NonNull String message, @Nullable Object... args) {
    printer.e(throwable, message, args);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
 * Based on your needs, you can change the following settings:
 * <ul>
}
void Singleton::f2();{
    printer.d(object);
  public static void e(@NonNull String message, @Nullable Object... args) {
    printer.e(null, message, args);
  public static void e(@Nullable Throwable throwable, @NonNull String message, @Nullable Object... args) {
    printer.e(throwable, message, args);
}
void Singleton::f3();{
 * </code></pre>
 * <h3>Json and Xml support (output will be in debug level)</h3>
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
 * Based on your needs, you can change the following settings:
 * <ul>
}
void Singleton::f2();{
    printer.d(object);
  public static void e(@NonNull String message, @Nullable Object... args) {
    printer.e(null, message, args);
  public static void e(@Nullable Throwable throwable, @NonNull String message, @Nullable Object... args) {
    printer.e(throwable, message, args);
}
void Singleton::f3();{
 * </code></pre>
 * <h3>Json and Xml support (output will be in debug level)</h3>
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
}
void Singleton::f4();{
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
 * Based on your needs, you can change the following settings:
 * <ul>
}
void Singleton::f2();{
    printer.d(object);
  public static void e(@NonNull String message, @Nullable Object... args) {
    printer.e(null, message, args);
  public static void e(@Nullable Throwable throwable, @NonNull String message, @Nullable Object... args) {
    printer.e(throwable, message, args);
}
void Singleton::f3();{
 * </code></pre>
 * <h3>Json and Xml support (output will be in debug level)</h3>
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
}
void Singleton::f4();{
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
}
void Singleton::f5();{
  public static final int WARN = 5;
  public static final int ERROR = 6;
  public static final int ASSERT = 7;
  @NonNull private static Printer printer = new LoggerPrinter();
  private Logger() {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
 * Based on your needs, you can change the following settings:
 * <ul>
}
void Singleton::f2();{
    printer.d(object);
  public static void e(@NonNull String message, @Nullable Object... args) {
    printer.e(null, message, args);
  public static void e(@Nullable Throwable throwable, @NonNull String message, @Nullable Object... args) {
    printer.e(throwable, message, args);
}
void Singleton::f3();{
 * </code></pre>
 * <h3>Json and Xml support (output will be in debug level)</h3>
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
}
void Singleton::f4();{
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
}
void Singleton::f5();{
  public static final int WARN = 5;
  public static final int ERROR = 6;
  public static final int ASSERT = 7;
  @NonNull private static Printer printer = new LoggerPrinter();
  private Logger() {
}
void Singleton::f6();{
   * General log function that accepts all configurations as parameter
   */
  public static void log(int priority, @Nullable String tag, @Nullable String message, @Nullable Throwable throwable) {
    printer.log(priority, tag, message, throwable);
  public static void d(@NonNull String message, @Nullable Object... args) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
 * Based on your needs, you can change the following settings:
 * <ul>
}
void Singleton::f2();{
    printer.d(object);
  public static void e(@NonNull String message, @Nullable Object... args) {
    printer.e(null, message, args);
  public static void e(@Nullable Throwable throwable, @NonNull String message, @Nullable Object... args) {
    printer.e(throwable, message, args);
}
void Singleton::f3();{
 * </code></pre>
 * <h3>Json and Xml support (output will be in debug level)</h3>
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
}
void Singleton::f4();{
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
}
void Singleton::f5();{
  public static final int WARN = 5;
  public static final int ERROR = 6;
  public static final int ASSERT = 7;
  @NonNull private static Printer printer = new LoggerPrinter();
  private Logger() {
}
void Singleton::f6();{
   * General log function that accepts all configurations as parameter
   */
  public static void log(int priority, @Nullable String tag, @Nullable String message, @Nullable Throwable throwable) {
    printer.log(priority, tag, message, throwable);
  public static void d(@NonNull String message, @Nullable Object... args) {
}
void Singleton::f7();{
  public static void v(@NonNull String message, @Nullable Object... args) {
    printer.v(message, args);
  public static void w(@NonNull String message, @Nullable Object... args) {
    printer.w(message, args);
  /**
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
 * Based on your needs, you can change the following settings:
 * <ul>
}
void Singleton::f2();{
    printer.d(object);
  public static void e(@NonNull String message, @Nullable Object... args) {
    printer.e(null, message, args);
  public static void e(@Nullable Throwable throwable, @NonNull String message, @Nullable Object... args) {
    printer.e(throwable, message, args);
}
void Singleton::f3();{
 * </code></pre>
 * <h3>Json and Xml support (output will be in debug level)</h3>
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
}
void Singleton::f4();{
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
}
void Singleton::f5();{
  public static final int WARN = 5;
  public static final int ERROR = 6;
  public static final int ASSERT = 7;
  @NonNull private static Printer printer = new LoggerPrinter();
  private Logger() {
}
void Singleton::f6();{
   * General log function that accepts all configurations as parameter
   */
  public static void log(int priority, @Nullable String tag, @Nullable String message, @Nullable Throwable throwable) {
    printer.log(priority, tag, message, throwable);
  public static void d(@NonNull String message, @Nullable Object... args) {
}
void Singleton::f7();{
  public static void v(@NonNull String message, @Nullable Object... args) {
    printer.v(message, args);
  public static void w(@NonNull String message, @Nullable Object... args) {
    printer.w(message, args);
  /**
}
void Singleton::f8();{
  public static final int VERBOSE = 2;
  public static final int DEBUG = 3;
  public static final int INFO = 4;
  public static final int WARN = 5;
  public static final int ERROR = 6;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
 * Based on your needs, you can change the following settings:
 * <ul>
}
void Singleton::f2();{
    printer.d(object);
  public static void e(@NonNull String message, @Nullable Object... args) {
    printer.e(null, message, args);
  public static void e(@Nullable Throwable throwable, @NonNull String message, @Nullable Object... args) {
    printer.e(throwable, message, args);
}
void Singleton::f3();{
 * </code></pre>
 * <h3>Json and Xml support (output will be in debug level)</h3>
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
}
void Singleton::f4();{
 * <pre><code>
 *   Logger.json(JSON_CONTENT);
 *   Logger.xml(XML_CONTENT);
 * </code></pre>
 * <h3>Customize Logger</h3>
}
void Singleton::f5();{
  public static final int WARN = 5;
  public static final int ERROR = 6;
  public static final int ASSERT = 7;
  @NonNull private static Printer printer = new LoggerPrinter();
  private Logger() {
}
void Singleton::f6();{
   * General log function that accepts all configurations as parameter
   */
  public static void log(int priority, @Nullable String tag, @Nullable String message, @Nullable Throwable throwable) {
    printer.log(priority, tag, message, throwable);
  public static void d(@NonNull String message, @Nullable Object... args) {
}
void Singleton::f7();{
  public static void v(@NonNull String message, @Nullable Object... args) {
    printer.v(message, args);
  public static void w(@NonNull String message, @Nullable Object... args) {
    printer.w(message, args);
  /**
}
void Singleton::f8();{
  public static final int VERBOSE = 2;
  public static final int DEBUG = 3;
  public static final int INFO = 4;
  public static final int WARN = 5;
  public static final int ERROR = 6;
}
void Singleton::f9();{
 *   Logger.e("error");
 *   Logger.w("warning");
 *   Logger.v("verbose");
 *   Logger.i("information");
 *   Logger.wtf("What a Terrible Failure");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
void InterfaceFrame::resetInterfaceTreeDisplay()
    ui->warningLabel->hide();
    ui->warningLabel->clear();
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
void InterfaceFrame::resetInterfaceTreeDisplay()
    ui->warningLabel->hide();
    ui->warningLabel->clear();
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
}
void Singleton::f2();{
    }
/* Proxy Method so we do not need to expose the source model */
void InterfaceFrame::getPoints(int idx, PointList * pts)
    source_model_.getPoints(idx, pts);
void InterfaceFrame::showRunOnFile(void)
}
void Singleton::f3();{
    QMenu * contextMenu = new QMenu(this);
    QList<int> typesDisplayed = proxy_model_.typesDisplayed();
    QMap<int, QString>::const_iterator it = ifTypeDescription.constBegin();
    while (it != ifTypeDescription.constEnd())
    {
}
void Singleton::f4();{
int InterfaceFrame::interfacesHidden()
    return proxy_model_.interfacesHidden();
int InterfaceFrame::interfacesPresent()
    return source_model_.rowCount() - proxy_model_.interfacesHidden();
void InterfaceFrame::ensureSelectedInterface()
}
void Singleton::f5();{
    QFileInfo bpf0_fi = QFileInfo("/dev/bpf0");
    return bpf0_fi.isReadable() && bpf0_fi.isWritable();
    // XXX Add checks for other platforms.
    return true;
void InterfaceFrame::updateSelectedInterfaces()
}
void Singleton::f6();{
    {
        QString warning_text = ui->warningLabel->text();
        warning_text.append(QString("<p><a href=\"%1\">%2</a></p>")
                            .arg(no_capture_link)
                            .arg(SimpleDialog::dontShowThisAgain()));
}
void Singleton::f7();{
    }
    // Disabled until bug 13354 is fixed
    contextMenu->addSeparator();
    QAction * toggleHideAction = new QAction(tr("Show hidden interfaces"), this);
    toggleHideAction->setCheckable(true);
}
void Singleton::f8();{
    ctx_menu.addAction(tr("Start capture"), this, SIGNAL(startCapture()));
    ctx_menu.exec(ui->interfaceTree->mapToGlobal(pos));
void InterfaceFrame::on_warningLabel_linkActivated(const QString &link)
    if (link.compare(no_capture_link) == 0) {
        recent.sys_warn_if_no_capture = FALSE;
}
void Singleton::f9();{
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
            "<p>"
            "Local interfaces are unavailable because no packet capture driver is installed."
            "</p><p>"
}
void Singleton::f10();{
        ui->interfaceTree->resizeColumnToContents(proxy_model_.mapSourceToColumn(IFTREE_COL_STATS));
    }
    else
    {
        ui->interfaceTree->hide();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
void InterfaceFrame::resetInterfaceTreeDisplay()
    ui->warningLabel->hide();
    ui->warningLabel->clear();
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
}
void Singleton::f2();{
    }
/* Proxy Method so we do not need to expose the source model */
void InterfaceFrame::getPoints(int idx, PointList * pts)
    source_model_.getPoints(idx, pts);
void InterfaceFrame::showRunOnFile(void)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
void InterfaceFrame::resetInterfaceTreeDisplay()
    ui->warningLabel->hide();
    ui->warningLabel->clear();
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
}
void Singleton::f2();{
    }
/* Proxy Method so we do not need to expose the source model */
void InterfaceFrame::getPoints(int idx, PointList * pts)
    source_model_.getPoints(idx, pts);
void InterfaceFrame::showRunOnFile(void)
}
void Singleton::f3();{
    QMenu * contextMenu = new QMenu(this);
    QList<int> typesDisplayed = proxy_model_.typesDisplayed();
    QMap<int, QString>::const_iterator it = ifTypeDescription.constBegin();
    while (it != ifTypeDescription.constEnd())
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
void InterfaceFrame::resetInterfaceTreeDisplay()
    ui->warningLabel->hide();
    ui->warningLabel->clear();
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
}
void Singleton::f2();{
    }
/* Proxy Method so we do not need to expose the source model */
void InterfaceFrame::getPoints(int idx, PointList * pts)
    source_model_.getPoints(idx, pts);
void InterfaceFrame::showRunOnFile(void)
}
void Singleton::f3();{
    QMenu * contextMenu = new QMenu(this);
    QList<int> typesDisplayed = proxy_model_.typesDisplayed();
    QMap<int, QString>::const_iterator it = ifTypeDescription.constBegin();
    while (it != ifTypeDescription.constEnd())
    {
}
void Singleton::f4();{
int InterfaceFrame::interfacesHidden()
    return proxy_model_.interfacesHidden();
int InterfaceFrame::interfacesPresent()
    return source_model_.rowCount() - proxy_model_.interfacesHidden();
void InterfaceFrame::ensureSelectedInterface()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
void InterfaceFrame::resetInterfaceTreeDisplay()
    ui->warningLabel->hide();
    ui->warningLabel->clear();
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
}
void Singleton::f2();{
    }
/* Proxy Method so we do not need to expose the source model */
void InterfaceFrame::getPoints(int idx, PointList * pts)
    source_model_.getPoints(idx, pts);
void InterfaceFrame::showRunOnFile(void)
}
void Singleton::f3();{
    QMenu * contextMenu = new QMenu(this);
    QList<int> typesDisplayed = proxy_model_.typesDisplayed();
    QMap<int, QString>::const_iterator it = ifTypeDescription.constBegin();
    while (it != ifTypeDescription.constEnd())
    {
}
void Singleton::f4();{
int InterfaceFrame::interfacesHidden()
    return proxy_model_.interfacesHidden();
int InterfaceFrame::interfacesPresent()
    return source_model_.rowCount() - proxy_model_.interfacesHidden();
void InterfaceFrame::ensureSelectedInterface()
}
void Singleton::f5();{
    QFileInfo bpf0_fi = QFileInfo("/dev/bpf0");
    return bpf0_fi.isReadable() && bpf0_fi.isWritable();
    // XXX Add checks for other platforms.
    return true;
void InterfaceFrame::updateSelectedInterfaces()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
void InterfaceFrame::resetInterfaceTreeDisplay()
    ui->warningLabel->hide();
    ui->warningLabel->clear();
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
}
void Singleton::f2();{
    }
/* Proxy Method so we do not need to expose the source model */
void InterfaceFrame::getPoints(int idx, PointList * pts)
    source_model_.getPoints(idx, pts);
void InterfaceFrame::showRunOnFile(void)
}
void Singleton::f3();{
    QMenu * contextMenu = new QMenu(this);
    QList<int> typesDisplayed = proxy_model_.typesDisplayed();
    QMap<int, QString>::const_iterator it = ifTypeDescription.constBegin();
    while (it != ifTypeDescription.constEnd())
    {
}
void Singleton::f4();{
int InterfaceFrame::interfacesHidden()
    return proxy_model_.interfacesHidden();
int InterfaceFrame::interfacesPresent()
    return source_model_.rowCount() - proxy_model_.interfacesHidden();
void InterfaceFrame::ensureSelectedInterface()
}
void Singleton::f5();{
    QFileInfo bpf0_fi = QFileInfo("/dev/bpf0");
    return bpf0_fi.isReadable() && bpf0_fi.isWritable();
    // XXX Add checks for other platforms.
    return true;
void InterfaceFrame::updateSelectedInterfaces()
}
void Singleton::f6();{
    {
        QString warning_text = ui->warningLabel->text();
        warning_text.append(QString("<p><a href=\"%1\">%2</a></p>")
                            .arg(no_capture_link)
                            .arg(SimpleDialog::dontShowThisAgain()));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
void InterfaceFrame::resetInterfaceTreeDisplay()
    ui->warningLabel->hide();
    ui->warningLabel->clear();
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
}
void Singleton::f2();{
    }
/* Proxy Method so we do not need to expose the source model */
void InterfaceFrame::getPoints(int idx, PointList * pts)
    source_model_.getPoints(idx, pts);
void InterfaceFrame::showRunOnFile(void)
}
void Singleton::f3();{
    QMenu * contextMenu = new QMenu(this);
    QList<int> typesDisplayed = proxy_model_.typesDisplayed();
    QMap<int, QString>::const_iterator it = ifTypeDescription.constBegin();
    while (it != ifTypeDescription.constEnd())
    {
}
void Singleton::f4();{
int InterfaceFrame::interfacesHidden()
    return proxy_model_.interfacesHidden();
int InterfaceFrame::interfacesPresent()
    return source_model_.rowCount() - proxy_model_.interfacesHidden();
void InterfaceFrame::ensureSelectedInterface()
}
void Singleton::f5();{
    QFileInfo bpf0_fi = QFileInfo("/dev/bpf0");
    return bpf0_fi.isReadable() && bpf0_fi.isWritable();
    // XXX Add checks for other platforms.
    return true;
void InterfaceFrame::updateSelectedInterfaces()
}
void Singleton::f6();{
    {
        QString warning_text = ui->warningLabel->text();
        warning_text.append(QString("<p><a href=\"%1\">%2</a></p>")
                            .arg(no_capture_link)
                            .arg(SimpleDialog::dontShowThisAgain()));
}
void Singleton::f7();{
    }
    // Disabled until bug 13354 is fixed
    contextMenu->addSeparator();
    QAction * toggleHideAction = new QAction(tr("Show hidden interfaces"), this);
    toggleHideAction->setCheckable(true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
void InterfaceFrame::resetInterfaceTreeDisplay()
    ui->warningLabel->hide();
    ui->warningLabel->clear();
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
}
void Singleton::f2();{
    }
/* Proxy Method so we do not need to expose the source model */
void InterfaceFrame::getPoints(int idx, PointList * pts)
    source_model_.getPoints(idx, pts);
void InterfaceFrame::showRunOnFile(void)
}
void Singleton::f3();{
    QMenu * contextMenu = new QMenu(this);
    QList<int> typesDisplayed = proxy_model_.typesDisplayed();
    QMap<int, QString>::const_iterator it = ifTypeDescription.constBegin();
    while (it != ifTypeDescription.constEnd())
    {
}
void Singleton::f4();{
int InterfaceFrame::interfacesHidden()
    return proxy_model_.interfacesHidden();
int InterfaceFrame::interfacesPresent()
    return source_model_.rowCount() - proxy_model_.interfacesHidden();
void InterfaceFrame::ensureSelectedInterface()
}
void Singleton::f5();{
    QFileInfo bpf0_fi = QFileInfo("/dev/bpf0");
    return bpf0_fi.isReadable() && bpf0_fi.isWritable();
    // XXX Add checks for other platforms.
    return true;
void InterfaceFrame::updateSelectedInterfaces()
}
void Singleton::f6();{
    {
        QString warning_text = ui->warningLabel->text();
        warning_text.append(QString("<p><a href=\"%1\">%2</a></p>")
                            .arg(no_capture_link)
                            .arg(SimpleDialog::dontShowThisAgain()));
}
void Singleton::f7();{
    }
    // Disabled until bug 13354 is fixed
    contextMenu->addSeparator();
    QAction * toggleHideAction = new QAction(tr("Show hidden interfaces"), this);
    toggleHideAction->setCheckable(true);
}
void Singleton::f8();{
    ctx_menu.addAction(tr("Start capture"), this, SIGNAL(startCapture()));
    ctx_menu.exec(ui->interfaceTree->mapToGlobal(pos));
void InterfaceFrame::on_warningLabel_linkActivated(const QString &link)
    if (link.compare(no_capture_link) == 0) {
        recent.sys_warn_if_no_capture = FALSE;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
void InterfaceFrame::resetInterfaceTreeDisplay()
    ui->warningLabel->hide();
    ui->warningLabel->clear();
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
}
void Singleton::f2();{
    }
/* Proxy Method so we do not need to expose the source model */
void InterfaceFrame::getPoints(int idx, PointList * pts)
    source_model_.getPoints(idx, pts);
void InterfaceFrame::showRunOnFile(void)
}
void Singleton::f3();{
    QMenu * contextMenu = new QMenu(this);
    QList<int> typesDisplayed = proxy_model_.typesDisplayed();
    QMap<int, QString>::const_iterator it = ifTypeDescription.constBegin();
    while (it != ifTypeDescription.constEnd())
    {
}
void Singleton::f4();{
int InterfaceFrame::interfacesHidden()
    return proxy_model_.interfacesHidden();
int InterfaceFrame::interfacesPresent()
    return source_model_.rowCount() - proxy_model_.interfacesHidden();
void InterfaceFrame::ensureSelectedInterface()
}
void Singleton::f5();{
    QFileInfo bpf0_fi = QFileInfo("/dev/bpf0");
    return bpf0_fi.isReadable() && bpf0_fi.isWritable();
    // XXX Add checks for other platforms.
    return true;
void InterfaceFrame::updateSelectedInterfaces()
}
void Singleton::f6();{
    {
        QString warning_text = ui->warningLabel->text();
        warning_text.append(QString("<p><a href=\"%1\">%2</a></p>")
                            .arg(no_capture_link)
                            .arg(SimpleDialog::dontShowThisAgain()));
}
void Singleton::f7();{
    }
    // Disabled until bug 13354 is fixed
    contextMenu->addSeparator();
    QAction * toggleHideAction = new QAction(tr("Show hidden interfaces"), this);
    toggleHideAction->setCheckable(true);
}
void Singleton::f8();{
    ctx_menu.addAction(tr("Start capture"), this, SIGNAL(startCapture()));
    ctx_menu.exec(ui->interfaceTree->mapToGlobal(pos));
void InterfaceFrame::on_warningLabel_linkActivated(const QString &link)
    if (link.compare(no_capture_link) == 0) {
        recent.sys_warn_if_no_capture = FALSE;
}
void Singleton::f9();{
    if (!has_wpcap) {
        ui->warningLabel->setText(tr(
            "<p>"
            "Local interfaces are unavailable because no packet capture driver is installed."
            "</p><p>"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        return;
    if (_storeOnChange)
    {
        QString new_pref;
        QList<int>::const_iterator it = displayHiddenTypes.constBegin();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        return;
    if (_storeOnChange)
    {
        QString new_pref;
        QList<int>::const_iterator it = displayHiddenTypes.constBegin();
}
void Singleton::f2();{
        QStringList ifTypesStored = stored_prefs.split(',');
        QStringList::const_iterator it = ifTypesStored.constBegin();
        while (it != ifTypesStored.constEnd())
        {
            int i_val = (*it).toInt();
}
void Singleton::f3();{
    QList<int> shownTypes;
    if (sourceModel()->rowCount() == 0)
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
}
void Singleton::f4();{
        resetPreferenceData();
    }
void InterfaceSortFilterModel::setFilterHidden(bool filter)
    _filterHidden = filter;
    invalidate();
}
void Singleton::f5();{
    return true;
bool InterfaceSortFilterModel::filterAcceptsColumn(int sourceColumn, const QModelIndex & sourceParent) const
    QModelIndex realIndex = sourceModel()->index(0, sourceColumn, sourceParent);
    if (! realIndex.isValid())
        return false;
}
void Singleton::f6();{
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
        int type = ((InterfaceTreeModel *)sourceModel())->getColumnContent(idx, IFTREE_COL_TYPE).toInt();
        bool hidden = ((InterfaceTreeModel *)sourceModel())->getColumnContent(idx, IFTREE_COL_HIDDEN).toBool();
}
void Singleton::f7();{
    return ((_invertTypeFilter && ! result) || (! _invertTypeFilter && result) );
bool InterfaceSortFilterModel::filterAcceptsRow(int sourceRow, const QModelIndex & sourceParent) const
    QModelIndex realIndex = sourceModel()->index(sourceRow, 0, sourceParent);
    if (! realIndex.isValid())
        return false;
}
void Singleton::f8();{
    {
        /* Remote interfaces have the if type IF_WIRED, therefore would be filtered, if not explicitly checked here */
        if (type != IF_WIRED || ! ((InterfaceTreeModel *)sourceModel())->isRemote(idx))
        return false;
    }
}
void Singleton::f9();{
QList<int> InterfaceSortFilterModel::typesDisplayed()
    QList<int> shownTypes;
    if (sourceModel()->rowCount() == 0)
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
}
void Singleton::f10();{
    /* Adding all columns, to have a default setting */
    for (int col = 0; col < IFTREE_COL_MAX; col++)
        _columns.append((InterfaceTreeColumns)col);
    invalidateFilter();
    invalidate();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        return;
    if (_storeOnChange)
    {
        QString new_pref;
        QList<int>::const_iterator it = displayHiddenTypes.constBegin();
}
void Singleton::f2();{
        QStringList ifTypesStored = stored_prefs.split(',');
        QStringList::const_iterator it = ifTypesStored.constBegin();
        while (it != ifTypesStored.constEnd())
        {
            int i_val = (*it).toInt();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        return;
    if (_storeOnChange)
    {
        QString new_pref;
        QList<int>::const_iterator it = displayHiddenTypes.constBegin();
}
void Singleton::f2();{
        QStringList ifTypesStored = stored_prefs.split(',');
        QStringList::const_iterator it = ifTypesStored.constBegin();
        while (it != ifTypesStored.constEnd())
        {
            int i_val = (*it).toInt();
}
void Singleton::f3();{
    QList<int> shownTypes;
    if (sourceModel()->rowCount() == 0)
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        return;
    if (_storeOnChange)
    {
        QString new_pref;
        QList<int>::const_iterator it = displayHiddenTypes.constBegin();
}
void Singleton::f2();{
        QStringList ifTypesStored = stored_prefs.split(',');
        QStringList::const_iterator it = ifTypesStored.constBegin();
        while (it != ifTypesStored.constEnd())
        {
            int i_val = (*it).toInt();
}
void Singleton::f3();{
    QList<int> shownTypes;
    if (sourceModel()->rowCount() == 0)
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
}
void Singleton::f4();{
        resetPreferenceData();
    }
void InterfaceSortFilterModel::setFilterHidden(bool filter)
    _filterHidden = filter;
    invalidate();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        return;
    if (_storeOnChange)
    {
        QString new_pref;
        QList<int>::const_iterator it = displayHiddenTypes.constBegin();
}
void Singleton::f2();{
        QStringList ifTypesStored = stored_prefs.split(',');
        QStringList::const_iterator it = ifTypesStored.constBegin();
        while (it != ifTypesStored.constEnd())
        {
            int i_val = (*it).toInt();
}
void Singleton::f3();{
    QList<int> shownTypes;
    if (sourceModel()->rowCount() == 0)
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
}
void Singleton::f4();{
        resetPreferenceData();
    }
void InterfaceSortFilterModel::setFilterHidden(bool filter)
    _filterHidden = filter;
    invalidate();
}
void Singleton::f5();{
    return true;
bool InterfaceSortFilterModel::filterAcceptsColumn(int sourceColumn, const QModelIndex & sourceParent) const
    QModelIndex realIndex = sourceModel()->index(0, sourceColumn, sourceParent);
    if (! realIndex.isValid())
        return false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        return;
    if (_storeOnChange)
    {
        QString new_pref;
        QList<int>::const_iterator it = displayHiddenTypes.constBegin();
}
void Singleton::f2();{
        QStringList ifTypesStored = stored_prefs.split(',');
        QStringList::const_iterator it = ifTypesStored.constBegin();
        while (it != ifTypesStored.constEnd())
        {
            int i_val = (*it).toInt();
}
void Singleton::f3();{
    QList<int> shownTypes;
    if (sourceModel()->rowCount() == 0)
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
}
void Singleton::f4();{
        resetPreferenceData();
    }
void InterfaceSortFilterModel::setFilterHidden(bool filter)
    _filterHidden = filter;
    invalidate();
}
void Singleton::f5();{
    return true;
bool InterfaceSortFilterModel::filterAcceptsColumn(int sourceColumn, const QModelIndex & sourceParent) const
    QModelIndex realIndex = sourceModel()->index(0, sourceColumn, sourceParent);
    if (! realIndex.isValid())
        return false;
}
void Singleton::f6();{
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
        int type = ((InterfaceTreeModel *)sourceModel())->getColumnContent(idx, IFTREE_COL_TYPE).toInt();
        bool hidden = ((InterfaceTreeModel *)sourceModel())->getColumnContent(idx, IFTREE_COL_HIDDEN).toBool();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        return;
    if (_storeOnChange)
    {
        QString new_pref;
        QList<int>::const_iterator it = displayHiddenTypes.constBegin();
}
void Singleton::f2();{
        QStringList ifTypesStored = stored_prefs.split(',');
        QStringList::const_iterator it = ifTypesStored.constBegin();
        while (it != ifTypesStored.constEnd())
        {
            int i_val = (*it).toInt();
}
void Singleton::f3();{
    QList<int> shownTypes;
    if (sourceModel()->rowCount() == 0)
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
}
void Singleton::f4();{
        resetPreferenceData();
    }
void InterfaceSortFilterModel::setFilterHidden(bool filter)
    _filterHidden = filter;
    invalidate();
}
void Singleton::f5();{
    return true;
bool InterfaceSortFilterModel::filterAcceptsColumn(int sourceColumn, const QModelIndex & sourceParent) const
    QModelIndex realIndex = sourceModel()->index(0, sourceColumn, sourceParent);
    if (! realIndex.isValid())
        return false;
}
void Singleton::f6();{
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
        int type = ((InterfaceTreeModel *)sourceModel())->getColumnContent(idx, IFTREE_COL_TYPE).toInt();
        bool hidden = ((InterfaceTreeModel *)sourceModel())->getColumnContent(idx, IFTREE_COL_HIDDEN).toBool();
}
void Singleton::f7();{
    return ((_invertTypeFilter && ! result) || (! _invertTypeFilter && result) );
bool InterfaceSortFilterModel::filterAcceptsRow(int sourceRow, const QModelIndex & sourceParent) const
    QModelIndex realIndex = sourceModel()->index(sourceRow, 0, sourceParent);
    if (! realIndex.isValid())
        return false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        return;
    if (_storeOnChange)
    {
        QString new_pref;
        QList<int>::const_iterator it = displayHiddenTypes.constBegin();
}
void Singleton::f2();{
        QStringList ifTypesStored = stored_prefs.split(',');
        QStringList::const_iterator it = ifTypesStored.constBegin();
        while (it != ifTypesStored.constEnd())
        {
            int i_val = (*it).toInt();
}
void Singleton::f3();{
    QList<int> shownTypes;
    if (sourceModel()->rowCount() == 0)
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
}
void Singleton::f4();{
        resetPreferenceData();
    }
void InterfaceSortFilterModel::setFilterHidden(bool filter)
    _filterHidden = filter;
    invalidate();
}
void Singleton::f5();{
    return true;
bool InterfaceSortFilterModel::filterAcceptsColumn(int sourceColumn, const QModelIndex & sourceParent) const
    QModelIndex realIndex = sourceModel()->index(0, sourceColumn, sourceParent);
    if (! realIndex.isValid())
        return false;
}
void Singleton::f6();{
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
        int type = ((InterfaceTreeModel *)sourceModel())->getColumnContent(idx, IFTREE_COL_TYPE).toInt();
        bool hidden = ((InterfaceTreeModel *)sourceModel())->getColumnContent(idx, IFTREE_COL_HIDDEN).toBool();
}
void Singleton::f7();{
    return ((_invertTypeFilter && ! result) || (! _invertTypeFilter && result) );
bool InterfaceSortFilterModel::filterAcceptsRow(int sourceRow, const QModelIndex & sourceParent) const
    QModelIndex realIndex = sourceModel()->index(sourceRow, 0, sourceParent);
    if (! realIndex.isValid())
        return false;
}
void Singleton::f8();{
    {
        /* Remote interfaces have the if type IF_WIRED, therefore would be filtered, if not explicitly checked here */
        if (type != IF_WIRED || ! ((InterfaceTreeModel *)sourceModel())->isRemote(idx))
        return false;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        return;
    if (_storeOnChange)
    {
        QString new_pref;
        QList<int>::const_iterator it = displayHiddenTypes.constBegin();
}
void Singleton::f2();{
        QStringList ifTypesStored = stored_prefs.split(',');
        QStringList::const_iterator it = ifTypesStored.constBegin();
        while (it != ifTypesStored.constEnd())
        {
            int i_val = (*it).toInt();
}
void Singleton::f3();{
    QList<int> shownTypes;
    if (sourceModel()->rowCount() == 0)
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
}
void Singleton::f4();{
        resetPreferenceData();
    }
void InterfaceSortFilterModel::setFilterHidden(bool filter)
    _filterHidden = filter;
    invalidate();
}
void Singleton::f5();{
    return true;
bool InterfaceSortFilterModel::filterAcceptsColumn(int sourceColumn, const QModelIndex & sourceParent) const
    QModelIndex realIndex = sourceModel()->index(0, sourceColumn, sourceParent);
    if (! realIndex.isValid())
        return false;
}
void Singleton::f6();{
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
    {
        int type = ((InterfaceTreeModel *)sourceModel())->getColumnContent(idx, IFTREE_COL_TYPE).toInt();
        bool hidden = ((InterfaceTreeModel *)sourceModel())->getColumnContent(idx, IFTREE_COL_HIDDEN).toBool();
}
void Singleton::f7();{
    return ((_invertTypeFilter && ! result) || (! _invertTypeFilter && result) );
bool InterfaceSortFilterModel::filterAcceptsRow(int sourceRow, const QModelIndex & sourceParent) const
    QModelIndex realIndex = sourceModel()->index(sourceRow, 0, sourceParent);
    if (! realIndex.isValid())
        return false;
}
void Singleton::f8();{
    {
        /* Remote interfaces have the if type IF_WIRED, therefore would be filtered, if not explicitly checked here */
        if (type != IF_WIRED || ! ((InterfaceTreeModel *)sourceModel())->isRemote(idx))
        return false;
    }
}
void Singleton::f9();{
QList<int> InterfaceSortFilterModel::typesDisplayed()
    QList<int> shownTypes;
    if (sourceModel()->rowCount() == 0)
        return shownTypes;
    for (int idx = 0; idx < sourceModel()->rowCount(); idx++)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    QString first_capturing_ifname;
    bool selected_found = false;
    for (guint i = 0; i < ifaces->len; i++)
    {
        interface_options *interface_opts = &g_array_index(ifaces, interface_options, i);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    QString first_capturing_ifname;
    bool selected_found = false;
    for (guint i = 0; i < ifaces->len; i++)
    {
        interface_options *interface_opts = &g_array_index(ifaces, interface_options, i);
}
void Singleton::f2();{
/* interface_toolbar.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f3();{
    {
        switch (command)
        {
            case commandControlSet:
                if (interface_[ifname].value[num] != payload)
}
void Singleton::f4();{
            default:
                break;
        }
        checkbox->blockSignals(false);
    }
}
void Singleton::f5();{
            }
            case commandControlAdd:
            {
                QString value;
                QString display;
}
void Singleton::f6();{
            break;
        case commandInformationMessage:
            simple_dialog_async(ESD_TYPE_INFO, ESD_BTN_OK, "%s", payload.data());
            break;
        case commandWarningMessage:
}
void Singleton::f7();{
            interface_[ifname].out_fd = _open_osfhandle((intptr_t)duplicate_out_handle, O_APPEND | O_BINARY);
        }
        startReaderThread(ifname, interface_opts->extcap_control_in);
        interface_[ifname].out_fd = ws_open(interface_opts->extcap_control_out, O_WRONLY | O_BINARY, 0);
        sendChangedValues(ifname);
}
void Singleton::f8();{
            ws_close (interface_[ifname].out_fd);
            interface_[ifname].out_fd = -1;
        }
        foreach (int num, control_widget_.keys())
        {
}
void Singleton::f9();{
        }
        switch (widget->property(interface_role_property).toInt())
        {
            case INTERFACE_ROLE_CONTROL:
                setWidgetValue(widget, commandControlSet, default_value_[num]);
}
void Singleton::f10();{
                break;
            case commandControlRemove:
                if (payload.size() == 0)
                {
                    interface_[ifname].value[num].clear();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    QString first_capturing_ifname;
    bool selected_found = false;
    for (guint i = 0; i < ifaces->len; i++)
    {
        interface_options *interface_opts = &g_array_index(ifaces, interface_options, i);
}
void Singleton::f2();{
/* interface_toolbar.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    QString first_capturing_ifname;
    bool selected_found = false;
    for (guint i = 0; i < ifaces->len; i++)
    {
        interface_options *interface_opts = &g_array_index(ifaces, interface_options, i);
}
void Singleton::f2();{
/* interface_toolbar.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f3();{
    {
        switch (command)
        {
            case commandControlSet:
                if (interface_[ifname].value[num] != payload)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    QString first_capturing_ifname;
    bool selected_found = false;
    for (guint i = 0; i < ifaces->len; i++)
    {
        interface_options *interface_opts = &g_array_index(ifaces, interface_options, i);
}
void Singleton::f2();{
/* interface_toolbar.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f3();{
    {
        switch (command)
        {
            case commandControlSet:
                if (interface_[ifname].value[num] != payload)
}
void Singleton::f4();{
            default:
                break;
        }
        checkbox->blockSignals(false);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    QString first_capturing_ifname;
    bool selected_found = false;
    for (guint i = 0; i < ifaces->len; i++)
    {
        interface_options *interface_opts = &g_array_index(ifaces, interface_options, i);
}
void Singleton::f2();{
/* interface_toolbar.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f3();{
    {
        switch (command)
        {
            case commandControlSet:
                if (interface_[ifname].value[num] != payload)
}
void Singleton::f4();{
            default:
                break;
        }
        checkbox->blockSignals(false);
    }
}
void Singleton::f5();{
            }
            case commandControlAdd:
            {
                QString value;
                QString display;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    QString first_capturing_ifname;
    bool selected_found = false;
    for (guint i = 0; i < ifaces->len; i++)
    {
        interface_options *interface_opts = &g_array_index(ifaces, interface_options, i);
}
void Singleton::f2();{
/* interface_toolbar.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f3();{
    {
        switch (command)
        {
            case commandControlSet:
                if (interface_[ifname].value[num] != payload)
}
void Singleton::f4();{
            default:
                break;
        }
        checkbox->blockSignals(false);
    }
}
void Singleton::f5();{
            }
            case commandControlAdd:
            {
                QString value;
                QString display;
}
void Singleton::f6();{
            break;
        case commandInformationMessage:
            simple_dialog_async(ESD_TYPE_INFO, ESD_BTN_OK, "%s", payload.data());
            break;
        case commandWarningMessage:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    QString first_capturing_ifname;
    bool selected_found = false;
    for (guint i = 0; i < ifaces->len; i++)
    {
        interface_options *interface_opts = &g_array_index(ifaces, interface_options, i);
}
void Singleton::f2();{
/* interface_toolbar.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f3();{
    {
        switch (command)
        {
            case commandControlSet:
                if (interface_[ifname].value[num] != payload)
}
void Singleton::f4();{
            default:
                break;
        }
        checkbox->blockSignals(false);
    }
}
void Singleton::f5();{
            }
            case commandControlAdd:
            {
                QString value;
                QString display;
}
void Singleton::f6();{
            break;
        case commandInformationMessage:
            simple_dialog_async(ESD_TYPE_INFO, ESD_BTN_OK, "%s", payload.data());
            break;
        case commandWarningMessage:
}
void Singleton::f7();{
            interface_[ifname].out_fd = _open_osfhandle((intptr_t)duplicate_out_handle, O_APPEND | O_BINARY);
        }
        startReaderThread(ifname, interface_opts->extcap_control_in);
        interface_[ifname].out_fd = ws_open(interface_opts->extcap_control_out, O_WRONLY | O_BINARY, 0);
        sendChangedValues(ifname);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    QString first_capturing_ifname;
    bool selected_found = false;
    for (guint i = 0; i < ifaces->len; i++)
    {
        interface_options *interface_opts = &g_array_index(ifaces, interface_options, i);
}
void Singleton::f2();{
/* interface_toolbar.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f3();{
    {
        switch (command)
        {
            case commandControlSet:
                if (interface_[ifname].value[num] != payload)
}
void Singleton::f4();{
            default:
                break;
        }
        checkbox->blockSignals(false);
    }
}
void Singleton::f5();{
            }
            case commandControlAdd:
            {
                QString value;
                QString display;
}
void Singleton::f6();{
            break;
        case commandInformationMessage:
            simple_dialog_async(ESD_TYPE_INFO, ESD_BTN_OK, "%s", payload.data());
            break;
        case commandWarningMessage:
}
void Singleton::f7();{
            interface_[ifname].out_fd = _open_osfhandle((intptr_t)duplicate_out_handle, O_APPEND | O_BINARY);
        }
        startReaderThread(ifname, interface_opts->extcap_control_in);
        interface_[ifname].out_fd = ws_open(interface_opts->extcap_control_out, O_WRONLY | O_BINARY, 0);
        sendChangedValues(ifname);
}
void Singleton::f8();{
            ws_close (interface_[ifname].out_fd);
            interface_[ifname].out_fd = -1;
        }
        foreach (int num, control_widget_.keys())
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    QString first_capturing_ifname;
    bool selected_found = false;
    for (guint i = 0; i < ifaces->len; i++)
    {
        interface_options *interface_opts = &g_array_index(ifaces, interface_options, i);
}
void Singleton::f2();{
/* interface_toolbar.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f3();{
    {
        switch (command)
        {
            case commandControlSet:
                if (interface_[ifname].value[num] != payload)
}
void Singleton::f4();{
            default:
                break;
        }
        checkbox->blockSignals(false);
    }
}
void Singleton::f5();{
            }
            case commandControlAdd:
            {
                QString value;
                QString display;
}
void Singleton::f6();{
            break;
        case commandInformationMessage:
            simple_dialog_async(ESD_TYPE_INFO, ESD_BTN_OK, "%s", payload.data());
            break;
        case commandWarningMessage:
}
void Singleton::f7();{
            interface_[ifname].out_fd = _open_osfhandle((intptr_t)duplicate_out_handle, O_APPEND | O_BINARY);
        }
        startReaderThread(ifname, interface_opts->extcap_control_in);
        interface_[ifname].out_fd = ws_open(interface_opts->extcap_control_out, O_WRONLY | O_BINARY, 0);
        sendChangedValues(ifname);
}
void Singleton::f8();{
            ws_close (interface_[ifname].out_fd);
            interface_[ifname].out_fd = -1;
        }
        foreach (int num, control_widget_.keys())
        {
}
void Singleton::f9();{
        }
        switch (widget->property(interface_role_property).toInt())
        {
            case INTERFACE_ROLE_CONTROL:
                setWidgetValue(widget, commandControlSet, default_value_[num]);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
// To do:
// - Make a narrower apply button
InterfaceToolbarLineEdit::InterfaceToolbarLineEdit(QWidget *parent, QString validation_regex, bool is_required) :
    QLineEdit(parent),
    regex_expr_(validation_regex),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
// To do:
// - Make a narrower apply button
InterfaceToolbarLineEdit::InterfaceToolbarLineEdit(QWidget *parent, QString validation_regex, bool is_required) :
    QLineEdit(parent),
    regex_expr_(validation_regex),
}
void Singleton::f2();{
    apply_button_->setEnabled(valid);
    updateStyleSheet(valid);
void InterfaceToolbarLineEdit::validateEditedText()
    text_edited_ = true;
void InterfaceToolbarLineEdit::applyEditedText()
}
void Singleton::f3();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f4();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f5();{
            .arg(apsz.width() + frameWidth)
            .arg(is_valid || !isEnabled() ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void InterfaceToolbarLineEdit::resizeEvent(QResizeEvent *)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
}
void Singleton::f6();{
            )
            .arg(apsz.width() + frameWidth)
            .arg(is_valid || !isEnabled() ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void InterfaceToolbarLineEdit::resizeEvent(QResizeEvent *)
}
void Singleton::f7();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f8();{
            "  background: transparent;" // Disables platform style on Windows.
            "  padding: 0 0 0 0;"
            "}"
            );
    updateStyleSheet(isValid());
}
void Singleton::f9();{
    if (is_required_ && text().length() == 0)
    {
        valid = false;
    }
    if (!regex_expr_.isEmpty() && text().length() > 0)
}
void Singleton::f10();{
    {
        valid = false;
    }
    if (!regex_expr_.isEmpty() && text().length() > 0)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
// To do:
// - Make a narrower apply button
InterfaceToolbarLineEdit::InterfaceToolbarLineEdit(QWidget *parent, QString validation_regex, bool is_required) :
    QLineEdit(parent),
    regex_expr_(validation_regex),
}
void Singleton::f2();{
    apply_button_->setEnabled(valid);
    updateStyleSheet(valid);
void InterfaceToolbarLineEdit::validateEditedText()
    text_edited_ = true;
void InterfaceToolbarLineEdit::applyEditedText()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
// To do:
// - Make a narrower apply button
InterfaceToolbarLineEdit::InterfaceToolbarLineEdit(QWidget *parent, QString validation_regex, bool is_required) :
    QLineEdit(parent),
    regex_expr_(validation_regex),
}
void Singleton::f2();{
    apply_button_->setEnabled(valid);
    updateStyleSheet(valid);
void InterfaceToolbarLineEdit::validateEditedText()
    text_edited_ = true;
void InterfaceToolbarLineEdit::applyEditedText()
}
void Singleton::f3();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
// To do:
// - Make a narrower apply button
InterfaceToolbarLineEdit::InterfaceToolbarLineEdit(QWidget *parent, QString validation_regex, bool is_required) :
    QLineEdit(parent),
    regex_expr_(validation_regex),
}
void Singleton::f2();{
    apply_button_->setEnabled(valid);
    updateStyleSheet(valid);
void InterfaceToolbarLineEdit::validateEditedText()
    text_edited_ = true;
void InterfaceToolbarLineEdit::applyEditedText()
}
void Singleton::f3();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f4();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
// To do:
// - Make a narrower apply button
InterfaceToolbarLineEdit::InterfaceToolbarLineEdit(QWidget *parent, QString validation_regex, bool is_required) :
    QLineEdit(parent),
    regex_expr_(validation_regex),
}
void Singleton::f2();{
    apply_button_->setEnabled(valid);
    updateStyleSheet(valid);
void InterfaceToolbarLineEdit::validateEditedText()
    text_edited_ = true;
void InterfaceToolbarLineEdit::applyEditedText()
}
void Singleton::f3();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f4();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f5();{
            .arg(apsz.width() + frameWidth)
            .arg(is_valid || !isEnabled() ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void InterfaceToolbarLineEdit::resizeEvent(QResizeEvent *)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
// To do:
// - Make a narrower apply button
InterfaceToolbarLineEdit::InterfaceToolbarLineEdit(QWidget *parent, QString validation_regex, bool is_required) :
    QLineEdit(parent),
    regex_expr_(validation_regex),
}
void Singleton::f2();{
    apply_button_->setEnabled(valid);
    updateStyleSheet(valid);
void InterfaceToolbarLineEdit::validateEditedText()
    text_edited_ = true;
void InterfaceToolbarLineEdit::applyEditedText()
}
void Singleton::f3();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f4();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f5();{
            .arg(apsz.width() + frameWidth)
            .arg(is_valid || !isEnabled() ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void InterfaceToolbarLineEdit::resizeEvent(QResizeEvent *)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
}
void Singleton::f6();{
            )
            .arg(apsz.width() + frameWidth)
            .arg(is_valid || !isEnabled() ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void InterfaceToolbarLineEdit::resizeEvent(QResizeEvent *)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
// To do:
// - Make a narrower apply button
InterfaceToolbarLineEdit::InterfaceToolbarLineEdit(QWidget *parent, QString validation_regex, bool is_required) :
    QLineEdit(parent),
    regex_expr_(validation_regex),
}
void Singleton::f2();{
    apply_button_->setEnabled(valid);
    updateStyleSheet(valid);
void InterfaceToolbarLineEdit::validateEditedText()
    text_edited_ = true;
void InterfaceToolbarLineEdit::applyEditedText()
}
void Singleton::f3();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f4();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f5();{
            .arg(apsz.width() + frameWidth)
            .arg(is_valid || !isEnabled() ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void InterfaceToolbarLineEdit::resizeEvent(QResizeEvent *)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
}
void Singleton::f6();{
            )
            .arg(apsz.width() + frameWidth)
            .arg(is_valid || !isEnabled() ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void InterfaceToolbarLineEdit::resizeEvent(QResizeEvent *)
}
void Singleton::f7();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
// To do:
// - Make a narrower apply button
InterfaceToolbarLineEdit::InterfaceToolbarLineEdit(QWidget *parent, QString validation_regex, bool is_required) :
    QLineEdit(parent),
    regex_expr_(validation_regex),
}
void Singleton::f2();{
    apply_button_->setEnabled(valid);
    updateStyleSheet(valid);
void InterfaceToolbarLineEdit::validateEditedText()
    text_edited_ = true;
void InterfaceToolbarLineEdit::applyEditedText()
}
void Singleton::f3();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f4();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f5();{
            .arg(apsz.width() + frameWidth)
            .arg(is_valid || !isEnabled() ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void InterfaceToolbarLineEdit::resizeEvent(QResizeEvent *)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
}
void Singleton::f6();{
            )
            .arg(apsz.width() + frameWidth)
            .arg(is_valid || !isEnabled() ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void InterfaceToolbarLineEdit::resizeEvent(QResizeEvent *)
}
void Singleton::f7();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f8();{
            "  background: transparent;" // Disables platform style on Windows.
            "  padding: 0 0 0 0;"
            "}"
            );
    updateStyleSheet(isValid());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
// To do:
// - Make a narrower apply button
InterfaceToolbarLineEdit::InterfaceToolbarLineEdit(QWidget *parent, QString validation_regex, bool is_required) :
    QLineEdit(parent),
    regex_expr_(validation_regex),
}
void Singleton::f2();{
    apply_button_->setEnabled(valid);
    updateStyleSheet(valid);
void InterfaceToolbarLineEdit::validateEditedText()
    text_edited_ = true;
void InterfaceToolbarLineEdit::applyEditedText()
}
void Singleton::f3();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f4();{
    }
    return valid;
void InterfaceToolbarLineEdit::updateStyleSheet(bool is_valid)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
    QSize apsz = apply_button_->sizeHint();
}
void Singleton::f5();{
            .arg(apsz.width() + frameWidth)
            .arg(is_valid || !isEnabled() ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void InterfaceToolbarLineEdit::resizeEvent(QResizeEvent *)
    int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
}
void Singleton::f6();{
            )
            .arg(apsz.width() + frameWidth)
            .arg(is_valid || !isEnabled() ? QString("") : ColorUtils::fromColorT(prefs.gui_text_invalid).name());
    setStyleSheet(style_sheet);
void InterfaceToolbarLineEdit::resizeEvent(QResizeEvent *)
}
void Singleton::f7();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f8();{
            "  background: transparent;" // Disables platform style on Windows.
            "  padding: 0 0 0 0;"
            "}"
            );
    updateStyleSheet(isValid());
}
void Singleton::f9();{
    if (is_required_ && text().length() == 0)
    {
        valid = false;
    }
    if (!regex_expr_.isEmpty() && text().length() > 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        if (QThread::currentThread()->isInterruptionRequested())
        {
            return -1;
        }
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        if (QThread::currentThread()->isInterruptionRequested())
        {
            return -1;
        }
    }
}
void Singleton::f2();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f3();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f4();{
            break;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
            break;
}
void Singleton::f5();{
        if (WaitForSingleObject(overlap.hEvent, INFINITE) == WAIT_OBJECT_0)
        {
            // The wait operation has completed.
            success = GetOverlappedResult(control_in_, &overlap, &nof_bytes_read, FALSE);
            if (success && nof_bytes_read != 0)
}
void Singleton::f6();{
void InterfaceToolbarReader::loop()
    QByteArray header;
    QByteArray payload;
    struct timeval timeout;
    fd_set readfds;
}
void Singleton::f7();{
        {
            return -1;
        }
    }
    return total_len;
}
void Singleton::f8();{
        unsigned char high_nibble = header[1] & 0xFF;
        unsigned char mid_nibble = header[2] & 0xFF;
        unsigned char low_nibble = header[3] & 0xFF;
        int payload_len = (int)((high_nibble << 16) + (mid_nibble << 8) + low_nibble) - 2;
        payload.resize(payload_len);
}
void Singleton::f9();{
    }
    ws_close(fd_in_);
    emit finished();
 * Editor modelines
 * Local Variables:
}
void Singleton::f10();{
        unsigned char high_nibble = header[1] & 0xFF;
        unsigned char mid_nibble = header[2] & 0xFF;
        unsigned char low_nibble = header[3] & 0xFF;
        int payload_len = (int)((high_nibble << 16) + (mid_nibble << 8) + low_nibble) - 2;
        payload.resize(payload_len);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        if (QThread::currentThread()->isInterruptionRequested())
        {
            return -1;
        }
    }
}
void Singleton::f2();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        if (QThread::currentThread()->isInterruptionRequested())
        {
            return -1;
        }
    }
}
void Singleton::f2();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f3();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        if (QThread::currentThread()->isInterruptionRequested())
        {
            return -1;
        }
    }
}
void Singleton::f2();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f3();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f4();{
            break;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
            break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        if (QThread::currentThread()->isInterruptionRequested())
        {
            return -1;
        }
    }
}
void Singleton::f2();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f3();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f4();{
            break;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
            break;
}
void Singleton::f5();{
        if (WaitForSingleObject(overlap.hEvent, INFINITE) == WAIT_OBJECT_0)
        {
            // The wait operation has completed.
            success = GetOverlappedResult(control_in_, &overlap, &nof_bytes_read, FALSE);
            if (success && nof_bytes_read != 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        if (QThread::currentThread()->isInterruptionRequested())
        {
            return -1;
        }
    }
}
void Singleton::f2();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f3();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f4();{
            break;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
            break;
}
void Singleton::f5();{
        if (WaitForSingleObject(overlap.hEvent, INFINITE) == WAIT_OBJECT_0)
        {
            // The wait operation has completed.
            success = GetOverlappedResult(control_in_, &overlap, &nof_bytes_read, FALSE);
            if (success && nof_bytes_read != 0)
}
void Singleton::f6();{
void InterfaceToolbarReader::loop()
    QByteArray header;
    QByteArray payload;
    struct timeval timeout;
    fd_set readfds;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        if (QThread::currentThread()->isInterruptionRequested())
        {
            return -1;
        }
    }
}
void Singleton::f2();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f3();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f4();{
            break;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
            break;
}
void Singleton::f5();{
        if (WaitForSingleObject(overlap.hEvent, INFINITE) == WAIT_OBJECT_0)
        {
            // The wait operation has completed.
            success = GetOverlappedResult(control_in_, &overlap, &nof_bytes_read, FALSE);
            if (success && nof_bytes_read != 0)
}
void Singleton::f6();{
void InterfaceToolbarReader::loop()
    QByteArray header;
    QByteArray payload;
    struct timeval timeout;
    fd_set readfds;
}
void Singleton::f7();{
        {
            return -1;
        }
    }
    return total_len;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        if (QThread::currentThread()->isInterruptionRequested())
        {
            return -1;
        }
    }
}
void Singleton::f2();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f3();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f4();{
            break;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
            break;
}
void Singleton::f5();{
        if (WaitForSingleObject(overlap.hEvent, INFINITE) == WAIT_OBJECT_0)
        {
            // The wait operation has completed.
            success = GetOverlappedResult(control_in_, &overlap, &nof_bytes_read, FALSE);
            if (success && nof_bytes_read != 0)
}
void Singleton::f6();{
void InterfaceToolbarReader::loop()
    QByteArray header;
    QByteArray payload;
    struct timeval timeout;
    fd_set readfds;
}
void Singleton::f7();{
        {
            return -1;
        }
    }
    return total_len;
}
void Singleton::f8();{
        unsigned char high_nibble = header[1] & 0xFF;
        unsigned char mid_nibble = header[2] & 0xFF;
        unsigned char low_nibble = header[3] & 0xFF;
        int payload_len = (int)((high_nibble << 16) + (mid_nibble << 8) + low_nibble) - 2;
        payload.resize(payload_len);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        if (QThread::currentThread()->isInterruptionRequested())
        {
            return -1;
        }
    }
}
void Singleton::f2();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f3();{
        {
            total_len += read_len;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
}
void Singleton::f4();{
            break;
        }
        if (QThread::currentThread()->isInterruptionRequested())
        {
            break;
}
void Singleton::f5();{
        if (WaitForSingleObject(overlap.hEvent, INFINITE) == WAIT_OBJECT_0)
        {
            // The wait operation has completed.
            success = GetOverlappedResult(control_in_, &overlap, &nof_bytes_read, FALSE);
            if (success && nof_bytes_read != 0)
}
void Singleton::f6();{
void InterfaceToolbarReader::loop()
    QByteArray header;
    QByteArray payload;
    struct timeval timeout;
    fd_set readfds;
}
void Singleton::f7();{
        {
            return -1;
        }
    }
    return total_len;
}
void Singleton::f8();{
        unsigned char high_nibble = header[1] & 0xFF;
        unsigned char mid_nibble = header[2] & 0xFF;
        unsigned char low_nibble = header[3] & 0xFF;
        int payload_len = (int)((high_nibble << 16) + (mid_nibble << 8) + low_nibble) - 2;
        payload.resize(payload_len);
}
void Singleton::f9();{
    }
    ws_close(fd_in_);
    emit finished();
 * Editor modelines
 * Local Variables:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
const interface_t * InterfaceTreeCacheModel::lookup(const QModelIndex &index) const
    const interface_t * result = 0;
    if (! index.isValid() || ! global_capture_opts.all_ifaces)
        return result;
    int idx = index.row();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
const interface_t * InterfaceTreeCacheModel::lookup(const QModelIndex &index) const
    const interface_t * result = 0;
    if (! index.isValid() || ! global_capture_opts.all_ifaces)
        return result;
    int idx = index.row();
}
void Singleton::f2();{
                ++it;
            }
        }
        QVariant content = getColumnContent(idx, IFTREE_COL_HIDDEN, Qt::CheckStateRole);
        if (content.isValid() && static_cast<Qt::CheckState>(content.toInt()) == Qt::Unchecked)
}
void Singleton::f3();{
            while (it != dataField->constEnd())
            {
                InterfaceTreeColumns col = it.key();
                QVariant saveValue = it.value();
                /* Setting the field values for each individual saved value cannot be generic, as the
}
void Singleton::f4();{
                    device->if_info.name = qstring_strdup(saveValue.toString());
                    g_free(device->name);
                    device->name = qstring_strdup(saveValue.toString());
                    g_free(device->display_name);
                    device->display_name = qstring_strdup(saveValue.toString());
}
void Singleton::f5();{
            return false;
        if (col == IFTREE_COL_BUFFERLEN)
            return false;
    }
    return true;
}
void Singleton::f6();{
        bool useDevice = false;
        QMap<InterfaceTreeColumns, QVariant> * dataField = storage->value(idx, 0);
        /* When devices are being added, they are added using generic values. So only devices
         * whose data have been changed should be used from here on out. */
        if (dataField != 0)
}
void Singleton::f7();{
                    QMap<InterfaceTreeColumns, QVariant> * dataField = 0;
                    if ((dataField = storage->value(row, 0)) != 0 &&
                            dataField->contains(IFTREE_COL_PIPE_PATH))
                    {
                        return dataField->value(IFTREE_COL_PIPE_PATH, QVariant());
}
void Singleton::f8();{
                }
                else if (device->if_info.type == IF_EXTCAP)
                {
                    /* extcap interfaces do not have the following columns.
                     * ATTENTION: all generic columns must be added, BEFORE this
}
void Singleton::f9();{
         * After saving, the devices are stored in global_capture_opts and no longer
         * classify as new devices. */
        const interface_t * device = lookup(index);
        if (device != 0)
        {
}
void Singleton::f10();{
         * are supported at the moment, so the information to be displayed is pretty limited.
         * After saving, the devices are stored in global_capture_opts and no longer
         * classify as new devices. */
        const interface_t * device = lookup(index);
        if (device != 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
const interface_t * InterfaceTreeCacheModel::lookup(const QModelIndex &index) const
    const interface_t * result = 0;
    if (! index.isValid() || ! global_capture_opts.all_ifaces)
        return result;
    int idx = index.row();
}
void Singleton::f2();{
                ++it;
            }
        }
        QVariant content = getColumnContent(idx, IFTREE_COL_HIDDEN, Qt::CheckStateRole);
        if (content.isValid() && static_cast<Qt::CheckState>(content.toInt()) == Qt::Unchecked)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
const interface_t * InterfaceTreeCacheModel::lookup(const QModelIndex &index) const
    const interface_t * result = 0;
    if (! index.isValid() || ! global_capture_opts.all_ifaces)
        return result;
    int idx = index.row();
}
void Singleton::f2();{
                ++it;
            }
        }
        QVariant content = getColumnContent(idx, IFTREE_COL_HIDDEN, Qt::CheckStateRole);
        if (content.isValid() && static_cast<Qt::CheckState>(content.toInt()) == Qt::Unchecked)
}
void Singleton::f3();{
            while (it != dataField->constEnd())
            {
                InterfaceTreeColumns col = it.key();
                QVariant saveValue = it.value();
                /* Setting the field values for each individual saved value cannot be generic, as the
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
const interface_t * InterfaceTreeCacheModel::lookup(const QModelIndex &index) const
    const interface_t * result = 0;
    if (! index.isValid() || ! global_capture_opts.all_ifaces)
        return result;
    int idx = index.row();
}
void Singleton::f2();{
                ++it;
            }
        }
        QVariant content = getColumnContent(idx, IFTREE_COL_HIDDEN, Qt::CheckStateRole);
        if (content.isValid() && static_cast<Qt::CheckState>(content.toInt()) == Qt::Unchecked)
}
void Singleton::f3();{
            while (it != dataField->constEnd())
            {
                InterfaceTreeColumns col = it.key();
                QVariant saveValue = it.value();
                /* Setting the field values for each individual saved value cannot be generic, as the
}
void Singleton::f4();{
                    device->if_info.name = qstring_strdup(saveValue.toString());
                    g_free(device->name);
                    device->name = qstring_strdup(saveValue.toString());
                    g_free(device->display_name);
                    device->display_name = qstring_strdup(saveValue.toString());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
const interface_t * InterfaceTreeCacheModel::lookup(const QModelIndex &index) const
    const interface_t * result = 0;
    if (! index.isValid() || ! global_capture_opts.all_ifaces)
        return result;
    int idx = index.row();
}
void Singleton::f2();{
                ++it;
            }
        }
        QVariant content = getColumnContent(idx, IFTREE_COL_HIDDEN, Qt::CheckStateRole);
        if (content.isValid() && static_cast<Qt::CheckState>(content.toInt()) == Qt::Unchecked)
}
void Singleton::f3();{
            while (it != dataField->constEnd())
            {
                InterfaceTreeColumns col = it.key();
                QVariant saveValue = it.value();
                /* Setting the field values for each individual saved value cannot be generic, as the
}
void Singleton::f4();{
                    device->if_info.name = qstring_strdup(saveValue.toString());
                    g_free(device->name);
                    device->name = qstring_strdup(saveValue.toString());
                    g_free(device->display_name);
                    device->display_name = qstring_strdup(saveValue.toString());
}
void Singleton::f5();{
            return false;
        if (col == IFTREE_COL_BUFFERLEN)
            return false;
    }
    return true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
const interface_t * InterfaceTreeCacheModel::lookup(const QModelIndex &index) const
    const interface_t * result = 0;
    if (! index.isValid() || ! global_capture_opts.all_ifaces)
        return result;
    int idx = index.row();
}
void Singleton::f2();{
                ++it;
            }
        }
        QVariant content = getColumnContent(idx, IFTREE_COL_HIDDEN, Qt::CheckStateRole);
        if (content.isValid() && static_cast<Qt::CheckState>(content.toInt()) == Qt::Unchecked)
}
void Singleton::f3();{
            while (it != dataField->constEnd())
            {
                InterfaceTreeColumns col = it.key();
                QVariant saveValue = it.value();
                /* Setting the field values for each individual saved value cannot be generic, as the
}
void Singleton::f4();{
                    device->if_info.name = qstring_strdup(saveValue.toString());
                    g_free(device->name);
                    device->name = qstring_strdup(saveValue.toString());
                    g_free(device->display_name);
                    device->display_name = qstring_strdup(saveValue.toString());
}
void Singleton::f5();{
            return false;
        if (col == IFTREE_COL_BUFFERLEN)
            return false;
    }
    return true;
}
void Singleton::f6();{
        bool useDevice = false;
        QMap<InterfaceTreeColumns, QVariant> * dataField = storage->value(idx, 0);
        /* When devices are being added, they are added using generic values. So only devices
         * whose data have been changed should be used from here on out. */
        if (dataField != 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
const interface_t * InterfaceTreeCacheModel::lookup(const QModelIndex &index) const
    const interface_t * result = 0;
    if (! index.isValid() || ! global_capture_opts.all_ifaces)
        return result;
    int idx = index.row();
}
void Singleton::f2();{
                ++it;
            }
        }
        QVariant content = getColumnContent(idx, IFTREE_COL_HIDDEN, Qt::CheckStateRole);
        if (content.isValid() && static_cast<Qt::CheckState>(content.toInt()) == Qt::Unchecked)
}
void Singleton::f3();{
            while (it != dataField->constEnd())
            {
                InterfaceTreeColumns col = it.key();
                QVariant saveValue = it.value();
                /* Setting the field values for each individual saved value cannot be generic, as the
}
void Singleton::f4();{
                    device->if_info.name = qstring_strdup(saveValue.toString());
                    g_free(device->name);
                    device->name = qstring_strdup(saveValue.toString());
                    g_free(device->display_name);
                    device->display_name = qstring_strdup(saveValue.toString());
}
void Singleton::f5();{
            return false;
        if (col == IFTREE_COL_BUFFERLEN)
            return false;
    }
    return true;
}
void Singleton::f6();{
        bool useDevice = false;
        QMap<InterfaceTreeColumns, QVariant> * dataField = storage->value(idx, 0);
        /* When devices are being added, they are added using generic values. So only devices
         * whose data have been changed should be used from here on out. */
        if (dataField != 0)
}
void Singleton::f7();{
                    QMap<InterfaceTreeColumns, QVariant> * dataField = 0;
                    if ((dataField = storage->value(row, 0)) != 0 &&
                            dataField->contains(IFTREE_COL_PIPE_PATH))
                    {
                        return dataField->value(IFTREE_COL_PIPE_PATH, QVariant());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
const interface_t * InterfaceTreeCacheModel::lookup(const QModelIndex &index) const
    const interface_t * result = 0;
    if (! index.isValid() || ! global_capture_opts.all_ifaces)
        return result;
    int idx = index.row();
}
void Singleton::f2();{
                ++it;
            }
        }
        QVariant content = getColumnContent(idx, IFTREE_COL_HIDDEN, Qt::CheckStateRole);
        if (content.isValid() && static_cast<Qt::CheckState>(content.toInt()) == Qt::Unchecked)
}
void Singleton::f3();{
            while (it != dataField->constEnd())
            {
                InterfaceTreeColumns col = it.key();
                QVariant saveValue = it.value();
                /* Setting the field values for each individual saved value cannot be generic, as the
}
void Singleton::f4();{
                    device->if_info.name = qstring_strdup(saveValue.toString());
                    g_free(device->name);
                    device->name = qstring_strdup(saveValue.toString());
                    g_free(device->display_name);
                    device->display_name = qstring_strdup(saveValue.toString());
}
void Singleton::f5();{
            return false;
        if (col == IFTREE_COL_BUFFERLEN)
            return false;
    }
    return true;
}
void Singleton::f6();{
        bool useDevice = false;
        QMap<InterfaceTreeColumns, QVariant> * dataField = storage->value(idx, 0);
        /* When devices are being added, they are added using generic values. So only devices
         * whose data have been changed should be used from here on out. */
        if (dataField != 0)
}
void Singleton::f7();{
                    QMap<InterfaceTreeColumns, QVariant> * dataField = 0;
                    if ((dataField = storage->value(row, 0)) != 0 &&
                            dataField->contains(IFTREE_COL_PIPE_PATH))
                    {
                        return dataField->value(IFTREE_COL_PIPE_PATH, QVariant());
}
void Singleton::f8();{
                }
                else if (device->if_info.type == IF_EXTCAP)
                {
                    /* extcap interfaces do not have the following columns.
                     * ATTENTION: all generic columns must be added, BEFORE this
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
const interface_t * InterfaceTreeCacheModel::lookup(const QModelIndex &index) const
    const interface_t * result = 0;
    if (! index.isValid() || ! global_capture_opts.all_ifaces)
        return result;
    int idx = index.row();
}
void Singleton::f2();{
                ++it;
            }
        }
        QVariant content = getColumnContent(idx, IFTREE_COL_HIDDEN, Qt::CheckStateRole);
        if (content.isValid() && static_cast<Qt::CheckState>(content.toInt()) == Qt::Unchecked)
}
void Singleton::f3();{
            while (it != dataField->constEnd())
            {
                InterfaceTreeColumns col = it.key();
                QVariant saveValue = it.value();
                /* Setting the field values for each individual saved value cannot be generic, as the
}
void Singleton::f4();{
                    device->if_info.name = qstring_strdup(saveValue.toString());
                    g_free(device->name);
                    device->name = qstring_strdup(saveValue.toString());
                    g_free(device->display_name);
                    device->display_name = qstring_strdup(saveValue.toString());
}
void Singleton::f5();{
            return false;
        if (col == IFTREE_COL_BUFFERLEN)
            return false;
    }
    return true;
}
void Singleton::f6();{
        bool useDevice = false;
        QMap<InterfaceTreeColumns, QVariant> * dataField = storage->value(idx, 0);
        /* When devices are being added, they are added using generic values. So only devices
         * whose data have been changed should be used from here on out. */
        if (dataField != 0)
}
void Singleton::f7();{
                    QMap<InterfaceTreeColumns, QVariant> * dataField = 0;
                    if ((dataField = storage->value(row, 0)) != 0 &&
                            dataField->contains(IFTREE_COL_PIPE_PATH))
                    {
                        return dataField->value(IFTREE_COL_PIPE_PATH, QVariant());
}
void Singleton::f8();{
                }
                else if (device->if_info.type == IF_EXTCAP)
                {
                    /* extcap interfaces do not have the following columns.
                     * ATTENTION: all generic columns must be added, BEFORE this
}
void Singleton::f9();{
         * After saving, the devices are stored in global_capture_opts and no longer
         * classify as new devices. */
        const interface_t * device = lookup(index);
        if (device != 0)
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        capture_stat_stop(stat_cache_);
        stat_cache_ = NULL;
    }
void InterfaceTreeModel::updateStatistic(unsigned int idx)
    if (! global_capture_opts.all_ifaces || global_capture_opts.all_ifaces->len <= (guint) idx)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        capture_stat_stop(stat_cache_);
        stat_cache_ = NULL;
    }
void InterfaceTreeModel::updateStatistic(unsigned int idx)
    if (! global_capture_opts.all_ifaces || global_capture_opts.all_ifaces->len <= (guint) idx)
}
void Singleton::f2();{
 * when interfaces are hidden by the proxy model. But for this to work, every access
 * to the index from within the view, has to be filtered through the proxy model.
InterfaceTreeModel::InterfaceTreeModel(QObject *parent) :
    QAbstractTableModel(parent)
    ,stat_cache_(NULL)
}
void Singleton::f3();{
    // If so, report it.
    //
    if (global_capture_opts.ifaces_err != 0)
    {
        return tr(global_capture_opts.ifaces_err_info);
}
void Singleton::f4();{
        /* Displays the configuration icon for extcap interfaces */
        else if (role == Qt::DecorationRole)
        {
            if (col == IFTREE_COL_EXTCAP)
            {
}
void Singleton::f5();{
                    linkname = QObject::tr("DLT %1").arg(device->active_dlt);
                    for (GList *list = device->links; list != Q_NULLPTR; list = gxx_list_next(list)) {
                        link_row *linkr = gxx_list_data(link_row *, list);
                        if (linkr->dlt == device->active_dlt) {
                            linkname = linkr->name;
}
void Singleton::f6();{
    {
        interface_t *device = &g_array_index(global_capture_opts.all_ifaces, interface_t, row);
        /* Data for display in cell */
        if (role == Qt::DisplayRole)
        {
}
void Singleton::f7();{
    {
        tt_str += tr("No capture filter");
    }
    else
    {
}
void Singleton::f8();{
                return QVariant::fromValue((int)device->if_info.type);
            }
            else if (col == IFTREE_COL_COMMENT)
            {
                QString comment = gchar_free_to_qstring(capture_dev_user_descr_find(device->name));
}
void Singleton::f9();{
    if (rowCount() == 0)
    {
        return tr("No interfaces found.");
    }
    //
}
void Singleton::f10();{
    }
    Q_UNUSED(sourceSelection)
    return selectionHasChanged;
 * Editor modelines
 * Local Variables:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        capture_stat_stop(stat_cache_);
        stat_cache_ = NULL;
    }
void InterfaceTreeModel::updateStatistic(unsigned int idx)
    if (! global_capture_opts.all_ifaces || global_capture_opts.all_ifaces->len <= (guint) idx)
}
void Singleton::f2();{
 * when interfaces are hidden by the proxy model. But for this to work, every access
 * to the index from within the view, has to be filtered through the proxy model.
InterfaceTreeModel::InterfaceTreeModel(QObject *parent) :
    QAbstractTableModel(parent)
    ,stat_cache_(NULL)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        capture_stat_stop(stat_cache_);
        stat_cache_ = NULL;
    }
void InterfaceTreeModel::updateStatistic(unsigned int idx)
    if (! global_capture_opts.all_ifaces || global_capture_opts.all_ifaces->len <= (guint) idx)
}
void Singleton::f2();{
 * when interfaces are hidden by the proxy model. But for this to work, every access
 * to the index from within the view, has to be filtered through the proxy model.
InterfaceTreeModel::InterfaceTreeModel(QObject *parent) :
    QAbstractTableModel(parent)
    ,stat_cache_(NULL)
}
void Singleton::f3();{
    // If so, report it.
    //
    if (global_capture_opts.ifaces_err != 0)
    {
        return tr(global_capture_opts.ifaces_err_info);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        capture_stat_stop(stat_cache_);
        stat_cache_ = NULL;
    }
void InterfaceTreeModel::updateStatistic(unsigned int idx)
    if (! global_capture_opts.all_ifaces || global_capture_opts.all_ifaces->len <= (guint) idx)
}
void Singleton::f2();{
 * when interfaces are hidden by the proxy model. But for this to work, every access
 * to the index from within the view, has to be filtered through the proxy model.
InterfaceTreeModel::InterfaceTreeModel(QObject *parent) :
    QAbstractTableModel(parent)
    ,stat_cache_(NULL)
}
void Singleton::f3();{
    // If so, report it.
    //
    if (global_capture_opts.ifaces_err != 0)
    {
        return tr(global_capture_opts.ifaces_err_info);
}
void Singleton::f4();{
        /* Displays the configuration icon for extcap interfaces */
        else if (role == Qt::DecorationRole)
        {
            if (col == IFTREE_COL_EXTCAP)
            {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        capture_stat_stop(stat_cache_);
        stat_cache_ = NULL;
    }
void InterfaceTreeModel::updateStatistic(unsigned int idx)
    if (! global_capture_opts.all_ifaces || global_capture_opts.all_ifaces->len <= (guint) idx)
}
void Singleton::f2();{
 * when interfaces are hidden by the proxy model. But for this to work, every access
 * to the index from within the view, has to be filtered through the proxy model.
InterfaceTreeModel::InterfaceTreeModel(QObject *parent) :
    QAbstractTableModel(parent)
    ,stat_cache_(NULL)
}
void Singleton::f3();{
    // If so, report it.
    //
    if (global_capture_opts.ifaces_err != 0)
    {
        return tr(global_capture_opts.ifaces_err_info);
}
void Singleton::f4();{
        /* Displays the configuration icon for extcap interfaces */
        else if (role == Qt::DecorationRole)
        {
            if (col == IFTREE_COL_EXTCAP)
            {
}
void Singleton::f5();{
                    linkname = QObject::tr("DLT %1").arg(device->active_dlt);
                    for (GList *list = device->links; list != Q_NULLPTR; list = gxx_list_next(list)) {
                        link_row *linkr = gxx_list_data(link_row *, list);
                        if (linkr->dlt == device->active_dlt) {
                            linkname = linkr->name;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        capture_stat_stop(stat_cache_);
        stat_cache_ = NULL;
    }
void InterfaceTreeModel::updateStatistic(unsigned int idx)
    if (! global_capture_opts.all_ifaces || global_capture_opts.all_ifaces->len <= (guint) idx)
}
void Singleton::f2();{
 * when interfaces are hidden by the proxy model. But for this to work, every access
 * to the index from within the view, has to be filtered through the proxy model.
InterfaceTreeModel::InterfaceTreeModel(QObject *parent) :
    QAbstractTableModel(parent)
    ,stat_cache_(NULL)
}
void Singleton::f3();{
    // If so, report it.
    //
    if (global_capture_opts.ifaces_err != 0)
    {
        return tr(global_capture_opts.ifaces_err_info);
}
void Singleton::f4();{
        /* Displays the configuration icon for extcap interfaces */
        else if (role == Qt::DecorationRole)
        {
            if (col == IFTREE_COL_EXTCAP)
            {
}
void Singleton::f5();{
                    linkname = QObject::tr("DLT %1").arg(device->active_dlt);
                    for (GList *list = device->links; list != Q_NULLPTR; list = gxx_list_next(list)) {
                        link_row *linkr = gxx_list_data(link_row *, list);
                        if (linkr->dlt == device->active_dlt) {
                            linkname = linkr->name;
}
void Singleton::f6();{
    {
        interface_t *device = &g_array_index(global_capture_opts.all_ifaces, interface_t, row);
        /* Data for display in cell */
        if (role == Qt::DisplayRole)
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        capture_stat_stop(stat_cache_);
        stat_cache_ = NULL;
    }
void InterfaceTreeModel::updateStatistic(unsigned int idx)
    if (! global_capture_opts.all_ifaces || global_capture_opts.all_ifaces->len <= (guint) idx)
}
void Singleton::f2();{
 * when interfaces are hidden by the proxy model. But for this to work, every access
 * to the index from within the view, has to be filtered through the proxy model.
InterfaceTreeModel::InterfaceTreeModel(QObject *parent) :
    QAbstractTableModel(parent)
    ,stat_cache_(NULL)
}
void Singleton::f3();{
    // If so, report it.
    //
    if (global_capture_opts.ifaces_err != 0)
    {
        return tr(global_capture_opts.ifaces_err_info);
}
void Singleton::f4();{
        /* Displays the configuration icon for extcap interfaces */
        else if (role == Qt::DecorationRole)
        {
            if (col == IFTREE_COL_EXTCAP)
            {
}
void Singleton::f5();{
                    linkname = QObject::tr("DLT %1").arg(device->active_dlt);
                    for (GList *list = device->links; list != Q_NULLPTR; list = gxx_list_next(list)) {
                        link_row *linkr = gxx_list_data(link_row *, list);
                        if (linkr->dlt == device->active_dlt) {
                            linkname = linkr->name;
}
void Singleton::f6();{
    {
        interface_t *device = &g_array_index(global_capture_opts.all_ifaces, interface_t, row);
        /* Data for display in cell */
        if (role == Qt::DisplayRole)
        {
}
void Singleton::f7();{
    {
        tt_str += tr("No capture filter");
    }
    else
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        capture_stat_stop(stat_cache_);
        stat_cache_ = NULL;
    }
void InterfaceTreeModel::updateStatistic(unsigned int idx)
    if (! global_capture_opts.all_ifaces || global_capture_opts.all_ifaces->len <= (guint) idx)
}
void Singleton::f2();{
 * when interfaces are hidden by the proxy model. But for this to work, every access
 * to the index from within the view, has to be filtered through the proxy model.
InterfaceTreeModel::InterfaceTreeModel(QObject *parent) :
    QAbstractTableModel(parent)
    ,stat_cache_(NULL)
}
void Singleton::f3();{
    // If so, report it.
    //
    if (global_capture_opts.ifaces_err != 0)
    {
        return tr(global_capture_opts.ifaces_err_info);
}
void Singleton::f4();{
        /* Displays the configuration icon for extcap interfaces */
        else if (role == Qt::DecorationRole)
        {
            if (col == IFTREE_COL_EXTCAP)
            {
}
void Singleton::f5();{
                    linkname = QObject::tr("DLT %1").arg(device->active_dlt);
                    for (GList *list = device->links; list != Q_NULLPTR; list = gxx_list_next(list)) {
                        link_row *linkr = gxx_list_data(link_row *, list);
                        if (linkr->dlt == device->active_dlt) {
                            linkname = linkr->name;
}
void Singleton::f6();{
    {
        interface_t *device = &g_array_index(global_capture_opts.all_ifaces, interface_t, row);
        /* Data for display in cell */
        if (role == Qt::DisplayRole)
        {
}
void Singleton::f7();{
    {
        tt_str += tr("No capture filter");
    }
    else
    {
}
void Singleton::f8();{
                return QVariant::fromValue((int)device->if_info.type);
            }
            else if (col == IFTREE_COL_COMMENT)
            {
                QString comment = gchar_free_to_qstring(capture_dev_user_descr_find(device->name));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        capture_stat_stop(stat_cache_);
        stat_cache_ = NULL;
    }
void InterfaceTreeModel::updateStatistic(unsigned int idx)
    if (! global_capture_opts.all_ifaces || global_capture_opts.all_ifaces->len <= (guint) idx)
}
void Singleton::f2();{
 * when interfaces are hidden by the proxy model. But for this to work, every access
 * to the index from within the view, has to be filtered through the proxy model.
InterfaceTreeModel::InterfaceTreeModel(QObject *parent) :
    QAbstractTableModel(parent)
    ,stat_cache_(NULL)
}
void Singleton::f3();{
    // If so, report it.
    //
    if (global_capture_opts.ifaces_err != 0)
    {
        return tr(global_capture_opts.ifaces_err_info);
}
void Singleton::f4();{
        /* Displays the configuration icon for extcap interfaces */
        else if (role == Qt::DecorationRole)
        {
            if (col == IFTREE_COL_EXTCAP)
            {
}
void Singleton::f5();{
                    linkname = QObject::tr("DLT %1").arg(device->active_dlt);
                    for (GList *list = device->links; list != Q_NULLPTR; list = gxx_list_next(list)) {
                        link_row *linkr = gxx_list_data(link_row *, list);
                        if (linkr->dlt == device->active_dlt) {
                            linkname = linkr->name;
}
void Singleton::f6();{
    {
        interface_t *device = &g_array_index(global_capture_opts.all_ifaces, interface_t, row);
        /* Data for display in cell */
        if (role == Qt::DisplayRole)
        {
}
void Singleton::f7();{
    {
        tt_str += tr("No capture filter");
    }
    else
    {
}
void Singleton::f8();{
                return QVariant::fromValue((int)device->if_info.type);
            }
            else if (col == IFTREE_COL_COMMENT)
            {
                QString comment = gchar_free_to_qstring(capture_dev_user_descr_find(device->name));
}
void Singleton::f9();{
    if (rowCount() == 0)
    {
        return tr("No interfaces found.");
    }
    //
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        } else if (bars_) {
            maxValue = maxValueFromGraphData(*bars_->data());
        }
        // If the maximum value is zero, then either we have no data or
        // everything is zero, do not scale the unit in this case.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        } else if (bars_) {
            maxValue = maxValueFromGraphData(*bars_->data());
        }
        // If the maximum value is zero, then either we have no data or
        // everything is zero, do not scale the unit in this case.
}
void Singleton::f2();{
    uat_model_->setData(uat_model_->index(currentRow, colColor), QColor(color_idx), Qt::DecorationRole);
    uat_model_->setData(uat_model_->index(currentRow, colStyle), val_to_str_const(style, graph_style_vs, "None"));
    uat_model_->setData(uat_model_->index(currentRow, colYAxis), val_to_str_const(value_units, y_axis_vs, "Packets"));
    uat_model_->setData(uat_model_->index(currentRow, colYField), yfield);
    uat_model_->setData(uat_model_->index(currentRow, colSMAPeriod), val_to_str_const((guint32) moving_average, moving_avg_vs, "None"));
}
void Singleton::f3();{
    header_field_info *hfi = proto_registrar_get_byname(vu_field_.toUtf8().constData());
    if (hfi) {
        hf_index_ = hfi->id;
    }
    if (old_hf_index != hf_index_) {
}
void Singleton::f4();{
    UAT_FLD_CSTRING(io_graph, name, "Graph Name", "The name of the graph"),
    UAT_FLD_DISPLAY_FILTER(io_graph, dfilter, "Display Filter", "Graph packets matching this display filter"),
    UAT_FLD_VS(io_graph, style, "Style", graph_style_vs, "Graph style (Line, Bars, etc.)"),
    UAT_FLD_VS(io_graph, yaxis, "Y Axis", y_axis_vs, "Y Axis units"),
    UAT_FLD_PROTO_FIELD(io_graph, yfield, "Y Field", "Apply calculations to this field"),
}
void Singleton::f5();{
void IOGraphDialog::toggleTracerStyle(bool force_default)
    if (!tracer_->visible() && !force_default) return;
    if (!ui->ioPlot->graph(0)) return;
    QPen sp_pen = ui->ioPlot->graph(0)->pen();
    QCPItemTracer::TracerStyle tstyle = QCPItemTracer::tsCrosshair;
}
void Singleton::f6();{
    } else {
        ui->dragRadioButton->toggle();
    }
void IOGraphDialog::on_actionToggleTimeOrigin_triggered()
void IOGraphDialog::on_actionCrosshairs_triggered()
}
void Singleton::f7();{
    }
    if (bars_) {
        return bars_->addToLegend();
    }
    return false;
}
void Singleton::f8();{
            graph_->setScatterStyle(QCPScatterStyle::ssDisc);
        }
        break;
    case psSquare:
        if (graph_) {
}
void Singleton::f9();{
        }
        break;
    default:
        if (bars_) {
            graph_ = parent_->addGraph(parent_->xAxis, parent_->yAxis);
}
void Singleton::f10();{
    QCPTextElement* legendTitle = qobject_cast<QCPTextElement*>(iop->legend->elementAt(0));
    if (legendTitle == NULL) {
        legendTitle = new QCPTextElement(iop, QString(""));
        iop->legend->insertRow(0);
        iop->legend->addElement(0, 0, legendTitle);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        } else if (bars_) {
            maxValue = maxValueFromGraphData(*bars_->data());
        }
        // If the maximum value is zero, then either we have no data or
        // everything is zero, do not scale the unit in this case.
}
void Singleton::f2();{
    uat_model_->setData(uat_model_->index(currentRow, colColor), QColor(color_idx), Qt::DecorationRole);
    uat_model_->setData(uat_model_->index(currentRow, colStyle), val_to_str_const(style, graph_style_vs, "None"));
    uat_model_->setData(uat_model_->index(currentRow, colYAxis), val_to_str_const(value_units, y_axis_vs, "Packets"));
    uat_model_->setData(uat_model_->index(currentRow, colYField), yfield);
    uat_model_->setData(uat_model_->index(currentRow, colSMAPeriod), val_to_str_const((guint32) moving_average, moving_avg_vs, "None"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        } else if (bars_) {
            maxValue = maxValueFromGraphData(*bars_->data());
        }
        // If the maximum value is zero, then either we have no data or
        // everything is zero, do not scale the unit in this case.
}
void Singleton::f2();{
    uat_model_->setData(uat_model_->index(currentRow, colColor), QColor(color_idx), Qt::DecorationRole);
    uat_model_->setData(uat_model_->index(currentRow, colStyle), val_to_str_const(style, graph_style_vs, "None"));
    uat_model_->setData(uat_model_->index(currentRow, colYAxis), val_to_str_const(value_units, y_axis_vs, "Packets"));
    uat_model_->setData(uat_model_->index(currentRow, colYField), yfield);
    uat_model_->setData(uat_model_->index(currentRow, colSMAPeriod), val_to_str_const((guint32) moving_average, moving_avg_vs, "None"));
}
void Singleton::f3();{
    header_field_info *hfi = proto_registrar_get_byname(vu_field_.toUtf8().constData());
    if (hfi) {
        hf_index_ = hfi->id;
    }
    if (old_hf_index != hf_index_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        } else if (bars_) {
            maxValue = maxValueFromGraphData(*bars_->data());
        }
        // If the maximum value is zero, then either we have no data or
        // everything is zero, do not scale the unit in this case.
}
void Singleton::f2();{
    uat_model_->setData(uat_model_->index(currentRow, colColor), QColor(color_idx), Qt::DecorationRole);
    uat_model_->setData(uat_model_->index(currentRow, colStyle), val_to_str_const(style, graph_style_vs, "None"));
    uat_model_->setData(uat_model_->index(currentRow, colYAxis), val_to_str_const(value_units, y_axis_vs, "Packets"));
    uat_model_->setData(uat_model_->index(currentRow, colYField), yfield);
    uat_model_->setData(uat_model_->index(currentRow, colSMAPeriod), val_to_str_const((guint32) moving_average, moving_avg_vs, "None"));
}
void Singleton::f3();{
    header_field_info *hfi = proto_registrar_get_byname(vu_field_.toUtf8().constData());
    if (hfi) {
        hf_index_ = hfi->id;
    }
    if (old_hf_index != hf_index_) {
}
void Singleton::f4();{
    UAT_FLD_CSTRING(io_graph, name, "Graph Name", "The name of the graph"),
    UAT_FLD_DISPLAY_FILTER(io_graph, dfilter, "Display Filter", "Graph packets matching this display filter"),
    UAT_FLD_VS(io_graph, style, "Style", graph_style_vs, "Graph style (Line, Bars, etc.)"),
    UAT_FLD_VS(io_graph, yaxis, "Y Axis", y_axis_vs, "Y Axis units"),
    UAT_FLD_PROTO_FIELD(io_graph, yfield, "Y Field", "Apply calculations to this field"),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        } else if (bars_) {
            maxValue = maxValueFromGraphData(*bars_->data());
        }
        // If the maximum value is zero, then either we have no data or
        // everything is zero, do not scale the unit in this case.
}
void Singleton::f2();{
    uat_model_->setData(uat_model_->index(currentRow, colColor), QColor(color_idx), Qt::DecorationRole);
    uat_model_->setData(uat_model_->index(currentRow, colStyle), val_to_str_const(style, graph_style_vs, "None"));
    uat_model_->setData(uat_model_->index(currentRow, colYAxis), val_to_str_const(value_units, y_axis_vs, "Packets"));
    uat_model_->setData(uat_model_->index(currentRow, colYField), yfield);
    uat_model_->setData(uat_model_->index(currentRow, colSMAPeriod), val_to_str_const((guint32) moving_average, moving_avg_vs, "None"));
}
void Singleton::f3();{
    header_field_info *hfi = proto_registrar_get_byname(vu_field_.toUtf8().constData());
    if (hfi) {
        hf_index_ = hfi->id;
    }
    if (old_hf_index != hf_index_) {
}
void Singleton::f4();{
    UAT_FLD_CSTRING(io_graph, name, "Graph Name", "The name of the graph"),
    UAT_FLD_DISPLAY_FILTER(io_graph, dfilter, "Display Filter", "Graph packets matching this display filter"),
    UAT_FLD_VS(io_graph, style, "Style", graph_style_vs, "Graph style (Line, Bars, etc.)"),
    UAT_FLD_VS(io_graph, yaxis, "Y Axis", y_axis_vs, "Y Axis units"),
    UAT_FLD_PROTO_FIELD(io_graph, yfield, "Y Field", "Apply calculations to this field"),
}
void Singleton::f5();{
void IOGraphDialog::toggleTracerStyle(bool force_default)
    if (!tracer_->visible() && !force_default) return;
    if (!ui->ioPlot->graph(0)) return;
    QPen sp_pen = ui->ioPlot->graph(0)->pen();
    QCPItemTracer::TracerStyle tstyle = QCPItemTracer::tsCrosshair;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        } else if (bars_) {
            maxValue = maxValueFromGraphData(*bars_->data());
        }
        // If the maximum value is zero, then either we have no data or
        // everything is zero, do not scale the unit in this case.
}
void Singleton::f2();{
    uat_model_->setData(uat_model_->index(currentRow, colColor), QColor(color_idx), Qt::DecorationRole);
    uat_model_->setData(uat_model_->index(currentRow, colStyle), val_to_str_const(style, graph_style_vs, "None"));
    uat_model_->setData(uat_model_->index(currentRow, colYAxis), val_to_str_const(value_units, y_axis_vs, "Packets"));
    uat_model_->setData(uat_model_->index(currentRow, colYField), yfield);
    uat_model_->setData(uat_model_->index(currentRow, colSMAPeriod), val_to_str_const((guint32) moving_average, moving_avg_vs, "None"));
}
void Singleton::f3();{
    header_field_info *hfi = proto_registrar_get_byname(vu_field_.toUtf8().constData());
    if (hfi) {
        hf_index_ = hfi->id;
    }
    if (old_hf_index != hf_index_) {
}
void Singleton::f4();{
    UAT_FLD_CSTRING(io_graph, name, "Graph Name", "The name of the graph"),
    UAT_FLD_DISPLAY_FILTER(io_graph, dfilter, "Display Filter", "Graph packets matching this display filter"),
    UAT_FLD_VS(io_graph, style, "Style", graph_style_vs, "Graph style (Line, Bars, etc.)"),
    UAT_FLD_VS(io_graph, yaxis, "Y Axis", y_axis_vs, "Y Axis units"),
    UAT_FLD_PROTO_FIELD(io_graph, yfield, "Y Field", "Apply calculations to this field"),
}
void Singleton::f5();{
void IOGraphDialog::toggleTracerStyle(bool force_default)
    if (!tracer_->visible() && !force_default) return;
    if (!ui->ioPlot->graph(0)) return;
    QPen sp_pen = ui->ioPlot->graph(0)->pen();
    QCPItemTracer::TracerStyle tstyle = QCPItemTracer::tsCrosshair;
}
void Singleton::f6();{
    } else {
        ui->dragRadioButton->toggle();
    }
void IOGraphDialog::on_actionToggleTimeOrigin_triggered()
void IOGraphDialog::on_actionCrosshairs_triggered()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        } else if (bars_) {
            maxValue = maxValueFromGraphData(*bars_->data());
        }
        // If the maximum value is zero, then either we have no data or
        // everything is zero, do not scale the unit in this case.
}
void Singleton::f2();{
    uat_model_->setData(uat_model_->index(currentRow, colColor), QColor(color_idx), Qt::DecorationRole);
    uat_model_->setData(uat_model_->index(currentRow, colStyle), val_to_str_const(style, graph_style_vs, "None"));
    uat_model_->setData(uat_model_->index(currentRow, colYAxis), val_to_str_const(value_units, y_axis_vs, "Packets"));
    uat_model_->setData(uat_model_->index(currentRow, colYField), yfield);
    uat_model_->setData(uat_model_->index(currentRow, colSMAPeriod), val_to_str_const((guint32) moving_average, moving_avg_vs, "None"));
}
void Singleton::f3();{
    header_field_info *hfi = proto_registrar_get_byname(vu_field_.toUtf8().constData());
    if (hfi) {
        hf_index_ = hfi->id;
    }
    if (old_hf_index != hf_index_) {
}
void Singleton::f4();{
    UAT_FLD_CSTRING(io_graph, name, "Graph Name", "The name of the graph"),
    UAT_FLD_DISPLAY_FILTER(io_graph, dfilter, "Display Filter", "Graph packets matching this display filter"),
    UAT_FLD_VS(io_graph, style, "Style", graph_style_vs, "Graph style (Line, Bars, etc.)"),
    UAT_FLD_VS(io_graph, yaxis, "Y Axis", y_axis_vs, "Y Axis units"),
    UAT_FLD_PROTO_FIELD(io_graph, yfield, "Y Field", "Apply calculations to this field"),
}
void Singleton::f5();{
void IOGraphDialog::toggleTracerStyle(bool force_default)
    if (!tracer_->visible() && !force_default) return;
    if (!ui->ioPlot->graph(0)) return;
    QPen sp_pen = ui->ioPlot->graph(0)->pen();
    QCPItemTracer::TracerStyle tstyle = QCPItemTracer::tsCrosshair;
}
void Singleton::f6();{
    } else {
        ui->dragRadioButton->toggle();
    }
void IOGraphDialog::on_actionToggleTimeOrigin_triggered()
void IOGraphDialog::on_actionCrosshairs_triggered()
}
void Singleton::f7();{
    }
    if (bars_) {
        return bars_->addToLegend();
    }
    return false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        } else if (bars_) {
            maxValue = maxValueFromGraphData(*bars_->data());
        }
        // If the maximum value is zero, then either we have no data or
        // everything is zero, do not scale the unit in this case.
}
void Singleton::f2();{
    uat_model_->setData(uat_model_->index(currentRow, colColor), QColor(color_idx), Qt::DecorationRole);
    uat_model_->setData(uat_model_->index(currentRow, colStyle), val_to_str_const(style, graph_style_vs, "None"));
    uat_model_->setData(uat_model_->index(currentRow, colYAxis), val_to_str_const(value_units, y_axis_vs, "Packets"));
    uat_model_->setData(uat_model_->index(currentRow, colYField), yfield);
    uat_model_->setData(uat_model_->index(currentRow, colSMAPeriod), val_to_str_const((guint32) moving_average, moving_avg_vs, "None"));
}
void Singleton::f3();{
    header_field_info *hfi = proto_registrar_get_byname(vu_field_.toUtf8().constData());
    if (hfi) {
        hf_index_ = hfi->id;
    }
    if (old_hf_index != hf_index_) {
}
void Singleton::f4();{
    UAT_FLD_CSTRING(io_graph, name, "Graph Name", "The name of the graph"),
    UAT_FLD_DISPLAY_FILTER(io_graph, dfilter, "Display Filter", "Graph packets matching this display filter"),
    UAT_FLD_VS(io_graph, style, "Style", graph_style_vs, "Graph style (Line, Bars, etc.)"),
    UAT_FLD_VS(io_graph, yaxis, "Y Axis", y_axis_vs, "Y Axis units"),
    UAT_FLD_PROTO_FIELD(io_graph, yfield, "Y Field", "Apply calculations to this field"),
}
void Singleton::f5();{
void IOGraphDialog::toggleTracerStyle(bool force_default)
    if (!tracer_->visible() && !force_default) return;
    if (!ui->ioPlot->graph(0)) return;
    QPen sp_pen = ui->ioPlot->graph(0)->pen();
    QCPItemTracer::TracerStyle tstyle = QCPItemTracer::tsCrosshair;
}
void Singleton::f6();{
    } else {
        ui->dragRadioButton->toggle();
    }
void IOGraphDialog::on_actionToggleTimeOrigin_triggered()
void IOGraphDialog::on_actionCrosshairs_triggered()
}
void Singleton::f7();{
    }
    if (bars_) {
        return bars_->addToLegend();
    }
    return false;
}
void Singleton::f8();{
            graph_->setScatterStyle(QCPScatterStyle::ssDisc);
        }
        break;
    case psSquare:
        if (graph_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        } else if (bars_) {
            maxValue = maxValueFromGraphData(*bars_->data());
        }
        // If the maximum value is zero, then either we have no data or
        // everything is zero, do not scale the unit in this case.
}
void Singleton::f2();{
    uat_model_->setData(uat_model_->index(currentRow, colColor), QColor(color_idx), Qt::DecorationRole);
    uat_model_->setData(uat_model_->index(currentRow, colStyle), val_to_str_const(style, graph_style_vs, "None"));
    uat_model_->setData(uat_model_->index(currentRow, colYAxis), val_to_str_const(value_units, y_axis_vs, "Packets"));
    uat_model_->setData(uat_model_->index(currentRow, colYField), yfield);
    uat_model_->setData(uat_model_->index(currentRow, colSMAPeriod), val_to_str_const((guint32) moving_average, moving_avg_vs, "None"));
}
void Singleton::f3();{
    header_field_info *hfi = proto_registrar_get_byname(vu_field_.toUtf8().constData());
    if (hfi) {
        hf_index_ = hfi->id;
    }
    if (old_hf_index != hf_index_) {
}
void Singleton::f4();{
    UAT_FLD_CSTRING(io_graph, name, "Graph Name", "The name of the graph"),
    UAT_FLD_DISPLAY_FILTER(io_graph, dfilter, "Display Filter", "Graph packets matching this display filter"),
    UAT_FLD_VS(io_graph, style, "Style", graph_style_vs, "Graph style (Line, Bars, etc.)"),
    UAT_FLD_VS(io_graph, yaxis, "Y Axis", y_axis_vs, "Y Axis units"),
    UAT_FLD_PROTO_FIELD(io_graph, yfield, "Y Field", "Apply calculations to this field"),
}
void Singleton::f5();{
void IOGraphDialog::toggleTracerStyle(bool force_default)
    if (!tracer_->visible() && !force_default) return;
    if (!ui->ioPlot->graph(0)) return;
    QPen sp_pen = ui->ioPlot->graph(0)->pen();
    QCPItemTracer::TracerStyle tstyle = QCPItemTracer::tsCrosshair;
}
void Singleton::f6();{
    } else {
        ui->dragRadioButton->toggle();
    }
void IOGraphDialog::on_actionToggleTimeOrigin_triggered()
void IOGraphDialog::on_actionCrosshairs_triggered()
}
void Singleton::f7();{
    }
    if (bars_) {
        return bars_->addToLegend();
    }
    return false;
}
void Singleton::f8();{
            graph_->setScatterStyle(QCPScatterStyle::ssDisc);
        }
        break;
    case psSquare:
        if (graph_) {
}
void Singleton::f9();{
        }
        break;
    default:
        if (bars_) {
            graph_ = parent_->addGraph(parent_->xAxis, parent_->yAxis);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
    style_sheet += "}";
    if (styleSheet().size() != style_sheet.size()) {
        // Can be computationally expensive.
        setStyleSheet(style_sheet);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
    style_sheet += "}";
    if (styleSheet().size() != style_sheet.size()) {
        // Can be computationally expensive.
        setStyleSheet(style_sheet);
}
void Singleton::f2();{
        emit toggleTemporaryFlash(true);
    }
    StackItem si;
    si.text = text;
    si.ctx = ctx;
}
void Singleton::f3();{
    si.text = text;
    si.ctx = ctx;
    labels_.prepend(si);
    fillLabel();
void LabelStack::setShrinkable(bool shrinkable)
}
void Singleton::f4();{
        temporary_timer_.stop();
    } else {
        for (int i = (num_flashes_ * 2); i > 0; i--) {
            if (temporary_epoch_.elapsed() >= temporary_flash_timeout_ * i) {
                emit toggleTemporaryFlash(i % 2);
}
void Singleton::f5();{
void LabelStack::pushText(const QString &text, int ctx) {
    popText(ctx);
    if (ctx == temporary_ctx_) {
        temporary_timer_.stop();
        temporary_epoch_.start();
}
void Singleton::f6();{
void LabelStack::popText(int ctx) {
    QMutableListIterator<StackItem> iter(labels_);
    while (iter.hasNext()) {
        if (iter.next().ctx == ctx) {
            iter.remove();
}
void Singleton::f7();{
    }
    QFrame::paintEvent(event);
    QString elided_text = fontMetrics().elidedText(text(), Qt::ElideMiddle, width());
    QPainter painter(this);
    QRect contents_rect = contentsRect();
}
void Singleton::f8();{
const int temporary_interval_ = 1000;
const int temporary_msg_timeout_ = temporary_interval_ * 9;
const int temporary_flash_timeout_ = temporary_interval_ / 5;
const int num_flashes_ = 3;
LabelStack::LabelStack(QWidget *parent) :
}
void Singleton::f9();{
        for (int i = (num_flashes_ * 2); i > 0; i--) {
            if (temporary_epoch_.elapsed() >= temporary_flash_timeout_ * i) {
                emit toggleTemporaryFlash(i % 2);
                break;
            }
}
void Singleton::f10();{
    QRect contents_rect = contentsRect();
    QStyleOption opt;
    contents_rect.adjust(margin(), margin(), -margin(), -margin());
    opt.initFrom(this);
    style()->drawItemText(&painter, contents_rect, alignment(), opt.palette,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
    style_sheet += "}";
    if (styleSheet().size() != style_sheet.size()) {
        // Can be computationally expensive.
        setStyleSheet(style_sheet);
}
void Singleton::f2();{
        emit toggleTemporaryFlash(true);
    }
    StackItem si;
    si.text = text;
    si.ctx = ctx;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
    style_sheet += "}";
    if (styleSheet().size() != style_sheet.size()) {
        // Can be computationally expensive.
        setStyleSheet(style_sheet);
}
void Singleton::f2();{
        emit toggleTemporaryFlash(true);
    }
    StackItem si;
    si.text = text;
    si.ctx = ctx;
}
void Singleton::f3();{
    si.text = text;
    si.ctx = ctx;
    labels_.prepend(si);
    fillLabel();
void LabelStack::setShrinkable(bool shrinkable)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
    style_sheet += "}";
    if (styleSheet().size() != style_sheet.size()) {
        // Can be computationally expensive.
        setStyleSheet(style_sheet);
}
void Singleton::f2();{
        emit toggleTemporaryFlash(true);
    }
    StackItem si;
    si.text = text;
    si.ctx = ctx;
}
void Singleton::f3();{
    si.text = text;
    si.ctx = ctx;
    labels_.prepend(si);
    fillLabel();
void LabelStack::setShrinkable(bool shrinkable)
}
void Singleton::f4();{
        temporary_timer_.stop();
    } else {
        for (int i = (num_flashes_ * 2); i > 0; i--) {
            if (temporary_epoch_.elapsed() >= temporary_flash_timeout_ * i) {
                emit toggleTemporaryFlash(i % 2);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
    style_sheet += "}";
    if (styleSheet().size() != style_sheet.size()) {
        // Can be computationally expensive.
        setStyleSheet(style_sheet);
}
void Singleton::f2();{
        emit toggleTemporaryFlash(true);
    }
    StackItem si;
    si.text = text;
    si.ctx = ctx;
}
void Singleton::f3();{
    si.text = text;
    si.ctx = ctx;
    labels_.prepend(si);
    fillLabel();
void LabelStack::setShrinkable(bool shrinkable)
}
void Singleton::f4();{
        temporary_timer_.stop();
    } else {
        for (int i = (num_flashes_ * 2); i > 0; i--) {
            if (temporary_epoch_.elapsed() >= temporary_flash_timeout_ * i) {
                emit toggleTemporaryFlash(i % 2);
}
void Singleton::f5();{
void LabelStack::pushText(const QString &text, int ctx) {
    popText(ctx);
    if (ctx == temporary_ctx_) {
        temporary_timer_.stop();
        temporary_epoch_.start();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
    style_sheet += "}";
    if (styleSheet().size() != style_sheet.size()) {
        // Can be computationally expensive.
        setStyleSheet(style_sheet);
}
void Singleton::f2();{
        emit toggleTemporaryFlash(true);
    }
    StackItem si;
    si.text = text;
    si.ctx = ctx;
}
void Singleton::f3();{
    si.text = text;
    si.ctx = ctx;
    labels_.prepend(si);
    fillLabel();
void LabelStack::setShrinkable(bool shrinkable)
}
void Singleton::f4();{
        temporary_timer_.stop();
    } else {
        for (int i = (num_flashes_ * 2); i > 0; i--) {
            if (temporary_epoch_.elapsed() >= temporary_flash_timeout_ * i) {
                emit toggleTemporaryFlash(i % 2);
}
void Singleton::f5();{
void LabelStack::pushText(const QString &text, int ctx) {
    popText(ctx);
    if (ctx == temporary_ctx_) {
        temporary_timer_.stop();
        temporary_epoch_.start();
}
void Singleton::f6();{
void LabelStack::popText(int ctx) {
    QMutableListIterator<StackItem> iter(labels_);
    while (iter.hasNext()) {
        if (iter.next().ctx == ctx) {
            iter.remove();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
    style_sheet += "}";
    if (styleSheet().size() != style_sheet.size()) {
        // Can be computationally expensive.
        setStyleSheet(style_sheet);
}
void Singleton::f2();{
        emit toggleTemporaryFlash(true);
    }
    StackItem si;
    si.text = text;
    si.ctx = ctx;
}
void Singleton::f3();{
    si.text = text;
    si.ctx = ctx;
    labels_.prepend(si);
    fillLabel();
void LabelStack::setShrinkable(bool shrinkable)
}
void Singleton::f4();{
        temporary_timer_.stop();
    } else {
        for (int i = (num_flashes_ * 2); i > 0; i--) {
            if (temporary_epoch_.elapsed() >= temporary_flash_timeout_ * i) {
                emit toggleTemporaryFlash(i % 2);
}
void Singleton::f5();{
void LabelStack::pushText(const QString &text, int ctx) {
    popText(ctx);
    if (ctx == temporary_ctx_) {
        temporary_timer_.stop();
        temporary_epoch_.start();
}
void Singleton::f6();{
void LabelStack::popText(int ctx) {
    QMutableListIterator<StackItem> iter(labels_);
    while (iter.hasNext()) {
        if (iter.next().ctx == ctx) {
            iter.remove();
}
void Singleton::f7();{
    }
    QFrame::paintEvent(event);
    QString elided_text = fontMetrics().elidedText(text(), Qt::ElideMiddle, width());
    QPainter painter(this);
    QRect contents_rect = contentsRect();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
    style_sheet += "}";
    if (styleSheet().size() != style_sheet.size()) {
        // Can be computationally expensive.
        setStyleSheet(style_sheet);
}
void Singleton::f2();{
        emit toggleTemporaryFlash(true);
    }
    StackItem si;
    si.text = text;
    si.ctx = ctx;
}
void Singleton::f3();{
    si.text = text;
    si.ctx = ctx;
    labels_.prepend(si);
    fillLabel();
void LabelStack::setShrinkable(bool shrinkable)
}
void Singleton::f4();{
        temporary_timer_.stop();
    } else {
        for (int i = (num_flashes_ * 2); i > 0; i--) {
            if (temporary_epoch_.elapsed() >= temporary_flash_timeout_ * i) {
                emit toggleTemporaryFlash(i % 2);
}
void Singleton::f5();{
void LabelStack::pushText(const QString &text, int ctx) {
    popText(ctx);
    if (ctx == temporary_ctx_) {
        temporary_timer_.stop();
        temporary_epoch_.start();
}
void Singleton::f6();{
void LabelStack::popText(int ctx) {
    QMutableListIterator<StackItem> iter(labels_);
    while (iter.hasNext()) {
        if (iter.next().ctx == ctx) {
            iter.remove();
}
void Singleton::f7();{
    }
    QFrame::paintEvent(event);
    QString elided_text = fontMetrics().elidedText(text(), Qt::ElideMiddle, width());
    QPainter painter(this);
    QRect contents_rect = contentsRect();
}
void Singleton::f8();{
const int temporary_interval_ = 1000;
const int temporary_msg_timeout_ = temporary_interval_ * 9;
const int temporary_flash_timeout_ = temporary_interval_ / 5;
const int num_flashes_ = 3;
LabelStack::LabelStack(QWidget *parent) :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
    style_sheet += "}";
    if (styleSheet().size() != style_sheet.size()) {
        // Can be computationally expensive.
        setStyleSheet(style_sheet);
}
void Singleton::f2();{
        emit toggleTemporaryFlash(true);
    }
    StackItem si;
    si.text = text;
    si.ctx = ctx;
}
void Singleton::f3();{
    si.text = text;
    si.ctx = ctx;
    labels_.prepend(si);
    fillLabel();
void LabelStack::setShrinkable(bool shrinkable)
}
void Singleton::f4();{
        temporary_timer_.stop();
    } else {
        for (int i = (num_flashes_ * 2); i > 0; i--) {
            if (temporary_epoch_.elapsed() >= temporary_flash_timeout_ * i) {
                emit toggleTemporaryFlash(i % 2);
}
void Singleton::f5();{
void LabelStack::pushText(const QString &text, int ctx) {
    popText(ctx);
    if (ctx == temporary_ctx_) {
        temporary_timer_.stop();
        temporary_epoch_.start();
}
void Singleton::f6();{
void LabelStack::popText(int ctx) {
    QMutableListIterator<StackItem> iter(labels_);
    while (iter.hasNext()) {
        if (iter.next().ctx == ctx) {
            iter.remove();
}
void Singleton::f7();{
    }
    QFrame::paintEvent(event);
    QString elided_text = fontMetrics().elidedText(text(), Qt::ElideMiddle, width());
    QPainter painter(this);
    QRect contents_rect = contentsRect();
}
void Singleton::f8();{
const int temporary_interval_ = 1000;
const int temporary_msg_timeout_ = temporary_interval_ * 9;
const int temporary_flash_timeout_ = temporary_interval_ / 5;
const int num_flashes_ = 3;
LabelStack::LabelStack(QWidget *parent) :
}
void Singleton::f9();{
        for (int i = (num_flashes_ * 2); i > 0; i--) {
            if (temporary_epoch_.elapsed() >= temporary_flash_timeout_ * i) {
                emit toggleTemporaryFlash(i % 2);
                break;
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
             "  margin-left: %1px;"
             "}"
             ).arg(ui->packetListSeparatorCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left());
    ui->packetListSeparatorCheckBox->setStyleSheet(indent_ss);
    ui->packetListHeaderShowColumnDefinition->setStyleSheet(indent_ss);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
             "  margin-left: %1px;"
             "}"
             ).arg(ui->packetListSeparatorCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left());
    ui->packetListSeparatorCheckBox->setStyleSheet(indent_ss);
    ui->packetListHeaderShowColumnDefinition->setStyleSheet(indent_ss);
}
void Singleton::f2();{
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowSelectedPacketCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_show_selected_packet_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowFileLoadTimeCheckBox_toggled(bool checked)
}
void Singleton::f3();{
void LayoutPreferencesFrame::on_pane3NoneRadioButton_toggled(bool checked)
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_none, pref_stashed);
void LayoutPreferencesFrame::on_restoreButtonBox_clicked(QAbstractButton *)
    reset_stashed_pref(pref_layout_type_);
}
void Singleton::f4();{
        ui->layout6ToolButton->setChecked(true);
        break;
    }
    switch (prefs_get_enum_value(pref_layout_content_1_, pref_stashed)) {
    case layout_pane_content_plist:
}
void Singleton::f5();{
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_plist, pref_stashed);
    if (ui->pane1PacketListRadioButton->isChecked())
        ui->pane1NoneRadioButton->click();
    if (ui->pane2PacketListRadioButton->isChecked())
}
void Singleton::f6();{
        ui->pane2PacketListRadioButton->setChecked(true);
        break;
    case layout_pane_content_pdetails:
        ui->pane2PacketDetailsRadioButton->setChecked(true);
        break;
}
void Singleton::f7();{
        ui->layout3ToolButton->setChecked(true);
        break;
    case layout_type_6:
        ui->layout6ToolButton->setChecked(true);
        break;
}
void Singleton::f8();{
    ui->statusBarShowFileLoadTimeCheckBox->setChecked(prefs_get_bool_value(pref_show_file_load_time_, pref_default));
void LayoutPreferencesFrame::on_packetListSeparatorCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_packet_list_separator_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
}
void Singleton::f9();{
    case layout_type_1:
        ui->layout1ToolButton->setChecked(true);
        break;
    case layout_type_4:
        ui->layout4ToolButton->setChecked(true);
}
void Singleton::f10();{
    ui->statusBarShowFileLoadTimeCheckBox->setChecked(prefs_get_bool_value(pref_show_file_load_time_, pref_stashed));
LayoutPreferencesFrame::~LayoutPreferencesFrame()
    delete ui;
void LayoutPreferencesFrame::showEvent(QShowEvent *)
    updateWidgets();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
             "  margin-left: %1px;"
             "}"
             ).arg(ui->packetListSeparatorCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left());
    ui->packetListSeparatorCheckBox->setStyleSheet(indent_ss);
    ui->packetListHeaderShowColumnDefinition->setStyleSheet(indent_ss);
}
void Singleton::f2();{
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowSelectedPacketCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_show_selected_packet_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowFileLoadTimeCheckBox_toggled(bool checked)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
             "  margin-left: %1px;"
             "}"
             ).arg(ui->packetListSeparatorCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left());
    ui->packetListSeparatorCheckBox->setStyleSheet(indent_ss);
    ui->packetListHeaderShowColumnDefinition->setStyleSheet(indent_ss);
}
void Singleton::f2();{
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowSelectedPacketCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_show_selected_packet_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowFileLoadTimeCheckBox_toggled(bool checked)
}
void Singleton::f3();{
void LayoutPreferencesFrame::on_pane3NoneRadioButton_toggled(bool checked)
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_none, pref_stashed);
void LayoutPreferencesFrame::on_restoreButtonBox_clicked(QAbstractButton *)
    reset_stashed_pref(pref_layout_type_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
             "  margin-left: %1px;"
             "}"
             ).arg(ui->packetListSeparatorCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left());
    ui->packetListSeparatorCheckBox->setStyleSheet(indent_ss);
    ui->packetListHeaderShowColumnDefinition->setStyleSheet(indent_ss);
}
void Singleton::f2();{
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowSelectedPacketCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_show_selected_packet_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowFileLoadTimeCheckBox_toggled(bool checked)
}
void Singleton::f3();{
void LayoutPreferencesFrame::on_pane3NoneRadioButton_toggled(bool checked)
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_none, pref_stashed);
void LayoutPreferencesFrame::on_restoreButtonBox_clicked(QAbstractButton *)
    reset_stashed_pref(pref_layout_type_);
}
void Singleton::f4();{
        ui->layout6ToolButton->setChecked(true);
        break;
    }
    switch (prefs_get_enum_value(pref_layout_content_1_, pref_stashed)) {
    case layout_pane_content_plist:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
             "  margin-left: %1px;"
             "}"
             ).arg(ui->packetListSeparatorCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left());
    ui->packetListSeparatorCheckBox->setStyleSheet(indent_ss);
    ui->packetListHeaderShowColumnDefinition->setStyleSheet(indent_ss);
}
void Singleton::f2();{
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowSelectedPacketCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_show_selected_packet_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowFileLoadTimeCheckBox_toggled(bool checked)
}
void Singleton::f3();{
void LayoutPreferencesFrame::on_pane3NoneRadioButton_toggled(bool checked)
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_none, pref_stashed);
void LayoutPreferencesFrame::on_restoreButtonBox_clicked(QAbstractButton *)
    reset_stashed_pref(pref_layout_type_);
}
void Singleton::f4();{
        ui->layout6ToolButton->setChecked(true);
        break;
    }
    switch (prefs_get_enum_value(pref_layout_content_1_, pref_stashed)) {
    case layout_pane_content_plist:
}
void Singleton::f5();{
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_plist, pref_stashed);
    if (ui->pane1PacketListRadioButton->isChecked())
        ui->pane1NoneRadioButton->click();
    if (ui->pane2PacketListRadioButton->isChecked())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
             "  margin-left: %1px;"
             "}"
             ).arg(ui->packetListSeparatorCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left());
    ui->packetListSeparatorCheckBox->setStyleSheet(indent_ss);
    ui->packetListHeaderShowColumnDefinition->setStyleSheet(indent_ss);
}
void Singleton::f2();{
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowSelectedPacketCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_show_selected_packet_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowFileLoadTimeCheckBox_toggled(bool checked)
}
void Singleton::f3();{
void LayoutPreferencesFrame::on_pane3NoneRadioButton_toggled(bool checked)
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_none, pref_stashed);
void LayoutPreferencesFrame::on_restoreButtonBox_clicked(QAbstractButton *)
    reset_stashed_pref(pref_layout_type_);
}
void Singleton::f4();{
        ui->layout6ToolButton->setChecked(true);
        break;
    }
    switch (prefs_get_enum_value(pref_layout_content_1_, pref_stashed)) {
    case layout_pane_content_plist:
}
void Singleton::f5();{
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_plist, pref_stashed);
    if (ui->pane1PacketListRadioButton->isChecked())
        ui->pane1NoneRadioButton->click();
    if (ui->pane2PacketListRadioButton->isChecked())
}
void Singleton::f6();{
        ui->pane2PacketListRadioButton->setChecked(true);
        break;
    case layout_pane_content_pdetails:
        ui->pane2PacketDetailsRadioButton->setChecked(true);
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
             "  margin-left: %1px;"
             "}"
             ).arg(ui->packetListSeparatorCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left());
    ui->packetListSeparatorCheckBox->setStyleSheet(indent_ss);
    ui->packetListHeaderShowColumnDefinition->setStyleSheet(indent_ss);
}
void Singleton::f2();{
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowSelectedPacketCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_show_selected_packet_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowFileLoadTimeCheckBox_toggled(bool checked)
}
void Singleton::f3();{
void LayoutPreferencesFrame::on_pane3NoneRadioButton_toggled(bool checked)
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_none, pref_stashed);
void LayoutPreferencesFrame::on_restoreButtonBox_clicked(QAbstractButton *)
    reset_stashed_pref(pref_layout_type_);
}
void Singleton::f4();{
        ui->layout6ToolButton->setChecked(true);
        break;
    }
    switch (prefs_get_enum_value(pref_layout_content_1_, pref_stashed)) {
    case layout_pane_content_plist:
}
void Singleton::f5();{
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_plist, pref_stashed);
    if (ui->pane1PacketListRadioButton->isChecked())
        ui->pane1NoneRadioButton->click();
    if (ui->pane2PacketListRadioButton->isChecked())
}
void Singleton::f6();{
        ui->pane2PacketListRadioButton->setChecked(true);
        break;
    case layout_pane_content_pdetails:
        ui->pane2PacketDetailsRadioButton->setChecked(true);
        break;
}
void Singleton::f7();{
        ui->layout3ToolButton->setChecked(true);
        break;
    case layout_type_6:
        ui->layout6ToolButton->setChecked(true);
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
             "  margin-left: %1px;"
             "}"
             ).arg(ui->packetListSeparatorCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left());
    ui->packetListSeparatorCheckBox->setStyleSheet(indent_ss);
    ui->packetListHeaderShowColumnDefinition->setStyleSheet(indent_ss);
}
void Singleton::f2();{
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowSelectedPacketCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_show_selected_packet_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowFileLoadTimeCheckBox_toggled(bool checked)
}
void Singleton::f3();{
void LayoutPreferencesFrame::on_pane3NoneRadioButton_toggled(bool checked)
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_none, pref_stashed);
void LayoutPreferencesFrame::on_restoreButtonBox_clicked(QAbstractButton *)
    reset_stashed_pref(pref_layout_type_);
}
void Singleton::f4();{
        ui->layout6ToolButton->setChecked(true);
        break;
    }
    switch (prefs_get_enum_value(pref_layout_content_1_, pref_stashed)) {
    case layout_pane_content_plist:
}
void Singleton::f5();{
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_plist, pref_stashed);
    if (ui->pane1PacketListRadioButton->isChecked())
        ui->pane1NoneRadioButton->click();
    if (ui->pane2PacketListRadioButton->isChecked())
}
void Singleton::f6();{
        ui->pane2PacketListRadioButton->setChecked(true);
        break;
    case layout_pane_content_pdetails:
        ui->pane2PacketDetailsRadioButton->setChecked(true);
        break;
}
void Singleton::f7();{
        ui->layout3ToolButton->setChecked(true);
        break;
    case layout_type_6:
        ui->layout6ToolButton->setChecked(true);
        break;
}
void Singleton::f8();{
    ui->statusBarShowFileLoadTimeCheckBox->setChecked(prefs_get_bool_value(pref_show_file_load_time_, pref_default));
void LayoutPreferencesFrame::on_packetListSeparatorCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_packet_list_separator_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
             "  margin-left: %1px;"
             "}"
             ).arg(ui->packetListSeparatorCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left());
    ui->packetListSeparatorCheckBox->setStyleSheet(indent_ss);
    ui->packetListHeaderShowColumnDefinition->setStyleSheet(indent_ss);
}
void Singleton::f2();{
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowSelectedPacketCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_show_selected_packet_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_statusBarShowFileLoadTimeCheckBox_toggled(bool checked)
}
void Singleton::f3();{
void LayoutPreferencesFrame::on_pane3NoneRadioButton_toggled(bool checked)
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_none, pref_stashed);
void LayoutPreferencesFrame::on_restoreButtonBox_clicked(QAbstractButton *)
    reset_stashed_pref(pref_layout_type_);
}
void Singleton::f4();{
        ui->layout6ToolButton->setChecked(true);
        break;
    }
    switch (prefs_get_enum_value(pref_layout_content_1_, pref_stashed)) {
    case layout_pane_content_plist:
}
void Singleton::f5();{
    if (!checked) return;
    prefs_set_enum_value(pref_layout_content_3_, layout_pane_content_plist, pref_stashed);
    if (ui->pane1PacketListRadioButton->isChecked())
        ui->pane1NoneRadioButton->click();
    if (ui->pane2PacketListRadioButton->isChecked())
}
void Singleton::f6();{
        ui->pane2PacketListRadioButton->setChecked(true);
        break;
    case layout_pane_content_pdetails:
        ui->pane2PacketDetailsRadioButton->setChecked(true);
        break;
}
void Singleton::f7();{
        ui->layout3ToolButton->setChecked(true);
        break;
    case layout_type_6:
        ui->layout6ToolButton->setChecked(true);
        break;
}
void Singleton::f8();{
    ui->statusBarShowFileLoadTimeCheckBox->setChecked(prefs_get_bool_value(pref_show_file_load_time_, pref_default));
void LayoutPreferencesFrame::on_packetListSeparatorCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_packet_list_separator_, (gboolean) checked, pref_stashed);
void LayoutPreferencesFrame::on_packetListHeaderShowColumnDefinition_toggled(bool checked)
    prefs_set_bool_value(pref_packet_header_column_definition_, (gboolean) checked, pref_stashed);
}
void Singleton::f9();{
    case layout_type_1:
        ui->layout1ToolButton->setChecked(true);
        break;
    case layout_type_4:
        ui->layout4ToolButton->setChecked(true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    if (rate >= OneGigabit)
    {
        rate /= OneGigabit;
        result = QString("%1G").arg(rate, 0, 'f', 2);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    if (rate >= OneGigabit)
    {
        rate /= OneGigabit;
        result = QString("%1G").arg(rate, 0, 'f', 2);
    }
}
void Singleton::f2();{
//          delete *it;
//      }
//      m_xxx.clear();
//    The for-loop calls the destructor for each item, while the clear() cleans up the space used by the QMap itself.
// A frame entry
}
void Singleton::f3();{
        nstime_t m_last_frame_timestamp;
        LBMLBTRMSourceTransportMap m_transports;
LBMLBTRMSourceEntry::LBMLBTRMSourceEntry(const QString & source_address) :
    QTreeWidgetItem(),
    m_address(source_address),
}
void Singleton::f4();{
    connect(m_ui->action_SourceNCFRate, SIGNAL(triggered(bool)), this, SLOT(actionSourceNCFRate_triggered(bool)));
    m_ui->action_SourceSMFrames->setChecked(true);
    m_source_context_menu->addAction(m_ui->action_SourceSMFrames);
    connect(m_ui->action_SourceSMFrames, SIGNAL(triggered(bool)), this, SLOT(actionSourceSMFrames_triggered(bool)));
    m_ui->action_SourceSMBytes->setChecked(true);
}
void Singleton::f5();{
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_NCFRate_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFrames_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFramesBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMRate_Column);
}
void Singleton::f6();{
        sortChildren(Detail_Frame_Column, Qt::AscendingOrder);
    }
    m_count++;
    setText(Detail_Count_Column, QString("%1").arg(m_count));
    setTextAlignment(Detail_Count_Column, Qt::AlignRight);
}
void Singleton::f7();{
    m_ui->action_SourceDataFramesBytes->setChecked(false);
    m_source_context_menu->addAction(m_ui->action_SourceDataFramesBytes);
    connect(m_ui->action_SourceDataFramesBytes, SIGNAL(triggered(bool)), this, SLOT(actionSourceDataFramesBytes_triggered(bool)));
    m_ui->action_SourceDataRate->setChecked(true);
    m_source_context_menu->addAction(m_ui->action_SourceDataRate);
}
void Singleton::f8();{
                {
                    QTreeWidgetItem * parent = NULL;
                    Ui::LBMLBTRMTransportDialog * ui = NULL;
                    source = new LBMLBTRMSourceEntry(src_address);
                    it = m_sources.insert(src_address, source);
}
void Singleton::f9();{
    if (frame == NULL)
    {
        // Must have double-clicked on something other than an expanded frame entry
        return;
    }
}
void Singleton::f10();{
        {
            it = m_ncf_sqns.find(tap_info->sqns[idx]);
            if (m_ncf_sqns.end() == it)
            {
                sqn = new LBMLBTRMNCFSQNEntry(tap_info->sqns[idx]);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    if (rate >= OneGigabit)
    {
        rate /= OneGigabit;
        result = QString("%1G").arg(rate, 0, 'f', 2);
    }
}
void Singleton::f2();{
//          delete *it;
//      }
//      m_xxx.clear();
//    The for-loop calls the destructor for each item, while the clear() cleans up the space used by the QMap itself.
// A frame entry
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    if (rate >= OneGigabit)
    {
        rate /= OneGigabit;
        result = QString("%1G").arg(rate, 0, 'f', 2);
    }
}
void Singleton::f2();{
//          delete *it;
//      }
//      m_xxx.clear();
//    The for-loop calls the destructor for each item, while the clear() cleans up the space used by the QMap itself.
// A frame entry
}
void Singleton::f3();{
        nstime_t m_last_frame_timestamp;
        LBMLBTRMSourceTransportMap m_transports;
LBMLBTRMSourceEntry::LBMLBTRMSourceEntry(const QString & source_address) :
    QTreeWidgetItem(),
    m_address(source_address),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    if (rate >= OneGigabit)
    {
        rate /= OneGigabit;
        result = QString("%1G").arg(rate, 0, 'f', 2);
    }
}
void Singleton::f2();{
//          delete *it;
//      }
//      m_xxx.clear();
//    The for-loop calls the destructor for each item, while the clear() cleans up the space used by the QMap itself.
// A frame entry
}
void Singleton::f3();{
        nstime_t m_last_frame_timestamp;
        LBMLBTRMSourceTransportMap m_transports;
LBMLBTRMSourceEntry::LBMLBTRMSourceEntry(const QString & source_address) :
    QTreeWidgetItem(),
    m_address(source_address),
}
void Singleton::f4();{
    connect(m_ui->action_SourceNCFRate, SIGNAL(triggered(bool)), this, SLOT(actionSourceNCFRate_triggered(bool)));
    m_ui->action_SourceSMFrames->setChecked(true);
    m_source_context_menu->addAction(m_ui->action_SourceSMFrames);
    connect(m_ui->action_SourceSMFrames, SIGNAL(triggered(bool)), this, SLOT(actionSourceSMFrames_triggered(bool)));
    m_ui->action_SourceSMBytes->setChecked(true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    if (rate >= OneGigabit)
    {
        rate /= OneGigabit;
        result = QString("%1G").arg(rate, 0, 'f', 2);
    }
}
void Singleton::f2();{
//          delete *it;
//      }
//      m_xxx.clear();
//    The for-loop calls the destructor for each item, while the clear() cleans up the space used by the QMap itself.
// A frame entry
}
void Singleton::f3();{
        nstime_t m_last_frame_timestamp;
        LBMLBTRMSourceTransportMap m_transports;
LBMLBTRMSourceEntry::LBMLBTRMSourceEntry(const QString & source_address) :
    QTreeWidgetItem(),
    m_address(source_address),
}
void Singleton::f4();{
    connect(m_ui->action_SourceNCFRate, SIGNAL(triggered(bool)), this, SLOT(actionSourceNCFRate_triggered(bool)));
    m_ui->action_SourceSMFrames->setChecked(true);
    m_source_context_menu->addAction(m_ui->action_SourceSMFrames);
    connect(m_ui->action_SourceSMFrames, SIGNAL(triggered(bool)), this, SLOT(actionSourceSMFrames_triggered(bool)));
    m_ui->action_SourceSMBytes->setChecked(true);
}
void Singleton::f5();{
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_NCFRate_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFrames_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFramesBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMRate_Column);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    if (rate >= OneGigabit)
    {
        rate /= OneGigabit;
        result = QString("%1G").arg(rate, 0, 'f', 2);
    }
}
void Singleton::f2();{
//          delete *it;
//      }
//      m_xxx.clear();
//    The for-loop calls the destructor for each item, while the clear() cleans up the space used by the QMap itself.
// A frame entry
}
void Singleton::f3();{
        nstime_t m_last_frame_timestamp;
        LBMLBTRMSourceTransportMap m_transports;
LBMLBTRMSourceEntry::LBMLBTRMSourceEntry(const QString & source_address) :
    QTreeWidgetItem(),
    m_address(source_address),
}
void Singleton::f4();{
    connect(m_ui->action_SourceNCFRate, SIGNAL(triggered(bool)), this, SLOT(actionSourceNCFRate_triggered(bool)));
    m_ui->action_SourceSMFrames->setChecked(true);
    m_source_context_menu->addAction(m_ui->action_SourceSMFrames);
    connect(m_ui->action_SourceSMFrames, SIGNAL(triggered(bool)), this, SLOT(actionSourceSMFrames_triggered(bool)));
    m_ui->action_SourceSMBytes->setChecked(true);
}
void Singleton::f5();{
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_NCFRate_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFrames_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFramesBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMRate_Column);
}
void Singleton::f6();{
        sortChildren(Detail_Frame_Column, Qt::AscendingOrder);
    }
    m_count++;
    setText(Detail_Count_Column, QString("%1").arg(m_count));
    setTextAlignment(Detail_Count_Column, Qt::AlignRight);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    if (rate >= OneGigabit)
    {
        rate /= OneGigabit;
        result = QString("%1G").arg(rate, 0, 'f', 2);
    }
}
void Singleton::f2();{
//          delete *it;
//      }
//      m_xxx.clear();
//    The for-loop calls the destructor for each item, while the clear() cleans up the space used by the QMap itself.
// A frame entry
}
void Singleton::f3();{
        nstime_t m_last_frame_timestamp;
        LBMLBTRMSourceTransportMap m_transports;
LBMLBTRMSourceEntry::LBMLBTRMSourceEntry(const QString & source_address) :
    QTreeWidgetItem(),
    m_address(source_address),
}
void Singleton::f4();{
    connect(m_ui->action_SourceNCFRate, SIGNAL(triggered(bool)), this, SLOT(actionSourceNCFRate_triggered(bool)));
    m_ui->action_SourceSMFrames->setChecked(true);
    m_source_context_menu->addAction(m_ui->action_SourceSMFrames);
    connect(m_ui->action_SourceSMFrames, SIGNAL(triggered(bool)), this, SLOT(actionSourceSMFrames_triggered(bool)));
    m_ui->action_SourceSMBytes->setChecked(true);
}
void Singleton::f5();{
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_NCFRate_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFrames_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFramesBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMRate_Column);
}
void Singleton::f6();{
        sortChildren(Detail_Frame_Column, Qt::AscendingOrder);
    }
    m_count++;
    setText(Detail_Count_Column, QString("%1").arg(m_count));
    setTextAlignment(Detail_Count_Column, Qt::AlignRight);
}
void Singleton::f7();{
    m_ui->action_SourceDataFramesBytes->setChecked(false);
    m_source_context_menu->addAction(m_ui->action_SourceDataFramesBytes);
    connect(m_ui->action_SourceDataFramesBytes, SIGNAL(triggered(bool)), this, SLOT(actionSourceDataFramesBytes_triggered(bool)));
    m_ui->action_SourceDataRate->setChecked(true);
    m_source_context_menu->addAction(m_ui->action_SourceDataRate);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    if (rate >= OneGigabit)
    {
        rate /= OneGigabit;
        result = QString("%1G").arg(rate, 0, 'f', 2);
    }
}
void Singleton::f2();{
//          delete *it;
//      }
//      m_xxx.clear();
//    The for-loop calls the destructor for each item, while the clear() cleans up the space used by the QMap itself.
// A frame entry
}
void Singleton::f3();{
        nstime_t m_last_frame_timestamp;
        LBMLBTRMSourceTransportMap m_transports;
LBMLBTRMSourceEntry::LBMLBTRMSourceEntry(const QString & source_address) :
    QTreeWidgetItem(),
    m_address(source_address),
}
void Singleton::f4();{
    connect(m_ui->action_SourceNCFRate, SIGNAL(triggered(bool)), this, SLOT(actionSourceNCFRate_triggered(bool)));
    m_ui->action_SourceSMFrames->setChecked(true);
    m_source_context_menu->addAction(m_ui->action_SourceSMFrames);
    connect(m_ui->action_SourceSMFrames, SIGNAL(triggered(bool)), this, SLOT(actionSourceSMFrames_triggered(bool)));
    m_ui->action_SourceSMBytes->setChecked(true);
}
void Singleton::f5();{
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_NCFRate_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFrames_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFramesBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMRate_Column);
}
void Singleton::f6();{
        sortChildren(Detail_Frame_Column, Qt::AscendingOrder);
    }
    m_count++;
    setText(Detail_Count_Column, QString("%1").arg(m_count));
    setTextAlignment(Detail_Count_Column, Qt::AlignRight);
}
void Singleton::f7();{
    m_ui->action_SourceDataFramesBytes->setChecked(false);
    m_source_context_menu->addAction(m_ui->action_SourceDataFramesBytes);
    connect(m_ui->action_SourceDataFramesBytes, SIGNAL(triggered(bool)), this, SLOT(actionSourceDataFramesBytes_triggered(bool)));
    m_ui->action_SourceDataRate->setChecked(true);
    m_source_context_menu->addAction(m_ui->action_SourceDataRate);
}
void Singleton::f8();{
                {
                    QTreeWidgetItem * parent = NULL;
                    Ui::LBMLBTRMTransportDialog * ui = NULL;
                    source = new LBMLBTRMSourceEntry(src_address);
                    it = m_sources.insert(src_address, source);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    if (rate >= OneGigabit)
    {
        rate /= OneGigabit;
        result = QString("%1G").arg(rate, 0, 'f', 2);
    }
}
void Singleton::f2();{
//          delete *it;
//      }
//      m_xxx.clear();
//    The for-loop calls the destructor for each item, while the clear() cleans up the space used by the QMap itself.
// A frame entry
}
void Singleton::f3();{
        nstime_t m_last_frame_timestamp;
        LBMLBTRMSourceTransportMap m_transports;
LBMLBTRMSourceEntry::LBMLBTRMSourceEntry(const QString & source_address) :
    QTreeWidgetItem(),
    m_address(source_address),
}
void Singleton::f4();{
    connect(m_ui->action_SourceNCFRate, SIGNAL(triggered(bool)), this, SLOT(actionSourceNCFRate_triggered(bool)));
    m_ui->action_SourceSMFrames->setChecked(true);
    m_source_context_menu->addAction(m_ui->action_SourceSMFrames);
    connect(m_ui->action_SourceSMFrames, SIGNAL(triggered(bool)), this, SLOT(actionSourceSMFrames_triggered(bool)));
    m_ui->action_SourceSMBytes->setChecked(true);
}
void Singleton::f5();{
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_NCFRate_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFrames_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMFramesBytes_Column);
    m_ui->sources_TreeWidget->resizeColumnToContents(Source_SMRate_Column);
}
void Singleton::f6();{
        sortChildren(Detail_Frame_Column, Qt::AscendingOrder);
    }
    m_count++;
    setText(Detail_Count_Column, QString("%1").arg(m_count));
    setTextAlignment(Detail_Count_Column, Qt::AlignRight);
}
void Singleton::f7();{
    m_ui->action_SourceDataFramesBytes->setChecked(false);
    m_source_context_menu->addAction(m_ui->action_SourceDataFramesBytes);
    connect(m_ui->action_SourceDataFramesBytes, SIGNAL(triggered(bool)), this, SLOT(actionSourceDataFramesBytes_triggered(bool)));
    m_ui->action_SourceDataRate->setChecked(true);
    m_source_context_menu->addAction(m_ui->action_SourceDataRate);
}
void Singleton::f8();{
                {
                    QTreeWidgetItem * parent = NULL;
                    Ui::LBMLBTRMTransportDialog * ui = NULL;
                    source = new LBMLBTRMSourceEntry(src_address);
                    it = m_sources.insert(src_address, source);
}
void Singleton::f9();{
    if (frame == NULL)
    {
        // Must have double-clicked on something other than an expanded frame entry
        return;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    {
        case 0:
        case 1:
        case 3:
            m_ui->sources_stackedWidget->setCurrentIndex(0);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    {
        case 0:
        case 1:
        case 3:
            m_ui->sources_stackedWidget->setCurrentIndex(0);
}
void Singleton::f2();{
        tapPacket,
        drawTreeItems,
        NULL);
    if (error_string)
    {
}
void Singleton::f3();{
    setTextAlignment(Source_SMFrames_Column, Qt::AlignRight);
    setText(Source_SMBytes_Column, QString("%1").arg(m_sm_bytes));
    setTextAlignment(Source_SMBytes_Column, Qt::AlignRight);
    setText(Source_SMFramesBytes_Column, QString("%1/%2").arg(m_sm_frames).arg(m_sm_bytes));
    setTextAlignment(Source_SMFramesBytes_Column, Qt::AlignRight);
}
void Singleton::f4();{
    m_ack_frames(0),
    m_ack_bytes(0),
    m_creq_frames(0),
    m_creq_bytes(0),
    m_first_frame_timestamp_valid(false),
}
void Singleton::f5();{
        guint64 m_creq_frames;
        guint64 m_creq_bytes;
        nstime_t m_first_frame_timestamp;
        bool m_first_frame_timestamp_valid;
        nstime_t m_last_frame_timestamp;
}
void Singleton::f6();{
                sqn = it.value();
            }
            sqn->processFrame(pinfo->num);
        }
        else
}
void Singleton::f7();{
    setTextAlignment(Detail_SQNReasonType_Column, Qt::AlignLeft);
    setText(Detail_Count_Column, QString("%1").arg(m_count));
    setTextAlignment(Detail_Count_Column, Qt::AlignRight);
    setText(Detail_Frame_Column, QString(" "));
LBMLBTRURSTReasonEntry::~LBMLBTRURSTReasonEntry(void)
}
void Singleton::f8();{
    m_ui->action_ReceiverCREQFramesBytes->setChecked(false);
    m_receiver_context_menu->addAction(m_ui->action_ReceiverCREQFramesBytes);
    connect(m_ui->action_ReceiverCREQFramesBytes, SIGNAL(triggered(bool)), this, SLOT(actionReceiverCREQFramesBytes_triggered(bool)));
    m_ui->action_ReceiverCREQRate->setChecked(true);
    m_receiver_context_menu->addAction(m_ui->action_ReceiverCREQRate);
}
void Singleton::f9();{
    while (m_ui->receivers_detail_sqn_TreeWidget->takeTopLevelItem(0) != NULL)
    {}
    while (m_ui->receivers_detail_reason_TreeWidget->takeTopLevelItem(0) != NULL)
    {}
    m_ui->receivers_detail_transport_Label->setText(QString(" "));
}
void Singleton::f10();{
    static const int Source_DataRate_Column = 4;
    static const int Source_RXDataFrames_Column = 5;
    static const int Source_RXDataBytes_Column = 6;
    static const int Source_RXDataFramesBytes_Column = 7;
    static const int Source_RXDataRate_Column = 8;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    {
        case 0:
        case 1:
        case 3:
            m_ui->sources_stackedWidget->setCurrentIndex(0);
}
void Singleton::f2();{
        tapPacket,
        drawTreeItems,
        NULL);
    if (error_string)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    {
        case 0:
        case 1:
        case 3:
            m_ui->sources_stackedWidget->setCurrentIndex(0);
}
void Singleton::f2();{
        tapPacket,
        drawTreeItems,
        NULL);
    if (error_string)
    {
}
void Singleton::f3();{
    setTextAlignment(Source_SMFrames_Column, Qt::AlignRight);
    setText(Source_SMBytes_Column, QString("%1").arg(m_sm_bytes));
    setTextAlignment(Source_SMBytes_Column, Qt::AlignRight);
    setText(Source_SMFramesBytes_Column, QString("%1/%2").arg(m_sm_frames).arg(m_sm_bytes));
    setTextAlignment(Source_SMFramesBytes_Column, Qt::AlignRight);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    {
        case 0:
        case 1:
        case 3:
            m_ui->sources_stackedWidget->setCurrentIndex(0);
}
void Singleton::f2();{
        tapPacket,
        drawTreeItems,
        NULL);
    if (error_string)
    {
}
void Singleton::f3();{
    setTextAlignment(Source_SMFrames_Column, Qt::AlignRight);
    setText(Source_SMBytes_Column, QString("%1").arg(m_sm_bytes));
    setTextAlignment(Source_SMBytes_Column, Qt::AlignRight);
    setText(Source_SMFramesBytes_Column, QString("%1/%2").arg(m_sm_frames).arg(m_sm_bytes));
    setTextAlignment(Source_SMFramesBytes_Column, Qt::AlignRight);
}
void Singleton::f4();{
    m_ack_frames(0),
    m_ack_bytes(0),
    m_creq_frames(0),
    m_creq_bytes(0),
    m_first_frame_timestamp_valid(false),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    {
        case 0:
        case 1:
        case 3:
            m_ui->sources_stackedWidget->setCurrentIndex(0);
}
void Singleton::f2();{
        tapPacket,
        drawTreeItems,
        NULL);
    if (error_string)
    {
}
void Singleton::f3();{
    setTextAlignment(Source_SMFrames_Column, Qt::AlignRight);
    setText(Source_SMBytes_Column, QString("%1").arg(m_sm_bytes));
    setTextAlignment(Source_SMBytes_Column, Qt::AlignRight);
    setText(Source_SMFramesBytes_Column, QString("%1/%2").arg(m_sm_frames).arg(m_sm_bytes));
    setTextAlignment(Source_SMFramesBytes_Column, Qt::AlignRight);
}
void Singleton::f4();{
    m_ack_frames(0),
    m_ack_bytes(0),
    m_creq_frames(0),
    m_creq_bytes(0),
    m_first_frame_timestamp_valid(false),
}
void Singleton::f5();{
        guint64 m_creq_frames;
        guint64 m_creq_bytes;
        nstime_t m_first_frame_timestamp;
        bool m_first_frame_timestamp_valid;
        nstime_t m_last_frame_timestamp;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    {
        case 0:
        case 1:
        case 3:
            m_ui->sources_stackedWidget->setCurrentIndex(0);
}
void Singleton::f2();{
        tapPacket,
        drawTreeItems,
        NULL);
    if (error_string)
    {
}
void Singleton::f3();{
    setTextAlignment(Source_SMFrames_Column, Qt::AlignRight);
    setText(Source_SMBytes_Column, QString("%1").arg(m_sm_bytes));
    setTextAlignment(Source_SMBytes_Column, Qt::AlignRight);
    setText(Source_SMFramesBytes_Column, QString("%1/%2").arg(m_sm_frames).arg(m_sm_bytes));
    setTextAlignment(Source_SMFramesBytes_Column, Qt::AlignRight);
}
void Singleton::f4();{
    m_ack_frames(0),
    m_ack_bytes(0),
    m_creq_frames(0),
    m_creq_bytes(0),
    m_first_frame_timestamp_valid(false),
}
void Singleton::f5();{
        guint64 m_creq_frames;
        guint64 m_creq_bytes;
        nstime_t m_first_frame_timestamp;
        bool m_first_frame_timestamp_valid;
        nstime_t m_last_frame_timestamp;
}
void Singleton::f6();{
                sqn = it.value();
            }
            sqn->processFrame(pinfo->num);
        }
        else
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    {
        case 0:
        case 1:
        case 3:
            m_ui->sources_stackedWidget->setCurrentIndex(0);
}
void Singleton::f2();{
        tapPacket,
        drawTreeItems,
        NULL);
    if (error_string)
    {
}
void Singleton::f3();{
    setTextAlignment(Source_SMFrames_Column, Qt::AlignRight);
    setText(Source_SMBytes_Column, QString("%1").arg(m_sm_bytes));
    setTextAlignment(Source_SMBytes_Column, Qt::AlignRight);
    setText(Source_SMFramesBytes_Column, QString("%1/%2").arg(m_sm_frames).arg(m_sm_bytes));
    setTextAlignment(Source_SMFramesBytes_Column, Qt::AlignRight);
}
void Singleton::f4();{
    m_ack_frames(0),
    m_ack_bytes(0),
    m_creq_frames(0),
    m_creq_bytes(0),
    m_first_frame_timestamp_valid(false),
}
void Singleton::f5();{
        guint64 m_creq_frames;
        guint64 m_creq_bytes;
        nstime_t m_first_frame_timestamp;
        bool m_first_frame_timestamp_valid;
        nstime_t m_last_frame_timestamp;
}
void Singleton::f6();{
                sqn = it.value();
            }
            sqn->processFrame(pinfo->num);
        }
        else
}
void Singleton::f7();{
    setTextAlignment(Detail_SQNReasonType_Column, Qt::AlignLeft);
    setText(Detail_Count_Column, QString("%1").arg(m_count));
    setTextAlignment(Detail_Count_Column, Qt::AlignRight);
    setText(Detail_Frame_Column, QString(" "));
LBMLBTRURSTReasonEntry::~LBMLBTRURSTReasonEntry(void)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    {
        case 0:
        case 1:
        case 3:
            m_ui->sources_stackedWidget->setCurrentIndex(0);
}
void Singleton::f2();{
        tapPacket,
        drawTreeItems,
        NULL);
    if (error_string)
    {
}
void Singleton::f3();{
    setTextAlignment(Source_SMFrames_Column, Qt::AlignRight);
    setText(Source_SMBytes_Column, QString("%1").arg(m_sm_bytes));
    setTextAlignment(Source_SMBytes_Column, Qt::AlignRight);
    setText(Source_SMFramesBytes_Column, QString("%1/%2").arg(m_sm_frames).arg(m_sm_bytes));
    setTextAlignment(Source_SMFramesBytes_Column, Qt::AlignRight);
}
void Singleton::f4();{
    m_ack_frames(0),
    m_ack_bytes(0),
    m_creq_frames(0),
    m_creq_bytes(0),
    m_first_frame_timestamp_valid(false),
}
void Singleton::f5();{
        guint64 m_creq_frames;
        guint64 m_creq_bytes;
        nstime_t m_first_frame_timestamp;
        bool m_first_frame_timestamp_valid;
        nstime_t m_last_frame_timestamp;
}
void Singleton::f6();{
                sqn = it.value();
            }
            sqn->processFrame(pinfo->num);
        }
        else
}
void Singleton::f7();{
    setTextAlignment(Detail_SQNReasonType_Column, Qt::AlignLeft);
    setText(Detail_Count_Column, QString("%1").arg(m_count));
    setTextAlignment(Detail_Count_Column, Qt::AlignRight);
    setText(Detail_Frame_Column, QString(" "));
LBMLBTRURSTReasonEntry::~LBMLBTRURSTReasonEntry(void)
}
void Singleton::f8();{
    m_ui->action_ReceiverCREQFramesBytes->setChecked(false);
    m_receiver_context_menu->addAction(m_ui->action_ReceiverCREQFramesBytes);
    connect(m_ui->action_ReceiverCREQFramesBytes, SIGNAL(triggered(bool)), this, SLOT(actionReceiverCREQFramesBytes_triggered(bool)));
    m_ui->action_ReceiverCREQRate->setChecked(true);
    m_receiver_context_menu->addAction(m_ui->action_ReceiverCREQRate);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    {
        case 0:
        case 1:
        case 3:
            m_ui->sources_stackedWidget->setCurrentIndex(0);
}
void Singleton::f2();{
        tapPacket,
        drawTreeItems,
        NULL);
    if (error_string)
    {
}
void Singleton::f3();{
    setTextAlignment(Source_SMFrames_Column, Qt::AlignRight);
    setText(Source_SMBytes_Column, QString("%1").arg(m_sm_bytes));
    setTextAlignment(Source_SMBytes_Column, Qt::AlignRight);
    setText(Source_SMFramesBytes_Column, QString("%1/%2").arg(m_sm_frames).arg(m_sm_bytes));
    setTextAlignment(Source_SMFramesBytes_Column, Qt::AlignRight);
}
void Singleton::f4();{
    m_ack_frames(0),
    m_ack_bytes(0),
    m_creq_frames(0),
    m_creq_bytes(0),
    m_first_frame_timestamp_valid(false),
}
void Singleton::f5();{
        guint64 m_creq_frames;
        guint64 m_creq_bytes;
        nstime_t m_first_frame_timestamp;
        bool m_first_frame_timestamp_valid;
        nstime_t m_last_frame_timestamp;
}
void Singleton::f6();{
                sqn = it.value();
            }
            sqn->processFrame(pinfo->num);
        }
        else
}
void Singleton::f7();{
    setTextAlignment(Detail_SQNReasonType_Column, Qt::AlignLeft);
    setText(Detail_Count_Column, QString("%1").arg(m_count));
    setTextAlignment(Detail_Count_Column, Qt::AlignRight);
    setText(Detail_Frame_Column, QString(" "));
LBMLBTRURSTReasonEntry::~LBMLBTRURSTReasonEntry(void)
}
void Singleton::f8();{
    m_ui->action_ReceiverCREQFramesBytes->setChecked(false);
    m_receiver_context_menu->addAction(m_ui->action_ReceiverCREQFramesBytes);
    connect(m_ui->action_ReceiverCREQFramesBytes, SIGNAL(triggered(bool)), this, SLOT(actionReceiverCREQFramesBytes_triggered(bool)));
    m_ui->action_ReceiverCREQRate->setChecked(true);
    m_receiver_context_menu->addAction(m_ui->action_ReceiverCREQRate);
}
void Singleton::f9();{
    while (m_ui->receivers_detail_sqn_TreeWidget->takeTopLevelItem(0) != NULL)
    {}
    while (m_ui->receivers_detail_reason_TreeWidget->takeTopLevelItem(0) != NULL)
    {}
    m_ui->receivers_detail_transport_Label->setText(QString(" "));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        m_first_frame = frame;
    }
    if (m_flast_frame < frame)
    {
        m_flast_frame = frame;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        m_first_frame = frame;
    }
    if (m_flast_frame < frame)
    {
        m_flast_frame = frame;
}
void Singleton::f2();{
    }
    stream->processPacket(pinfo, stream_info);
void LBMStreamDialogInfo::resetStreams(void)
    LBMStreamMapIterator it = m_streams.begin();
    while (it != m_streams.end())
}
void Singleton::f3();{
    LBMSubstreamMapIterator it;
    for (it = m_substreams.begin(); it != m_substreams.end(); ++it)
    {
        delete *it;
    }
}
void Singleton::f4();{
        void fillItem(gboolean update_only = TRUE);
        QString formatEndpoint(const packet_info * pinfo, const lbm_uim_stream_endpoint_t * endpoint);
        guint64 m_channel;
        QString m_endpoint_a;
        QString m_endpoint_b;
}
void Singleton::f5();{
    if (error_string)
    {
        QMessageBox::critical(this, tr("LBM Stream failed to attach to tap"),
            error_string->str);
        g_string_free(error_string, TRUE);
}
void Singleton::f6();{
LBMStreamDialog::~LBMStreamDialog(void)
    delete m_ui;
    if (m_dialog_info != NULL)
    {
        delete m_dialog_info;
}
void Singleton::f7();{
    private:
        void fillItem(gboolean update_only = TRUE);
        guint64 m_channel;
        guint32 m_substream_id;
        QString m_endpoint_a;
}
void Singleton::f8();{
    if (pinfo->fd->passed_dfilter == 1)
    {
        const lbm_uim_stream_tap_info_t * tapinfo = (const lbm_uim_stream_tap_info_t *)stream_info;
        LBMStreamDialogInfo * info = (LBMStreamDialogInfo *)tap_data;
        info->processPacket(pinfo, tapinfo);
}
void Singleton::f9();{
               .arg(address_to_str(pinfo->pool, &(endpoint->stream_info.dest.addr)))
               .arg(endpoint->stream_info.dest.port);
    }
void LBMStreamEntry::processPacket(const packet_info * pinfo, const lbm_uim_stream_tap_info_t * stream_info)
    LBMSubstreamEntry * substream = NULL;
}
void Singleton::f10();{
    fillItem();
void LBMSubstreamEntry::setItem(QTreeWidgetItem * item)
    m_item = item;
    fillItem(FALSE);
void LBMSubstreamEntry::fillItem(gboolean update_only)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        m_first_frame = frame;
    }
    if (m_flast_frame < frame)
    {
        m_flast_frame = frame;
}
void Singleton::f2();{
    }
    stream->processPacket(pinfo, stream_info);
void LBMStreamDialogInfo::resetStreams(void)
    LBMStreamMapIterator it = m_streams.begin();
    while (it != m_streams.end())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        m_first_frame = frame;
    }
    if (m_flast_frame < frame)
    {
        m_flast_frame = frame;
}
void Singleton::f2();{
    }
    stream->processPacket(pinfo, stream_info);
void LBMStreamDialogInfo::resetStreams(void)
    LBMStreamMapIterator it = m_streams.begin();
    while (it != m_streams.end())
}
void Singleton::f3();{
    LBMSubstreamMapIterator it;
    for (it = m_substreams.begin(); it != m_substreams.end(); ++it)
    {
        delete *it;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        m_first_frame = frame;
    }
    if (m_flast_frame < frame)
    {
        m_flast_frame = frame;
}
void Singleton::f2();{
    }
    stream->processPacket(pinfo, stream_info);
void LBMStreamDialogInfo::resetStreams(void)
    LBMStreamMapIterator it = m_streams.begin();
    while (it != m_streams.end())
}
void Singleton::f3();{
    LBMSubstreamMapIterator it;
    for (it = m_substreams.begin(); it != m_substreams.end(); ++it)
    {
        delete *it;
    }
}
void Singleton::f4();{
        void fillItem(gboolean update_only = TRUE);
        QString formatEndpoint(const packet_info * pinfo, const lbm_uim_stream_endpoint_t * endpoint);
        guint64 m_channel;
        QString m_endpoint_a;
        QString m_endpoint_b;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        m_first_frame = frame;
    }
    if (m_flast_frame < frame)
    {
        m_flast_frame = frame;
}
void Singleton::f2();{
    }
    stream->processPacket(pinfo, stream_info);
void LBMStreamDialogInfo::resetStreams(void)
    LBMStreamMapIterator it = m_streams.begin();
    while (it != m_streams.end())
}
void Singleton::f3();{
    LBMSubstreamMapIterator it;
    for (it = m_substreams.begin(); it != m_substreams.end(); ++it)
    {
        delete *it;
    }
}
void Singleton::f4();{
        void fillItem(gboolean update_only = TRUE);
        QString formatEndpoint(const packet_info * pinfo, const lbm_uim_stream_endpoint_t * endpoint);
        guint64 m_channel;
        QString m_endpoint_a;
        QString m_endpoint_b;
}
void Singleton::f5();{
    if (error_string)
    {
        QMessageBox::critical(this, tr("LBM Stream failed to attach to tap"),
            error_string->str);
        g_string_free(error_string, TRUE);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        m_first_frame = frame;
    }
    if (m_flast_frame < frame)
    {
        m_flast_frame = frame;
}
void Singleton::f2();{
    }
    stream->processPacket(pinfo, stream_info);
void LBMStreamDialogInfo::resetStreams(void)
    LBMStreamMapIterator it = m_streams.begin();
    while (it != m_streams.end())
}
void Singleton::f3();{
    LBMSubstreamMapIterator it;
    for (it = m_substreams.begin(); it != m_substreams.end(); ++it)
    {
        delete *it;
    }
}
void Singleton::f4();{
        void fillItem(gboolean update_only = TRUE);
        QString formatEndpoint(const packet_info * pinfo, const lbm_uim_stream_endpoint_t * endpoint);
        guint64 m_channel;
        QString m_endpoint_a;
        QString m_endpoint_b;
}
void Singleton::f5();{
    if (error_string)
    {
        QMessageBox::critical(this, tr("LBM Stream failed to attach to tap"),
            error_string->str);
        g_string_free(error_string, TRUE);
}
void Singleton::f6();{
LBMStreamDialog::~LBMStreamDialog(void)
    delete m_ui;
    if (m_dialog_info != NULL)
    {
        delete m_dialog_info;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        m_first_frame = frame;
    }
    if (m_flast_frame < frame)
    {
        m_flast_frame = frame;
}
void Singleton::f2();{
    }
    stream->processPacket(pinfo, stream_info);
void LBMStreamDialogInfo::resetStreams(void)
    LBMStreamMapIterator it = m_streams.begin();
    while (it != m_streams.end())
}
void Singleton::f3();{
    LBMSubstreamMapIterator it;
    for (it = m_substreams.begin(); it != m_substreams.end(); ++it)
    {
        delete *it;
    }
}
void Singleton::f4();{
        void fillItem(gboolean update_only = TRUE);
        QString formatEndpoint(const packet_info * pinfo, const lbm_uim_stream_endpoint_t * endpoint);
        guint64 m_channel;
        QString m_endpoint_a;
        QString m_endpoint_b;
}
void Singleton::f5();{
    if (error_string)
    {
        QMessageBox::critical(this, tr("LBM Stream failed to attach to tap"),
            error_string->str);
        g_string_free(error_string, TRUE);
}
void Singleton::f6();{
LBMStreamDialog::~LBMStreamDialog(void)
    delete m_ui;
    if (m_dialog_info != NULL)
    {
        delete m_dialog_info;
}
void Singleton::f7();{
    private:
        void fillItem(gboolean update_only = TRUE);
        guint64 m_channel;
        guint32 m_substream_id;
        QString m_endpoint_a;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        m_first_frame = frame;
    }
    if (m_flast_frame < frame)
    {
        m_flast_frame = frame;
}
void Singleton::f2();{
    }
    stream->processPacket(pinfo, stream_info);
void LBMStreamDialogInfo::resetStreams(void)
    LBMStreamMapIterator it = m_streams.begin();
    while (it != m_streams.end())
}
void Singleton::f3();{
    LBMSubstreamMapIterator it;
    for (it = m_substreams.begin(); it != m_substreams.end(); ++it)
    {
        delete *it;
    }
}
void Singleton::f4();{
        void fillItem(gboolean update_only = TRUE);
        QString formatEndpoint(const packet_info * pinfo, const lbm_uim_stream_endpoint_t * endpoint);
        guint64 m_channel;
        QString m_endpoint_a;
        QString m_endpoint_b;
}
void Singleton::f5();{
    if (error_string)
    {
        QMessageBox::critical(this, tr("LBM Stream failed to attach to tap"),
            error_string->str);
        g_string_free(error_string, TRUE);
}
void Singleton::f6();{
LBMStreamDialog::~LBMStreamDialog(void)
    delete m_ui;
    if (m_dialog_info != NULL)
    {
        delete m_dialog_info;
}
void Singleton::f7();{
    private:
        void fillItem(gboolean update_only = TRUE);
        guint64 m_channel;
        guint32 m_substream_id;
        QString m_endpoint_a;
}
void Singleton::f8();{
    if (pinfo->fd->passed_dfilter == 1)
    {
        const lbm_uim_stream_tap_info_t * tapinfo = (const lbm_uim_stream_tap_info_t *)stream_info;
        LBMStreamDialogInfo * info = (LBMStreamDialogInfo *)tap_data;
        info->processPacket(pinfo, tapinfo);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        m_first_frame = frame;
    }
    if (m_flast_frame < frame)
    {
        m_flast_frame = frame;
}
void Singleton::f2();{
    }
    stream->processPacket(pinfo, stream_info);
void LBMStreamDialogInfo::resetStreams(void)
    LBMStreamMapIterator it = m_streams.begin();
    while (it != m_streams.end())
}
void Singleton::f3();{
    LBMSubstreamMapIterator it;
    for (it = m_substreams.begin(); it != m_substreams.end(); ++it)
    {
        delete *it;
    }
}
void Singleton::f4();{
        void fillItem(gboolean update_only = TRUE);
        QString formatEndpoint(const packet_info * pinfo, const lbm_uim_stream_endpoint_t * endpoint);
        guint64 m_channel;
        QString m_endpoint_a;
        QString m_endpoint_b;
}
void Singleton::f5();{
    if (error_string)
    {
        QMessageBox::critical(this, tr("LBM Stream failed to attach to tap"),
            error_string->str);
        g_string_free(error_string, TRUE);
}
void Singleton::f6();{
LBMStreamDialog::~LBMStreamDialog(void)
    delete m_ui;
    if (m_dialog_info != NULL)
    {
        delete m_dialog_info;
}
void Singleton::f7();{
    private:
        void fillItem(gboolean update_only = TRUE);
        guint64 m_channel;
        guint32 m_substream_id;
        QString m_endpoint_a;
}
void Singleton::f8();{
    if (pinfo->fd->passed_dfilter == 1)
    {
        const lbm_uim_stream_tap_info_t * tapinfo = (const lbm_uim_stream_tap_info_t *)stream_info;
        LBMStreamDialogInfo * info = (LBMStreamDialogInfo *)tap_data;
        info->processPacket(pinfo, tapinfo);
}
void Singleton::f9();{
               .arg(address_to_str(pinfo->pool, &(endpoint->stream_info.dest.addr)))
               .arg(endpoint->stream_info.dest.port);
    }
void LBMStreamEntry::processPacket(const packet_info * pinfo, const lbm_uim_stream_tap_info_t * stream_info)
    LBMSubstreamEntry * substream = NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                break;
            case col_dl_crc_failed_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_retx_:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                break;
            case col_dl_crc_failed_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_retx_:
}
void Singleton::f2();{
class MacUETreeWidgetItem : public QTreeWidgetItem
public:
    MacUETreeWidgetItem(QTreeWidget *parent, const mac_lte_tap_info *mlt_info) :
        QTreeWidgetItem (parent, mac_whole_ue_row_type_),
        rnti_(0),
}
void Singleton::f3();{
                // The rest are numeric
                statsTreeWidget()->setColumnWidth(col, one_em * 4);
                statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
                break;
        }
}
void Singleton::f4();{
    }
    else {
        // Nothing selected yet, but set whole-UE labels.
        statsTreeWidget()->setHeaderLabels(mac_whole_ue_row_labels);
    }
}
void Singleton::f5();{
// Draw current common statistics by regenerating label with current values.
void LteMacStatisticsDialog::drawCommonStats()
    if (!commonStatsCurrent_) {
        QString stats_tables = "<html><head></head><body>\n";
        stats_tables += QString("<table>\n");
}
void Singleton::f6();{
    ws_dlg->clearCommonStats();
//---------------------------------------------------------------------------------------
// Process tap info from a new packet.
// Returns TAP_PACKET_REDRAW if a redraw is needed, TAP_PACKET_DONT_REDRAW otherwise.
tap_packet_status LteMacStatisticsDialog::tapPacket(void *ws_dlg_ptr, struct _packet_info *, epan_dissect *, const void *mac_lte_tap_info_ptr)
}
void Singleton::f7();{
        }
    }
    // Update the UE item with info from tap!
    mac_ue_ti->update(mlt_info);
    return TAP_PACKET_REDRAW;
}
void Singleton::f8();{
        QList<QVariant> row_data;
        // Key fields
        row_data << rnti_ << (type_ == C_RNTI ? QObject::tr("C-RNTI") : QObject::tr("SPS-RNTI")) << ueid_;
        // UL
        row_data << ul_frames_ << ul_bytes_
}
void Singleton::f9();{
            case col_ul_retx_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_frames_:
                statsTreeWidget()->setColumnWidth(col, one_em * 5);
}
void Singleton::f10();{
        if (ti->type() != mac_whole_ue_row_type_) {
            continue;
        }
        // Tell the UE item to draw itself.
        MacUETreeWidgetItem *mac_ue_ti = static_cast<MacUETreeWidgetItem*>(ti);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                break;
            case col_dl_crc_failed_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_retx_:
}
void Singleton::f2();{
class MacUETreeWidgetItem : public QTreeWidgetItem
public:
    MacUETreeWidgetItem(QTreeWidget *parent, const mac_lte_tap_info *mlt_info) :
        QTreeWidgetItem (parent, mac_whole_ue_row_type_),
        rnti_(0),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                break;
            case col_dl_crc_failed_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_retx_:
}
void Singleton::f2();{
class MacUETreeWidgetItem : public QTreeWidgetItem
public:
    MacUETreeWidgetItem(QTreeWidget *parent, const mac_lte_tap_info *mlt_info) :
        QTreeWidgetItem (parent, mac_whole_ue_row_type_),
        rnti_(0),
}
void Singleton::f3();{
                // The rest are numeric
                statsTreeWidget()->setColumnWidth(col, one_em * 4);
                statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
                break;
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                break;
            case col_dl_crc_failed_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_retx_:
}
void Singleton::f2();{
class MacUETreeWidgetItem : public QTreeWidgetItem
public:
    MacUETreeWidgetItem(QTreeWidget *parent, const mac_lte_tap_info *mlt_info) :
        QTreeWidgetItem (parent, mac_whole_ue_row_type_),
        rnti_(0),
}
void Singleton::f3();{
                // The rest are numeric
                statsTreeWidget()->setColumnWidth(col, one_em * 4);
                statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
                break;
        }
}
void Singleton::f4();{
    }
    else {
        // Nothing selected yet, but set whole-UE labels.
        statsTreeWidget()->setHeaderLabels(mac_whole_ue_row_labels);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                break;
            case col_dl_crc_failed_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_retx_:
}
void Singleton::f2();{
class MacUETreeWidgetItem : public QTreeWidgetItem
public:
    MacUETreeWidgetItem(QTreeWidget *parent, const mac_lte_tap_info *mlt_info) :
        QTreeWidgetItem (parent, mac_whole_ue_row_type_),
        rnti_(0),
}
void Singleton::f3();{
                // The rest are numeric
                statsTreeWidget()->setColumnWidth(col, one_em * 4);
                statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
                break;
        }
}
void Singleton::f4();{
    }
    else {
        // Nothing selected yet, but set whole-UE labels.
        statsTreeWidget()->setHeaderLabels(mac_whole_ue_row_labels);
    }
}
void Singleton::f5();{
// Draw current common statistics by regenerating label with current values.
void LteMacStatisticsDialog::drawCommonStats()
    if (!commonStatsCurrent_) {
        QString stats_tables = "<html><head></head><body>\n";
        stats_tables += QString("<table>\n");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                break;
            case col_dl_crc_failed_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_retx_:
}
void Singleton::f2();{
class MacUETreeWidgetItem : public QTreeWidgetItem
public:
    MacUETreeWidgetItem(QTreeWidget *parent, const mac_lte_tap_info *mlt_info) :
        QTreeWidgetItem (parent, mac_whole_ue_row_type_),
        rnti_(0),
}
void Singleton::f3();{
                // The rest are numeric
                statsTreeWidget()->setColumnWidth(col, one_em * 4);
                statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
                break;
        }
}
void Singleton::f4();{
    }
    else {
        // Nothing selected yet, but set whole-UE labels.
        statsTreeWidget()->setHeaderLabels(mac_whole_ue_row_labels);
    }
}
void Singleton::f5();{
// Draw current common statistics by regenerating label with current values.
void LteMacStatisticsDialog::drawCommonStats()
    if (!commonStatsCurrent_) {
        QString stats_tables = "<html><head></head><body>\n";
        stats_tables += QString("<table>\n");
}
void Singleton::f6();{
    ws_dlg->clearCommonStats();
//---------------------------------------------------------------------------------------
// Process tap info from a new packet.
// Returns TAP_PACKET_REDRAW if a redraw is needed, TAP_PACKET_DONT_REDRAW otherwise.
tap_packet_status LteMacStatisticsDialog::tapPacket(void *ws_dlg_ptr, struct _packet_info *, epan_dissect *, const void *mac_lte_tap_info_ptr)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                break;
            case col_dl_crc_failed_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_retx_:
}
void Singleton::f2();{
class MacUETreeWidgetItem : public QTreeWidgetItem
public:
    MacUETreeWidgetItem(QTreeWidget *parent, const mac_lte_tap_info *mlt_info) :
        QTreeWidgetItem (parent, mac_whole_ue_row_type_),
        rnti_(0),
}
void Singleton::f3();{
                // The rest are numeric
                statsTreeWidget()->setColumnWidth(col, one_em * 4);
                statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
                break;
        }
}
void Singleton::f4();{
    }
    else {
        // Nothing selected yet, but set whole-UE labels.
        statsTreeWidget()->setHeaderLabels(mac_whole_ue_row_labels);
    }
}
void Singleton::f5();{
// Draw current common statistics by regenerating label with current values.
void LteMacStatisticsDialog::drawCommonStats()
    if (!commonStatsCurrent_) {
        QString stats_tables = "<html><head></head><body>\n";
        stats_tables += QString("<table>\n");
}
void Singleton::f6();{
    ws_dlg->clearCommonStats();
//---------------------------------------------------------------------------------------
// Process tap info from a new packet.
// Returns TAP_PACKET_REDRAW if a redraw is needed, TAP_PACKET_DONT_REDRAW otherwise.
tap_packet_status LteMacStatisticsDialog::tapPacket(void *ws_dlg_ptr, struct _packet_info *, epan_dissect *, const void *mac_lte_tap_info_ptr)
}
void Singleton::f7();{
        }
    }
    // Update the UE item with info from tap!
    mac_ue_ti->update(mlt_info);
    return TAP_PACKET_REDRAW;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                break;
            case col_dl_crc_failed_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_retx_:
}
void Singleton::f2();{
class MacUETreeWidgetItem : public QTreeWidgetItem
public:
    MacUETreeWidgetItem(QTreeWidget *parent, const mac_lte_tap_info *mlt_info) :
        QTreeWidgetItem (parent, mac_whole_ue_row_type_),
        rnti_(0),
}
void Singleton::f3();{
                // The rest are numeric
                statsTreeWidget()->setColumnWidth(col, one_em * 4);
                statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
                break;
        }
}
void Singleton::f4();{
    }
    else {
        // Nothing selected yet, but set whole-UE labels.
        statsTreeWidget()->setHeaderLabels(mac_whole_ue_row_labels);
    }
}
void Singleton::f5();{
// Draw current common statistics by regenerating label with current values.
void LteMacStatisticsDialog::drawCommonStats()
    if (!commonStatsCurrent_) {
        QString stats_tables = "<html><head></head><body>\n";
        stats_tables += QString("<table>\n");
}
void Singleton::f6();{
    ws_dlg->clearCommonStats();
//---------------------------------------------------------------------------------------
// Process tap info from a new packet.
// Returns TAP_PACKET_REDRAW if a redraw is needed, TAP_PACKET_DONT_REDRAW otherwise.
tap_packet_status LteMacStatisticsDialog::tapPacket(void *ws_dlg_ptr, struct _packet_info *, epan_dissect *, const void *mac_lte_tap_info_ptr)
}
void Singleton::f7();{
        }
    }
    // Update the UE item with info from tap!
    mac_ue_ti->update(mlt_info);
    return TAP_PACKET_REDRAW;
}
void Singleton::f8();{
        QList<QVariant> row_data;
        // Key fields
        row_data << rnti_ << (type_ == C_RNTI ? QObject::tr("C-RNTI") : QObject::tr("SPS-RNTI")) << ueid_;
        // UL
        row_data << ul_frames_ << ul_bytes_
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                break;
            case col_dl_crc_failed_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_retx_:
}
void Singleton::f2();{
class MacUETreeWidgetItem : public QTreeWidgetItem
public:
    MacUETreeWidgetItem(QTreeWidget *parent, const mac_lte_tap_info *mlt_info) :
        QTreeWidgetItem (parent, mac_whole_ue_row_type_),
        rnti_(0),
}
void Singleton::f3();{
                // The rest are numeric
                statsTreeWidget()->setColumnWidth(col, one_em * 4);
                statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
                break;
        }
}
void Singleton::f4();{
    }
    else {
        // Nothing selected yet, but set whole-UE labels.
        statsTreeWidget()->setHeaderLabels(mac_whole_ue_row_labels);
    }
}
void Singleton::f5();{
// Draw current common statistics by regenerating label with current values.
void LteMacStatisticsDialog::drawCommonStats()
    if (!commonStatsCurrent_) {
        QString stats_tables = "<html><head></head><body>\n";
        stats_tables += QString("<table>\n");
}
void Singleton::f6();{
    ws_dlg->clearCommonStats();
//---------------------------------------------------------------------------------------
// Process tap info from a new packet.
// Returns TAP_PACKET_REDRAW if a redraw is needed, TAP_PACKET_DONT_REDRAW otherwise.
tap_packet_status LteMacStatisticsDialog::tapPacket(void *ws_dlg_ptr, struct _packet_info *, epan_dissect *, const void *mac_lte_tap_info_ptr)
}
void Singleton::f7();{
        }
    }
    // Update the UE item with info from tap!
    mac_ue_ti->update(mlt_info);
    return TAP_PACKET_REDRAW;
}
void Singleton::f8();{
        QList<QVariant> row_data;
        // Key fields
        row_data << rnti_ << (type_ == C_RNTI ? QObject::tr("C-RNTI") : QObject::tr("SPS-RNTI")) << ueid_;
        // UL
        row_data << ul_frames_ << ul_bytes_
}
void Singleton::f9();{
            case col_ul_retx_:
                statsTreeWidget()->setColumnWidth(col, one_em * 6);
                break;
            case col_dl_frames_:
                statsTreeWidget()->setColumnWidth(col, one_em * 5);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    QCustomPlot *rp = ui->rlcPlot;
    QCPRange x_range = rp->xAxis->scaleType() == QCPAxis::stLogarithmic ?
                rp->xAxis->range().sanitizedForLogScale() : rp->xAxis->range();
    double pixel_pad = 10.0; // per side
    rp->rescaleAxes(true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    QCustomPlot *rp = ui->rlcPlot;
    QCPRange x_range = rp->xAxis->scaleType() == QCPAxis::stLogarithmic ?
                rp->xAxis->range().sanitizedForLogScale() : rp->xAxis->range();
    double pixel_pad = 10.0; // per side
    rp->rescaleAxes(true);
}
void Singleton::f2();{
        }
        rp->setCursor(QCursor(shape));
    }
    // Trying to let 'hint' grow efficiently.  Still pretty slow for a dense graph...
    QString hint;
}
void Singleton::f3();{
    panAxes(0, 10);
void LteRlcGraphDialog::on_actionMoveUp100_triggered()
    panAxes(0, 100);
void LteRlcGraphDialog::on_actionMoveLeft10_triggered()
    panAxes(-10, 0);
}
void Singleton::f4();{
            ui->hintLabel->setText(hint);
            ui->rlcPlot->replot(QCustomPlot::rpQueuedReplot);
            return;
        }
        tracer_->setVisible(true);
}
void Singleton::f5();{
        sp->graph(i)->setVisible(true);
    }
    // N.B. ssDisc is really too slow. TODO: work out how to turn off aliasing, or experiment
    // with ssCustom.  Other styles tried didn't look right.
    // GTK version was speeded up noticibly by turning down aliasing level...
}
void Singleton::f6();{
                        .arg(zoom_ranges.y() + zoom_ranges.height());
            } else {
                hint += tr("Unable to select range.");
            }
        } else {
}
void Singleton::f7();{
        tracer_->setVisible(true);
        packet_num_ = packet_seg->num;
        // N.B. because tracer only looks up entries in base_graph_,
        // we know that packet_seg will be a data segment, so no need to check
        // iscontrolPDU or isResegmented fields.
}
void Singleton::f8();{
    case Qt::Key_K:
        panAxes(0, pan_pixels);
        break;
    case Qt::Key_Down:
    case Qt::Key_J:
}
void Singleton::f9();{
            zoomYAxis(true);    // lower case y -> Zoom in
        }
        break;
    case Qt::Key_Right:
    case Qt::Key_L:
}
void Singleton::f10();{
    case Qt::Key_Home:
	case Qt::Key_R:
        resetAxes();
        break;
    case Qt::Key_G:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    QCustomPlot *rp = ui->rlcPlot;
    QCPRange x_range = rp->xAxis->scaleType() == QCPAxis::stLogarithmic ?
                rp->xAxis->range().sanitizedForLogScale() : rp->xAxis->range();
    double pixel_pad = 10.0; // per side
    rp->rescaleAxes(true);
}
void Singleton::f2();{
        }
        rp->setCursor(QCursor(shape));
    }
    // Trying to let 'hint' grow efficiently.  Still pretty slow for a dense graph...
    QString hint;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    QCustomPlot *rp = ui->rlcPlot;
    QCPRange x_range = rp->xAxis->scaleType() == QCPAxis::stLogarithmic ?
                rp->xAxis->range().sanitizedForLogScale() : rp->xAxis->range();
    double pixel_pad = 10.0; // per side
    rp->rescaleAxes(true);
}
void Singleton::f2();{
        }
        rp->setCursor(QCursor(shape));
    }
    // Trying to let 'hint' grow efficiently.  Still pretty slow for a dense graph...
    QString hint;
}
void Singleton::f3();{
    panAxes(0, 10);
void LteRlcGraphDialog::on_actionMoveUp100_triggered()
    panAxes(0, 100);
void LteRlcGraphDialog::on_actionMoveLeft10_triggered()
    panAxes(-10, 0);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    QCustomPlot *rp = ui->rlcPlot;
    QCPRange x_range = rp->xAxis->scaleType() == QCPAxis::stLogarithmic ?
                rp->xAxis->range().sanitizedForLogScale() : rp->xAxis->range();
    double pixel_pad = 10.0; // per side
    rp->rescaleAxes(true);
}
void Singleton::f2();{
        }
        rp->setCursor(QCursor(shape));
    }
    // Trying to let 'hint' grow efficiently.  Still pretty slow for a dense graph...
    QString hint;
}
void Singleton::f3();{
    panAxes(0, 10);
void LteRlcGraphDialog::on_actionMoveUp100_triggered()
    panAxes(0, 100);
void LteRlcGraphDialog::on_actionMoveLeft10_triggered()
    panAxes(-10, 0);
}
void Singleton::f4();{
            ui->hintLabel->setText(hint);
            ui->rlcPlot->replot(QCustomPlot::rpQueuedReplot);
            return;
        }
        tracer_->setVisible(true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    QCustomPlot *rp = ui->rlcPlot;
    QCPRange x_range = rp->xAxis->scaleType() == QCPAxis::stLogarithmic ?
                rp->xAxis->range().sanitizedForLogScale() : rp->xAxis->range();
    double pixel_pad = 10.0; // per side
    rp->rescaleAxes(true);
}
void Singleton::f2();{
        }
        rp->setCursor(QCursor(shape));
    }
    // Trying to let 'hint' grow efficiently.  Still pretty slow for a dense graph...
    QString hint;
}
void Singleton::f3();{
    panAxes(0, 10);
void LteRlcGraphDialog::on_actionMoveUp100_triggered()
    panAxes(0, 100);
void LteRlcGraphDialog::on_actionMoveLeft10_triggered()
    panAxes(-10, 0);
}
void Singleton::f4();{
            ui->hintLabel->setText(hint);
            ui->rlcPlot->replot(QCustomPlot::rpQueuedReplot);
            return;
        }
        tracer_->setVisible(true);
}
void Singleton::f5();{
        sp->graph(i)->setVisible(true);
    }
    // N.B. ssDisc is really too slow. TODO: work out how to turn off aliasing, or experiment
    // with ssCustom.  Other styles tried didn't look right.
    // GTK version was speeded up noticibly by turning down aliasing level...
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    QCustomPlot *rp = ui->rlcPlot;
    QCPRange x_range = rp->xAxis->scaleType() == QCPAxis::stLogarithmic ?
                rp->xAxis->range().sanitizedForLogScale() : rp->xAxis->range();
    double pixel_pad = 10.0; // per side
    rp->rescaleAxes(true);
}
void Singleton::f2();{
        }
        rp->setCursor(QCursor(shape));
    }
    // Trying to let 'hint' grow efficiently.  Still pretty slow for a dense graph...
    QString hint;
}
void Singleton::f3();{
    panAxes(0, 10);
void LteRlcGraphDialog::on_actionMoveUp100_triggered()
    panAxes(0, 100);
void LteRlcGraphDialog::on_actionMoveLeft10_triggered()
    panAxes(-10, 0);
}
void Singleton::f4();{
            ui->hintLabel->setText(hint);
            ui->rlcPlot->replot(QCustomPlot::rpQueuedReplot);
            return;
        }
        tracer_->setVisible(true);
}
void Singleton::f5();{
        sp->graph(i)->setVisible(true);
    }
    // N.B. ssDisc is really too slow. TODO: work out how to turn off aliasing, or experiment
    // with ssCustom.  Other styles tried didn't look right.
    // GTK version was speeded up noticibly by turning down aliasing level...
}
void Singleton::f6();{
                        .arg(zoom_ranges.y() + zoom_ranges.height());
            } else {
                hint += tr("Unable to select range.");
            }
        } else {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    QCustomPlot *rp = ui->rlcPlot;
    QCPRange x_range = rp->xAxis->scaleType() == QCPAxis::stLogarithmic ?
                rp->xAxis->range().sanitizedForLogScale() : rp->xAxis->range();
    double pixel_pad = 10.0; // per side
    rp->rescaleAxes(true);
}
void Singleton::f2();{
        }
        rp->setCursor(QCursor(shape));
    }
    // Trying to let 'hint' grow efficiently.  Still pretty slow for a dense graph...
    QString hint;
}
void Singleton::f3();{
    panAxes(0, 10);
void LteRlcGraphDialog::on_actionMoveUp100_triggered()
    panAxes(0, 100);
void LteRlcGraphDialog::on_actionMoveLeft10_triggered()
    panAxes(-10, 0);
}
void Singleton::f4();{
            ui->hintLabel->setText(hint);
            ui->rlcPlot->replot(QCustomPlot::rpQueuedReplot);
            return;
        }
        tracer_->setVisible(true);
}
void Singleton::f5();{
        sp->graph(i)->setVisible(true);
    }
    // N.B. ssDisc is really too slow. TODO: work out how to turn off aliasing, or experiment
    // with ssCustom.  Other styles tried didn't look right.
    // GTK version was speeded up noticibly by turning down aliasing level...
}
void Singleton::f6();{
                        .arg(zoom_ranges.y() + zoom_ranges.height());
            } else {
                hint += tr("Unable to select range.");
            }
        } else {
}
void Singleton::f7();{
        tracer_->setVisible(true);
        packet_num_ = packet_seg->num;
        // N.B. because tracer only looks up entries in base_graph_,
        // we know that packet_seg will be a data segment, so no need to check
        // iscontrolPDU or isResegmented fields.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    QCustomPlot *rp = ui->rlcPlot;
    QCPRange x_range = rp->xAxis->scaleType() == QCPAxis::stLogarithmic ?
                rp->xAxis->range().sanitizedForLogScale() : rp->xAxis->range();
    double pixel_pad = 10.0; // per side
    rp->rescaleAxes(true);
}
void Singleton::f2();{
        }
        rp->setCursor(QCursor(shape));
    }
    // Trying to let 'hint' grow efficiently.  Still pretty slow for a dense graph...
    QString hint;
}
void Singleton::f3();{
    panAxes(0, 10);
void LteRlcGraphDialog::on_actionMoveUp100_triggered()
    panAxes(0, 100);
void LteRlcGraphDialog::on_actionMoveLeft10_triggered()
    panAxes(-10, 0);
}
void Singleton::f4();{
            ui->hintLabel->setText(hint);
            ui->rlcPlot->replot(QCustomPlot::rpQueuedReplot);
            return;
        }
        tracer_->setVisible(true);
}
void Singleton::f5();{
        sp->graph(i)->setVisible(true);
    }
    // N.B. ssDisc is really too slow. TODO: work out how to turn off aliasing, or experiment
    // with ssCustom.  Other styles tried didn't look right.
    // GTK version was speeded up noticibly by turning down aliasing level...
}
void Singleton::f6();{
                        .arg(zoom_ranges.y() + zoom_ranges.height());
            } else {
                hint += tr("Unable to select range.");
            }
        } else {
}
void Singleton::f7();{
        tracer_->setVisible(true);
        packet_num_ = packet_seg->num;
        // N.B. because tracer only looks up entries in base_graph_,
        // we know that packet_seg will be a data segment, so no need to check
        // iscontrolPDU or isResegmented fields.
}
void Singleton::f8();{
    case Qt::Key_K:
        panAxes(0, pan_pixels);
        break;
    case Qt::Key_Down:
    case Qt::Key_J:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    QCustomPlot *rp = ui->rlcPlot;
    QCPRange x_range = rp->xAxis->scaleType() == QCPAxis::stLogarithmic ?
                rp->xAxis->range().sanitizedForLogScale() : rp->xAxis->range();
    double pixel_pad = 10.0; // per side
    rp->rescaleAxes(true);
}
void Singleton::f2();{
        }
        rp->setCursor(QCursor(shape));
    }
    // Trying to let 'hint' grow efficiently.  Still pretty slow for a dense graph...
    QString hint;
}
void Singleton::f3();{
    panAxes(0, 10);
void LteRlcGraphDialog::on_actionMoveUp100_triggered()
    panAxes(0, 100);
void LteRlcGraphDialog::on_actionMoveLeft10_triggered()
    panAxes(-10, 0);
}
void Singleton::f4();{
            ui->hintLabel->setText(hint);
            ui->rlcPlot->replot(QCustomPlot::rpQueuedReplot);
            return;
        }
        tracer_->setVisible(true);
}
void Singleton::f5();{
        sp->graph(i)->setVisible(true);
    }
    // N.B. ssDisc is really too slow. TODO: work out how to turn off aliasing, or experiment
    // with ssCustom.  Other styles tried didn't look right.
    // GTK version was speeded up noticibly by turning down aliasing level...
}
void Singleton::f6();{
                        .arg(zoom_ranges.y() + zoom_ranges.height());
            } else {
                hint += tr("Unable to select range.");
            }
        } else {
}
void Singleton::f7();{
        tracer_->setVisible(true);
        packet_num_ = packet_seg->num;
        // N.B. because tracer only looks up entries in base_graph_,
        // we know that packet_seg will be a data segment, so no need to check
        // iscontrolPDU or isResegmented fields.
}
void Singleton::f8();{
    case Qt::Key_K:
        panAxes(0, pan_pixels);
        break;
    case Qt::Key_Down:
    case Qt::Key_J:
}
void Singleton::f9();{
            zoomYAxis(true);    // lower case y -> Zoom in
        }
        break;
    case Qt::Key_Right:
    case Qt::Key_L:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    QT_TR_NOOP("RLC Statistics"),
    "rlc-lte,stat",
    lte_rlc_statistics_init,
    0,
    NULL
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    QT_TR_NOOP("RLC Statistics"),
    "rlc-lte,stat",
    lte_rlc_statistics_init,
    0,
    NULL
}
void Singleton::f2();{
    verticalLayout()->insertLayout(filter_controls_layout_idx, filter_controls_grid);
    int one_em = fontMetrics().height();
    filter_controls_grid->setColumnMinimumWidth(2, one_em * 2);
    filter_controls_grid->setColumnStretch(2, 1);
    filter_controls_grid->setColumnMinimumWidth(5, one_em * 2);
}
void Singleton::f3();{
                                 stats_.UL_total_bytes)
                 << stats_.UL_total_acks << stats_.UL_total_nacks << stats_.UL_total_missing;
        // DL
        row_data << stats_.DL_frames << stats_.DL_total_bytes
                 << calculate_bw(&stats_.DL_time_start,
}
void Singleton::f4();{
    if (!ue_ti) {
        // Existing UE wasn't found so create a new one.
        ue_ti = new RlcUeTreeWidgetItem(ws_dlg->statsTreeWidget(), rlt_info);
        for (int col = 0; col < ws_dlg->statsTreeWidget()->columnCount(); col++) {
            ue_ti->setTextAlignment(col, ws_dlg->statsTreeWidget()->headerItem()->textAlignment(col));
}
void Singleton::f5();{
        return filter_expr;
    }
    // Accessors (queried for launching graph)
    unsigned get_ueid() const { return ueid_; }
    unsigned get_channelType() const { return channelType_; }
}
void Singleton::f6();{
    guint32  UL_frames;
    guint32  UL_total_bytes;
    nstime_t UL_time_start;
    nstime_t UL_time_stop;
    guint32  UL_total_acks;
}
void Singleton::f7();{
        switch (treeWidget()->sortColumn()) {
            case col_ueid_:
                return ueid_ < other_row->ueid_;
            default:
                break;
}
void Singleton::f8();{
        mode_(mode),
        priority_(0)
    {
        QString mode_str;
        switch (mode_) {
}
void Singleton::f9();{
    WiresharkDialog::captureFileClosing();
// Launch a UL graph for the currently-selected channel.
void LteRlcStatisticsDialog::launchULGraphButtonClicked()
    if (statsTreeWidget()->selectedItems().count() > 0 && statsTreeWidget()->selectedItems()[0]->type() == rlc_channel_row_type_) {
        // Get the channel item.
}
void Singleton::f10();{
    guint32  DL_total_acks;
    guint32  DL_total_nacks;
    guint32  DL_total_missing;
} rlc_ue_stats;
//-------------------------------------------------------------------
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    QT_TR_NOOP("RLC Statistics"),
    "rlc-lte,stat",
    lte_rlc_statistics_init,
    0,
    NULL
}
void Singleton::f2();{
    verticalLayout()->insertLayout(filter_controls_layout_idx, filter_controls_grid);
    int one_em = fontMetrics().height();
    filter_controls_grid->setColumnMinimumWidth(2, one_em * 2);
    filter_controls_grid->setColumnStretch(2, 1);
    filter_controls_grid->setColumnMinimumWidth(5, one_em * 2);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    QT_TR_NOOP("RLC Statistics"),
    "rlc-lte,stat",
    lte_rlc_statistics_init,
    0,
    NULL
}
void Singleton::f2();{
    verticalLayout()->insertLayout(filter_controls_layout_idx, filter_controls_grid);
    int one_em = fontMetrics().height();
    filter_controls_grid->setColumnMinimumWidth(2, one_em * 2);
    filter_controls_grid->setColumnStretch(2, 1);
    filter_controls_grid->setColumnMinimumWidth(5, one_em * 2);
}
void Singleton::f3();{
                                 stats_.UL_total_bytes)
                 << stats_.UL_total_acks << stats_.UL_total_nacks << stats_.UL_total_missing;
        // DL
        row_data << stats_.DL_frames << stats_.DL_total_bytes
                 << calculate_bw(&stats_.DL_time_start,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    QT_TR_NOOP("RLC Statistics"),
    "rlc-lte,stat",
    lte_rlc_statistics_init,
    0,
    NULL
}
void Singleton::f2();{
    verticalLayout()->insertLayout(filter_controls_layout_idx, filter_controls_grid);
    int one_em = fontMetrics().height();
    filter_controls_grid->setColumnMinimumWidth(2, one_em * 2);
    filter_controls_grid->setColumnStretch(2, 1);
    filter_controls_grid->setColumnMinimumWidth(5, one_em * 2);
}
void Singleton::f3();{
                                 stats_.UL_total_bytes)
                 << stats_.UL_total_acks << stats_.UL_total_nacks << stats_.UL_total_missing;
        // DL
        row_data << stats_.DL_frames << stats_.DL_total_bytes
                 << calculate_bw(&stats_.DL_time_start,
}
void Singleton::f4();{
    if (!ue_ti) {
        // Existing UE wasn't found so create a new one.
        ue_ti = new RlcUeTreeWidgetItem(ws_dlg->statsTreeWidget(), rlt_info);
        for (int col = 0; col < ws_dlg->statsTreeWidget()->columnCount(); col++) {
            ue_ti->setTextAlignment(col, ws_dlg->statsTreeWidget()->headerItem()->textAlignment(col));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    QT_TR_NOOP("RLC Statistics"),
    "rlc-lte,stat",
    lte_rlc_statistics_init,
    0,
    NULL
}
void Singleton::f2();{
    verticalLayout()->insertLayout(filter_controls_layout_idx, filter_controls_grid);
    int one_em = fontMetrics().height();
    filter_controls_grid->setColumnMinimumWidth(2, one_em * 2);
    filter_controls_grid->setColumnStretch(2, 1);
    filter_controls_grid->setColumnMinimumWidth(5, one_em * 2);
}
void Singleton::f3();{
                                 stats_.UL_total_bytes)
                 << stats_.UL_total_acks << stats_.UL_total_nacks << stats_.UL_total_missing;
        // DL
        row_data << stats_.DL_frames << stats_.DL_total_bytes
                 << calculate_bw(&stats_.DL_time_start,
}
void Singleton::f4();{
    if (!ue_ti) {
        // Existing UE wasn't found so create a new one.
        ue_ti = new RlcUeTreeWidgetItem(ws_dlg->statsTreeWidget(), rlt_info);
        for (int col = 0; col < ws_dlg->statsTreeWidget()->columnCount(); col++) {
            ue_ti->setTextAlignment(col, ws_dlg->statsTreeWidget()->headerItem()->textAlignment(col));
}
void Singleton::f5();{
        return filter_expr;
    }
    // Accessors (queried for launching graph)
    unsigned get_ueid() const { return ueid_; }
    unsigned get_channelType() const { return channelType_; }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    QT_TR_NOOP("RLC Statistics"),
    "rlc-lte,stat",
    lte_rlc_statistics_init,
    0,
    NULL
}
void Singleton::f2();{
    verticalLayout()->insertLayout(filter_controls_layout_idx, filter_controls_grid);
    int one_em = fontMetrics().height();
    filter_controls_grid->setColumnMinimumWidth(2, one_em * 2);
    filter_controls_grid->setColumnStretch(2, 1);
    filter_controls_grid->setColumnMinimumWidth(5, one_em * 2);
}
void Singleton::f3();{
                                 stats_.UL_total_bytes)
                 << stats_.UL_total_acks << stats_.UL_total_nacks << stats_.UL_total_missing;
        // DL
        row_data << stats_.DL_frames << stats_.DL_total_bytes
                 << calculate_bw(&stats_.DL_time_start,
}
void Singleton::f4();{
    if (!ue_ti) {
        // Existing UE wasn't found so create a new one.
        ue_ti = new RlcUeTreeWidgetItem(ws_dlg->statsTreeWidget(), rlt_info);
        for (int col = 0; col < ws_dlg->statsTreeWidget()->columnCount(); col++) {
            ue_ti->setTextAlignment(col, ws_dlg->statsTreeWidget()->headerItem()->textAlignment(col));
}
void Singleton::f5();{
        return filter_expr;
    }
    // Accessors (queried for launching graph)
    unsigned get_ueid() const { return ueid_; }
    unsigned get_channelType() const { return channelType_; }
}
void Singleton::f6();{
    guint32  UL_frames;
    guint32  UL_total_bytes;
    nstime_t UL_time_start;
    nstime_t UL_time_stop;
    guint32  UL_total_acks;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    QT_TR_NOOP("RLC Statistics"),
    "rlc-lte,stat",
    lte_rlc_statistics_init,
    0,
    NULL
}
void Singleton::f2();{
    verticalLayout()->insertLayout(filter_controls_layout_idx, filter_controls_grid);
    int one_em = fontMetrics().height();
    filter_controls_grid->setColumnMinimumWidth(2, one_em * 2);
    filter_controls_grid->setColumnStretch(2, 1);
    filter_controls_grid->setColumnMinimumWidth(5, one_em * 2);
}
void Singleton::f3();{
                                 stats_.UL_total_bytes)
                 << stats_.UL_total_acks << stats_.UL_total_nacks << stats_.UL_total_missing;
        // DL
        row_data << stats_.DL_frames << stats_.DL_total_bytes
                 << calculate_bw(&stats_.DL_time_start,
}
void Singleton::f4();{
    if (!ue_ti) {
        // Existing UE wasn't found so create a new one.
        ue_ti = new RlcUeTreeWidgetItem(ws_dlg->statsTreeWidget(), rlt_info);
        for (int col = 0; col < ws_dlg->statsTreeWidget()->columnCount(); col++) {
            ue_ti->setTextAlignment(col, ws_dlg->statsTreeWidget()->headerItem()->textAlignment(col));
}
void Singleton::f5();{
        return filter_expr;
    }
    // Accessors (queried for launching graph)
    unsigned get_ueid() const { return ueid_; }
    unsigned get_channelType() const { return channelType_; }
}
void Singleton::f6();{
    guint32  UL_frames;
    guint32  UL_total_bytes;
    nstime_t UL_time_start;
    nstime_t UL_time_stop;
    guint32  UL_total_acks;
}
void Singleton::f7();{
        switch (treeWidget()->sortColumn()) {
            case col_ueid_:
                return ueid_ < other_row->ueid_;
            default:
                break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    QT_TR_NOOP("RLC Statistics"),
    "rlc-lte,stat",
    lte_rlc_statistics_init,
    0,
    NULL
}
void Singleton::f2();{
    verticalLayout()->insertLayout(filter_controls_layout_idx, filter_controls_grid);
    int one_em = fontMetrics().height();
    filter_controls_grid->setColumnMinimumWidth(2, one_em * 2);
    filter_controls_grid->setColumnStretch(2, 1);
    filter_controls_grid->setColumnMinimumWidth(5, one_em * 2);
}
void Singleton::f3();{
                                 stats_.UL_total_bytes)
                 << stats_.UL_total_acks << stats_.UL_total_nacks << stats_.UL_total_missing;
        // DL
        row_data << stats_.DL_frames << stats_.DL_total_bytes
                 << calculate_bw(&stats_.DL_time_start,
}
void Singleton::f4();{
    if (!ue_ti) {
        // Existing UE wasn't found so create a new one.
        ue_ti = new RlcUeTreeWidgetItem(ws_dlg->statsTreeWidget(), rlt_info);
        for (int col = 0; col < ws_dlg->statsTreeWidget()->columnCount(); col++) {
            ue_ti->setTextAlignment(col, ws_dlg->statsTreeWidget()->headerItem()->textAlignment(col));
}
void Singleton::f5();{
        return filter_expr;
    }
    // Accessors (queried for launching graph)
    unsigned get_ueid() const { return ueid_; }
    unsigned get_channelType() const { return channelType_; }
}
void Singleton::f6();{
    guint32  UL_frames;
    guint32  UL_total_bytes;
    nstime_t UL_time_start;
    nstime_t UL_time_stop;
    guint32  UL_total_acks;
}
void Singleton::f7();{
        switch (treeWidget()->sortColumn()) {
            case col_ueid_:
                return ueid_ < other_row->ueid_;
            default:
                break;
}
void Singleton::f8();{
        mode_(mode),
        priority_(0)
    {
        QString mode_str;
        switch (mode_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    QT_TR_NOOP("RLC Statistics"),
    "rlc-lte,stat",
    lte_rlc_statistics_init,
    0,
    NULL
}
void Singleton::f2();{
    verticalLayout()->insertLayout(filter_controls_layout_idx, filter_controls_grid);
    int one_em = fontMetrics().height();
    filter_controls_grid->setColumnMinimumWidth(2, one_em * 2);
    filter_controls_grid->setColumnStretch(2, 1);
    filter_controls_grid->setColumnMinimumWidth(5, one_em * 2);
}
void Singleton::f3();{
                                 stats_.UL_total_bytes)
                 << stats_.UL_total_acks << stats_.UL_total_nacks << stats_.UL_total_missing;
        // DL
        row_data << stats_.DL_frames << stats_.DL_total_bytes
                 << calculate_bw(&stats_.DL_time_start,
}
void Singleton::f4();{
    if (!ue_ti) {
        // Existing UE wasn't found so create a new one.
        ue_ti = new RlcUeTreeWidgetItem(ws_dlg->statsTreeWidget(), rlt_info);
        for (int col = 0; col < ws_dlg->statsTreeWidget()->columnCount(); col++) {
            ue_ti->setTextAlignment(col, ws_dlg->statsTreeWidget()->headerItem()->textAlignment(col));
}
void Singleton::f5();{
        return filter_expr;
    }
    // Accessors (queried for launching graph)
    unsigned get_ueid() const { return ueid_; }
    unsigned get_channelType() const { return channelType_; }
}
void Singleton::f6();{
    guint32  UL_frames;
    guint32  UL_total_bytes;
    nstime_t UL_time_start;
    nstime_t UL_time_stop;
    guint32  UL_total_acks;
}
void Singleton::f7();{
        switch (treeWidget()->sortColumn()) {
            case col_ueid_:
                return ueid_ < other_row->ueid_;
            default:
                break;
}
void Singleton::f8();{
        mode_(mode),
        priority_(0)
    {
        QString mode_str;
        switch (mode_) {
}
void Singleton::f9();{
    WiresharkDialog::captureFileClosing();
// Launch a UL graph for the currently-selected channel.
void LteRlcStatisticsDialog::launchULGraphButtonClicked()
    if (statsTreeWidget()->selectedItems().count() > 0 && statsTreeWidget()->selectedItems()[0]->type() == rlc_channel_row_type_) {
        // Get the channel item.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
        break;
    case AIRPCAP_DLL_ERROR:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_ERROR\n");
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
        break;
    case AIRPCAP_DLL_ERROR:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_ERROR\n");
        break;
}
void Singleton::f2();{
    // https://doc.qt.io/qt-5/highdpi.html
    // https://bugreports.qt.io/browse/QTBUG-53022 - The device pixel ratio is pretty much bogus on Windows.
    // https://bugreports.qt.io/browse/QTBUG-55510 - Windows have wrong size
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    /* Create The Wireshark app */
}
void Singleton::f3();{
    /* Register all dissectors; we must do this before checking for the
       "-G" flag, as the "-G" flag dumps information registered by the
       dissectors, and we must do it before we read the preferences, in
       case any dissectors register preferences. */
    if (!epan_init(splash_update, NULL, TRUE)) {
}
void Singleton::f4();{
      wsApp->setLastOpenDir(recent.gui_fileopen_remembered_dir);
    } else {
      wsApp->setLastOpenDir(get_persdatafile_dir());
    }
    set_console_log_handler();
}
void Singleton::f5();{
            if (capture_start(&global_capture_opts, main_w->captureSession(), main_w->captureInfoData(), main_window_update)) {
                /* The capture started.  Open stat windows; we do so after creating
                   the main window, to avoid GTK warnings, and after successfully
                   opening the capture file, so we know we have something to compute
                   stats on, and after registering all dissectors, so that MATE will
}
void Singleton::f6();{
            g_string_append(str, ", with mixed DPI");
        } else {
            g_string_append(str, ", without HiDPI");
        }
    }
}
void Singleton::f7();{
// - You install Wireshark that was built on a machine with Qt version
//   5.x.z installed in the default location.
// Qt5Core.dll will load qwindows.dll from your local C:\Qt\5.x\...\plugins
// directory. This may not be compatible with qwindows.dll from that
// same path on the build machine. At any rate, loading DLLs from paths
}
void Singleton::f8();{
    QCoreApplication::addLibraryPath(app_path);
/* And now our feature presentation... [ fade to music ] */
int main(int argc, char *qt_argv[])
    MainWindow *main_w;
    LPWSTR              *wc_argv;
}
void Singleton::f9();{
    /*
     * XXX - Maybe we need to warn the user if one of the following happens???
     */
    case AIRPCAP_DLL_OLD:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
}
void Singleton::f10();{
    g_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_INFO, "Calling module preferences, elapsed time %" G_GUINT64_FORMAT " us \n", g_get_monotonic_time() - start_time);
    global_commandline_info.prefs_p = ws_app.readConfigurationFiles(false);
    /* Now get our args */
    commandline_other_options(argc, argv, TRUE);
    /* Convert some command-line parameters to QStrings */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
        break;
    case AIRPCAP_DLL_ERROR:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_ERROR\n");
        break;
}
void Singleton::f2();{
    // https://doc.qt.io/qt-5/highdpi.html
    // https://bugreports.qt.io/browse/QTBUG-53022 - The device pixel ratio is pretty much bogus on Windows.
    // https://bugreports.qt.io/browse/QTBUG-55510 - Windows have wrong size
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    /* Create The Wireshark app */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
        break;
    case AIRPCAP_DLL_ERROR:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_ERROR\n");
        break;
}
void Singleton::f2();{
    // https://doc.qt.io/qt-5/highdpi.html
    // https://bugreports.qt.io/browse/QTBUG-53022 - The device pixel ratio is pretty much bogus on Windows.
    // https://bugreports.qt.io/browse/QTBUG-55510 - Windows have wrong size
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    /* Create The Wireshark app */
}
void Singleton::f3();{
    /* Register all dissectors; we must do this before checking for the
       "-G" flag, as the "-G" flag dumps information registered by the
       dissectors, and we must do it before we read the preferences, in
       case any dissectors register preferences. */
    if (!epan_init(splash_update, NULL, TRUE)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
        break;
    case AIRPCAP_DLL_ERROR:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_ERROR\n");
        break;
}
void Singleton::f2();{
    // https://doc.qt.io/qt-5/highdpi.html
    // https://bugreports.qt.io/browse/QTBUG-53022 - The device pixel ratio is pretty much bogus on Windows.
    // https://bugreports.qt.io/browse/QTBUG-55510 - Windows have wrong size
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    /* Create The Wireshark app */
}
void Singleton::f3();{
    /* Register all dissectors; we must do this before checking for the
       "-G" flag, as the "-G" flag dumps information registered by the
       dissectors, and we must do it before we read the preferences, in
       case any dissectors register preferences. */
    if (!epan_init(splash_update, NULL, TRUE)) {
}
void Singleton::f4();{
      wsApp->setLastOpenDir(recent.gui_fileopen_remembered_dir);
    } else {
      wsApp->setLastOpenDir(get_persdatafile_dir());
    }
    set_console_log_handler();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
        break;
    case AIRPCAP_DLL_ERROR:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_ERROR\n");
        break;
}
void Singleton::f2();{
    // https://doc.qt.io/qt-5/highdpi.html
    // https://bugreports.qt.io/browse/QTBUG-53022 - The device pixel ratio is pretty much bogus on Windows.
    // https://bugreports.qt.io/browse/QTBUG-55510 - Windows have wrong size
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    /* Create The Wireshark app */
}
void Singleton::f3();{
    /* Register all dissectors; we must do this before checking for the
       "-G" flag, as the "-G" flag dumps information registered by the
       dissectors, and we must do it before we read the preferences, in
       case any dissectors register preferences. */
    if (!epan_init(splash_update, NULL, TRUE)) {
}
void Singleton::f4();{
      wsApp->setLastOpenDir(recent.gui_fileopen_remembered_dir);
    } else {
      wsApp->setLastOpenDir(get_persdatafile_dir());
    }
    set_console_log_handler();
}
void Singleton::f5();{
            if (capture_start(&global_capture_opts, main_w->captureSession(), main_w->captureInfoData(), main_window_update)) {
                /* The capture started.  Open stat windows; we do so after creating
                   the main window, to avoid GTK warnings, and after successfully
                   opening the capture file, so we know we have something to compute
                   stats on, and after registering all dissectors, so that MATE will
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
        break;
    case AIRPCAP_DLL_ERROR:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_ERROR\n");
        break;
}
void Singleton::f2();{
    // https://doc.qt.io/qt-5/highdpi.html
    // https://bugreports.qt.io/browse/QTBUG-53022 - The device pixel ratio is pretty much bogus on Windows.
    // https://bugreports.qt.io/browse/QTBUG-55510 - Windows have wrong size
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    /* Create The Wireshark app */
}
void Singleton::f3();{
    /* Register all dissectors; we must do this before checking for the
       "-G" flag, as the "-G" flag dumps information registered by the
       dissectors, and we must do it before we read the preferences, in
       case any dissectors register preferences. */
    if (!epan_init(splash_update, NULL, TRUE)) {
}
void Singleton::f4();{
      wsApp->setLastOpenDir(recent.gui_fileopen_remembered_dir);
    } else {
      wsApp->setLastOpenDir(get_persdatafile_dir());
    }
    set_console_log_handler();
}
void Singleton::f5();{
            if (capture_start(&global_capture_opts, main_w->captureSession(), main_w->captureInfoData(), main_window_update)) {
                /* The capture started.  Open stat windows; we do so after creating
                   the main window, to avoid GTK warnings, and after successfully
                   opening the capture file, so we know we have something to compute
                   stats on, and after registering all dissectors, so that MATE will
}
void Singleton::f6();{
            g_string_append(str, ", with mixed DPI");
        } else {
            g_string_append(str, ", without HiDPI");
        }
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
        break;
    case AIRPCAP_DLL_ERROR:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_ERROR\n");
        break;
}
void Singleton::f2();{
    // https://doc.qt.io/qt-5/highdpi.html
    // https://bugreports.qt.io/browse/QTBUG-53022 - The device pixel ratio is pretty much bogus on Windows.
    // https://bugreports.qt.io/browse/QTBUG-55510 - Windows have wrong size
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    /* Create The Wireshark app */
}
void Singleton::f3();{
    /* Register all dissectors; we must do this before checking for the
       "-G" flag, as the "-G" flag dumps information registered by the
       dissectors, and we must do it before we read the preferences, in
       case any dissectors register preferences. */
    if (!epan_init(splash_update, NULL, TRUE)) {
}
void Singleton::f4();{
      wsApp->setLastOpenDir(recent.gui_fileopen_remembered_dir);
    } else {
      wsApp->setLastOpenDir(get_persdatafile_dir());
    }
    set_console_log_handler();
}
void Singleton::f5();{
            if (capture_start(&global_capture_opts, main_w->captureSession(), main_w->captureInfoData(), main_window_update)) {
                /* The capture started.  Open stat windows; we do so after creating
                   the main window, to avoid GTK warnings, and after successfully
                   opening the capture file, so we know we have something to compute
                   stats on, and after registering all dissectors, so that MATE will
}
void Singleton::f6();{
            g_string_append(str, ", with mixed DPI");
        } else {
            g_string_append(str, ", without HiDPI");
        }
    }
}
void Singleton::f7();{
// - You install Wireshark that was built on a machine with Qt version
//   5.x.z installed in the default location.
// Qt5Core.dll will load qwindows.dll from your local C:\Qt\5.x\...\plugins
// directory. This may not be compatible with qwindows.dll from that
// same path on the build machine. At any rate, loading DLLs from paths
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
        break;
    case AIRPCAP_DLL_ERROR:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_ERROR\n");
        break;
}
void Singleton::f2();{
    // https://doc.qt.io/qt-5/highdpi.html
    // https://bugreports.qt.io/browse/QTBUG-53022 - The device pixel ratio is pretty much bogus on Windows.
    // https://bugreports.qt.io/browse/QTBUG-55510 - Windows have wrong size
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    /* Create The Wireshark app */
}
void Singleton::f3();{
    /* Register all dissectors; we must do this before checking for the
       "-G" flag, as the "-G" flag dumps information registered by the
       dissectors, and we must do it before we read the preferences, in
       case any dissectors register preferences. */
    if (!epan_init(splash_update, NULL, TRUE)) {
}
void Singleton::f4();{
      wsApp->setLastOpenDir(recent.gui_fileopen_remembered_dir);
    } else {
      wsApp->setLastOpenDir(get_persdatafile_dir());
    }
    set_console_log_handler();
}
void Singleton::f5();{
            if (capture_start(&global_capture_opts, main_w->captureSession(), main_w->captureInfoData(), main_window_update)) {
                /* The capture started.  Open stat windows; we do so after creating
                   the main window, to avoid GTK warnings, and after successfully
                   opening the capture file, so we know we have something to compute
                   stats on, and after registering all dissectors, so that MATE will
}
void Singleton::f6();{
            g_string_append(str, ", with mixed DPI");
        } else {
            g_string_append(str, ", without HiDPI");
        }
    }
}
void Singleton::f7();{
// - You install Wireshark that was built on a machine with Qt version
//   5.x.z installed in the default location.
// Qt5Core.dll will load qwindows.dll from your local C:\Qt\5.x\...\plugins
// directory. This may not be compatible with qwindows.dll from that
// same path on the build machine. At any rate, loading DLLs from paths
}
void Singleton::f8();{
    QCoreApplication::addLibraryPath(app_path);
/* And now our feature presentation... [ fade to music ] */
int main(int argc, char *qt_argv[])
    MainWindow *main_w;
    LPWSTR              *wc_argv;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
        break;
    case AIRPCAP_DLL_ERROR:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_ERROR\n");
        break;
}
void Singleton::f2();{
    // https://doc.qt.io/qt-5/highdpi.html
    // https://bugreports.qt.io/browse/QTBUG-53022 - The device pixel ratio is pretty much bogus on Windows.
    // https://bugreports.qt.io/browse/QTBUG-55510 - Windows have wrong size
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    /* Create The Wireshark app */
}
void Singleton::f3();{
    /* Register all dissectors; we must do this before checking for the
       "-G" flag, as the "-G" flag dumps information registered by the
       dissectors, and we must do it before we read the preferences, in
       case any dissectors register preferences. */
    if (!epan_init(splash_update, NULL, TRUE)) {
}
void Singleton::f4();{
      wsApp->setLastOpenDir(recent.gui_fileopen_remembered_dir);
    } else {
      wsApp->setLastOpenDir(get_persdatafile_dir());
    }
    set_console_log_handler();
}
void Singleton::f5();{
            if (capture_start(&global_capture_opts, main_w->captureSession(), main_w->captureInfoData(), main_window_update)) {
                /* The capture started.  Open stat windows; we do so after creating
                   the main window, to avoid GTK warnings, and after successfully
                   opening the capture file, so we know we have something to compute
                   stats on, and after registering all dissectors, so that MATE will
}
void Singleton::f6();{
            g_string_append(str, ", with mixed DPI");
        } else {
            g_string_append(str, ", without HiDPI");
        }
    }
}
void Singleton::f7();{
// - You install Wireshark that was built on a machine with Qt version
//   5.x.z installed in the default location.
// Qt5Core.dll will load qwindows.dll from your local C:\Qt\5.x\...\plugins
// directory. This may not be compatible with qwindows.dll from that
// same path on the build machine. At any rate, loading DLLs from paths
}
void Singleton::f8();{
    QCoreApplication::addLibraryPath(app_path);
/* And now our feature presentation... [ fade to music ] */
int main(int argc, char *qt_argv[])
    MainWindow *main_w;
    LPWSTR              *wc_argv;
}
void Singleton::f9();{
    /*
     * XXX - Maybe we need to warn the user if one of the following happens???
     */
    case AIRPCAP_DLL_OLD:
        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s","AIRPCAP_DLL_OLD\n");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    profile_menu_.addActions(global.actions());
    if (button == Qt::LeftButton) {
        profile_menu_.exec(global_pos);
    } else {
        bool enable_edit = false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    profile_menu_.addActions(global.actions());
    if (button == Qt::LeftButton) {
        profile_menu_.exec(global_pos);
    } else {
        bool enable_edit = false;
}
void Singleton::f2();{
    splitter->addWidget(info_progress);
    splitter->addWidget(&packet_status_);
    splitter->addWidget(&profile_status_);
    splitter->setStretchFactor(0, 3);
    splitter->setStretchFactor(1, 3);
}
void Singleton::f3();{
        if (! idx.data(ProfileModel::DATA_IS_DEFAULT).toBool() && ! idx.data(ProfileModel::DATA_IS_GLOBAL).toBool())
            enable_edit = true;
        profile_menu_.setTitle(tr("Switch to"));
        QMenu ctx_menu_;
        QAction * action = ctx_menu_.addAction(tr("Manage Profiles" UTF8_HORIZONTAL_ELLIPSIS), this, SLOT(manageProfile()));
}
void Singleton::f4();{
    // We might have to switch to a QPushButton.
    QString stock_name = "x-expert-";
    QString tt_text = tr(" is the highest expert information level");
    switch(expert_get_highest_severity()) {
    case(PI_ERROR):
}
void Singleton::f5();{
    ready_msg_(tr("Ready to load or capture")),
    ready_msg_(tr("Ready to load file")),
    cs_fixed_(false),
    cs_count_(0)
    QSplitter *splitter = new QSplitter(this);
}
void Singleton::f6();{
        expertUpdate();
void MainStatusBar::popGenericStatus(StatusContext status)
    LabelStack * stack = &info_status_;
    if (status == STATUS_CTX_MAIN)
        stack = &packet_status_;
}
void Singleton::f7();{
    else
        stack->pushText(message, status);
    stack->setToolTip(messagetip);
    if (status == STATUS_CTX_FILTER || status == STATUS_CTX_FILE)
        expertUpdate();
}
void Singleton::f8();{
    {
        if (hInfo.description.length() > 0) {
            item_info.append(hInfo.description);
        } else {
            item_info.append(hInfo.name);
}
void Singleton::f9();{
            if (cap_file_->packet_comment_count > 0) {
                packets_str.append(QString(tr(" %1 Comments: %2"))
                    .arg(UTF8_MIDDLE_DOT)
                    .arg(cap_file_->packet_comment_count));
            }
}
void Singleton::f10();{
                                   .arg(UTF8_MIDDLE_DOT));
            }
            packets_str.append(QString(tr("Packets: %1"))
                               .arg(cs_count_));
        } else if (cs_count_ > 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    profile_menu_.addActions(global.actions());
    if (button == Qt::LeftButton) {
        profile_menu_.exec(global_pos);
    } else {
        bool enable_edit = false;
}
void Singleton::f2();{
    splitter->addWidget(info_progress);
    splitter->addWidget(&packet_status_);
    splitter->addWidget(&profile_status_);
    splitter->setStretchFactor(0, 3);
    splitter->setStretchFactor(1, 3);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    profile_menu_.addActions(global.actions());
    if (button == Qt::LeftButton) {
        profile_menu_.exec(global_pos);
    } else {
        bool enable_edit = false;
}
void Singleton::f2();{
    splitter->addWidget(info_progress);
    splitter->addWidget(&packet_status_);
    splitter->addWidget(&profile_status_);
    splitter->setStretchFactor(0, 3);
    splitter->setStretchFactor(1, 3);
}
void Singleton::f3();{
        if (! idx.data(ProfileModel::DATA_IS_DEFAULT).toBool() && ! idx.data(ProfileModel::DATA_IS_GLOBAL).toBool())
            enable_edit = true;
        profile_menu_.setTitle(tr("Switch to"));
        QMenu ctx_menu_;
        QAction * action = ctx_menu_.addAction(tr("Manage Profiles" UTF8_HORIZONTAL_ELLIPSIS), this, SLOT(manageProfile()));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    profile_menu_.addActions(global.actions());
    if (button == Qt::LeftButton) {
        profile_menu_.exec(global_pos);
    } else {
        bool enable_edit = false;
}
void Singleton::f2();{
    splitter->addWidget(info_progress);
    splitter->addWidget(&packet_status_);
    splitter->addWidget(&profile_status_);
    splitter->setStretchFactor(0, 3);
    splitter->setStretchFactor(1, 3);
}
void Singleton::f3();{
        if (! idx.data(ProfileModel::DATA_IS_DEFAULT).toBool() && ! idx.data(ProfileModel::DATA_IS_GLOBAL).toBool())
            enable_edit = true;
        profile_menu_.setTitle(tr("Switch to"));
        QMenu ctx_menu_;
        QAction * action = ctx_menu_.addAction(tr("Manage Profiles" UTF8_HORIZONTAL_ELLIPSIS), this, SLOT(manageProfile()));
}
void Singleton::f4();{
    // We might have to switch to a QPushButton.
    QString stock_name = "x-expert-";
    QString tt_text = tr(" is the highest expert information level");
    switch(expert_get_highest_severity()) {
    case(PI_ERROR):
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    profile_menu_.addActions(global.actions());
    if (button == Qt::LeftButton) {
        profile_menu_.exec(global_pos);
    } else {
        bool enable_edit = false;
}
void Singleton::f2();{
    splitter->addWidget(info_progress);
    splitter->addWidget(&packet_status_);
    splitter->addWidget(&profile_status_);
    splitter->setStretchFactor(0, 3);
    splitter->setStretchFactor(1, 3);
}
void Singleton::f3();{
        if (! idx.data(ProfileModel::DATA_IS_DEFAULT).toBool() && ! idx.data(ProfileModel::DATA_IS_GLOBAL).toBool())
            enable_edit = true;
        profile_menu_.setTitle(tr("Switch to"));
        QMenu ctx_menu_;
        QAction * action = ctx_menu_.addAction(tr("Manage Profiles" UTF8_HORIZONTAL_ELLIPSIS), this, SLOT(manageProfile()));
}
void Singleton::f4();{
    // We might have to switch to a QPushButton.
    QString stock_name = "x-expert-";
    QString tt_text = tr(" is the highest expert information level");
    switch(expert_get_highest_severity()) {
    case(PI_ERROR):
}
void Singleton::f5();{
    ready_msg_(tr("Ready to load or capture")),
    ready_msg_(tr("Ready to load file")),
    cs_fixed_(false),
    cs_count_(0)
    QSplitter *splitter = new QSplitter(this);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    profile_menu_.addActions(global.actions());
    if (button == Qt::LeftButton) {
        profile_menu_.exec(global_pos);
    } else {
        bool enable_edit = false;
}
void Singleton::f2();{
    splitter->addWidget(info_progress);
    splitter->addWidget(&packet_status_);
    splitter->addWidget(&profile_status_);
    splitter->setStretchFactor(0, 3);
    splitter->setStretchFactor(1, 3);
}
void Singleton::f3();{
        if (! idx.data(ProfileModel::DATA_IS_DEFAULT).toBool() && ! idx.data(ProfileModel::DATA_IS_GLOBAL).toBool())
            enable_edit = true;
        profile_menu_.setTitle(tr("Switch to"));
        QMenu ctx_menu_;
        QAction * action = ctx_menu_.addAction(tr("Manage Profiles" UTF8_HORIZONTAL_ELLIPSIS), this, SLOT(manageProfile()));
}
void Singleton::f4();{
    // We might have to switch to a QPushButton.
    QString stock_name = "x-expert-";
    QString tt_text = tr(" is the highest expert information level");
    switch(expert_get_highest_severity()) {
    case(PI_ERROR):
}
void Singleton::f5();{
    ready_msg_(tr("Ready to load or capture")),
    ready_msg_(tr("Ready to load file")),
    cs_fixed_(false),
    cs_count_(0)
    QSplitter *splitter = new QSplitter(this);
}
void Singleton::f6();{
        expertUpdate();
void MainStatusBar::popGenericStatus(StatusContext status)
    LabelStack * stack = &info_status_;
    if (status == STATUS_CTX_MAIN)
        stack = &packet_status_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    profile_menu_.addActions(global.actions());
    if (button == Qt::LeftButton) {
        profile_menu_.exec(global_pos);
    } else {
        bool enable_edit = false;
}
void Singleton::f2();{
    splitter->addWidget(info_progress);
    splitter->addWidget(&packet_status_);
    splitter->addWidget(&profile_status_);
    splitter->setStretchFactor(0, 3);
    splitter->setStretchFactor(1, 3);
}
void Singleton::f3();{
        if (! idx.data(ProfileModel::DATA_IS_DEFAULT).toBool() && ! idx.data(ProfileModel::DATA_IS_GLOBAL).toBool())
            enable_edit = true;
        profile_menu_.setTitle(tr("Switch to"));
        QMenu ctx_menu_;
        QAction * action = ctx_menu_.addAction(tr("Manage Profiles" UTF8_HORIZONTAL_ELLIPSIS), this, SLOT(manageProfile()));
}
void Singleton::f4();{
    // We might have to switch to a QPushButton.
    QString stock_name = "x-expert-";
    QString tt_text = tr(" is the highest expert information level");
    switch(expert_get_highest_severity()) {
    case(PI_ERROR):
}
void Singleton::f5();{
    ready_msg_(tr("Ready to load or capture")),
    ready_msg_(tr("Ready to load file")),
    cs_fixed_(false),
    cs_count_(0)
    QSplitter *splitter = new QSplitter(this);
}
void Singleton::f6();{
        expertUpdate();
void MainStatusBar::popGenericStatus(StatusContext status)
    LabelStack * stack = &info_status_;
    if (status == STATUS_CTX_MAIN)
        stack = &packet_status_;
}
void Singleton::f7();{
    else
        stack->pushText(message, status);
    stack->setToolTip(messagetip);
    if (status == STATUS_CTX_FILTER || status == STATUS_CTX_FILE)
        expertUpdate();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    profile_menu_.addActions(global.actions());
    if (button == Qt::LeftButton) {
        profile_menu_.exec(global_pos);
    } else {
        bool enable_edit = false;
}
void Singleton::f2();{
    splitter->addWidget(info_progress);
    splitter->addWidget(&packet_status_);
    splitter->addWidget(&profile_status_);
    splitter->setStretchFactor(0, 3);
    splitter->setStretchFactor(1, 3);
}
void Singleton::f3();{
        if (! idx.data(ProfileModel::DATA_IS_DEFAULT).toBool() && ! idx.data(ProfileModel::DATA_IS_GLOBAL).toBool())
            enable_edit = true;
        profile_menu_.setTitle(tr("Switch to"));
        QMenu ctx_menu_;
        QAction * action = ctx_menu_.addAction(tr("Manage Profiles" UTF8_HORIZONTAL_ELLIPSIS), this, SLOT(manageProfile()));
}
void Singleton::f4();{
    // We might have to switch to a QPushButton.
    QString stock_name = "x-expert-";
    QString tt_text = tr(" is the highest expert information level");
    switch(expert_get_highest_severity()) {
    case(PI_ERROR):
}
void Singleton::f5();{
    ready_msg_(tr("Ready to load or capture")),
    ready_msg_(tr("Ready to load file")),
    cs_fixed_(false),
    cs_count_(0)
    QSplitter *splitter = new QSplitter(this);
}
void Singleton::f6();{
        expertUpdate();
void MainStatusBar::popGenericStatus(StatusContext status)
    LabelStack * stack = &info_status_;
    if (status == STATUS_CTX_MAIN)
        stack = &packet_status_;
}
void Singleton::f7();{
    else
        stack->pushText(message, status);
    stack->setToolTip(messagetip);
    if (status == STATUS_CTX_FILTER || status == STATUS_CTX_FILE)
        expertUpdate();
}
void Singleton::f8();{
    {
        if (hInfo.description.length() > 0) {
            item_info.append(hInfo.description);
        } else {
            item_info.append(hInfo.name);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    profile_menu_.addActions(global.actions());
    if (button == Qt::LeftButton) {
        profile_menu_.exec(global_pos);
    } else {
        bool enable_edit = false;
}
void Singleton::f2();{
    splitter->addWidget(info_progress);
    splitter->addWidget(&packet_status_);
    splitter->addWidget(&profile_status_);
    splitter->setStretchFactor(0, 3);
    splitter->setStretchFactor(1, 3);
}
void Singleton::f3();{
        if (! idx.data(ProfileModel::DATA_IS_DEFAULT).toBool() && ! idx.data(ProfileModel::DATA_IS_GLOBAL).toBool())
            enable_edit = true;
        profile_menu_.setTitle(tr("Switch to"));
        QMenu ctx_menu_;
        QAction * action = ctx_menu_.addAction(tr("Manage Profiles" UTF8_HORIZONTAL_ELLIPSIS), this, SLOT(manageProfile()));
}
void Singleton::f4();{
    // We might have to switch to a QPushButton.
    QString stock_name = "x-expert-";
    QString tt_text = tr(" is the highest expert information level");
    switch(expert_get_highest_severity()) {
    case(PI_ERROR):
}
void Singleton::f5();{
    ready_msg_(tr("Ready to load or capture")),
    ready_msg_(tr("Ready to load file")),
    cs_fixed_(false),
    cs_count_(0)
    QSplitter *splitter = new QSplitter(this);
}
void Singleton::f6();{
        expertUpdate();
void MainStatusBar::popGenericStatus(StatusContext status)
    LabelStack * stack = &info_status_;
    if (status == STATUS_CTX_MAIN)
        stack = &packet_status_;
}
void Singleton::f7();{
    else
        stack->pushText(message, status);
    stack->setToolTip(messagetip);
    if (status == STATUS_CTX_FILTER || status == STATUS_CTX_FILE)
        expertUpdate();
}
void Singleton::f8();{
    {
        if (hInfo.description.length() > 0) {
            item_info.append(hInfo.description);
        } else {
            item_info.append(hInfo.name);
}
void Singleton::f9();{
            if (cap_file_->packet_comment_count > 0) {
                packets_str.append(QString(tr(" %1 Comments: %2"))
                    .arg(UTF8_MIDDLE_DOT)
                    .arg(cap_file_->packet_comment_count));
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            title.append(QString(" %1 %2").arg(UTF8_EM_DASH).arg(custom_title));
            title.append(QString(" [%1]").arg(custom_title));
        }
    }
    setWindowTitle(title);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            title.append(QString(" %1 %2").arg(UTF8_EM_DASH).arg(custom_title));
            title.append(QString(" [%1]").arg(custom_title));
        }
    }
    setWindowTitle(title);
}
void Singleton::f2();{
    main_ui_->goToLineEdit->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToGo->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToCancel->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->actionEditPreferences->setMenuRole(QAction::PreferencesRole);
    QAction *update_sep = main_ui_->menuHelp->insertSeparator(main_ui_->actionHelpAbout);
}
void Singleton::f3();{
            g_free(tmpname);
            continue;
        }
        cf_close(capture_file_.capFile());
        /* Try to open the merged capture file. */
}
void Singleton::f4();{
void MainWindow::setMenusForCaptureFile(bool force_disable)
    bool enable = true;
    bool can_write = false;
    bool can_save = false;
    bool can_save_as = false;
}
void Singleton::f5();{
            conv_action->setColorNumber(i++);
            submenu->addAction(conv_action);
            connect(this, SIGNAL(packetInfoChanged(_packet_info*)), conv_action, SLOT(setPacketInfo(_packet_info*)));
            connect(conv_action, SIGNAL(triggered()), this, SLOT(colorizeActionTriggered()));
        }
}
void Singleton::f6();{
    {
        /* We may have a filename associated with the main window so let's use it */
        QString fileNameString = gbl_cur_main_window_->getMwFileName();
        if (fileNameString.length())
        {
}
void Singleton::f7();{
    QList<QAction *> freeze_actions = QList<QAction *>()
            << main_ui_->actionFileClose
            << main_ui_->actionViewReload
            << main_ui_->actionEditMarkPacket
            << main_ui_->actionEditMarkAllDisplayed
}
void Singleton::f8();{
void MainWindow::removeMenuActions(QList<QAction *> &actions, int menu_group)
    foreach(QAction *action, actions) {
        switch (menu_group) {
        case REGISTER_ANALYZE_GROUP_UNSORTED:
        case REGISTER_STAT_GROUP_UNSORTED:
}
void Singleton::f9();{
    const char * module_name;
    const char * pref_name;
    const char * pref_value;
    if (g_hash_table_lookup_extended(data_set, "pref_module", NULL, (void**)&module_name) &&
        g_hash_table_lookup_extended(data_set, "pref_key", NULL, (void**)&pref_name) &&
}
void Singleton::f10();{
        }
        /* Clear MainWindow file name details */
        gbl_cur_main_window_->setMwFileName("");
        /* captureStop() will close the file if not having any packets */
        if (capture_file_.capFile() && context != Restart && context != Reload)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            title.append(QString(" %1 %2").arg(UTF8_EM_DASH).arg(custom_title));
            title.append(QString(" [%1]").arg(custom_title));
        }
    }
    setWindowTitle(title);
}
void Singleton::f2();{
    main_ui_->goToLineEdit->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToGo->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToCancel->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->actionEditPreferences->setMenuRole(QAction::PreferencesRole);
    QAction *update_sep = main_ui_->menuHelp->insertSeparator(main_ui_->actionHelpAbout);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            title.append(QString(" %1 %2").arg(UTF8_EM_DASH).arg(custom_title));
            title.append(QString(" [%1]").arg(custom_title));
        }
    }
    setWindowTitle(title);
}
void Singleton::f2();{
    main_ui_->goToLineEdit->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToGo->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToCancel->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->actionEditPreferences->setMenuRole(QAction::PreferencesRole);
    QAction *update_sep = main_ui_->menuHelp->insertSeparator(main_ui_->actionHelpAbout);
}
void Singleton::f3();{
            g_free(tmpname);
            continue;
        }
        cf_close(capture_file_.capFile());
        /* Try to open the merged capture file. */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            title.append(QString(" %1 %2").arg(UTF8_EM_DASH).arg(custom_title));
            title.append(QString(" [%1]").arg(custom_title));
        }
    }
    setWindowTitle(title);
}
void Singleton::f2();{
    main_ui_->goToLineEdit->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToGo->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToCancel->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->actionEditPreferences->setMenuRole(QAction::PreferencesRole);
    QAction *update_sep = main_ui_->menuHelp->insertSeparator(main_ui_->actionHelpAbout);
}
void Singleton::f3();{
            g_free(tmpname);
            continue;
        }
        cf_close(capture_file_.capFile());
        /* Try to open the merged capture file. */
}
void Singleton::f4();{
void MainWindow::setMenusForCaptureFile(bool force_disable)
    bool enable = true;
    bool can_write = false;
    bool can_save = false;
    bool can_save_as = false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            title.append(QString(" %1 %2").arg(UTF8_EM_DASH).arg(custom_title));
            title.append(QString(" [%1]").arg(custom_title));
        }
    }
    setWindowTitle(title);
}
void Singleton::f2();{
    main_ui_->goToLineEdit->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToGo->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToCancel->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->actionEditPreferences->setMenuRole(QAction::PreferencesRole);
    QAction *update_sep = main_ui_->menuHelp->insertSeparator(main_ui_->actionHelpAbout);
}
void Singleton::f3();{
            g_free(tmpname);
            continue;
        }
        cf_close(capture_file_.capFile());
        /* Try to open the merged capture file. */
}
void Singleton::f4();{
void MainWindow::setMenusForCaptureFile(bool force_disable)
    bool enable = true;
    bool can_write = false;
    bool can_save = false;
    bool can_save_as = false;
}
void Singleton::f5();{
            conv_action->setColorNumber(i++);
            submenu->addAction(conv_action);
            connect(this, SIGNAL(packetInfoChanged(_packet_info*)), conv_action, SLOT(setPacketInfo(_packet_info*)));
            connect(conv_action, SIGNAL(triggered()), this, SLOT(colorizeActionTriggered()));
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            title.append(QString(" %1 %2").arg(UTF8_EM_DASH).arg(custom_title));
            title.append(QString(" [%1]").arg(custom_title));
        }
    }
    setWindowTitle(title);
}
void Singleton::f2();{
    main_ui_->goToLineEdit->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToGo->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToCancel->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->actionEditPreferences->setMenuRole(QAction::PreferencesRole);
    QAction *update_sep = main_ui_->menuHelp->insertSeparator(main_ui_->actionHelpAbout);
}
void Singleton::f3();{
            g_free(tmpname);
            continue;
        }
        cf_close(capture_file_.capFile());
        /* Try to open the merged capture file. */
}
void Singleton::f4();{
void MainWindow::setMenusForCaptureFile(bool force_disable)
    bool enable = true;
    bool can_write = false;
    bool can_save = false;
    bool can_save_as = false;
}
void Singleton::f5();{
            conv_action->setColorNumber(i++);
            submenu->addAction(conv_action);
            connect(this, SIGNAL(packetInfoChanged(_packet_info*)), conv_action, SLOT(setPacketInfo(_packet_info*)));
            connect(conv_action, SIGNAL(triggered()), this, SLOT(colorizeActionTriggered()));
        }
}
void Singleton::f6();{
    {
        /* We may have a filename associated with the main window so let's use it */
        QString fileNameString = gbl_cur_main_window_->getMwFileName();
        if (fileNameString.length())
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            title.append(QString(" %1 %2").arg(UTF8_EM_DASH).arg(custom_title));
            title.append(QString(" [%1]").arg(custom_title));
        }
    }
    setWindowTitle(title);
}
void Singleton::f2();{
    main_ui_->goToLineEdit->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToGo->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToCancel->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->actionEditPreferences->setMenuRole(QAction::PreferencesRole);
    QAction *update_sep = main_ui_->menuHelp->insertSeparator(main_ui_->actionHelpAbout);
}
void Singleton::f3();{
            g_free(tmpname);
            continue;
        }
        cf_close(capture_file_.capFile());
        /* Try to open the merged capture file. */
}
void Singleton::f4();{
void MainWindow::setMenusForCaptureFile(bool force_disable)
    bool enable = true;
    bool can_write = false;
    bool can_save = false;
    bool can_save_as = false;
}
void Singleton::f5();{
            conv_action->setColorNumber(i++);
            submenu->addAction(conv_action);
            connect(this, SIGNAL(packetInfoChanged(_packet_info*)), conv_action, SLOT(setPacketInfo(_packet_info*)));
            connect(conv_action, SIGNAL(triggered()), this, SLOT(colorizeActionTriggered()));
        }
}
void Singleton::f6();{
    {
        /* We may have a filename associated with the main window so let's use it */
        QString fileNameString = gbl_cur_main_window_->getMwFileName();
        if (fileNameString.length())
        {
}
void Singleton::f7();{
    QList<QAction *> freeze_actions = QList<QAction *>()
            << main_ui_->actionFileClose
            << main_ui_->actionViewReload
            << main_ui_->actionEditMarkPacket
            << main_ui_->actionEditMarkAllDisplayed
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            title.append(QString(" %1 %2").arg(UTF8_EM_DASH).arg(custom_title));
            title.append(QString(" [%1]").arg(custom_title));
        }
    }
    setWindowTitle(title);
}
void Singleton::f2();{
    main_ui_->goToLineEdit->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToGo->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToCancel->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->actionEditPreferences->setMenuRole(QAction::PreferencesRole);
    QAction *update_sep = main_ui_->menuHelp->insertSeparator(main_ui_->actionHelpAbout);
}
void Singleton::f3();{
            g_free(tmpname);
            continue;
        }
        cf_close(capture_file_.capFile());
        /* Try to open the merged capture file. */
}
void Singleton::f4();{
void MainWindow::setMenusForCaptureFile(bool force_disable)
    bool enable = true;
    bool can_write = false;
    bool can_save = false;
    bool can_save_as = false;
}
void Singleton::f5();{
            conv_action->setColorNumber(i++);
            submenu->addAction(conv_action);
            connect(this, SIGNAL(packetInfoChanged(_packet_info*)), conv_action, SLOT(setPacketInfo(_packet_info*)));
            connect(conv_action, SIGNAL(triggered()), this, SLOT(colorizeActionTriggered()));
        }
}
void Singleton::f6();{
    {
        /* We may have a filename associated with the main window so let's use it */
        QString fileNameString = gbl_cur_main_window_->getMwFileName();
        if (fileNameString.length())
        {
}
void Singleton::f7();{
    QList<QAction *> freeze_actions = QList<QAction *>()
            << main_ui_->actionFileClose
            << main_ui_->actionViewReload
            << main_ui_->actionEditMarkPacket
            << main_ui_->actionEditMarkAllDisplayed
}
void Singleton::f8();{
void MainWindow::removeMenuActions(QList<QAction *> &actions, int menu_group)
    foreach(QAction *action, actions) {
        switch (menu_group) {
        case REGISTER_ANALYZE_GROUP_UNSORTED:
        case REGISTER_STAT_GROUP_UNSORTED:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            title.append(QString(" %1 %2").arg(UTF8_EM_DASH).arg(custom_title));
            title.append(QString(" [%1]").arg(custom_title));
        }
    }
    setWindowTitle(title);
}
void Singleton::f2();{
    main_ui_->goToLineEdit->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToGo->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->goToCancel->setAttribute(Qt::WA_MacSmallSize, true);
    main_ui_->actionEditPreferences->setMenuRole(QAction::PreferencesRole);
    QAction *update_sep = main_ui_->menuHelp->insertSeparator(main_ui_->actionHelpAbout);
}
void Singleton::f3();{
            g_free(tmpname);
            continue;
        }
        cf_close(capture_file_.capFile());
        /* Try to open the merged capture file. */
}
void Singleton::f4();{
void MainWindow::setMenusForCaptureFile(bool force_disable)
    bool enable = true;
    bool can_write = false;
    bool can_save = false;
    bool can_save_as = false;
}
void Singleton::f5();{
            conv_action->setColorNumber(i++);
            submenu->addAction(conv_action);
            connect(this, SIGNAL(packetInfoChanged(_packet_info*)), conv_action, SLOT(setPacketInfo(_packet_info*)));
            connect(conv_action, SIGNAL(triggered()), this, SLOT(colorizeActionTriggered()));
        }
}
void Singleton::f6();{
    {
        /* We may have a filename associated with the main window so let's use it */
        QString fileNameString = gbl_cur_main_window_->getMwFileName();
        if (fileNameString.length())
        {
}
void Singleton::f7();{
    QList<QAction *> freeze_actions = QList<QAction *>()
            << main_ui_->actionFileClose
            << main_ui_->actionViewReload
            << main_ui_->actionEditMarkPacket
            << main_ui_->actionEditMarkAllDisplayed
}
void Singleton::f8();{
void MainWindow::removeMenuActions(QList<QAction *> &actions, int menu_group)
    foreach(QAction *action, actions) {
        switch (menu_group) {
        case REGISTER_ANALYZE_GROUP_UNSORTED:
        case REGISTER_STAT_GROUP_UNSORTED:
}
void Singleton::f9();{
    const char * module_name;
    const char * pref_name;
    const char * pref_value;
    if (g_hash_table_lookup_extended(data_set, "pref_module", NULL, (void**)&module_name) &&
        g_hash_table_lookup_extended(data_set, "pref_key", NULL, (void**)&pref_name) &&
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        break;
    case(layout_type_2):
    case(layout_type_4):
        parents[0] = &master_split_;
        parents[1] = &extra_split_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        break;
    case(layout_type_2):
    case(layout_type_4):
        parents[0] = &master_split_;
        parents[1] = &extra_split_;
}
void Singleton::f2();{
    parents[1]->addWidget(getLayoutWidget(prefs.gui_layout_content_2));
    parents[2]->addWidget(getLayoutWidget(prefs.gui_layout_content_3));
    const QList<QWidget *> ms_children = master_split_.findChildren<QWidget *>();
    extra_split_.setVisible(ms_children.contains(&extra_split_));
    packet_list_->setVisible(ms_children.contains(packet_list_) && recent.packet_list_show);
}
void Singleton::f3();{
    // when the master splitter is set as current widget for the first time.
    master_split_.show();
    packet_list_->thaw(true);
    cur_layout_ = new_layout;
// The recent layout geometry should be applied after the layout has been
}
void Singleton::f4();{
    } else {
        master_sizes[0] = master_last_size / master_sizes.length();
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
}
void Singleton::f5();{
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
        if (master_sizes.length() > 2) {
            master_sizes[1] = recent.gui_geometry_main_lower_pane;
}
void Singleton::f6();{
        } else if (extra_sizes.length() > 0) {
            extra_sizes[0] = extra_last_size / 2;
            extra_last_size -= extra_last_size / 2;
            extra_sizes.last() = extra_last_size;
        }
}
void Singleton::f7();{
        /* Fall Through */
    case(layout_type_5):
        master_split_.setOrientation(Qt::Vertical);
        break;
    case(layout_type_4):
}
void Singleton::f8();{
    QWidget *cur_w = main_ui_->mainStack->currentWidget();
    showCapture();
    QRect geom = main_ui_->mainStack->geometry();
    QList<int> master_sizes = master_split_.sizes();
    QList<int> extra_sizes = extra_split_.sizes();
}
void Singleton::f9();{
        /* Fall Through */
    case(layout_type_5):
        master_split_.setOrientation(Qt::Vertical);
        break;
    case(layout_type_4):
}
void Singleton::f10();{
    }
    switch(prefs.gui_layout_type) {
    case(layout_type_5):
    case(layout_type_6):
        parents[0] = &master_split_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        break;
    case(layout_type_2):
    case(layout_type_4):
        parents[0] = &master_split_;
        parents[1] = &extra_split_;
}
void Singleton::f2();{
    parents[1]->addWidget(getLayoutWidget(prefs.gui_layout_content_2));
    parents[2]->addWidget(getLayoutWidget(prefs.gui_layout_content_3));
    const QList<QWidget *> ms_children = master_split_.findChildren<QWidget *>();
    extra_split_.setVisible(ms_children.contains(&extra_split_));
    packet_list_->setVisible(ms_children.contains(packet_list_) && recent.packet_list_show);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        break;
    case(layout_type_2):
    case(layout_type_4):
        parents[0] = &master_split_;
        parents[1] = &extra_split_;
}
void Singleton::f2();{
    parents[1]->addWidget(getLayoutWidget(prefs.gui_layout_content_2));
    parents[2]->addWidget(getLayoutWidget(prefs.gui_layout_content_3));
    const QList<QWidget *> ms_children = master_split_.findChildren<QWidget *>();
    extra_split_.setVisible(ms_children.contains(&extra_split_));
    packet_list_->setVisible(ms_children.contains(packet_list_) && recent.packet_list_show);
}
void Singleton::f3();{
    // when the master splitter is set as current widget for the first time.
    master_split_.show();
    packet_list_->thaw(true);
    cur_layout_ = new_layout;
// The recent layout geometry should be applied after the layout has been
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        break;
    case(layout_type_2):
    case(layout_type_4):
        parents[0] = &master_split_;
        parents[1] = &extra_split_;
}
void Singleton::f2();{
    parents[1]->addWidget(getLayoutWidget(prefs.gui_layout_content_2));
    parents[2]->addWidget(getLayoutWidget(prefs.gui_layout_content_3));
    const QList<QWidget *> ms_children = master_split_.findChildren<QWidget *>();
    extra_split_.setVisible(ms_children.contains(&extra_split_));
    packet_list_->setVisible(ms_children.contains(packet_list_) && recent.packet_list_show);
}
void Singleton::f3();{
    // when the master splitter is set as current widget for the first time.
    master_split_.show();
    packet_list_->thaw(true);
    cur_layout_ = new_layout;
// The recent layout geometry should be applied after the layout has been
}
void Singleton::f4();{
    } else {
        master_sizes[0] = master_last_size / master_sizes.length();
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        break;
    case(layout_type_2):
    case(layout_type_4):
        parents[0] = &master_split_;
        parents[1] = &extra_split_;
}
void Singleton::f2();{
    parents[1]->addWidget(getLayoutWidget(prefs.gui_layout_content_2));
    parents[2]->addWidget(getLayoutWidget(prefs.gui_layout_content_3));
    const QList<QWidget *> ms_children = master_split_.findChildren<QWidget *>();
    extra_split_.setVisible(ms_children.contains(&extra_split_));
    packet_list_->setVisible(ms_children.contains(packet_list_) && recent.packet_list_show);
}
void Singleton::f3();{
    // when the master splitter is set as current widget for the first time.
    master_split_.show();
    packet_list_->thaw(true);
    cur_layout_ = new_layout;
// The recent layout geometry should be applied after the layout has been
}
void Singleton::f4();{
    } else {
        master_sizes[0] = master_last_size / master_sizes.length();
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
}
void Singleton::f5();{
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
        if (master_sizes.length() > 2) {
            master_sizes[1] = recent.gui_geometry_main_lower_pane;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        break;
    case(layout_type_2):
    case(layout_type_4):
        parents[0] = &master_split_;
        parents[1] = &extra_split_;
}
void Singleton::f2();{
    parents[1]->addWidget(getLayoutWidget(prefs.gui_layout_content_2));
    parents[2]->addWidget(getLayoutWidget(prefs.gui_layout_content_3));
    const QList<QWidget *> ms_children = master_split_.findChildren<QWidget *>();
    extra_split_.setVisible(ms_children.contains(&extra_split_));
    packet_list_->setVisible(ms_children.contains(packet_list_) && recent.packet_list_show);
}
void Singleton::f3();{
    // when the master splitter is set as current widget for the first time.
    master_split_.show();
    packet_list_->thaw(true);
    cur_layout_ = new_layout;
// The recent layout geometry should be applied after the layout has been
}
void Singleton::f4();{
    } else {
        master_sizes[0] = master_last_size / master_sizes.length();
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
}
void Singleton::f5();{
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
        if (master_sizes.length() > 2) {
            master_sizes[1] = recent.gui_geometry_main_lower_pane;
}
void Singleton::f6();{
        } else if (extra_sizes.length() > 0) {
            extra_sizes[0] = extra_last_size / 2;
            extra_last_size -= extra_last_size / 2;
            extra_sizes.last() = extra_last_size;
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        break;
    case(layout_type_2):
    case(layout_type_4):
        parents[0] = &master_split_;
        parents[1] = &extra_split_;
}
void Singleton::f2();{
    parents[1]->addWidget(getLayoutWidget(prefs.gui_layout_content_2));
    parents[2]->addWidget(getLayoutWidget(prefs.gui_layout_content_3));
    const QList<QWidget *> ms_children = master_split_.findChildren<QWidget *>();
    extra_split_.setVisible(ms_children.contains(&extra_split_));
    packet_list_->setVisible(ms_children.contains(packet_list_) && recent.packet_list_show);
}
void Singleton::f3();{
    // when the master splitter is set as current widget for the first time.
    master_split_.show();
    packet_list_->thaw(true);
    cur_layout_ = new_layout;
// The recent layout geometry should be applied after the layout has been
}
void Singleton::f4();{
    } else {
        master_sizes[0] = master_last_size / master_sizes.length();
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
}
void Singleton::f5();{
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
        if (master_sizes.length() > 2) {
            master_sizes[1] = recent.gui_geometry_main_lower_pane;
}
void Singleton::f6();{
        } else if (extra_sizes.length() > 0) {
            extra_sizes[0] = extra_last_size / 2;
            extra_last_size -= extra_last_size / 2;
            extra_sizes.last() = extra_last_size;
        }
}
void Singleton::f7();{
        /* Fall Through */
    case(layout_type_5):
        master_split_.setOrientation(Qt::Vertical);
        break;
    case(layout_type_4):
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        break;
    case(layout_type_2):
    case(layout_type_4):
        parents[0] = &master_split_;
        parents[1] = &extra_split_;
}
void Singleton::f2();{
    parents[1]->addWidget(getLayoutWidget(prefs.gui_layout_content_2));
    parents[2]->addWidget(getLayoutWidget(prefs.gui_layout_content_3));
    const QList<QWidget *> ms_children = master_split_.findChildren<QWidget *>();
    extra_split_.setVisible(ms_children.contains(&extra_split_));
    packet_list_->setVisible(ms_children.contains(packet_list_) && recent.packet_list_show);
}
void Singleton::f3();{
    // when the master splitter is set as current widget for the first time.
    master_split_.show();
    packet_list_->thaw(true);
    cur_layout_ = new_layout;
// The recent layout geometry should be applied after the layout has been
}
void Singleton::f4();{
    } else {
        master_sizes[0] = master_last_size / master_sizes.length();
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
}
void Singleton::f5();{
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
        if (master_sizes.length() > 2) {
            master_sizes[1] = recent.gui_geometry_main_lower_pane;
}
void Singleton::f6();{
        } else if (extra_sizes.length() > 0) {
            extra_sizes[0] = extra_last_size / 2;
            extra_last_size -= extra_last_size / 2;
            extra_sizes.last() = extra_last_size;
        }
}
void Singleton::f7();{
        /* Fall Through */
    case(layout_type_5):
        master_split_.setOrientation(Qt::Vertical);
        break;
    case(layout_type_4):
}
void Singleton::f8();{
    QWidget *cur_w = main_ui_->mainStack->currentWidget();
    showCapture();
    QRect geom = main_ui_->mainStack->geometry();
    QList<int> master_sizes = master_split_.sizes();
    QList<int> extra_sizes = extra_split_.sizes();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        break;
    case(layout_type_2):
    case(layout_type_4):
        parents[0] = &master_split_;
        parents[1] = &extra_split_;
}
void Singleton::f2();{
    parents[1]->addWidget(getLayoutWidget(prefs.gui_layout_content_2));
    parents[2]->addWidget(getLayoutWidget(prefs.gui_layout_content_3));
    const QList<QWidget *> ms_children = master_split_.findChildren<QWidget *>();
    extra_split_.setVisible(ms_children.contains(&extra_split_));
    packet_list_->setVisible(ms_children.contains(packet_list_) && recent.packet_list_show);
}
void Singleton::f3();{
    // when the master splitter is set as current widget for the first time.
    master_split_.show();
    packet_list_->thaw(true);
    cur_layout_ = new_layout;
// The recent layout geometry should be applied after the layout has been
}
void Singleton::f4();{
    } else {
        master_sizes[0] = master_last_size / master_sizes.length();
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
}
void Singleton::f5();{
        master_last_size -= master_last_size / master_sizes.length();
    }
    if (recent.gui_geometry_main_lower_pane > 0) {
        if (master_sizes.length() > 2) {
            master_sizes[1] = recent.gui_geometry_main_lower_pane;
}
void Singleton::f6();{
        } else if (extra_sizes.length() > 0) {
            extra_sizes[0] = extra_last_size / 2;
            extra_last_size -= extra_last_size / 2;
            extra_sizes.last() = extra_last_size;
        }
}
void Singleton::f7();{
        /* Fall Through */
    case(layout_type_5):
        master_split_.setOrientation(Qt::Vertical);
        break;
    case(layout_type_4):
}
void Singleton::f8();{
    QWidget *cur_w = main_ui_->mainStack->currentWidget();
    showCapture();
    QRect geom = main_ui_->mainStack->geometry();
    QList<int> master_sizes = master_split_.sizes();
    QList<int> extra_sizes = extra_split_.sizes();
}
void Singleton::f9();{
        /* Fall Through */
    case(layout_type_5):
        master_split_.setOrientation(Qt::Vertical);
        break;
    case(layout_type_4):
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    ui->foStyleSpecifiedLineEdit->setText(specified_dir);
    prefs_set_string_value(pref_fileopen_dir_, specified_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
void MainWindowPreferencesFrame::on_maxFilterLineEdit_textEdited(const QString &new_max)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    ui->foStyleSpecifiedLineEdit->setText(specified_dir);
    prefs_set_string_value(pref_fileopen_dir_, specified_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
void MainWindowPreferencesFrame::on_maxFilterLineEdit_textEdited(const QString &new_max)
}
void Singleton::f2();{
    prefs_set_enum_value(pref_toolbar_main_style_, index, pref_stashed);
void MainWindowPreferencesFrame::on_languageComboBox_currentIndexChanged(int index)
    g_free(language);
    language = g_strdup(ui->languageComboBox->itemData(index).toString().toStdString().c_str());
void MainWindowPreferencesFrame::on_windowTitle_textEdited(const QString &new_title)
}
void Singleton::f3();{
    ui(new Ui::MainWindowPreferencesFrame)
    ui->setupUi(this);
    pref_geometry_save_position_ = prefFromPrefPtr(&prefs.gui_geometry_save_position);
    pref_geometry_save_size_ = prefFromPrefPtr(&prefs.gui_geometry_save_size);
    pref_geometry_save_maximized_ = prefFromPrefPtr(&prefs.gui_geometry_save_maximized);
}
void Singleton::f4();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedRadioButton_toggled(bool checked)
    if (checked) {
        prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    }
}
void Singleton::f5();{
            ui->languageComboBox->setCurrentIndex(i);
            break;
        }
    }
    ui->windowTitle->setText(prefs_get_string_value(pref_window_title_, pref_stashed));
}
void Singleton::f6();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedLineEdit_textEdited(const QString &new_dir)
    prefs_set_string_value(pref_fileopen_dir_, new_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
}
void Singleton::f7();{
        locale.truncate(locale.lastIndexOf('.'));
        locale.remove(0, locale.indexOf('_') + 1);
        QString lang = QLocale::languageToString(QLocale(locale).language());
        QIcon ico = QIcon();
        if (QFile::exists(QString(":/languages/%1.svg").arg(locale)))
}
void Singleton::f8();{
void MainWindowPreferencesFrame::on_confirmUnsavedCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_ask_unsaved_, checked, pref_stashed);
void MainWindowPreferencesFrame::on_displayAutoCompleteCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_autocomplete_filter_, checked, pref_stashed);
void MainWindowPreferencesFrame::on_mainToolbarComboBox_currentIndexChanged(int index)
}
void Singleton::f9();{
    ui->maxFilterLineEdit->setMaximumWidth(num_entry_width);
    ui->maxRecentLineEdit->setMaximumWidth(num_entry_width);
    QString globalLanguagesPath(QString(get_datafile_dir()) + "/languages/");
    QString userLanguagesPath(gchar_free_to_qstring(get_persconffile_path("languages/", FALSE)));
    QStringList filenames = QDir(":/i18n/").entryList(QStringList("wireshark_*.qm"));
}
void Singleton::f10();{
    QFrame(parent),
    ui(new Ui::MainWindowPreferencesFrame)
    ui->setupUi(this);
    pref_geometry_save_position_ = prefFromPrefPtr(&prefs.gui_geometry_save_position);
    pref_geometry_save_size_ = prefFromPrefPtr(&prefs.gui_geometry_save_size);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    ui->foStyleSpecifiedLineEdit->setText(specified_dir);
    prefs_set_string_value(pref_fileopen_dir_, specified_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
void MainWindowPreferencesFrame::on_maxFilterLineEdit_textEdited(const QString &new_max)
}
void Singleton::f2();{
    prefs_set_enum_value(pref_toolbar_main_style_, index, pref_stashed);
void MainWindowPreferencesFrame::on_languageComboBox_currentIndexChanged(int index)
    g_free(language);
    language = g_strdup(ui->languageComboBox->itemData(index).toString().toStdString().c_str());
void MainWindowPreferencesFrame::on_windowTitle_textEdited(const QString &new_title)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    ui->foStyleSpecifiedLineEdit->setText(specified_dir);
    prefs_set_string_value(pref_fileopen_dir_, specified_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
void MainWindowPreferencesFrame::on_maxFilterLineEdit_textEdited(const QString &new_max)
}
void Singleton::f2();{
    prefs_set_enum_value(pref_toolbar_main_style_, index, pref_stashed);
void MainWindowPreferencesFrame::on_languageComboBox_currentIndexChanged(int index)
    g_free(language);
    language = g_strdup(ui->languageComboBox->itemData(index).toString().toStdString().c_str());
void MainWindowPreferencesFrame::on_windowTitle_textEdited(const QString &new_title)
}
void Singleton::f3();{
    ui(new Ui::MainWindowPreferencesFrame)
    ui->setupUi(this);
    pref_geometry_save_position_ = prefFromPrefPtr(&prefs.gui_geometry_save_position);
    pref_geometry_save_size_ = prefFromPrefPtr(&prefs.gui_geometry_save_size);
    pref_geometry_save_maximized_ = prefFromPrefPtr(&prefs.gui_geometry_save_maximized);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    ui->foStyleSpecifiedLineEdit->setText(specified_dir);
    prefs_set_string_value(pref_fileopen_dir_, specified_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
void MainWindowPreferencesFrame::on_maxFilterLineEdit_textEdited(const QString &new_max)
}
void Singleton::f2();{
    prefs_set_enum_value(pref_toolbar_main_style_, index, pref_stashed);
void MainWindowPreferencesFrame::on_languageComboBox_currentIndexChanged(int index)
    g_free(language);
    language = g_strdup(ui->languageComboBox->itemData(index).toString().toStdString().c_str());
void MainWindowPreferencesFrame::on_windowTitle_textEdited(const QString &new_title)
}
void Singleton::f3();{
    ui(new Ui::MainWindowPreferencesFrame)
    ui->setupUi(this);
    pref_geometry_save_position_ = prefFromPrefPtr(&prefs.gui_geometry_save_position);
    pref_geometry_save_size_ = prefFromPrefPtr(&prefs.gui_geometry_save_size);
    pref_geometry_save_maximized_ = prefFromPrefPtr(&prefs.gui_geometry_save_maximized);
}
void Singleton::f4();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedRadioButton_toggled(bool checked)
    if (checked) {
        prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    ui->foStyleSpecifiedLineEdit->setText(specified_dir);
    prefs_set_string_value(pref_fileopen_dir_, specified_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
void MainWindowPreferencesFrame::on_maxFilterLineEdit_textEdited(const QString &new_max)
}
void Singleton::f2();{
    prefs_set_enum_value(pref_toolbar_main_style_, index, pref_stashed);
void MainWindowPreferencesFrame::on_languageComboBox_currentIndexChanged(int index)
    g_free(language);
    language = g_strdup(ui->languageComboBox->itemData(index).toString().toStdString().c_str());
void MainWindowPreferencesFrame::on_windowTitle_textEdited(const QString &new_title)
}
void Singleton::f3();{
    ui(new Ui::MainWindowPreferencesFrame)
    ui->setupUi(this);
    pref_geometry_save_position_ = prefFromPrefPtr(&prefs.gui_geometry_save_position);
    pref_geometry_save_size_ = prefFromPrefPtr(&prefs.gui_geometry_save_size);
    pref_geometry_save_maximized_ = prefFromPrefPtr(&prefs.gui_geometry_save_maximized);
}
void Singleton::f4();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedRadioButton_toggled(bool checked)
    if (checked) {
        prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    }
}
void Singleton::f5();{
            ui->languageComboBox->setCurrentIndex(i);
            break;
        }
    }
    ui->windowTitle->setText(prefs_get_string_value(pref_window_title_, pref_stashed));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    ui->foStyleSpecifiedLineEdit->setText(specified_dir);
    prefs_set_string_value(pref_fileopen_dir_, specified_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
void MainWindowPreferencesFrame::on_maxFilterLineEdit_textEdited(const QString &new_max)
}
void Singleton::f2();{
    prefs_set_enum_value(pref_toolbar_main_style_, index, pref_stashed);
void MainWindowPreferencesFrame::on_languageComboBox_currentIndexChanged(int index)
    g_free(language);
    language = g_strdup(ui->languageComboBox->itemData(index).toString().toStdString().c_str());
void MainWindowPreferencesFrame::on_windowTitle_textEdited(const QString &new_title)
}
void Singleton::f3();{
    ui(new Ui::MainWindowPreferencesFrame)
    ui->setupUi(this);
    pref_geometry_save_position_ = prefFromPrefPtr(&prefs.gui_geometry_save_position);
    pref_geometry_save_size_ = prefFromPrefPtr(&prefs.gui_geometry_save_size);
    pref_geometry_save_maximized_ = prefFromPrefPtr(&prefs.gui_geometry_save_maximized);
}
void Singleton::f4();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedRadioButton_toggled(bool checked)
    if (checked) {
        prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    }
}
void Singleton::f5();{
            ui->languageComboBox->setCurrentIndex(i);
            break;
        }
    }
    ui->windowTitle->setText(prefs_get_string_value(pref_window_title_, pref_stashed));
}
void Singleton::f6();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedLineEdit_textEdited(const QString &new_dir)
    prefs_set_string_value(pref_fileopen_dir_, new_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    ui->foStyleSpecifiedLineEdit->setText(specified_dir);
    prefs_set_string_value(pref_fileopen_dir_, specified_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
void MainWindowPreferencesFrame::on_maxFilterLineEdit_textEdited(const QString &new_max)
}
void Singleton::f2();{
    prefs_set_enum_value(pref_toolbar_main_style_, index, pref_stashed);
void MainWindowPreferencesFrame::on_languageComboBox_currentIndexChanged(int index)
    g_free(language);
    language = g_strdup(ui->languageComboBox->itemData(index).toString().toStdString().c_str());
void MainWindowPreferencesFrame::on_windowTitle_textEdited(const QString &new_title)
}
void Singleton::f3();{
    ui(new Ui::MainWindowPreferencesFrame)
    ui->setupUi(this);
    pref_geometry_save_position_ = prefFromPrefPtr(&prefs.gui_geometry_save_position);
    pref_geometry_save_size_ = prefFromPrefPtr(&prefs.gui_geometry_save_size);
    pref_geometry_save_maximized_ = prefFromPrefPtr(&prefs.gui_geometry_save_maximized);
}
void Singleton::f4();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedRadioButton_toggled(bool checked)
    if (checked) {
        prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    }
}
void Singleton::f5();{
            ui->languageComboBox->setCurrentIndex(i);
            break;
        }
    }
    ui->windowTitle->setText(prefs_get_string_value(pref_window_title_, pref_stashed));
}
void Singleton::f6();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedLineEdit_textEdited(const QString &new_dir)
    prefs_set_string_value(pref_fileopen_dir_, new_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
}
void Singleton::f7();{
        locale.truncate(locale.lastIndexOf('.'));
        locale.remove(0, locale.indexOf('_') + 1);
        QString lang = QLocale::languageToString(QLocale(locale).language());
        QIcon ico = QIcon();
        if (QFile::exists(QString(":/languages/%1.svg").arg(locale)))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    ui->foStyleSpecifiedLineEdit->setText(specified_dir);
    prefs_set_string_value(pref_fileopen_dir_, specified_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
void MainWindowPreferencesFrame::on_maxFilterLineEdit_textEdited(const QString &new_max)
}
void Singleton::f2();{
    prefs_set_enum_value(pref_toolbar_main_style_, index, pref_stashed);
void MainWindowPreferencesFrame::on_languageComboBox_currentIndexChanged(int index)
    g_free(language);
    language = g_strdup(ui->languageComboBox->itemData(index).toString().toStdString().c_str());
void MainWindowPreferencesFrame::on_windowTitle_textEdited(const QString &new_title)
}
void Singleton::f3();{
    ui(new Ui::MainWindowPreferencesFrame)
    ui->setupUi(this);
    pref_geometry_save_position_ = prefFromPrefPtr(&prefs.gui_geometry_save_position);
    pref_geometry_save_size_ = prefFromPrefPtr(&prefs.gui_geometry_save_size);
    pref_geometry_save_maximized_ = prefFromPrefPtr(&prefs.gui_geometry_save_maximized);
}
void Singleton::f4();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedRadioButton_toggled(bool checked)
    if (checked) {
        prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    }
}
void Singleton::f5();{
            ui->languageComboBox->setCurrentIndex(i);
            break;
        }
    }
    ui->windowTitle->setText(prefs_get_string_value(pref_window_title_, pref_stashed));
}
void Singleton::f6();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedLineEdit_textEdited(const QString &new_dir)
    prefs_set_string_value(pref_fileopen_dir_, new_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
}
void Singleton::f7();{
        locale.truncate(locale.lastIndexOf('.'));
        locale.remove(0, locale.indexOf('_') + 1);
        QString lang = QLocale::languageToString(QLocale(locale).language());
        QIcon ico = QIcon();
        if (QFile::exists(QString(":/languages/%1.svg").arg(locale)))
}
void Singleton::f8();{
void MainWindowPreferencesFrame::on_confirmUnsavedCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_ask_unsaved_, checked, pref_stashed);
void MainWindowPreferencesFrame::on_displayAutoCompleteCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_autocomplete_filter_, checked, pref_stashed);
void MainWindowPreferencesFrame::on_mainToolbarComboBox_currentIndexChanged(int index)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    ui->foStyleSpecifiedLineEdit->setText(specified_dir);
    prefs_set_string_value(pref_fileopen_dir_, specified_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
void MainWindowPreferencesFrame::on_maxFilterLineEdit_textEdited(const QString &new_max)
}
void Singleton::f2();{
    prefs_set_enum_value(pref_toolbar_main_style_, index, pref_stashed);
void MainWindowPreferencesFrame::on_languageComboBox_currentIndexChanged(int index)
    g_free(language);
    language = g_strdup(ui->languageComboBox->itemData(index).toString().toStdString().c_str());
void MainWindowPreferencesFrame::on_windowTitle_textEdited(const QString &new_title)
}
void Singleton::f3();{
    ui(new Ui::MainWindowPreferencesFrame)
    ui->setupUi(this);
    pref_geometry_save_position_ = prefFromPrefPtr(&prefs.gui_geometry_save_position);
    pref_geometry_save_size_ = prefFromPrefPtr(&prefs.gui_geometry_save_size);
    pref_geometry_save_maximized_ = prefFromPrefPtr(&prefs.gui_geometry_save_maximized);
}
void Singleton::f4();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedRadioButton_toggled(bool checked)
    if (checked) {
        prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    }
}
void Singleton::f5();{
            ui->languageComboBox->setCurrentIndex(i);
            break;
        }
    }
    ui->windowTitle->setText(prefs_get_string_value(pref_window_title_, pref_stashed));
}
void Singleton::f6();{
    }
void MainWindowPreferencesFrame::on_foStyleSpecifiedLineEdit_textEdited(const QString &new_dir)
    prefs_set_string_value(pref_fileopen_dir_, new_dir.toStdString().c_str(), pref_stashed);
    prefs_set_enum_value(pref_fileopen_style_, FO_STYLE_SPECIFIED, pref_stashed);
    updateWidgets();
}
void Singleton::f7();{
        locale.truncate(locale.lastIndexOf('.'));
        locale.remove(0, locale.indexOf('_') + 1);
        QString lang = QLocale::languageToString(QLocale(locale).language());
        QIcon ico = QIcon();
        if (QFile::exists(QString(":/languages/%1.svg").arg(locale)))
}
void Singleton::f8();{
void MainWindowPreferencesFrame::on_confirmUnsavedCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_ask_unsaved_, checked, pref_stashed);
void MainWindowPreferencesFrame::on_displayAutoCompleteCheckBox_toggled(bool checked)
    prefs_set_bool_value(pref_autocomplete_filter_, checked, pref_stashed);
void MainWindowPreferencesFrame::on_mainToolbarComboBox_currentIndexChanged(int index)
}
void Singleton::f9();{
    ui->maxFilterLineEdit->setMaximumWidth(num_entry_width);
    ui->maxRecentLineEdit->setMaximumWidth(num_entry_width);
    QString globalLanguagesPath(QString(get_datafile_dir()) + "/languages/");
    QString userLanguagesPath(gchar_free_to_qstring(get_persconffile_path("languages/", FALSE)));
    QStringList filenames = QDir(":/i18n/").entryList(QStringList("wireshark_*.qm"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    if (recent.gui_time_precision != tsp) {
        /* the actual precision will be set in packet_list_queue_draw() below */
        timestamp_set_precision(tsp);
        recent.gui_time_precision = tsp;
        if (packet_list_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    if (recent.gui_time_precision != tsp) {
        /* the actual precision will be set in packet_list_queue_draw() below */
        timestamp_set_precision(tsp);
        recent.gui_time_precision = tsp;
        if (packet_list_) {
}
void Singleton::f2();{
        main_ui_->actionCaptureStart->setChecked(false);
    }
void MainWindow::on_actionCaptureStop_triggered()
    stopCapture();
void MainWindow::on_actionCaptureRestart_triggered()
}
void Singleton::f3();{
    {
        about_dialog->showNormal();
    }
    else
    {
}
void Singleton::f4();{
                df_combo_box_->setCurrentIndex(index);
            }
        } else {
            df_combo_box_->lineEdit()->clear();
        }
}
void Singleton::f5();{
            captureFileOpened();
            break;
        case CaptureEvent::Closing:
            captureFileClosing();
            break;
}
void Singleton::f6();{
    packet_list_->recolorPackets();
    setMenusForSelectedPacket();
void MainWindow::on_actionViewColorizeNewColoringRule_triggered()
    colorizeConversation(true);
void MainWindow::on_actionViewResetLayout_triggered()
}
void Singleton::f7();{
    collect_ifaces(&global_capture_opts);
    CaptureFile::globalCapFile()->window = this;
    info_data_.ui.ui = this;
    if (capture_start(&global_capture_opts, &cap_session_, &info_data_, main_window_update)) {
        capture_options *capture_opts = cap_session_.capture_opts;
}
void Singleton::f8();{
    QByteArray conv_filter = conv_action->filter();
    if (conv_filter.isEmpty()) return;
    if (conv_action->isFilterValid(pinfo)) {
        df_combo_box_->lineEdit()->setText(conv_filter);
        df_combo_box_->applyDisplayFilter();
}
void Singleton::f9();{
    /* Making the menu context-sensitive allows for easier selection of the
       desired item and has the added benefit, with large captures, of
       avoiding needless looping through huge lists for marked, ignored,
       or time-referenced packets. */
    /* We have one or more items in the packet list */
}
void Singleton::f10();{
    case FilterAction::ActionTypePlain:
        new_filter = action_filter;
        break;
    case FilterAction::ActionTypeAnd:
        if (cur_filter.length()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    if (recent.gui_time_precision != tsp) {
        /* the actual precision will be set in packet_list_queue_draw() below */
        timestamp_set_precision(tsp);
        recent.gui_time_precision = tsp;
        if (packet_list_) {
}
void Singleton::f2();{
        main_ui_->actionCaptureStart->setChecked(false);
    }
void MainWindow::on_actionCaptureStop_triggered()
    stopCapture();
void MainWindow::on_actionCaptureRestart_triggered()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    if (recent.gui_time_precision != tsp) {
        /* the actual precision will be set in packet_list_queue_draw() below */
        timestamp_set_precision(tsp);
        recent.gui_time_precision = tsp;
        if (packet_list_) {
}
void Singleton::f2();{
        main_ui_->actionCaptureStart->setChecked(false);
    }
void MainWindow::on_actionCaptureStop_triggered()
    stopCapture();
void MainWindow::on_actionCaptureRestart_triggered()
}
void Singleton::f3();{
    {
        about_dialog->showNormal();
    }
    else
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    if (recent.gui_time_precision != tsp) {
        /* the actual precision will be set in packet_list_queue_draw() below */
        timestamp_set_precision(tsp);
        recent.gui_time_precision = tsp;
        if (packet_list_) {
}
void Singleton::f2();{
        main_ui_->actionCaptureStart->setChecked(false);
    }
void MainWindow::on_actionCaptureStop_triggered()
    stopCapture();
void MainWindow::on_actionCaptureRestart_triggered()
}
void Singleton::f3();{
    {
        about_dialog->showNormal();
    }
    else
    {
}
void Singleton::f4();{
                df_combo_box_->setCurrentIndex(index);
            }
        } else {
            df_combo_box_->lineEdit()->clear();
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    if (recent.gui_time_precision != tsp) {
        /* the actual precision will be set in packet_list_queue_draw() below */
        timestamp_set_precision(tsp);
        recent.gui_time_precision = tsp;
        if (packet_list_) {
}
void Singleton::f2();{
        main_ui_->actionCaptureStart->setChecked(false);
    }
void MainWindow::on_actionCaptureStop_triggered()
    stopCapture();
void MainWindow::on_actionCaptureRestart_triggered()
}
void Singleton::f3();{
    {
        about_dialog->showNormal();
    }
    else
    {
}
void Singleton::f4();{
                df_combo_box_->setCurrentIndex(index);
            }
        } else {
            df_combo_box_->lineEdit()->clear();
        }
}
void Singleton::f5();{
            captureFileOpened();
            break;
        case CaptureEvent::Closing:
            captureFileClosing();
            break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    if (recent.gui_time_precision != tsp) {
        /* the actual precision will be set in packet_list_queue_draw() below */
        timestamp_set_precision(tsp);
        recent.gui_time_precision = tsp;
        if (packet_list_) {
}
void Singleton::f2();{
        main_ui_->actionCaptureStart->setChecked(false);
    }
void MainWindow::on_actionCaptureStop_triggered()
    stopCapture();
void MainWindow::on_actionCaptureRestart_triggered()
}
void Singleton::f3();{
    {
        about_dialog->showNormal();
    }
    else
    {
}
void Singleton::f4();{
                df_combo_box_->setCurrentIndex(index);
            }
        } else {
            df_combo_box_->lineEdit()->clear();
        }
}
void Singleton::f5();{
            captureFileOpened();
            break;
        case CaptureEvent::Closing:
            captureFileClosing();
            break;
}
void Singleton::f6();{
    packet_list_->recolorPackets();
    setMenusForSelectedPacket();
void MainWindow::on_actionViewColorizeNewColoringRule_triggered()
    colorizeConversation(true);
void MainWindow::on_actionViewResetLayout_triggered()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    if (recent.gui_time_precision != tsp) {
        /* the actual precision will be set in packet_list_queue_draw() below */
        timestamp_set_precision(tsp);
        recent.gui_time_precision = tsp;
        if (packet_list_) {
}
void Singleton::f2();{
        main_ui_->actionCaptureStart->setChecked(false);
    }
void MainWindow::on_actionCaptureStop_triggered()
    stopCapture();
void MainWindow::on_actionCaptureRestart_triggered()
}
void Singleton::f3();{
    {
        about_dialog->showNormal();
    }
    else
    {
}
void Singleton::f4();{
                df_combo_box_->setCurrentIndex(index);
            }
        } else {
            df_combo_box_->lineEdit()->clear();
        }
}
void Singleton::f5();{
            captureFileOpened();
            break;
        case CaptureEvent::Closing:
            captureFileClosing();
            break;
}
void Singleton::f6();{
    packet_list_->recolorPackets();
    setMenusForSelectedPacket();
void MainWindow::on_actionViewColorizeNewColoringRule_triggered()
    colorizeConversation(true);
void MainWindow::on_actionViewResetLayout_triggered()
}
void Singleton::f7();{
    collect_ifaces(&global_capture_opts);
    CaptureFile::globalCapFile()->window = this;
    info_data_.ui.ui = this;
    if (capture_start(&global_capture_opts, &cap_session_, &info_data_, main_window_update)) {
        capture_options *capture_opts = cap_session_.capture_opts;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    if (recent.gui_time_precision != tsp) {
        /* the actual precision will be set in packet_list_queue_draw() below */
        timestamp_set_precision(tsp);
        recent.gui_time_precision = tsp;
        if (packet_list_) {
}
void Singleton::f2();{
        main_ui_->actionCaptureStart->setChecked(false);
    }
void MainWindow::on_actionCaptureStop_triggered()
    stopCapture();
void MainWindow::on_actionCaptureRestart_triggered()
}
void Singleton::f3();{
    {
        about_dialog->showNormal();
    }
    else
    {
}
void Singleton::f4();{
                df_combo_box_->setCurrentIndex(index);
            }
        } else {
            df_combo_box_->lineEdit()->clear();
        }
}
void Singleton::f5();{
            captureFileOpened();
            break;
        case CaptureEvent::Closing:
            captureFileClosing();
            break;
}
void Singleton::f6();{
    packet_list_->recolorPackets();
    setMenusForSelectedPacket();
void MainWindow::on_actionViewColorizeNewColoringRule_triggered()
    colorizeConversation(true);
void MainWindow::on_actionViewResetLayout_triggered()
}
void Singleton::f7();{
    collect_ifaces(&global_capture_opts);
    CaptureFile::globalCapFile()->window = this;
    info_data_.ui.ui = this;
    if (capture_start(&global_capture_opts, &cap_session_, &info_data_, main_window_update)) {
        capture_options *capture_opts = cap_session_.capture_opts;
}
void Singleton::f8();{
    QByteArray conv_filter = conv_action->filter();
    if (conv_filter.isEmpty()) return;
    if (conv_action->isFilterValid(pinfo)) {
        df_combo_box_->lineEdit()->setText(conv_filter);
        df_combo_box_->applyDisplayFilter();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    if (recent.gui_time_precision != tsp) {
        /* the actual precision will be set in packet_list_queue_draw() below */
        timestamp_set_precision(tsp);
        recent.gui_time_precision = tsp;
        if (packet_list_) {
}
void Singleton::f2();{
        main_ui_->actionCaptureStart->setChecked(false);
    }
void MainWindow::on_actionCaptureStop_triggered()
    stopCapture();
void MainWindow::on_actionCaptureRestart_triggered()
}
void Singleton::f3();{
    {
        about_dialog->showNormal();
    }
    else
    {
}
void Singleton::f4();{
                df_combo_box_->setCurrentIndex(index);
            }
        } else {
            df_combo_box_->lineEdit()->clear();
        }
}
void Singleton::f5();{
            captureFileOpened();
            break;
        case CaptureEvent::Closing:
            captureFileClosing();
            break;
}
void Singleton::f6();{
    packet_list_->recolorPackets();
    setMenusForSelectedPacket();
void MainWindow::on_actionViewColorizeNewColoringRule_triggered()
    colorizeConversation(true);
void MainWindow::on_actionViewResetLayout_triggered()
}
void Singleton::f7();{
    collect_ifaces(&global_capture_opts);
    CaptureFile::globalCapFile()->window = this;
    info_data_.ui.ui = this;
    if (capture_start(&global_capture_opts, &cap_session_, &info_data_, main_window_update)) {
        capture_options *capture_opts = cap_session_.capture_opts;
}
void Singleton::f8();{
    QByteArray conv_filter = conv_action->filter();
    if (conv_filter.isEmpty()) return;
    if (conv_action->isFilterValid(pinfo)) {
        df_combo_box_->lineEdit()->setText(conv_filter);
        df_combo_box_->applyDisplayFilter();
}
void Singleton::f9();{
    /* Making the menu context-sensitive allows for easier selection of the
       desired item and has the added benefit, with large captures, of
       avoiding needless looping through huge lists for marked, ignored,
       or time-referenced packets. */
    /* We have one or more items in the packet list */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        if (item->childCount() < 1) { // Leaf
            enable_remote_settings = true;
        } else {
            enable_del_remote = true;
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        if (item->childCount() < 1) { // Leaf
            enable_remote_settings = true;
        } else {
            enable_del_remote = true;
        }
}
void Singleton::f2();{
    gchar *descr, *auth_str;
    if_capabilities_t *caps;
    gint linktype_count;
    bool monitor_mode, found = false;
    GSList *curr_addr;
}
void Singleton::f3();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}
void Singleton::f4();{
    // Assume that our disclosure and checkbox controls are square, or at least fit within an em.
    int one_em = fontMetrics().height();
    ui->remoteList->setIndentation(one_em);
    ui->remoteList->setColumnWidth(col_r_show_, one_em * 4);
    ui->remoteSettings->setEnabled(false);
}
void Singleton::f5();{
        descr = capture_dev_user_descr_find(if_info->name);
        if (descr != NULL) {
            /* Yes, we have a user-supplied description; use it. */
            if_string = g_strdup_printf("%s: %s", descr, if_info->name);
            g_free(descr);
}
void Singleton::f6();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}
void Singleton::f7();{
    device.timestamp_type = g_strdup(global_capture_opts.default_options.timestamp_type);
    device.buffer       = DEFAULT_CAPTURE_BUFFER_SIZE;
    device.active_dlt = -1;
    device.if_info.name = g_strdup(device.name);
    device.if_info.type = IF_PIPE;
}
void Singleton::f8();{
            continue;
        capture_opts_free_interface_t(device);
        global_capture_opts.all_ifaces = g_array_remove_index(global_capture_opts.all_ifaces, i);
    }
    delete item;
}
void Singleton::f9();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f10();{
    gchar *descr, *auth_str;
    if_capabilities_t *caps;
    gint linktype_count;
    bool monitor_mode, found = false;
    GSList *curr_addr;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        if (item->childCount() < 1) { // Leaf
            enable_remote_settings = true;
        } else {
            enable_del_remote = true;
        }
}
void Singleton::f2();{
    gchar *descr, *auth_str;
    if_capabilities_t *caps;
    gint linktype_count;
    bool monitor_mode, found = false;
    GSList *curr_addr;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        if (item->childCount() < 1) { // Leaf
            enable_remote_settings = true;
        } else {
            enable_del_remote = true;
        }
}
void Singleton::f2();{
    gchar *descr, *auth_str;
    if_capabilities_t *caps;
    gint linktype_count;
    bool monitor_mode, found = false;
    GSList *curr_addr;
}
void Singleton::f3();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        if (item->childCount() < 1) { // Leaf
            enable_remote_settings = true;
        } else {
            enable_del_remote = true;
        }
}
void Singleton::f2();{
    gchar *descr, *auth_str;
    if_capabilities_t *caps;
    gint linktype_count;
    bool monitor_mode, found = false;
    GSList *curr_addr;
}
void Singleton::f3();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}
void Singleton::f4();{
    // Assume that our disclosure and checkbox controls are square, or at least fit within an em.
    int one_em = fontMetrics().height();
    ui->remoteList->setIndentation(one_em);
    ui->remoteList->setColumnWidth(col_r_show_, one_em * 4);
    ui->remoteSettings->setEnabled(false);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        if (item->childCount() < 1) { // Leaf
            enable_remote_settings = true;
        } else {
            enable_del_remote = true;
        }
}
void Singleton::f2();{
    gchar *descr, *auth_str;
    if_capabilities_t *caps;
    gint linktype_count;
    bool monitor_mode, found = false;
    GSList *curr_addr;
}
void Singleton::f3();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}
void Singleton::f4();{
    // Assume that our disclosure and checkbox controls are square, or at least fit within an em.
    int one_em = fontMetrics().height();
    ui->remoteList->setIndentation(one_em);
    ui->remoteList->setColumnWidth(col_r_show_, one_em * 4);
    ui->remoteSettings->setEnabled(false);
}
void Singleton::f5();{
        descr = capture_dev_user_descr_find(if_info->name);
        if (descr != NULL) {
            /* Yes, we have a user-supplied description; use it. */
            if_string = g_strdup_printf("%s: %s", descr, if_info->name);
            g_free(descr);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        if (item->childCount() < 1) { // Leaf
            enable_remote_settings = true;
        } else {
            enable_del_remote = true;
        }
}
void Singleton::f2();{
    gchar *descr, *auth_str;
    if_capabilities_t *caps;
    gint linktype_count;
    bool monitor_mode, found = false;
    GSList *curr_addr;
}
void Singleton::f3();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}
void Singleton::f4();{
    // Assume that our disclosure and checkbox controls are square, or at least fit within an em.
    int one_em = fontMetrics().height();
    ui->remoteList->setIndentation(one_em);
    ui->remoteList->setColumnWidth(col_r_show_, one_em * 4);
    ui->remoteSettings->setEnabled(false);
}
void Singleton::f5();{
        descr = capture_dev_user_descr_find(if_info->name);
        if (descr != NULL) {
            /* Yes, we have a user-supplied description; use it. */
            if_string = g_strdup_printf("%s: %s", descr, if_info->name);
            g_free(descr);
}
void Singleton::f6();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        if (item->childCount() < 1) { // Leaf
            enable_remote_settings = true;
        } else {
            enable_del_remote = true;
        }
}
void Singleton::f2();{
    gchar *descr, *auth_str;
    if_capabilities_t *caps;
    gint linktype_count;
    bool monitor_mode, found = false;
    GSList *curr_addr;
}
void Singleton::f3();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}
void Singleton::f4();{
    // Assume that our disclosure and checkbox controls are square, or at least fit within an em.
    int one_em = fontMetrics().height();
    ui->remoteList->setIndentation(one_em);
    ui->remoteList->setColumnWidth(col_r_show_, one_em * 4);
    ui->remoteSettings->setEnabled(false);
}
void Singleton::f5();{
        descr = capture_dev_user_descr_find(if_info->name);
        if (descr != NULL) {
            /* Yes, we have a user-supplied description; use it. */
            if_string = g_strdup_printf("%s: %s", descr, if_info->name);
            g_free(descr);
}
void Singleton::f6();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}
void Singleton::f7();{
    device.timestamp_type = g_strdup(global_capture_opts.default_options.timestamp_type);
    device.buffer       = DEFAULT_CAPTURE_BUFFER_SIZE;
    device.active_dlt = -1;
    device.if_info.name = g_strdup(device.name);
    device.if_info.type = IF_PIPE;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        if (item->childCount() < 1) { // Leaf
            enable_remote_settings = true;
        } else {
            enable_del_remote = true;
        }
}
void Singleton::f2();{
    gchar *descr, *auth_str;
    if_capabilities_t *caps;
    gint linktype_count;
    bool monitor_mode, found = false;
    GSList *curr_addr;
}
void Singleton::f3();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}
void Singleton::f4();{
    // Assume that our disclosure and checkbox controls are square, or at least fit within an em.
    int one_em = fontMetrics().height();
    ui->remoteList->setIndentation(one_em);
    ui->remoteList->setColumnWidth(col_r_show_, one_em * 4);
    ui->remoteSettings->setEnabled(false);
}
void Singleton::f5();{
        descr = capture_dev_user_descr_find(if_info->name);
        if (descr != NULL) {
            /* Yes, we have a user-supplied description; use it. */
            if_string = g_strdup_printf("%s: %s", descr, if_info->name);
            g_free(descr);
}
void Singleton::f6();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}
void Singleton::f7();{
    device.timestamp_type = g_strdup(global_capture_opts.default_options.timestamp_type);
    device.buffer       = DEFAULT_CAPTURE_BUFFER_SIZE;
    device.active_dlt = -1;
    device.if_info.name = g_strdup(device.name);
    device.if_info.type = IF_PIPE;
}
void Singleton::f8();{
            continue;
        capture_opts_free_interface_t(device);
        global_capture_opts.all_ifaces = g_array_remove_index(global_capture_opts.all_ifaces, i);
    }
    delete item;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        if (item->childCount() < 1) { // Leaf
            enable_remote_settings = true;
        } else {
            enable_del_remote = true;
        }
}
void Singleton::f2();{
    gchar *descr, *auth_str;
    if_capabilities_t *caps;
    gint linktype_count;
    bool monitor_mode, found = false;
    GSList *curr_addr;
}
void Singleton::f3();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}
void Singleton::f4();{
    // Assume that our disclosure and checkbox controls are square, or at least fit within an em.
    int one_em = fontMetrics().height();
    ui->remoteList->setIndentation(one_em);
    ui->remoteList->setColumnWidth(col_r_show_, one_em * 4);
    ui->remoteSettings->setEnabled(false);
}
void Singleton::f5();{
        descr = capture_dev_user_descr_find(if_info->name);
        if (descr != NULL) {
            /* Yes, we have a user-supplied description; use it. */
            if_string = g_strdup_printf("%s: %s", descr, if_info->name);
            g_free(descr);
}
void Singleton::f6();{
    device.selected     = TRUE;
    device.pmode        = global_capture_opts.default_options.promisc_mode;
    device.has_snaplen  = global_capture_opts.default_options.has_snaplen;
    device.snaplen      = global_capture_opts.default_options.snaplen;
    device.cfilter      = g_strdup(global_capture_opts.default_options.cfilter);
}
void Singleton::f7();{
    device.timestamp_type = g_strdup(global_capture_opts.default_options.timestamp_type);
    device.buffer       = DEFAULT_CAPTURE_BUFFER_SIZE;
    device.active_dlt = -1;
    device.if_info.name = g_strdup(device.name);
    device.if_info.type = IF_PIPE;
}
void Singleton::f8();{
            continue;
        capture_opts_free_interface_t(device);
        global_capture_opts.all_ifaces = g_array_remove_index(global_capture_opts.all_ifaces, i);
    }
    delete item;
}
void Singleton::f9();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                                                 ThriftFastBinaryMethods,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL};
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                                                 ThriftFastBinaryMethods,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL};
}
void Singleton::f2();{
    return NULL;
  return protocol.getEncodedValue();
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
}
void Singleton::f3();{
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
// TODO(dreiss): Why do we need cStringIO for reading, why not just char*?
}
void Singleton::f4();{
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
}
void Singleton::f5();{
  if (INT_CONV_ERROR_OCCURRED(v)) {
    PyErr_Clear();
    return default_value;
  return v;
template <typename T>
}
void Singleton::f6();{
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
}
void Singleton::f7();{
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
  if (INT_CONV_ERROR_OCCURRED(v)) {
    PyErr_Clear();
}
void Singleton::f8();{
    if (!INTERN_STRING(value))                                                                     \
      INITERROR                                                                                    \
  } while (0)
  INIT_INTERN_STRING(TFrozenDict);
  INIT_INTERN_STRING(cstringio_buf);
}
void Singleton::f9();{
  return protocol.getEncodedValue();
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
  if (INT_CONV_ERROR_OCCURRED(v)) {
}
void Singleton::f10();{
/* -- PYTHON MODULE SETUP STUFF --- */
extern "C" {
static PyObject* encode_binary(PyObject*, PyObject* args) {
  return encode_impl<BinaryProtocol>(args);
static PyObject* decode_binary(PyObject*, PyObject* args) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                                                 ThriftFastBinaryMethods,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL};
}
void Singleton::f2();{
    return NULL;
  return protocol.getEncodedValue();
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                                                 ThriftFastBinaryMethods,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL};
}
void Singleton::f2();{
    return NULL;
  return protocol.getEncodedValue();
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
}
void Singleton::f3();{
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
// TODO(dreiss): Why do we need cStringIO for reading, why not just char*?
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                                                 ThriftFastBinaryMethods,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL};
}
void Singleton::f2();{
    return NULL;
  return protocol.getEncodedValue();
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
}
void Singleton::f3();{
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
// TODO(dreiss): Why do we need cStringIO for reading, why not just char*?
}
void Singleton::f4();{
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                                                 ThriftFastBinaryMethods,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL};
}
void Singleton::f2();{
    return NULL;
  return protocol.getEncodedValue();
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
}
void Singleton::f3();{
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
// TODO(dreiss): Why do we need cStringIO for reading, why not just char*?
}
void Singleton::f4();{
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
}
void Singleton::f5();{
  if (INT_CONV_ERROR_OCCURRED(v)) {
    PyErr_Clear();
    return default_value;
  return v;
template <typename T>
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                                                 ThriftFastBinaryMethods,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL};
}
void Singleton::f2();{
    return NULL;
  return protocol.getEncodedValue();
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
}
void Singleton::f3();{
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
// TODO(dreiss): Why do we need cStringIO for reading, why not just char*?
}
void Singleton::f4();{
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
}
void Singleton::f5();{
  if (INT_CONV_ERROR_OCCURRED(v)) {
    PyErr_Clear();
    return default_value;
  return v;
template <typename T>
}
void Singleton::f6();{
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                                                 ThriftFastBinaryMethods,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL};
}
void Singleton::f2();{
    return NULL;
  return protocol.getEncodedValue();
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
}
void Singleton::f3();{
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
// TODO(dreiss): Why do we need cStringIO for reading, why not just char*?
}
void Singleton::f4();{
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
}
void Singleton::f5();{
  if (INT_CONV_ERROR_OCCURRED(v)) {
    PyErr_Clear();
    return default_value;
  return v;
template <typename T>
}
void Singleton::f6();{
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
}
void Singleton::f7();{
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
  if (INT_CONV_ERROR_OCCURRED(v)) {
    PyErr_Clear();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                                                 ThriftFastBinaryMethods,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL};
}
void Singleton::f2();{
    return NULL;
  return protocol.getEncodedValue();
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
}
void Singleton::f3();{
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
// TODO(dreiss): Why do we need cStringIO for reading, why not just char*?
}
void Singleton::f4();{
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
}
void Singleton::f5();{
  if (INT_CONV_ERROR_OCCURRED(v)) {
    PyErr_Clear();
    return default_value;
  return v;
template <typename T>
}
void Singleton::f6();{
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
}
void Singleton::f7();{
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
  if (INT_CONV_ERROR_OCCURRED(v)) {
    PyErr_Clear();
}
void Singleton::f8();{
    if (!INTERN_STRING(value))                                                                     \
      INITERROR                                                                                    \
  } while (0)
  INIT_INTERN_STRING(TFrozenDict);
  INIT_INTERN_STRING(cstringio_buf);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                                                 ThriftFastBinaryMethods,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL};
}
void Singleton::f2();{
    return NULL;
  return protocol.getEncodedValue();
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
}
void Singleton::f3();{
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
// TODO(dreiss): Why do we need cStringIO for reading, why not just char*?
}
void Singleton::f4();{
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
}
void Singleton::f5();{
  if (INT_CONV_ERROR_OCCURRED(v)) {
    PyErr_Clear();
    return default_value;
  return v;
template <typename T>
}
void Singleton::f6();{
 * specific language governing permissions and limitations
 * under the License.
// TODO(dreiss): defval appears to be unused.  Look into removing it.
// TODO(dreiss): Make parse_spec_args recursive, and cache the output
//               permanently in the object.  (Malloc and orphan.)
}
void Singleton::f7();{
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
  if (INT_CONV_ERROR_OCCURRED(v)) {
    PyErr_Clear();
}
void Singleton::f8();{
    if (!INTERN_STRING(value))                                                                     \
      INITERROR                                                                                    \
  } while (0)
  INIT_INTERN_STRING(TFrozenDict);
  INIT_INTERN_STRING(cstringio_buf);
}
void Singleton::f9();{
  return protocol.getEncodedValue();
static inline long as_long_then_delete(PyObject* value, long default_value) {
  ScopedPyObject scope(value);
  long v = PyInt_AsLong(value);
  if (INT_CONV_ERROR_OCCURRED(v)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    case PREF_SAVE_FILENAME:
    case PREF_OPEN_FILENAME:
    case PREF_DIRNAME:
    {
        QLabel *label = new QLabel(prefs_get_title(pref));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    case PREF_SAVE_FILENAME:
    case PREF_OPEN_FILENAME:
    case PREF_DIRNAME:
    {
        QLabel *label = new QLabel(prefs_get_title(pref));
}
void Singleton::f2();{
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
    }
void ModulePreferencesScrollArea::dirnamePushButtonClicked()
}
void Singleton::f3();{
            break;
        }
    }
    foreach (QCheckBox *cb, findChildren<QCheckBox *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(cb->property(pref_prop_));
}
void Singleton::f4();{
    {
        QHBoxLayout *hb = new QHBoxLayout();
        QLabel *label = new QLabel(prefs_get_title(pref));
        label->setToolTip(tooltip);
        hb->addWidget(label);
}
void Singleton::f5();{
    {
        QCheckBox *bool_cb = new QCheckBox(title_to_shortcut(prefs_get_title(pref)));
        bool_cb->setToolTip(tooltip);
        bool_cb->setProperty(pref_prop_, VariantPointer<pref_t>::asQVariant(pref));
        vb->addWidget(bool_cb);
}
void Singleton::f6();{
    foreach (QPushButton *pb, findChildren<QPushButton *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(pb->property(pref_prop_));
        if (!pref) continue;
        switch (prefs_get_type(pref)) {
        case PREF_UAT:
}
void Singleton::f7();{
    QString shortcut_str(title);
    shortcut_str.replace('&', "&&");
    return shortcut_str;
extern "C" {
// Callbacks prefs routines
}
void Singleton::f8();{
    QString filename = WiresharkFileDialog::getOpenFileName(this, wsApp->windowTitleString(prefs_get_title(pref)),
                                                    prefs_get_string_value(pref, pref_stashed));
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
}
void Singleton::f9();{
    foreach (QCheckBox *cb, findChildren<QCheckBox *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(cb->property(pref_prop_));
        if (!pref) continue;
        if (prefs_get_type(pref) == PREF_BOOL) {
            cb->setChecked(prefs_get_bool_value(pref, pref_stashed));
}
void Singleton::f10();{
    {
        QHBoxLayout *hb = new QHBoxLayout();
        QLabel *label = new QLabel(prefs_get_title(pref));
        label->setToolTip(tooltip);
        hb->addWidget(label);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    case PREF_SAVE_FILENAME:
    case PREF_OPEN_FILENAME:
    case PREF_DIRNAME:
    {
        QLabel *label = new QLabel(prefs_get_title(pref));
}
void Singleton::f2();{
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
    }
void ModulePreferencesScrollArea::dirnamePushButtonClicked()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    case PREF_SAVE_FILENAME:
    case PREF_OPEN_FILENAME:
    case PREF_DIRNAME:
    {
        QLabel *label = new QLabel(prefs_get_title(pref));
}
void Singleton::f2();{
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
    }
void ModulePreferencesScrollArea::dirnamePushButtonClicked()
}
void Singleton::f3();{
            break;
        }
    }
    foreach (QCheckBox *cb, findChildren<QCheckBox *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(cb->property(pref_prop_));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    case PREF_SAVE_FILENAME:
    case PREF_OPEN_FILENAME:
    case PREF_DIRNAME:
    {
        QLabel *label = new QLabel(prefs_get_title(pref));
}
void Singleton::f2();{
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
    }
void ModulePreferencesScrollArea::dirnamePushButtonClicked()
}
void Singleton::f3();{
            break;
        }
    }
    foreach (QCheckBox *cb, findChildren<QCheckBox *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(cb->property(pref_prop_));
}
void Singleton::f4();{
    {
        QHBoxLayout *hb = new QHBoxLayout();
        QLabel *label = new QLabel(prefs_get_title(pref));
        label->setToolTip(tooltip);
        hb->addWidget(label);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    case PREF_SAVE_FILENAME:
    case PREF_OPEN_FILENAME:
    case PREF_DIRNAME:
    {
        QLabel *label = new QLabel(prefs_get_title(pref));
}
void Singleton::f2();{
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
    }
void ModulePreferencesScrollArea::dirnamePushButtonClicked()
}
void Singleton::f3();{
            break;
        }
    }
    foreach (QCheckBox *cb, findChildren<QCheckBox *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(cb->property(pref_prop_));
}
void Singleton::f4();{
    {
        QHBoxLayout *hb = new QHBoxLayout();
        QLabel *label = new QLabel(prefs_get_title(pref));
        label->setToolTip(tooltip);
        hb->addWidget(label);
}
void Singleton::f5();{
    {
        QCheckBox *bool_cb = new QCheckBox(title_to_shortcut(prefs_get_title(pref)));
        bool_cb->setToolTip(tooltip);
        bool_cb->setProperty(pref_prop_, VariantPointer<pref_t>::asQVariant(pref));
        vb->addWidget(bool_cb);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    case PREF_SAVE_FILENAME:
    case PREF_OPEN_FILENAME:
    case PREF_DIRNAME:
    {
        QLabel *label = new QLabel(prefs_get_title(pref));
}
void Singleton::f2();{
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
    }
void ModulePreferencesScrollArea::dirnamePushButtonClicked()
}
void Singleton::f3();{
            break;
        }
    }
    foreach (QCheckBox *cb, findChildren<QCheckBox *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(cb->property(pref_prop_));
}
void Singleton::f4();{
    {
        QHBoxLayout *hb = new QHBoxLayout();
        QLabel *label = new QLabel(prefs_get_title(pref));
        label->setToolTip(tooltip);
        hb->addWidget(label);
}
void Singleton::f5();{
    {
        QCheckBox *bool_cb = new QCheckBox(title_to_shortcut(prefs_get_title(pref)));
        bool_cb->setToolTip(tooltip);
        bool_cb->setProperty(pref_prop_, VariantPointer<pref_t>::asQVariant(pref));
        vb->addWidget(bool_cb);
}
void Singleton::f6();{
    foreach (QPushButton *pb, findChildren<QPushButton *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(pb->property(pref_prop_));
        if (!pref) continue;
        switch (prefs_get_type(pref)) {
        case PREF_UAT:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    case PREF_SAVE_FILENAME:
    case PREF_OPEN_FILENAME:
    case PREF_DIRNAME:
    {
        QLabel *label = new QLabel(prefs_get_title(pref));
}
void Singleton::f2();{
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
    }
void ModulePreferencesScrollArea::dirnamePushButtonClicked()
}
void Singleton::f3();{
            break;
        }
    }
    foreach (QCheckBox *cb, findChildren<QCheckBox *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(cb->property(pref_prop_));
}
void Singleton::f4();{
    {
        QHBoxLayout *hb = new QHBoxLayout();
        QLabel *label = new QLabel(prefs_get_title(pref));
        label->setToolTip(tooltip);
        hb->addWidget(label);
}
void Singleton::f5();{
    {
        QCheckBox *bool_cb = new QCheckBox(title_to_shortcut(prefs_get_title(pref)));
        bool_cb->setToolTip(tooltip);
        bool_cb->setProperty(pref_prop_, VariantPointer<pref_t>::asQVariant(pref));
        vb->addWidget(bool_cb);
}
void Singleton::f6();{
    foreach (QPushButton *pb, findChildren<QPushButton *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(pb->property(pref_prop_));
        if (!pref) continue;
        switch (prefs_get_type(pref)) {
        case PREF_UAT:
}
void Singleton::f7();{
    QString shortcut_str(title);
    shortcut_str.replace('&', "&&");
    return shortcut_str;
extern "C" {
// Callbacks prefs routines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    case PREF_SAVE_FILENAME:
    case PREF_OPEN_FILENAME:
    case PREF_DIRNAME:
    {
        QLabel *label = new QLabel(prefs_get_title(pref));
}
void Singleton::f2();{
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
    }
void ModulePreferencesScrollArea::dirnamePushButtonClicked()
}
void Singleton::f3();{
            break;
        }
    }
    foreach (QCheckBox *cb, findChildren<QCheckBox *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(cb->property(pref_prop_));
}
void Singleton::f4();{
    {
        QHBoxLayout *hb = new QHBoxLayout();
        QLabel *label = new QLabel(prefs_get_title(pref));
        label->setToolTip(tooltip);
        hb->addWidget(label);
}
void Singleton::f5();{
    {
        QCheckBox *bool_cb = new QCheckBox(title_to_shortcut(prefs_get_title(pref)));
        bool_cb->setToolTip(tooltip);
        bool_cb->setProperty(pref_prop_, VariantPointer<pref_t>::asQVariant(pref));
        vb->addWidget(bool_cb);
}
void Singleton::f6();{
    foreach (QPushButton *pb, findChildren<QPushButton *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(pb->property(pref_prop_));
        if (!pref) continue;
        switch (prefs_get_type(pref)) {
        case PREF_UAT:
}
void Singleton::f7();{
    QString shortcut_str(title);
    shortcut_str.replace('&', "&&");
    return shortcut_str;
extern "C" {
// Callbacks prefs routines
}
void Singleton::f8();{
    QString filename = WiresharkFileDialog::getOpenFileName(this, wsApp->windowTitleString(prefs_get_title(pref)),
                                                    prefs_get_string_value(pref, pref_stashed));
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    case PREF_SAVE_FILENAME:
    case PREF_OPEN_FILENAME:
    case PREF_DIRNAME:
    {
        QLabel *label = new QLabel(prefs_get_title(pref));
}
void Singleton::f2();{
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
    }
void ModulePreferencesScrollArea::dirnamePushButtonClicked()
}
void Singleton::f3();{
            break;
        }
    }
    foreach (QCheckBox *cb, findChildren<QCheckBox *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(cb->property(pref_prop_));
}
void Singleton::f4();{
    {
        QHBoxLayout *hb = new QHBoxLayout();
        QLabel *label = new QLabel(prefs_get_title(pref));
        label->setToolTip(tooltip);
        hb->addWidget(label);
}
void Singleton::f5();{
    {
        QCheckBox *bool_cb = new QCheckBox(title_to_shortcut(prefs_get_title(pref)));
        bool_cb->setToolTip(tooltip);
        bool_cb->setProperty(pref_prop_, VariantPointer<pref_t>::asQVariant(pref));
        vb->addWidget(bool_cb);
}
void Singleton::f6();{
    foreach (QPushButton *pb, findChildren<QPushButton *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(pb->property(pref_prop_));
        if (!pref) continue;
        switch (prefs_get_type(pref)) {
        case PREF_UAT:
}
void Singleton::f7();{
    QString shortcut_str(title);
    shortcut_str.replace('&', "&&");
    return shortcut_str;
extern "C" {
// Callbacks prefs routines
}
void Singleton::f8();{
    QString filename = WiresharkFileDialog::getOpenFileName(this, wsApp->windowTitleString(prefs_get_title(pref)),
                                                    prefs_get_string_value(pref, pref_stashed));
    if (!filename.isEmpty()) {
        prefs_set_string_value(pref, QDir::toNativeSeparators(filename).toStdString().c_str(), pref_stashed);
        updateWidgets();
}
void Singleton::f9();{
    foreach (QCheckBox *cb, findChildren<QCheckBox *>()) {
        pref_t *pref = VariantPointer<pref_t>::asPtr(cb->property(pref_prop_));
        if (!pref) continue;
        if (prefs_get_type(pref) == PREF_BOOL) {
            cb->setChecked(prefs_get_bool_value(pref, pref_stashed));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        << table_vheader_tmpl.arg(tr("Total MSUs"))
        << table_data_tmpl.arg(total_msus)
        << table_row_end;
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("MSUs/s"))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        << table_vheader_tmpl.arg(tr("Total MSUs"))
        << table_data_tmpl.arg(total_msus)
        << table_row_end;
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("MSUs/s"))
}
void Singleton::f2();{
    }
    // count
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("Packets"))
        << table_data_tmpl.arg(summary.packet_count)
}
void Singleton::f3();{
    section_tmpl = "<p><strong>%1</strong></p>\n";
    table_begin = "<p><table>\n";
    table_end = "</table></p>\n";
    table_row_begin = "<tr>\n";
    table_ul_row_begin = "<tr style=\"border-bottom: 1px solid gray;\">\n";
}
void Singleton::f4();{
    WiresharkDialog(parent, capture_file),
    ui(new Ui::Mtp3SummaryDialog)
    ui->setupUi(this);
    setWindowSubtitle(tr("MTP3 Summary"));
    updateWidgets();
}
void Singleton::f5();{
    mtp3_stat_si_code_t		mtp3_si_code[MTP3_NUM_SI_CODE];
} mtp3_stat_t;
static mtp3_stat_t mtp3_stat[MTP3_MAX_NUM_OPC_DPC];
static size_t mtp3_num_used;
Mtp3SummaryDialog::Mtp3SummaryDialog(QWidget &parent, CaptureFile &capture_file) :
}
void Singleton::f6();{
    out << section_tmpl.arg(tr("Service Indicator (SI) Totals"));
    out << table_begin;
    out << table_row_begin
        << table_hheader25_tmpl.arg(tr("SI"))
        << table_hheader15_tmpl.arg(tr("MSUs"))
}
void Singleton::f7();{
            {
                elapsed_str = QString("%1 days ").arg(elapsed_time / 86400);
            }
            elapsed_str += QString("%1:%2:%3")
                    .arg(elapsed_time % 86400 / 3600, 2, 10, QChar('0'))
}
void Singleton::f8();{
    int			size;
} mtp3_stat_si_code_t;
typedef struct _mtp3_stat_t {
    mtp3_addr_pc_t		addr_opc;
    mtp3_addr_pc_t		addr_dpc;
}
void Singleton::f9();{
    out << table_end;
    // Data Section
    out << section_tmpl.arg(tr("Data"));
    out << table_begin;
    if (summary.packet_count_ts == summary.packet_count &&
}
void Singleton::f10();{
    int total_msus = 0;
    int total_bytes = 0;
    double seconds = summary.stop_time - summary.start_time;
    // SI Section
    out << section_tmpl.arg(tr("Service Indicator (SI) Totals"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        << table_vheader_tmpl.arg(tr("Total MSUs"))
        << table_data_tmpl.arg(total_msus)
        << table_row_end;
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("MSUs/s"))
}
void Singleton::f2();{
    }
    // count
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("Packets"))
        << table_data_tmpl.arg(summary.packet_count)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        << table_vheader_tmpl.arg(tr("Total MSUs"))
        << table_data_tmpl.arg(total_msus)
        << table_row_end;
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("MSUs/s"))
}
void Singleton::f2();{
    }
    // count
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("Packets"))
        << table_data_tmpl.arg(summary.packet_count)
}
void Singleton::f3();{
    section_tmpl = "<p><strong>%1</strong></p>\n";
    table_begin = "<p><table>\n";
    table_end = "</table></p>\n";
    table_row_begin = "<tr>\n";
    table_ul_row_begin = "<tr style=\"border-bottom: 1px solid gray;\">\n";
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        << table_vheader_tmpl.arg(tr("Total MSUs"))
        << table_data_tmpl.arg(total_msus)
        << table_row_end;
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("MSUs/s"))
}
void Singleton::f2();{
    }
    // count
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("Packets"))
        << table_data_tmpl.arg(summary.packet_count)
}
void Singleton::f3();{
    section_tmpl = "<p><strong>%1</strong></p>\n";
    table_begin = "<p><table>\n";
    table_end = "</table></p>\n";
    table_row_begin = "<tr>\n";
    table_ul_row_begin = "<tr style=\"border-bottom: 1px solid gray;\">\n";
}
void Singleton::f4();{
    WiresharkDialog(parent, capture_file),
    ui(new Ui::Mtp3SummaryDialog)
    ui->setupUi(this);
    setWindowSubtitle(tr("MTP3 Summary"));
    updateWidgets();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        << table_vheader_tmpl.arg(tr("Total MSUs"))
        << table_data_tmpl.arg(total_msus)
        << table_row_end;
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("MSUs/s"))
}
void Singleton::f2();{
    }
    // count
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("Packets"))
        << table_data_tmpl.arg(summary.packet_count)
}
void Singleton::f3();{
    section_tmpl = "<p><strong>%1</strong></p>\n";
    table_begin = "<p><table>\n";
    table_end = "</table></p>\n";
    table_row_begin = "<tr>\n";
    table_ul_row_begin = "<tr style=\"border-bottom: 1px solid gray;\">\n";
}
void Singleton::f4();{
    WiresharkDialog(parent, capture_file),
    ui(new Ui::Mtp3SummaryDialog)
    ui->setupUi(this);
    setWindowSubtitle(tr("MTP3 Summary"));
    updateWidgets();
}
void Singleton::f5();{
    mtp3_stat_si_code_t		mtp3_si_code[MTP3_NUM_SI_CODE];
} mtp3_stat_t;
static mtp3_stat_t mtp3_stat[MTP3_MAX_NUM_OPC_DPC];
static size_t mtp3_num_used;
Mtp3SummaryDialog::Mtp3SummaryDialog(QWidget &parent, CaptureFile &capture_file) :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        << table_vheader_tmpl.arg(tr("Total MSUs"))
        << table_data_tmpl.arg(total_msus)
        << table_row_end;
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("MSUs/s"))
}
void Singleton::f2();{
    }
    // count
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("Packets"))
        << table_data_tmpl.arg(summary.packet_count)
}
void Singleton::f3();{
    section_tmpl = "<p><strong>%1</strong></p>\n";
    table_begin = "<p><table>\n";
    table_end = "</table></p>\n";
    table_row_begin = "<tr>\n";
    table_ul_row_begin = "<tr style=\"border-bottom: 1px solid gray;\">\n";
}
void Singleton::f4();{
    WiresharkDialog(parent, capture_file),
    ui(new Ui::Mtp3SummaryDialog)
    ui->setupUi(this);
    setWindowSubtitle(tr("MTP3 Summary"));
    updateWidgets();
}
void Singleton::f5();{
    mtp3_stat_si_code_t		mtp3_si_code[MTP3_NUM_SI_CODE];
} mtp3_stat_t;
static mtp3_stat_t mtp3_stat[MTP3_MAX_NUM_OPC_DPC];
static size_t mtp3_num_used;
Mtp3SummaryDialog::Mtp3SummaryDialog(QWidget &parent, CaptureFile &capture_file) :
}
void Singleton::f6();{
    out << section_tmpl.arg(tr("Service Indicator (SI) Totals"));
    out << table_begin;
    out << table_row_begin
        << table_hheader25_tmpl.arg(tr("SI"))
        << table_hheader15_tmpl.arg(tr("MSUs"))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        << table_vheader_tmpl.arg(tr("Total MSUs"))
        << table_data_tmpl.arg(total_msus)
        << table_row_end;
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("MSUs/s"))
}
void Singleton::f2();{
    }
    // count
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("Packets"))
        << table_data_tmpl.arg(summary.packet_count)
}
void Singleton::f3();{
    section_tmpl = "<p><strong>%1</strong></p>\n";
    table_begin = "<p><table>\n";
    table_end = "</table></p>\n";
    table_row_begin = "<tr>\n";
    table_ul_row_begin = "<tr style=\"border-bottom: 1px solid gray;\">\n";
}
void Singleton::f4();{
    WiresharkDialog(parent, capture_file),
    ui(new Ui::Mtp3SummaryDialog)
    ui->setupUi(this);
    setWindowSubtitle(tr("MTP3 Summary"));
    updateWidgets();
}
void Singleton::f5();{
    mtp3_stat_si_code_t		mtp3_si_code[MTP3_NUM_SI_CODE];
} mtp3_stat_t;
static mtp3_stat_t mtp3_stat[MTP3_MAX_NUM_OPC_DPC];
static size_t mtp3_num_used;
Mtp3SummaryDialog::Mtp3SummaryDialog(QWidget &parent, CaptureFile &capture_file) :
}
void Singleton::f6();{
    out << section_tmpl.arg(tr("Service Indicator (SI) Totals"));
    out << table_begin;
    out << table_row_begin
        << table_hheader25_tmpl.arg(tr("SI"))
        << table_hheader15_tmpl.arg(tr("MSUs"))
}
void Singleton::f7();{
            {
                elapsed_str = QString("%1 days ").arg(elapsed_time / 86400);
            }
            elapsed_str += QString("%1:%2:%3")
                    .arg(elapsed_time % 86400 / 3600, 2, 10, QChar('0'))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        << table_vheader_tmpl.arg(tr("Total MSUs"))
        << table_data_tmpl.arg(total_msus)
        << table_row_end;
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("MSUs/s"))
}
void Singleton::f2();{
    }
    // count
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("Packets"))
        << table_data_tmpl.arg(summary.packet_count)
}
void Singleton::f3();{
    section_tmpl = "<p><strong>%1</strong></p>\n";
    table_begin = "<p><table>\n";
    table_end = "</table></p>\n";
    table_row_begin = "<tr>\n";
    table_ul_row_begin = "<tr style=\"border-bottom: 1px solid gray;\">\n";
}
void Singleton::f4();{
    WiresharkDialog(parent, capture_file),
    ui(new Ui::Mtp3SummaryDialog)
    ui->setupUi(this);
    setWindowSubtitle(tr("MTP3 Summary"));
    updateWidgets();
}
void Singleton::f5();{
    mtp3_stat_si_code_t		mtp3_si_code[MTP3_NUM_SI_CODE];
} mtp3_stat_t;
static mtp3_stat_t mtp3_stat[MTP3_MAX_NUM_OPC_DPC];
static size_t mtp3_num_used;
Mtp3SummaryDialog::Mtp3SummaryDialog(QWidget &parent, CaptureFile &capture_file) :
}
void Singleton::f6();{
    out << section_tmpl.arg(tr("Service Indicator (SI) Totals"));
    out << table_begin;
    out << table_row_begin
        << table_hheader25_tmpl.arg(tr("SI"))
        << table_hheader15_tmpl.arg(tr("MSUs"))
}
void Singleton::f7();{
            {
                elapsed_str = QString("%1 days ").arg(elapsed_time / 86400);
            }
            elapsed_str += QString("%1:%2:%3")
                    .arg(elapsed_time % 86400 / 3600, 2, 10, QChar('0'))
}
void Singleton::f8();{
    int			size;
} mtp3_stat_si_code_t;
typedef struct _mtp3_stat_t {
    mtp3_addr_pc_t		addr_opc;
    mtp3_addr_pc_t		addr_dpc;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        << table_vheader_tmpl.arg(tr("Total MSUs"))
        << table_data_tmpl.arg(total_msus)
        << table_row_end;
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("MSUs/s"))
}
void Singleton::f2();{
    }
    // count
    out << table_row_begin
        << table_vheader_tmpl.arg(tr("Packets"))
        << table_data_tmpl.arg(summary.packet_count)
}
void Singleton::f3();{
    section_tmpl = "<p><strong>%1</strong></p>\n";
    table_begin = "<p><table>\n";
    table_end = "</table></p>\n";
    table_row_begin = "<tr>\n";
    table_ul_row_begin = "<tr style=\"border-bottom: 1px solid gray;\">\n";
}
void Singleton::f4();{
    WiresharkDialog(parent, capture_file),
    ui(new Ui::Mtp3SummaryDialog)
    ui->setupUi(this);
    setWindowSubtitle(tr("MTP3 Summary"));
    updateWidgets();
}
void Singleton::f5();{
    mtp3_stat_si_code_t		mtp3_si_code[MTP3_NUM_SI_CODE];
} mtp3_stat_t;
static mtp3_stat_t mtp3_stat[MTP3_MAX_NUM_OPC_DPC];
static size_t mtp3_num_used;
Mtp3SummaryDialog::Mtp3SummaryDialog(QWidget &parent, CaptureFile &capture_file) :
}
void Singleton::f6();{
    out << section_tmpl.arg(tr("Service Indicator (SI) Totals"));
    out << table_begin;
    out << table_row_begin
        << table_hheader25_tmpl.arg(tr("SI"))
        << table_hheader15_tmpl.arg(tr("MSUs"))
}
void Singleton::f7();{
            {
                elapsed_str = QString("%1 days ").arg(elapsed_time / 86400);
            }
            elapsed_str += QString("%1:%2:%3")
                    .arg(elapsed_time % 86400 / 3600, 2, 10, QChar('0'))
}
void Singleton::f8();{
    int			size;
} mtp3_stat_si_code_t;
typedef struct _mtp3_stat_t {
    mtp3_addr_pc_t		addr_opc;
    mtp3_addr_pc_t		addr_dpc;
}
void Singleton::f9();{
    out << table_end;
    // Data Section
    out << section_tmpl.arg(tr("Data"));
    out << table_begin;
    if (summary.packet_count_ts == summary.packet_count &&
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        setText(col_max_buffers_, bits_s_to_qstring(top_buff_usage_));
        setText(col_buffer_alarms_, QString::number(num_buff_alarms_));
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        setText(col_max_buffers_, bits_s_to_qstring(top_buff_usage_));
        setText(col_buffer_alarms_, QString::number(num_buff_alarms_));
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
}
void Singleton::f2();{
    else {
        return QList<QVariant>();
    }
const QString MulticastStatisticsDialog::filterExpression()
    QString filter_expr;
}
void Singleton::f3();{
            << line_edits_ << displayFilterLineEdit() << applyFilterButton();
    foreach (QWidget *w, disable_widgets) w->setEnabled(false);
    /* Scan for Mcast streams (redissect all packets) */
    mcaststream_scan(tapinfo_, cap_file_.capFile());
    tapDraw(tapinfo_);
}
void Singleton::f4();{
        setText(col_packets_, QString::number(num_packets_));
        setText(col_packets_s_, QString::number(avg_pps_, 'f', 2));
        setText(col_avg_bw_, bits_s_to_qstring(avg_bw_));
        setText(col_max_bw_, bits_s_to_qstring(max_bw_));
        setText(col_max_burst_, QString("%1 / %2ms").arg(top_burst_size_).arg(mcast_stream_burstint));
}
void Singleton::f5();{
    } else {
        stream_empty_speed_le_->setSyntaxState(SyntaxLineEdit::Valid);
    }
    param = total_empty_speed_le_->text().toInt(&ok);
    if (!ok || param < 1 || param > 10000000) {
}
void Singleton::f6();{
        QString ip_version;
        if (src_addr_.type == AT_IPv6) ip_version = "v6";
        const QString filter_expr = QString("(ip%1.src==%2 && udp.srcport==%3 && ip%1.dst==%4 && udp.dstport==%5)")
                .arg(ip_version)
                .arg(address_to_qstring(&src_addr_))
}
void Singleton::f7();{
    MulticastStatTreeWidgetItem *ms_ti = dynamic_cast<MulticastStatTreeWidgetItem*>(ti);
    if (ms_ti) {
        return ms_ti->rowData();
    }
    else {
}
void Singleton::f8();{
        updateWidgets();
        WiresharkDialog::captureFileClosing();
    }
// Stat command + args
static void
}
void Singleton::f9();{
    int num_bursts_;
    int top_buff_usage_;
    int num_buff_alarms_;
MulticastStatisticsDialog::MulticastStatisticsDialog(QWidget &parent, CaptureFile &cf, const char *filter) :
    TapParameterDialog(parent, cf)
}
void Singleton::f10();{
    foreach (QWidget *line_edit, line_edits_) {
        line_edit->setMinimumWidth(one_em * 5);
        connect(line_edit, SIGNAL(textEdited(QString)), this, SLOT(updateWidgets()));
    }
    addFilterActions();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        setText(col_max_buffers_, bits_s_to_qstring(top_buff_usage_));
        setText(col_buffer_alarms_, QString::number(num_buff_alarms_));
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
}
void Singleton::f2();{
    else {
        return QList<QVariant>();
    }
const QString MulticastStatisticsDialog::filterExpression()
    QString filter_expr;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        setText(col_max_buffers_, bits_s_to_qstring(top_buff_usage_));
        setText(col_buffer_alarms_, QString::number(num_buff_alarms_));
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
}
void Singleton::f2();{
    else {
        return QList<QVariant>();
    }
const QString MulticastStatisticsDialog::filterExpression()
    QString filter_expr;
}
void Singleton::f3();{
            << line_edits_ << displayFilterLineEdit() << applyFilterButton();
    foreach (QWidget *w, disable_widgets) w->setEnabled(false);
    /* Scan for Mcast streams (redissect all packets) */
    mcaststream_scan(tapinfo_, cap_file_.capFile());
    tapDraw(tapinfo_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        setText(col_max_buffers_, bits_s_to_qstring(top_buff_usage_));
        setText(col_buffer_alarms_, QString::number(num_buff_alarms_));
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
}
void Singleton::f2();{
    else {
        return QList<QVariant>();
    }
const QString MulticastStatisticsDialog::filterExpression()
    QString filter_expr;
}
void Singleton::f3();{
            << line_edits_ << displayFilterLineEdit() << applyFilterButton();
    foreach (QWidget *w, disable_widgets) w->setEnabled(false);
    /* Scan for Mcast streams (redissect all packets) */
    mcaststream_scan(tapinfo_, cap_file_.capFile());
    tapDraw(tapinfo_);
}
void Singleton::f4();{
        setText(col_packets_, QString::number(num_packets_));
        setText(col_packets_s_, QString::number(avg_pps_, 'f', 2));
        setText(col_avg_bw_, bits_s_to_qstring(avg_bw_));
        setText(col_max_bw_, bits_s_to_qstring(max_bw_));
        setText(col_max_burst_, QString("%1 / %2ms").arg(top_burst_size_).arg(mcast_stream_burstint));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        setText(col_max_buffers_, bits_s_to_qstring(top_buff_usage_));
        setText(col_buffer_alarms_, QString::number(num_buff_alarms_));
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
}
void Singleton::f2();{
    else {
        return QList<QVariant>();
    }
const QString MulticastStatisticsDialog::filterExpression()
    QString filter_expr;
}
void Singleton::f3();{
            << line_edits_ << displayFilterLineEdit() << applyFilterButton();
    foreach (QWidget *w, disable_widgets) w->setEnabled(false);
    /* Scan for Mcast streams (redissect all packets) */
    mcaststream_scan(tapinfo_, cap_file_.capFile());
    tapDraw(tapinfo_);
}
void Singleton::f4();{
        setText(col_packets_, QString::number(num_packets_));
        setText(col_packets_s_, QString::number(avg_pps_, 'f', 2));
        setText(col_avg_bw_, bits_s_to_qstring(avg_bw_));
        setText(col_max_bw_, bits_s_to_qstring(max_bw_));
        setText(col_max_burst_, QString("%1 / %2ms").arg(top_burst_size_).arg(mcast_stream_burstint));
}
void Singleton::f5();{
    } else {
        stream_empty_speed_le_->setSyntaxState(SyntaxLineEdit::Valid);
    }
    param = total_empty_speed_le_->text().toInt(&ok);
    if (!ok || param < 1 || param > 10000000) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        setText(col_max_buffers_, bits_s_to_qstring(top_buff_usage_));
        setText(col_buffer_alarms_, QString::number(num_buff_alarms_));
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
}
void Singleton::f2();{
    else {
        return QList<QVariant>();
    }
const QString MulticastStatisticsDialog::filterExpression()
    QString filter_expr;
}
void Singleton::f3();{
            << line_edits_ << displayFilterLineEdit() << applyFilterButton();
    foreach (QWidget *w, disable_widgets) w->setEnabled(false);
    /* Scan for Mcast streams (redissect all packets) */
    mcaststream_scan(tapinfo_, cap_file_.capFile());
    tapDraw(tapinfo_);
}
void Singleton::f4();{
        setText(col_packets_, QString::number(num_packets_));
        setText(col_packets_s_, QString::number(avg_pps_, 'f', 2));
        setText(col_avg_bw_, bits_s_to_qstring(avg_bw_));
        setText(col_max_bw_, bits_s_to_qstring(max_bw_));
        setText(col_max_burst_, QString("%1 / %2ms").arg(top_burst_size_).arg(mcast_stream_burstint));
}
void Singleton::f5();{
    } else {
        stream_empty_speed_le_->setSyntaxState(SyntaxLineEdit::Valid);
    }
    param = total_empty_speed_le_->text().toInt(&ok);
    if (!ok || param < 1 || param > 10000000) {
}
void Singleton::f6();{
        QString ip_version;
        if (src_addr_.type == AT_IPv6) ip_version = "v6";
        const QString filter_expr = QString("(ip%1.src==%2 && udp.srcport==%3 && ip%1.dst==%4 && udp.dstport==%5)")
                .arg(ip_version)
                .arg(address_to_qstring(&src_addr_))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        setText(col_max_buffers_, bits_s_to_qstring(top_buff_usage_));
        setText(col_buffer_alarms_, QString::number(num_buff_alarms_));
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
}
void Singleton::f2();{
    else {
        return QList<QVariant>();
    }
const QString MulticastStatisticsDialog::filterExpression()
    QString filter_expr;
}
void Singleton::f3();{
            << line_edits_ << displayFilterLineEdit() << applyFilterButton();
    foreach (QWidget *w, disable_widgets) w->setEnabled(false);
    /* Scan for Mcast streams (redissect all packets) */
    mcaststream_scan(tapinfo_, cap_file_.capFile());
    tapDraw(tapinfo_);
}
void Singleton::f4();{
        setText(col_packets_, QString::number(num_packets_));
        setText(col_packets_s_, QString::number(avg_pps_, 'f', 2));
        setText(col_avg_bw_, bits_s_to_qstring(avg_bw_));
        setText(col_max_bw_, bits_s_to_qstring(max_bw_));
        setText(col_max_burst_, QString("%1 / %2ms").arg(top_burst_size_).arg(mcast_stream_burstint));
}
void Singleton::f5();{
    } else {
        stream_empty_speed_le_->setSyntaxState(SyntaxLineEdit::Valid);
    }
    param = total_empty_speed_le_->text().toInt(&ok);
    if (!ok || param < 1 || param > 10000000) {
}
void Singleton::f6();{
        QString ip_version;
        if (src_addr_.type == AT_IPv6) ip_version = "v6";
        const QString filter_expr = QString("(ip%1.src==%2 && udp.srcport==%3 && ip%1.dst==%4 && udp.dstport==%5)")
                .arg(ip_version)
                .arg(address_to_qstring(&src_addr_))
}
void Singleton::f7();{
    MulticastStatTreeWidgetItem *ms_ti = dynamic_cast<MulticastStatTreeWidgetItem*>(ti);
    if (ms_ti) {
        return ms_ti->rowData();
    }
    else {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        setText(col_max_buffers_, bits_s_to_qstring(top_buff_usage_));
        setText(col_buffer_alarms_, QString::number(num_buff_alarms_));
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
}
void Singleton::f2();{
    else {
        return QList<QVariant>();
    }
const QString MulticastStatisticsDialog::filterExpression()
    QString filter_expr;
}
void Singleton::f3();{
            << line_edits_ << displayFilterLineEdit() << applyFilterButton();
    foreach (QWidget *w, disable_widgets) w->setEnabled(false);
    /* Scan for Mcast streams (redissect all packets) */
    mcaststream_scan(tapinfo_, cap_file_.capFile());
    tapDraw(tapinfo_);
}
void Singleton::f4();{
        setText(col_packets_, QString::number(num_packets_));
        setText(col_packets_s_, QString::number(avg_pps_, 'f', 2));
        setText(col_avg_bw_, bits_s_to_qstring(avg_bw_));
        setText(col_max_bw_, bits_s_to_qstring(max_bw_));
        setText(col_max_burst_, QString("%1 / %2ms").arg(top_burst_size_).arg(mcast_stream_burstint));
}
void Singleton::f5();{
    } else {
        stream_empty_speed_le_->setSyntaxState(SyntaxLineEdit::Valid);
    }
    param = total_empty_speed_le_->text().toInt(&ok);
    if (!ok || param < 1 || param > 10000000) {
}
void Singleton::f6();{
        QString ip_version;
        if (src_addr_.type == AT_IPv6) ip_version = "v6";
        const QString filter_expr = QString("(ip%1.src==%2 && udp.srcport==%3 && ip%1.dst==%4 && udp.dstport==%5)")
                .arg(ip_version)
                .arg(address_to_qstring(&src_addr_))
}
void Singleton::f7();{
    MulticastStatTreeWidgetItem *ms_ti = dynamic_cast<MulticastStatTreeWidgetItem*>(ti);
    if (ms_ti) {
        return ms_ti->rowData();
    }
    else {
}
void Singleton::f8();{
        updateWidgets();
        WiresharkDialog::captureFileClosing();
    }
// Stat command + args
static void
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        setText(col_max_buffers_, bits_s_to_qstring(top_buff_usage_));
        setText(col_buffer_alarms_, QString::number(num_buff_alarms_));
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
}
void Singleton::f2();{
    else {
        return QList<QVariant>();
    }
const QString MulticastStatisticsDialog::filterExpression()
    QString filter_expr;
}
void Singleton::f3();{
            << line_edits_ << displayFilterLineEdit() << applyFilterButton();
    foreach (QWidget *w, disable_widgets) w->setEnabled(false);
    /* Scan for Mcast streams (redissect all packets) */
    mcaststream_scan(tapinfo_, cap_file_.capFile());
    tapDraw(tapinfo_);
}
void Singleton::f4();{
        setText(col_packets_, QString::number(num_packets_));
        setText(col_packets_s_, QString::number(avg_pps_, 'f', 2));
        setText(col_avg_bw_, bits_s_to_qstring(avg_bw_));
        setText(col_max_bw_, bits_s_to_qstring(max_bw_));
        setText(col_max_burst_, QString("%1 / %2ms").arg(top_burst_size_).arg(mcast_stream_burstint));
}
void Singleton::f5();{
    } else {
        stream_empty_speed_le_->setSyntaxState(SyntaxLineEdit::Valid);
    }
    param = total_empty_speed_le_->text().toInt(&ok);
    if (!ok || param < 1 || param > 10000000) {
}
void Singleton::f6();{
        QString ip_version;
        if (src_addr_.type == AT_IPv6) ip_version = "v6";
        const QString filter_expr = QString("(ip%1.src==%2 && udp.srcport==%3 && ip%1.dst==%4 && udp.dstport==%5)")
                .arg(ip_version)
                .arg(address_to_qstring(&src_addr_))
}
void Singleton::f7();{
    MulticastStatTreeWidgetItem *ms_ti = dynamic_cast<MulticastStatTreeWidgetItem*>(ti);
    if (ms_ti) {
        return ms_ti->rowData();
    }
    else {
}
void Singleton::f8();{
        updateWidgets();
        WiresharkDialog::captureFileClosing();
    }
// Stat command + args
static void
}
void Singleton::f9();{
    int num_bursts_;
    int top_buff_usage_;
    int num_buff_alarms_;
MulticastStatisticsDialog::MulticastStatisticsDialog(QWidget &parent, CaptureFile &cf, const char *filter) :
    TapParameterDialog(parent, cf)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    {
        bool canConvert = false;
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    {
        bool canConvert = false;
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
}
void Singleton::f2();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f3();{
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
        QSpinBox * spinBox = qobject_cast<QSpinBox *>(editor);
        spinBox->setValue(val);
}
void Singleton::f4();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f5();{
void NumericValueChooserDelegate::onValueChanged(int)
    QSpinBox * spinBox = qobject_cast<QSpinBox *>(sender());
    emit commitData(spinBox);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f7();{
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
void NumericValueChooserDelegate::setDefaultValue(int defValue, QVariant defaultReturn)
}
void Singleton::f8();{
    _defReturn = defaultReturn;
QWidget* NumericValueChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const
    if (!index.isValid()) {
        return QStyledItemDelegate::createEditor(parent, option, index);
    }
}
void Singleton::f9();{
    } else {
        QStyledItemDelegate::setModelData(editor, model, index);
    }
void NumericValueChooserDelegate::onValueChanged(int)
    QSpinBox * spinBox = qobject_cast<QSpinBox *>(sender());
}
void Singleton::f10();{
    _max = max;
    _default = min;
NumericValueChooserDelegate::~NumericValueChooserDelegate()
void NumericValueChooserDelegate::setMinMaxRange(int min, int max)
    _min = qMin(min, max);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    {
        bool canConvert = false;
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
}
void Singleton::f2();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    {
        bool canConvert = false;
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
}
void Singleton::f2();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f3();{
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
        QSpinBox * spinBox = qobject_cast<QSpinBox *>(editor);
        spinBox->setValue(val);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    {
        bool canConvert = false;
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
}
void Singleton::f2();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f3();{
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
        QSpinBox * spinBox = qobject_cast<QSpinBox *>(editor);
        spinBox->setValue(val);
}
void Singleton::f4();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    {
        bool canConvert = false;
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
}
void Singleton::f2();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f3();{
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
        QSpinBox * spinBox = qobject_cast<QSpinBox *>(editor);
        spinBox->setValue(val);
}
void Singleton::f4();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f5();{
void NumericValueChooserDelegate::onValueChanged(int)
    QSpinBox * spinBox = qobject_cast<QSpinBox *>(sender());
    emit commitData(spinBox);
 * Editor modelines
 * Local Variables:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    {
        bool canConvert = false;
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
}
void Singleton::f2();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f3();{
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
        QSpinBox * spinBox = qobject_cast<QSpinBox *>(editor);
        spinBox->setValue(val);
}
void Singleton::f4();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f5();{
void NumericValueChooserDelegate::onValueChanged(int)
    QSpinBox * spinBox = qobject_cast<QSpinBox *>(sender());
    emit commitData(spinBox);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    {
        bool canConvert = false;
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
}
void Singleton::f2();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f3();{
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
        QSpinBox * spinBox = qobject_cast<QSpinBox *>(editor);
        spinBox->setValue(val);
}
void Singleton::f4();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f5();{
void NumericValueChooserDelegate::onValueChanged(int)
    QSpinBox * spinBox = qobject_cast<QSpinBox *>(sender());
    emit commitData(spinBox);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f7();{
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
void NumericValueChooserDelegate::setDefaultValue(int defValue, QVariant defaultReturn)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    {
        bool canConvert = false;
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
}
void Singleton::f2();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f3();{
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
        QSpinBox * spinBox = qobject_cast<QSpinBox *>(editor);
        spinBox->setValue(val);
}
void Singleton::f4();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f5();{
void NumericValueChooserDelegate::onValueChanged(int)
    QSpinBox * spinBox = qobject_cast<QSpinBox *>(sender());
    emit commitData(spinBox);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f7();{
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
void NumericValueChooserDelegate::setDefaultValue(int defValue, QVariant defaultReturn)
}
void Singleton::f8();{
    _defReturn = defaultReturn;
QWidget* NumericValueChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const
    if (!index.isValid()) {
        return QStyledItemDelegate::createEditor(parent, option, index);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    {
        bool canConvert = false;
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
}
void Singleton::f2();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f3();{
        int val = index.data().toInt(&canConvert);
        if (! canConvert)
            val = _default;
        QSpinBox * spinBox = qobject_cast<QSpinBox *>(editor);
        spinBox->setValue(val);
}
void Singleton::f4();{
    _min = qMin(min, max);
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
}
void Singleton::f5();{
void NumericValueChooserDelegate::onValueChanged(int)
    QSpinBox * spinBox = qobject_cast<QSpinBox *>(sender());
    emit commitData(spinBox);
 * Editor modelines
 * Local Variables:
}
void Singleton::f6();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f7();{
    _max = qMax(min, max);
    /* ensure, that the default value is within the new min<->max */
    _default = qMin(_max, qMax(_min, _default));
    _defReturn = QVariant::fromValue(_default);
void NumericValueChooserDelegate::setDefaultValue(int defValue, QVariant defaultReturn)
}
void Singleton::f8();{
    _defReturn = defaultReturn;
QWidget* NumericValueChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const
    if (!index.isValid()) {
        return QStyledItemDelegate::createEditor(parent, option, index);
    }
}
void Singleton::f9();{
    } else {
        QStyledItemDelegate::setModelData(editor, model, index);
    }
void NumericValueChooserDelegate::onValueChanged(int)
    QSpinBox * spinBox = qobject_cast<QSpinBox *>(sender());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        setValue((clicked_packet * packet_to_sb_value) + top_pad);
    }
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        setValue((clicked_packet * packet_to_sb_value) + top_pad);
    }
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f2();{
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
void OverlayScrollBar::paintEvent(QPaintEvent *event)
}
void Singleton::f3();{
// content.
class OsbProxyStyle : public QProxyStyle
  public:
    // Disable transient behavior. Mainly for macOS but possibly applies to
    // other platforms. If we want to enable transience we'll have to
}
void Singleton::f4();{
    return child_sb_.style()->subControlRect(QStyle::CC_ScrollBar, &opt, QStyle::SC_ScrollBarGroove, &child_sb_);
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
}
void Singleton::f5();{
    // Other visibility changes.
    // HoverEnter & HoverLeave events from QAbstractScrollArea.
    // Size (and possibly opacity) changes while painting.
    //
    // Another approach would be to flip the child-parent relationship
}
void Singleton::f6();{
            QRect groove_rect = grooveRect();
            qreal dp_ratio = devicePixelRatio();
            groove_rect.setTopLeft(groove_rect.topLeft() * dp_ratio);
            groove_rect.setSize(groove_rect.size() * dp_ratio);
            QImage marked_map(groove_rect.width(), groove_rect.height(), QImage::Format_ARGB32_Premultiplied);
}
void Singleton::f7();{
        // Draw the image supplied by the packet list.
        QPainter pm_painter(&packet_map);
        pm_painter.setPen(Qt::NoPen);
        QRect near_dest(0, 0, pm_size.width(), pm_size.height());
        pm_painter.drawImage(near_dest, packet_map_img_.scaled(near_dest.size(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation));
}
void Singleton::f8();{
        updateGeometry();
    }
    update();
void OverlayScrollBar::setMarkedPacketImage(QImage &mp_image)
    qreal dp_ratio = devicePixelRatio();
}
void Singleton::f9();{
    packet_map_img_ = overlay_image;
    packet_count_ = packet_count;
    start_pos_ = start_pos;
    end_pos_ = end_pos;
    positions_ = positions;
}
void Singleton::f10();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        setValue((clicked_packet * packet_to_sb_value) + top_pad);
    }
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f2();{
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
void OverlayScrollBar::paintEvent(QPaintEvent *event)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        setValue((clicked_packet * packet_to_sb_value) + top_pad);
    }
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f2();{
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
void OverlayScrollBar::paintEvent(QPaintEvent *event)
}
void Singleton::f3();{
// content.
class OsbProxyStyle : public QProxyStyle
  public:
    // Disable transient behavior. Mainly for macOS but possibly applies to
    // other platforms. If we want to enable transience we'll have to
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        setValue((clicked_packet * packet_to_sb_value) + top_pad);
    }
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f2();{
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
void OverlayScrollBar::paintEvent(QPaintEvent *event)
}
void Singleton::f3();{
// content.
class OsbProxyStyle : public QProxyStyle
  public:
    // Disable transient behavior. Mainly for macOS but possibly applies to
    // other platforms. If we want to enable transience we'll have to
}
void Singleton::f4();{
    return child_sb_.style()->subControlRect(QStyle::CC_ScrollBar, &opt, QStyle::SC_ScrollBarGroove, &child_sb_);
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        setValue((clicked_packet * packet_to_sb_value) + top_pad);
    }
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f2();{
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
void OverlayScrollBar::paintEvent(QPaintEvent *event)
}
void Singleton::f3();{
// content.
class OsbProxyStyle : public QProxyStyle
  public:
    // Disable transient behavior. Mainly for macOS but possibly applies to
    // other platforms. If we want to enable transience we'll have to
}
void Singleton::f4();{
    return child_sb_.style()->subControlRect(QStyle::CC_ScrollBar, &opt, QStyle::SC_ScrollBarGroove, &child_sb_);
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
}
void Singleton::f5();{
    // Other visibility changes.
    // HoverEnter & HoverLeave events from QAbstractScrollArea.
    // Size (and possibly opacity) changes while painting.
    //
    // Another approach would be to flip the child-parent relationship
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        setValue((clicked_packet * packet_to_sb_value) + top_pad);
    }
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f2();{
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
void OverlayScrollBar::paintEvent(QPaintEvent *event)
}
void Singleton::f3();{
// content.
class OsbProxyStyle : public QProxyStyle
  public:
    // Disable transient behavior. Mainly for macOS but possibly applies to
    // other platforms. If we want to enable transience we'll have to
}
void Singleton::f4();{
    return child_sb_.style()->subControlRect(QStyle::CC_ScrollBar, &opt, QStyle::SC_ScrollBarGroove, &child_sb_);
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
}
void Singleton::f5();{
    // Other visibility changes.
    // HoverEnter & HoverLeave events from QAbstractScrollArea.
    // Size (and possibly opacity) changes while painting.
    //
    // Another approach would be to flip the child-parent relationship
}
void Singleton::f6();{
            QRect groove_rect = grooveRect();
            qreal dp_ratio = devicePixelRatio();
            groove_rect.setTopLeft(groove_rect.topLeft() * dp_ratio);
            groove_rect.setSize(groove_rect.size() * dp_ratio);
            QImage marked_map(groove_rect.width(), groove_rect.height(), QImage::Format_ARGB32_Premultiplied);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        setValue((clicked_packet * packet_to_sb_value) + top_pad);
    }
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f2();{
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
void OverlayScrollBar::paintEvent(QPaintEvent *event)
}
void Singleton::f3();{
// content.
class OsbProxyStyle : public QProxyStyle
  public:
    // Disable transient behavior. Mainly for macOS but possibly applies to
    // other platforms. If we want to enable transience we'll have to
}
void Singleton::f4();{
    return child_sb_.style()->subControlRect(QStyle::CC_ScrollBar, &opt, QStyle::SC_ScrollBarGroove, &child_sb_);
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
}
void Singleton::f5();{
    // Other visibility changes.
    // HoverEnter & HoverLeave events from QAbstractScrollArea.
    // Size (and possibly opacity) changes while painting.
    //
    // Another approach would be to flip the child-parent relationship
}
void Singleton::f6();{
            QRect groove_rect = grooveRect();
            qreal dp_ratio = devicePixelRatio();
            groove_rect.setTopLeft(groove_rect.topLeft() * dp_ratio);
            groove_rect.setSize(groove_rect.size() * dp_ratio);
            QImage marked_map(groove_rect.width(), groove_rect.height(), QImage::Format_ARGB32_Premultiplied);
}
void Singleton::f7();{
        // Draw the image supplied by the packet list.
        QPainter pm_painter(&packet_map);
        pm_painter.setPen(Qt::NoPen);
        QRect near_dest(0, 0, pm_size.width(), pm_size.height());
        pm_painter.drawImage(near_dest, packet_map_img_.scaled(near_dest.size(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        setValue((clicked_packet * packet_to_sb_value) + top_pad);
    }
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f2();{
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
void OverlayScrollBar::paintEvent(QPaintEvent *event)
}
void Singleton::f3();{
// content.
class OsbProxyStyle : public QProxyStyle
  public:
    // Disable transient behavior. Mainly for macOS but possibly applies to
    // other platforms. If we want to enable transience we'll have to
}
void Singleton::f4();{
    return child_sb_.style()->subControlRect(QStyle::CC_ScrollBar, &opt, QStyle::SC_ScrollBarGroove, &child_sb_);
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
}
void Singleton::f5();{
    // Other visibility changes.
    // HoverEnter & HoverLeave events from QAbstractScrollArea.
    // Size (and possibly opacity) changes while painting.
    //
    // Another approach would be to flip the child-parent relationship
}
void Singleton::f6();{
            QRect groove_rect = grooveRect();
            qreal dp_ratio = devicePixelRatio();
            groove_rect.setTopLeft(groove_rect.topLeft() * dp_ratio);
            groove_rect.setSize(groove_rect.size() * dp_ratio);
            QImage marked_map(groove_rect.width(), groove_rect.height(), QImage::Format_ARGB32_Premultiplied);
}
void Singleton::f7();{
        // Draw the image supplied by the packet list.
        QPainter pm_painter(&packet_map);
        pm_painter.setPen(Qt::NoPen);
        QRect near_dest(0, 0, pm_size.width(), pm_size.height());
        pm_painter.drawImage(near_dest, packet_map_img_.scaled(near_dest.size(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation));
}
void Singleton::f8();{
        updateGeometry();
    }
    update();
void OverlayScrollBar::setMarkedPacketImage(QImage &mp_image)
    qreal dp_ratio = devicePixelRatio();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        setValue((clicked_packet * packet_to_sb_value) + top_pad);
    }
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f2();{
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
void OverlayScrollBar::paintEvent(QPaintEvent *event)
}
void Singleton::f3();{
// content.
class OsbProxyStyle : public QProxyStyle
  public:
    // Disable transient behavior. Mainly for macOS but possibly applies to
    // other platforms. If we want to enable transience we'll have to
}
void Singleton::f4();{
    return child_sb_.style()->subControlRect(QStyle::CC_ScrollBar, &opt, QStyle::SC_ScrollBarGroove, &child_sb_);
void OverlayScrollBar::resizeEvent(QResizeEvent *event)
    QScrollBar::resizeEvent(event);
    child_sb_.move(packet_map_width_, 0);
    child_sb_.resize(child_sb_.sizeHint().width(), height());
}
void Singleton::f5();{
    // Other visibility changes.
    // HoverEnter & HoverLeave events from QAbstractScrollArea.
    // Size (and possibly opacity) changes while painting.
    //
    // Another approach would be to flip the child-parent relationship
}
void Singleton::f6();{
            QRect groove_rect = grooveRect();
            qreal dp_ratio = devicePixelRatio();
            groove_rect.setTopLeft(groove_rect.topLeft() * dp_ratio);
            groove_rect.setSize(groove_rect.size() * dp_ratio);
            QImage marked_map(groove_rect.width(), groove_rect.height(), QImage::Format_ARGB32_Premultiplied);
}
void Singleton::f7();{
        // Draw the image supplied by the packet list.
        QPainter pm_painter(&packet_map);
        pm_painter.setPen(Qt::NoPen);
        QRect near_dest(0, 0, pm_size.width(), pm_size.height());
        pm_painter.drawImage(near_dest, packet_map_img_.scaled(near_dest.size(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation));
}
void Singleton::f8();{
        updateGeometry();
    }
    update();
void OverlayScrollBar::setMarkedPacketImage(QImage &mp_image)
    qreal dp_ratio = devicePixelRatio();
}
void Singleton::f9();{
    packet_map_img_ = overlay_image;
    packet_count_ = packet_count;
    start_pos_ = start_pos;
    end_pos_ = end_pos;
    positions_ = positions;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
        return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
        return;
}
void Singleton::f2();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f3();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f4();{
     ui->hintLabel->setText(hint);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    loadGeometry(parent.width() * 4 / 5, parent.height() * 4 / 5);
    ui->hintLabel->setSmallText();
    wtap_rec_init(&rec_);
    ws_buffer_init(&buf_, 1514);
    edt_.session = NULL;
}
void Singleton::f6();{
    edt_.tree = NULL;
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
}
void Singleton::f7();{
    byte_view_tab_->setCaptureFile(cap_file_.capFile());
    byte_view_tab_->selectedFrameChanged(QList<int>() << 0);
    ui->packetSplitter->setStretchFactor(1, 0);
    QStringList col_parts;
    for (int i = 0; i < cap_file_.capFile()->cinfo.num_cols; ++i) {
}
void Singleton::f8();{
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 4 / 5);
    ui->hintLabel->setSmallText();
    wtap_rec_init(&rec_);
    ws_buffer_init(&buf_, 1514);
}
void Singleton::f9();{
void PacketDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_NEW_PACKET_DIALOG);
void PacketDialog::setHintText(FieldInformation * finfo)
    QString hint;
     if (finfo)
}
void Singleton::f10();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Copy over experimental packet editing code.
// - Fix ElidedText width.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
        return;
}
void Singleton::f2();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
        return;
}
void Singleton::f2();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f3();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
        return;
}
void Singleton::f2();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f3();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f4();{
     ui->hintLabel->setText(hint);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
        return;
}
void Singleton::f2();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f3();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f4();{
     ui->hintLabel->setText(hint);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    loadGeometry(parent.width() * 4 / 5, parent.height() * 4 / 5);
    ui->hintLabel->setSmallText();
    wtap_rec_init(&rec_);
    ws_buffer_init(&buf_, 1514);
    edt_.session = NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
        return;
}
void Singleton::f2();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f3();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f4();{
     ui->hintLabel->setText(hint);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    loadGeometry(parent.width() * 4 / 5, parent.height() * 4 / 5);
    ui->hintLabel->setSmallText();
    wtap_rec_init(&rec_);
    ws_buffer_init(&buf_, 1514);
    edt_.session = NULL;
}
void Singleton::f6();{
    edt_.tree = NULL;
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
        return;
}
void Singleton::f2();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f3();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f4();{
     ui->hintLabel->setText(hint);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    loadGeometry(parent.width() * 4 / 5, parent.height() * 4 / 5);
    ui->hintLabel->setSmallText();
    wtap_rec_init(&rec_);
    ws_buffer_init(&buf_, 1514);
    edt_.session = NULL;
}
void Singleton::f6();{
    edt_.tree = NULL;
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
}
void Singleton::f7();{
    byte_view_tab_->setCaptureFile(cap_file_.capFile());
    byte_view_tab_->selectedFrameChanged(QList<int>() << 0);
    ui->packetSplitter->setStretchFactor(1, 0);
    QStringList col_parts;
    for (int i = 0; i < cap_file_.capFile()->cinfo.num_cols; ++i) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
        return;
}
void Singleton::f2();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f3();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f4();{
     ui->hintLabel->setText(hint);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    loadGeometry(parent.width() * 4 / 5, parent.height() * 4 / 5);
    ui->hintLabel->setSmallText();
    wtap_rec_init(&rec_);
    ws_buffer_init(&buf_, 1514);
    edt_.session = NULL;
}
void Singleton::f6();{
    edt_.tree = NULL;
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
}
void Singleton::f7();{
    byte_view_tab_->setCaptureFile(cap_file_.capFile());
    byte_view_tab_->selectedFrameChanged(QList<int>() << 0);
    ui->packetSplitter->setStretchFactor(1, 0);
    QStringList col_parts;
    for (int i = 0; i < cap_file_.capFile()->cinfo.num_cols; ++i) {
}
void Singleton::f8();{
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 4 / 5);
    ui->hintLabel->setSmallText();
    wtap_rec_init(&rec_);
    ws_buffer_init(&buf_, 1514);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
        return;
}
void Singleton::f2();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f3();{
    QString hint;
     if (finfo)
     {
         FieldInformation::Position pos = finfo->position();
         QString field_str;
}
void Singleton::f4();{
     ui->hintLabel->setText(hint);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f5();{
    loadGeometry(parent.width() * 4 / 5, parent.height() * 4 / 5);
    ui->hintLabel->setSmallText();
    wtap_rec_init(&rec_);
    ws_buffer_init(&buf_, 1514);
    edt_.session = NULL;
}
void Singleton::f6();{
    edt_.tree = NULL;
    memset(&edt_.pi, 0x0, sizeof(edt_.pi));
    setWindowSubtitle(tr("Packet %1").arg(fdata->num));
    if (!cf_read_record(cap_file_.capFile(), fdata, &rec_, &buf_)) {
        reject();
}
void Singleton::f7();{
    byte_view_tab_->setCaptureFile(cap_file_.capFile());
    byte_view_tab_->selectedFrameChanged(QList<int>() << 0);
    ui->packetSplitter->setStretchFactor(1, 0);
    QStringList col_parts;
    for (int i = 0; i < cap_file_.capFile()->cinfo.num_cols; ++i) {
}
void Singleton::f8();{
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 4 / 5);
    ui->hintLabel->setSmallText();
    wtap_rec_init(&rec_);
    ws_buffer_init(&buf_, 1514);
}
void Singleton::f9();{
void PacketDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_NEW_PACKET_DIALOG);
void PacketDialog::setHintText(FieldInformation * finfo)
    QString hint;
     if (finfo)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    pf_ui_->setupUi(this);
    setFlat(true);
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    pf_ui_->setupUi(this);
    setFlat(true);
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
}
void Singleton::f2();{
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
}
void Singleton::f3();{
    pf_ui_->allCollapsedButton->setStyleSheet(QString(
                      "QRadioButton {"
                      "  padding-left: %1px;"
                      "}"
                      ).arg(cb_label_offset));
}
void Singleton::f4();{
    return pf_ui_->detailsCheckBox->isChecked();
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
}
void Singleton::f5();{
PacketFormatGroupBox::~PacketFormatGroupBox()
    delete pf_ui_;
bool PacketFormatGroupBox::summaryEnabled()
    return pf_ui_->summaryCheckBox->isChecked();
bool PacketFormatGroupBox::detailsEnabled()
}
void Singleton::f6();{
PacketFormatGroupBox::PacketFormatGroupBox(QWidget *parent) :
    QGroupBox(parent),
    pf_ui_(new Ui::PacketFormatGroupBox)
    pf_ui_->setupUi(this);
    setFlat(true);
}
void Singleton::f7();{
                      "}"
                      ).arg(cb_label_offset));
PacketFormatGroupBox::~PacketFormatGroupBox()
    delete pf_ui_;
bool PacketFormatGroupBox::summaryEnabled()
}
void Singleton::f8();{
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
    return pf_ui_->allCollapsedButton->isChecked();
}
void Singleton::f9();{
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
    pf_ui_->includeColumnHeadingsCheckBox->setStyleSheet(QString(
                      "QCheckBox {"
}
void Singleton::f10();{
    return pf_ui_->summaryCheckBox->isChecked();
bool PacketFormatGroupBox::detailsEnabled()
    return pf_ui_->detailsCheckBox->isChecked();
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    pf_ui_->setupUi(this);
    setFlat(true);
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
}
void Singleton::f2();{
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    pf_ui_->setupUi(this);
    setFlat(true);
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
}
void Singleton::f2();{
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
}
void Singleton::f3();{
    pf_ui_->allCollapsedButton->setStyleSheet(QString(
                      "QRadioButton {"
                      "  padding-left: %1px;"
                      "}"
                      ).arg(cb_label_offset));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    pf_ui_->setupUi(this);
    setFlat(true);
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
}
void Singleton::f2();{
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
}
void Singleton::f3();{
    pf_ui_->allCollapsedButton->setStyleSheet(QString(
                      "QRadioButton {"
                      "  padding-left: %1px;"
                      "}"
                      ).arg(cb_label_offset));
}
void Singleton::f4();{
    return pf_ui_->detailsCheckBox->isChecked();
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    pf_ui_->setupUi(this);
    setFlat(true);
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
}
void Singleton::f2();{
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
}
void Singleton::f3();{
    pf_ui_->allCollapsedButton->setStyleSheet(QString(
                      "QRadioButton {"
                      "  padding-left: %1px;"
                      "}"
                      ).arg(cb_label_offset));
}
void Singleton::f4();{
    return pf_ui_->detailsCheckBox->isChecked();
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
}
void Singleton::f5();{
PacketFormatGroupBox::~PacketFormatGroupBox()
    delete pf_ui_;
bool PacketFormatGroupBox::summaryEnabled()
    return pf_ui_->summaryCheckBox->isChecked();
bool PacketFormatGroupBox::detailsEnabled()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    pf_ui_->setupUi(this);
    setFlat(true);
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
}
void Singleton::f2();{
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
}
void Singleton::f3();{
    pf_ui_->allCollapsedButton->setStyleSheet(QString(
                      "QRadioButton {"
                      "  padding-left: %1px;"
                      "}"
                      ).arg(cb_label_offset));
}
void Singleton::f4();{
    return pf_ui_->detailsCheckBox->isChecked();
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
}
void Singleton::f5();{
PacketFormatGroupBox::~PacketFormatGroupBox()
    delete pf_ui_;
bool PacketFormatGroupBox::summaryEnabled()
    return pf_ui_->summaryCheckBox->isChecked();
bool PacketFormatGroupBox::detailsEnabled()
}
void Singleton::f6();{
PacketFormatGroupBox::PacketFormatGroupBox(QWidget *parent) :
    QGroupBox(parent),
    pf_ui_(new Ui::PacketFormatGroupBox)
    pf_ui_->setupUi(this);
    setFlat(true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    pf_ui_->setupUi(this);
    setFlat(true);
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
}
void Singleton::f2();{
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
}
void Singleton::f3();{
    pf_ui_->allCollapsedButton->setStyleSheet(QString(
                      "QRadioButton {"
                      "  padding-left: %1px;"
                      "}"
                      ).arg(cb_label_offset));
}
void Singleton::f4();{
    return pf_ui_->detailsCheckBox->isChecked();
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
}
void Singleton::f5();{
PacketFormatGroupBox::~PacketFormatGroupBox()
    delete pf_ui_;
bool PacketFormatGroupBox::summaryEnabled()
    return pf_ui_->summaryCheckBox->isChecked();
bool PacketFormatGroupBox::detailsEnabled()
}
void Singleton::f6();{
PacketFormatGroupBox::PacketFormatGroupBox(QWidget *parent) :
    QGroupBox(parent),
    pf_ui_(new Ui::PacketFormatGroupBox)
    pf_ui_->setupUi(this);
    setFlat(true);
}
void Singleton::f7();{
                      "}"
                      ).arg(cb_label_offset));
PacketFormatGroupBox::~PacketFormatGroupBox()
    delete pf_ui_;
bool PacketFormatGroupBox::summaryEnabled()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    pf_ui_->setupUi(this);
    setFlat(true);
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
}
void Singleton::f2();{
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
}
void Singleton::f3();{
    pf_ui_->allCollapsedButton->setStyleSheet(QString(
                      "QRadioButton {"
                      "  padding-left: %1px;"
                      "}"
                      ).arg(cb_label_offset));
}
void Singleton::f4();{
    return pf_ui_->detailsCheckBox->isChecked();
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
}
void Singleton::f5();{
PacketFormatGroupBox::~PacketFormatGroupBox()
    delete pf_ui_;
bool PacketFormatGroupBox::summaryEnabled()
    return pf_ui_->summaryCheckBox->isChecked();
bool PacketFormatGroupBox::detailsEnabled()
}
void Singleton::f6();{
PacketFormatGroupBox::PacketFormatGroupBox(QWidget *parent) :
    QGroupBox(parent),
    pf_ui_(new Ui::PacketFormatGroupBox)
    pf_ui_->setupUi(this);
    setFlat(true);
}
void Singleton::f7();{
                      "}"
                      ).arg(cb_label_offset));
PacketFormatGroupBox::~PacketFormatGroupBox()
    delete pf_ui_;
bool PacketFormatGroupBox::summaryEnabled()
}
void Singleton::f8();{
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
    return pf_ui_->allCollapsedButton->isChecked();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    pf_ui_->setupUi(this);
    setFlat(true);
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
}
void Singleton::f2();{
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
}
void Singleton::f3();{
    pf_ui_->allCollapsedButton->setStyleSheet(QString(
                      "QRadioButton {"
                      "  padding-left: %1px;"
                      "}"
                      ).arg(cb_label_offset));
}
void Singleton::f4();{
    return pf_ui_->detailsCheckBox->isChecked();
bool PacketFormatGroupBox::bytesEnabled()
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
}
void Singleton::f5();{
PacketFormatGroupBox::~PacketFormatGroupBox()
    delete pf_ui_;
bool PacketFormatGroupBox::summaryEnabled()
    return pf_ui_->summaryCheckBox->isChecked();
bool PacketFormatGroupBox::detailsEnabled()
}
void Singleton::f6();{
PacketFormatGroupBox::PacketFormatGroupBox(QWidget *parent) :
    QGroupBox(parent),
    pf_ui_(new Ui::PacketFormatGroupBox)
    pf_ui_->setupUi(this);
    setFlat(true);
}
void Singleton::f7();{
                      "}"
                      ).arg(cb_label_offset));
PacketFormatGroupBox::~PacketFormatGroupBox()
    delete pf_ui_;
bool PacketFormatGroupBox::summaryEnabled()
}
void Singleton::f8();{
    return pf_ui_->bytesCheckBox->isChecked();
bool PacketFormatGroupBox::includeColumnHeadingsEnabled()
    return pf_ui_->includeColumnHeadingsCheckBox->isChecked();
bool PacketFormatGroupBox::allCollapsedEnabled()
    return pf_ui_->allCollapsedButton->isChecked();
}
void Singleton::f9();{
    QStyleOption style_opt;
    int cb_label_offset =  pf_ui_->detailsCheckBox->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    // Indent the checkbox under the "Packet summary" checkbox
    pf_ui_->includeColumnHeadingsCheckBox->setStyleSheet(QString(
                      "QCheckBox {"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        g_ptr_array_free(finfo_array, TRUE);
    }
    proto_prefs_menu_.setModule(module_name);
    QModelIndex ctxIndex = indexAt(event->pos());
    if (selectionModel() && selectionModel()->selectedRows(0).count() > 1)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        g_ptr_array_free(finfo_array, TRUE);
    }
    proto_prefs_menu_.setModule(module_name);
    QModelIndex ctxIndex = indexAt(event->pos());
    if (selectionModel() && selectionModel()->selectedRows(0).count() > 1)
}
void Singleton::f2();{
        "  color: %2;"
        "  background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1 stop: 0 %4, stop: 0.5 %3, stop: 1 %4);"
        "}";
    QString hover_style;
    QPalette default_pal = QApplication::palette();
}
void Singleton::f3();{
    QList<int> saved_sizes;
    int sort_idx;
    // Since we undo the move below, these should always stay in sync.
    // Otherwise the order of columns can be unexpected after drag and drop.
    if (logicalIndex != oldVisualIndex) {
}
void Singleton::f4();{
    int o_height = groove_size.height();
    int pl_rows = packet_list_model_->rowCount();
    QImage overlay(o_width, o_height, QImage::Format_ARGB32_Premultiplied);
    bool have_marked_image = false;
    // If only there were references from popular culture about getting into
}
void Singleton::f5();{
    return joinSummaryRow(col_parts, row, type);
QString PacketList::createHeaderSummaryText(SummaryCopyType type)
    QStringList col_parts;
    for (int col = 0; col < packet_list_model_->columnCount(); ++col)
    {
}
void Singleton::f6();{
        return;
    bool create_new = da_action->property("create_new").toBool();
    DecodeAsDialog *da_dialog = new DecodeAsDialog(this, cap_file_, create_new);
    connect(da_dialog, SIGNAL(destroyed(QObject*)), wsApp, SLOT(flushAppSignals()));
    da_dialog->setWindowModality(Qt::ApplicationModal);
}
void Singleton::f7();{
                             c_inactive,
                             foreground.name(),
                             background1.name(),
                             background2.name());
    }
}
void Singleton::f8();{
        painter.setPen(tick_color);
        for (int row = 0; row < pl_rows; row++) {
            frame_data *fdata = packet_list_model_->getRowFdata(row);
            if (fdata->marked || fdata->ref_time || fdata->ignored) {
                int new_line = row * o_height / pl_rows;
}
void Singleton::f9();{
    {
        QStringList content;
        if (model() && selectionModel() && selectionModel()->hasSelection())
        {
            QList<int> rows;
}
void Singleton::f10();{
        QImage overlay;
        overlay_sb_->setNearOverlayImage(overlay);
    }
void PacketList::drawFarOverlay()
    if (create_far_overlay_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        g_ptr_array_free(finfo_array, TRUE);
    }
    proto_prefs_menu_.setModule(module_name);
    QModelIndex ctxIndex = indexAt(event->pos());
    if (selectionModel() && selectionModel()->selectedRows(0).count() > 1)
}
void Singleton::f2();{
        "  color: %2;"
        "  background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1 stop: 0 %4, stop: 0.5 %3, stop: 1 %4);"
        "}";
    QString hover_style;
    QPalette default_pal = QApplication::palette();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        g_ptr_array_free(finfo_array, TRUE);
    }
    proto_prefs_menu_.setModule(module_name);
    QModelIndex ctxIndex = indexAt(event->pos());
    if (selectionModel() && selectionModel()->selectedRows(0).count() > 1)
}
void Singleton::f2();{
        "  color: %2;"
        "  background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1 stop: 0 %4, stop: 0.5 %3, stop: 1 %4);"
        "}";
    QString hover_style;
    QPalette default_pal = QApplication::palette();
}
void Singleton::f3();{
    QList<int> saved_sizes;
    int sort_idx;
    // Since we undo the move below, these should always stay in sync.
    // Otherwise the order of columns can be unexpected after drag and drop.
    if (logicalIndex != oldVisualIndex) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        g_ptr_array_free(finfo_array, TRUE);
    }
    proto_prefs_menu_.setModule(module_name);
    QModelIndex ctxIndex = indexAt(event->pos());
    if (selectionModel() && selectionModel()->selectedRows(0).count() > 1)
}
void Singleton::f2();{
        "  color: %2;"
        "  background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1 stop: 0 %4, stop: 0.5 %3, stop: 1 %4);"
        "}";
    QString hover_style;
    QPalette default_pal = QApplication::palette();
}
void Singleton::f3();{
    QList<int> saved_sizes;
    int sort_idx;
    // Since we undo the move below, these should always stay in sync.
    // Otherwise the order of columns can be unexpected after drag and drop.
    if (logicalIndex != oldVisualIndex) {
}
void Singleton::f4();{
    int o_height = groove_size.height();
    int pl_rows = packet_list_model_->rowCount();
    QImage overlay(o_width, o_height, QImage::Format_ARGB32_Premultiplied);
    bool have_marked_image = false;
    // If only there were references from popular culture about getting into
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        g_ptr_array_free(finfo_array, TRUE);
    }
    proto_prefs_menu_.setModule(module_name);
    QModelIndex ctxIndex = indexAt(event->pos());
    if (selectionModel() && selectionModel()->selectedRows(0).count() > 1)
}
void Singleton::f2();{
        "  color: %2;"
        "  background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1 stop: 0 %4, stop: 0.5 %3, stop: 1 %4);"
        "}";
    QString hover_style;
    QPalette default_pal = QApplication::palette();
}
void Singleton::f3();{
    QList<int> saved_sizes;
    int sort_idx;
    // Since we undo the move below, these should always stay in sync.
    // Otherwise the order of columns can be unexpected after drag and drop.
    if (logicalIndex != oldVisualIndex) {
}
void Singleton::f4();{
    int o_height = groove_size.height();
    int pl_rows = packet_list_model_->rowCount();
    QImage overlay(o_width, o_height, QImage::Format_ARGB32_Premultiplied);
    bool have_marked_image = false;
    // If only there were references from popular culture about getting into
}
void Singleton::f5();{
    return joinSummaryRow(col_parts, row, type);
QString PacketList::createHeaderSummaryText(SummaryCopyType type)
    QStringList col_parts;
    for (int col = 0; col < packet_list_model_->columnCount(); ++col)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        g_ptr_array_free(finfo_array, TRUE);
    }
    proto_prefs_menu_.setModule(module_name);
    QModelIndex ctxIndex = indexAt(event->pos());
    if (selectionModel() && selectionModel()->selectedRows(0).count() > 1)
}
void Singleton::f2();{
        "  color: %2;"
        "  background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1 stop: 0 %4, stop: 0.5 %3, stop: 1 %4);"
        "}";
    QString hover_style;
    QPalette default_pal = QApplication::palette();
}
void Singleton::f3();{
    QList<int> saved_sizes;
    int sort_idx;
    // Since we undo the move below, these should always stay in sync.
    // Otherwise the order of columns can be unexpected after drag and drop.
    if (logicalIndex != oldVisualIndex) {
}
void Singleton::f4();{
    int o_height = groove_size.height();
    int pl_rows = packet_list_model_->rowCount();
    QImage overlay(o_width, o_height, QImage::Format_ARGB32_Premultiplied);
    bool have_marked_image = false;
    // If only there were references from popular culture about getting into
}
void Singleton::f5();{
    return joinSummaryRow(col_parts, row, type);
QString PacketList::createHeaderSummaryText(SummaryCopyType type)
    QStringList col_parts;
    for (int col = 0; col < packet_list_model_->columnCount(); ++col)
    {
}
void Singleton::f6();{
        return;
    bool create_new = da_action->property("create_new").toBool();
    DecodeAsDialog *da_dialog = new DecodeAsDialog(this, cap_file_, create_new);
    connect(da_dialog, SIGNAL(destroyed(QObject*)), wsApp, SLOT(flushAppSignals()));
    da_dialog->setWindowModality(Qt::ApplicationModal);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        g_ptr_array_free(finfo_array, TRUE);
    }
    proto_prefs_menu_.setModule(module_name);
    QModelIndex ctxIndex = indexAt(event->pos());
    if (selectionModel() && selectionModel()->selectedRows(0).count() > 1)
}
void Singleton::f2();{
        "  color: %2;"
        "  background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1 stop: 0 %4, stop: 0.5 %3, stop: 1 %4);"
        "}";
    QString hover_style;
    QPalette default_pal = QApplication::palette();
}
void Singleton::f3();{
    QList<int> saved_sizes;
    int sort_idx;
    // Since we undo the move below, these should always stay in sync.
    // Otherwise the order of columns can be unexpected after drag and drop.
    if (logicalIndex != oldVisualIndex) {
}
void Singleton::f4();{
    int o_height = groove_size.height();
    int pl_rows = packet_list_model_->rowCount();
    QImage overlay(o_width, o_height, QImage::Format_ARGB32_Premultiplied);
    bool have_marked_image = false;
    // If only there were references from popular culture about getting into
}
void Singleton::f5();{
    return joinSummaryRow(col_parts, row, type);
QString PacketList::createHeaderSummaryText(SummaryCopyType type)
    QStringList col_parts;
    for (int col = 0; col < packet_list_model_->columnCount(); ++col)
    {
}
void Singleton::f6();{
        return;
    bool create_new = da_action->property("create_new").toBool();
    DecodeAsDialog *da_dialog = new DecodeAsDialog(this, cap_file_, create_new);
    connect(da_dialog, SIGNAL(destroyed(QObject*)), wsApp, SLOT(flushAppSignals()));
    da_dialog->setWindowModality(Qt::ApplicationModal);
}
void Singleton::f7();{
                             c_inactive,
                             foreground.name(),
                             background1.name(),
                             background2.name());
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        g_ptr_array_free(finfo_array, TRUE);
    }
    proto_prefs_menu_.setModule(module_name);
    QModelIndex ctxIndex = indexAt(event->pos());
    if (selectionModel() && selectionModel()->selectedRows(0).count() > 1)
}
void Singleton::f2();{
        "  color: %2;"
        "  background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1 stop: 0 %4, stop: 0.5 %3, stop: 1 %4);"
        "}";
    QString hover_style;
    QPalette default_pal = QApplication::palette();
}
void Singleton::f3();{
    QList<int> saved_sizes;
    int sort_idx;
    // Since we undo the move below, these should always stay in sync.
    // Otherwise the order of columns can be unexpected after drag and drop.
    if (logicalIndex != oldVisualIndex) {
}
void Singleton::f4();{
    int o_height = groove_size.height();
    int pl_rows = packet_list_model_->rowCount();
    QImage overlay(o_width, o_height, QImage::Format_ARGB32_Premultiplied);
    bool have_marked_image = false;
    // If only there were references from popular culture about getting into
}
void Singleton::f5();{
    return joinSummaryRow(col_parts, row, type);
QString PacketList::createHeaderSummaryText(SummaryCopyType type)
    QStringList col_parts;
    for (int col = 0; col < packet_list_model_->columnCount(); ++col)
    {
}
void Singleton::f6();{
        return;
    bool create_new = da_action->property("create_new").toBool();
    DecodeAsDialog *da_dialog = new DecodeAsDialog(this, cap_file_, create_new);
    connect(da_dialog, SIGNAL(destroyed(QObject*)), wsApp, SLOT(flushAppSignals()));
    da_dialog->setWindowModality(Qt::ApplicationModal);
}
void Singleton::f7();{
                             c_inactive,
                             foreground.name(),
                             background1.name(),
                             background2.name());
    }
}
void Singleton::f8();{
        painter.setPen(tick_color);
        for (int row = 0; row < pl_rows; row++) {
            frame_data *fdata = packet_list_model_->getRowFdata(row);
            if (fdata->marked || fdata->ref_time || fdata->ignored) {
                int new_line = row * o_height / pl_rows;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        g_ptr_array_free(finfo_array, TRUE);
    }
    proto_prefs_menu_.setModule(module_name);
    QModelIndex ctxIndex = indexAt(event->pos());
    if (selectionModel() && selectionModel()->selectedRows(0).count() > 1)
}
void Singleton::f2();{
        "  color: %2;"
        "  background-color: qlineargradient(x1:0, y1:0, x2:0, y2:1 stop: 0 %4, stop: 0.5 %3, stop: 1 %4);"
        "}";
    QString hover_style;
    QPalette default_pal = QApplication::palette();
}
void Singleton::f3();{
    QList<int> saved_sizes;
    int sort_idx;
    // Since we undo the move below, these should always stay in sync.
    // Otherwise the order of columns can be unexpected after drag and drop.
    if (logicalIndex != oldVisualIndex) {
}
void Singleton::f4();{
    int o_height = groove_size.height();
    int pl_rows = packet_list_model_->rowCount();
    QImage overlay(o_width, o_height, QImage::Format_ARGB32_Premultiplied);
    bool have_marked_image = false;
    // If only there were references from popular culture about getting into
}
void Singleton::f5();{
    return joinSummaryRow(col_parts, row, type);
QString PacketList::createHeaderSummaryText(SummaryCopyType type)
    QStringList col_parts;
    for (int col = 0; col < packet_list_model_->columnCount(); ++col)
    {
}
void Singleton::f6();{
        return;
    bool create_new = da_action->property("create_new").toBool();
    DecodeAsDialog *da_dialog = new DecodeAsDialog(this, cap_file_, create_new);
    connect(da_dialog, SIGNAL(destroyed(QObject*)), wsApp, SLOT(flushAppSignals()));
    da_dialog->setWindowModality(Qt::ApplicationModal);
}
void Singleton::f7();{
                             c_inactive,
                             foreground.name(),
                             background1.name(),
                             background2.name());
    }
}
void Singleton::f8();{
        painter.setPen(tick_color);
        for (int row = 0; row < pl_rows; row++) {
            frame_data *fdata = packet_list_model_->getRowFdata(row);
            if (fdata->marked || fdata->ref_time || fdata->ignored) {
                int new_line = row * o_height / pl_rows;
}
void Singleton::f9();{
    {
        QStringList content;
        if (model() && selectionModel() && selectionModel()->hasSelection())
        {
            QList<int> rows;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
        lastSize = sectionSize(sectIdx);
        QToolTip::showText(e->globalPos(), QString("Width: %1").arg(sectionSize(sectIdx)));
    }
    QHeaderView::mousePressEvent(e);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
        lastSize = sectionSize(sectIdx);
        QToolTip::showText(e->globalPos(), QString("Width: %1").arg(sectionSize(sectIdx)));
    }
    QHeaderView::mousePressEvent(e);
}
void Singleton::f2();{
void PacketListHeader::columnVisibilityTriggered()
    QAction *ha = qobject_cast<QAction*>(sender());
    if (!ha) return;
    int col = ha->data().toInt();
    set_column_visible(col, ha->isChecked());
}
void Singleton::f3();{
    }
    else
        QHeaderView::dragMoveEvent(event);
void PacketListHeader::dropEvent(QDropEvent *event)
    if (! event || ! event->mimeData())
}
void Singleton::f4();{
    if (e->button() == Qt::LeftButton && sectionIdx < 0)
    {
        /* No move happening yet */
        int sectIdx = logicalIndexAt(e->localPos().x() - 4, e->localPos().y());
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
}
void Singleton::f5();{
void PacketListHeader::setAlignment(QAction *action)
    if (!action)
        return;
    QActionGroup * group = action->actionGroup();
    if (! group)
}
void Singleton::f6();{
        connect(action, &QAction::triggered, this, &PacketListHeader::columnVisibilityTriggered);
        contextMenu->addAction(action);
    }
    contextMenu->setToolTipsVisible(true);
    contextMenu->addSeparator();
}
void Singleton::f7();{
        return;
    int section = menu->property("column").toInt();
    emit editColumn(section);
void PacketListHeader::doResolveNames()
    QAction * action = qobject_cast<QAction *>(sender());
}
void Singleton::f8();{
            event->acceptProposedAction();
        }
    }
    else
        QHeaderView::dropEvent(event);
}
void Singleton::f9();{
        QHeaderView::dragMoveEvent(event);
void PacketListHeader::dropEvent(QDropEvent *event)
    if (! event || ! event->mimeData())
        return;
    /* Moving items around */
}
void Singleton::f10();{
        connect(action, &QAction::triggered, this, &PacketListHeader::columnVisibilityTriggered);
        contextMenu->addAction(action);
    }
    contextMenu->setToolTipsVisible(true);
    contextMenu->addSeparator();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
        lastSize = sectionSize(sectIdx);
        QToolTip::showText(e->globalPos(), QString("Width: %1").arg(sectionSize(sectIdx)));
    }
    QHeaderView::mousePressEvent(e);
}
void Singleton::f2();{
void PacketListHeader::columnVisibilityTriggered()
    QAction *ha = qobject_cast<QAction*>(sender());
    if (!ha) return;
    int col = ha->data().toInt();
    set_column_visible(col, ha->isChecked());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
        lastSize = sectionSize(sectIdx);
        QToolTip::showText(e->globalPos(), QString("Width: %1").arg(sectionSize(sectIdx)));
    }
    QHeaderView::mousePressEvent(e);
}
void Singleton::f2();{
void PacketListHeader::columnVisibilityTriggered()
    QAction *ha = qobject_cast<QAction*>(sender());
    if (!ha) return;
    int col = ha->data().toInt();
    set_column_visible(col, ha->isChecked());
}
void Singleton::f3();{
    }
    else
        QHeaderView::dragMoveEvent(event);
void PacketListHeader::dropEvent(QDropEvent *event)
    if (! event || ! event->mimeData())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
        lastSize = sectionSize(sectIdx);
        QToolTip::showText(e->globalPos(), QString("Width: %1").arg(sectionSize(sectIdx)));
    }
    QHeaderView::mousePressEvent(e);
}
void Singleton::f2();{
void PacketListHeader::columnVisibilityTriggered()
    QAction *ha = qobject_cast<QAction*>(sender());
    if (!ha) return;
    int col = ha->data().toInt();
    set_column_visible(col, ha->isChecked());
}
void Singleton::f3();{
    }
    else
        QHeaderView::dragMoveEvent(event);
void PacketListHeader::dropEvent(QDropEvent *event)
    if (! event || ! event->mimeData())
}
void Singleton::f4();{
    if (e->button() == Qt::LeftButton && sectionIdx < 0)
    {
        /* No move happening yet */
        int sectIdx = logicalIndexAt(e->localPos().x() - 4, e->localPos().y());
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
        lastSize = sectionSize(sectIdx);
        QToolTip::showText(e->globalPos(), QString("Width: %1").arg(sectionSize(sectIdx)));
    }
    QHeaderView::mousePressEvent(e);
}
void Singleton::f2();{
void PacketListHeader::columnVisibilityTriggered()
    QAction *ha = qobject_cast<QAction*>(sender());
    if (!ha) return;
    int col = ha->data().toInt();
    set_column_visible(col, ha->isChecked());
}
void Singleton::f3();{
    }
    else
        QHeaderView::dragMoveEvent(event);
void PacketListHeader::dropEvent(QDropEvent *event)
    if (! event || ! event->mimeData())
}
void Singleton::f4();{
    if (e->button() == Qt::LeftButton && sectionIdx < 0)
    {
        /* No move happening yet */
        int sectIdx = logicalIndexAt(e->localPos().x() - 4, e->localPos().y());
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
}
void Singleton::f5();{
void PacketListHeader::setAlignment(QAction *action)
    if (!action)
        return;
    QActionGroup * group = action->actionGroup();
    if (! group)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
        lastSize = sectionSize(sectIdx);
        QToolTip::showText(e->globalPos(), QString("Width: %1").arg(sectionSize(sectIdx)));
    }
    QHeaderView::mousePressEvent(e);
}
void Singleton::f2();{
void PacketListHeader::columnVisibilityTriggered()
    QAction *ha = qobject_cast<QAction*>(sender());
    if (!ha) return;
    int col = ha->data().toInt();
    set_column_visible(col, ha->isChecked());
}
void Singleton::f3();{
    }
    else
        QHeaderView::dragMoveEvent(event);
void PacketListHeader::dropEvent(QDropEvent *event)
    if (! event || ! event->mimeData())
}
void Singleton::f4();{
    if (e->button() == Qt::LeftButton && sectionIdx < 0)
    {
        /* No move happening yet */
        int sectIdx = logicalIndexAt(e->localPos().x() - 4, e->localPos().y());
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
}
void Singleton::f5();{
void PacketListHeader::setAlignment(QAction *action)
    if (!action)
        return;
    QActionGroup * group = action->actionGroup();
    if (! group)
}
void Singleton::f6();{
        connect(action, &QAction::triggered, this, &PacketListHeader::columnVisibilityTriggered);
        contextMenu->addAction(action);
    }
    contextMenu->setToolTipsVisible(true);
    contextMenu->addSeparator();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
        lastSize = sectionSize(sectIdx);
        QToolTip::showText(e->globalPos(), QString("Width: %1").arg(sectionSize(sectIdx)));
    }
    QHeaderView::mousePressEvent(e);
}
void Singleton::f2();{
void PacketListHeader::columnVisibilityTriggered()
    QAction *ha = qobject_cast<QAction*>(sender());
    if (!ha) return;
    int col = ha->data().toInt();
    set_column_visible(col, ha->isChecked());
}
void Singleton::f3();{
    }
    else
        QHeaderView::dragMoveEvent(event);
void PacketListHeader::dropEvent(QDropEvent *event)
    if (! event || ! event->mimeData())
}
void Singleton::f4();{
    if (e->button() == Qt::LeftButton && sectionIdx < 0)
    {
        /* No move happening yet */
        int sectIdx = logicalIndexAt(e->localPos().x() - 4, e->localPos().y());
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
}
void Singleton::f5();{
void PacketListHeader::setAlignment(QAction *action)
    if (!action)
        return;
    QActionGroup * group = action->actionGroup();
    if (! group)
}
void Singleton::f6();{
        connect(action, &QAction::triggered, this, &PacketListHeader::columnVisibilityTriggered);
        contextMenu->addAction(action);
    }
    contextMenu->setToolTipsVisible(true);
    contextMenu->addSeparator();
}
void Singleton::f7();{
        return;
    int section = menu->property("column").toInt();
    emit editColumn(section);
void PacketListHeader::doResolveNames()
    QAction * action = qobject_cast<QAction *>(sender());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
        lastSize = sectionSize(sectIdx);
        QToolTip::showText(e->globalPos(), QString("Width: %1").arg(sectionSize(sectIdx)));
    }
    QHeaderView::mousePressEvent(e);
}
void Singleton::f2();{
void PacketListHeader::columnVisibilityTriggered()
    QAction *ha = qobject_cast<QAction*>(sender());
    if (!ha) return;
    int col = ha->data().toInt();
    set_column_visible(col, ha->isChecked());
}
void Singleton::f3();{
    }
    else
        QHeaderView::dragMoveEvent(event);
void PacketListHeader::dropEvent(QDropEvent *event)
    if (! event || ! event->mimeData())
}
void Singleton::f4();{
    if (e->button() == Qt::LeftButton && sectionIdx < 0)
    {
        /* No move happening yet */
        int sectIdx = logicalIndexAt(e->localPos().x() - 4, e->localPos().y());
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
}
void Singleton::f5();{
void PacketListHeader::setAlignment(QAction *action)
    if (!action)
        return;
    QActionGroup * group = action->actionGroup();
    if (! group)
}
void Singleton::f6();{
        connect(action, &QAction::triggered, this, &PacketListHeader::columnVisibilityTriggered);
        contextMenu->addAction(action);
    }
    contextMenu->setToolTipsVisible(true);
    contextMenu->addSeparator();
}
void Singleton::f7();{
        return;
    int section = menu->property("column").toInt();
    emit editColumn(section);
void PacketListHeader::doResolveNames()
    QAction * action = qobject_cast<QAction *>(sender());
}
void Singleton::f8();{
            event->acceptProposedAction();
        }
    }
    else
        QHeaderView::dropEvent(event);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
        lastSize = sectionSize(sectIdx);
        QToolTip::showText(e->globalPos(), QString("Width: %1").arg(sectionSize(sectIdx)));
    }
    QHeaderView::mousePressEvent(e);
}
void Singleton::f2();{
void PacketListHeader::columnVisibilityTriggered()
    QAction *ha = qobject_cast<QAction*>(sender());
    if (!ha) return;
    int col = ha->data().toInt();
    set_column_visible(col, ha->isChecked());
}
void Singleton::f3();{
    }
    else
        QHeaderView::dragMoveEvent(event);
void PacketListHeader::dropEvent(QDropEvent *event)
    if (! event || ! event->mimeData())
}
void Singleton::f4();{
    if (e->button() == Qt::LeftButton && sectionIdx < 0)
    {
        /* No move happening yet */
        int sectIdx = logicalIndexAt(e->localPos().x() - 4, e->localPos().y());
        QString headerName = model()->headerData(sectIdx, orientation()).toString();
}
void Singleton::f5();{
void PacketListHeader::setAlignment(QAction *action)
    if (!action)
        return;
    QActionGroup * group = action->actionGroup();
    if (! group)
}
void Singleton::f6();{
        connect(action, &QAction::triggered, this, &PacketListHeader::columnVisibilityTriggered);
        contextMenu->addAction(action);
    }
    contextMenu->setToolTipsVisible(true);
    contextMenu->addSeparator();
}
void Singleton::f7();{
        return;
    int section = menu->property("column").toInt();
    emit editColumn(section);
void PacketListHeader::doResolveNames()
    QAction * action = qobject_cast<QAction *>(sender());
}
void Singleton::f8();{
            event->acceptProposedAction();
        }
    }
    else
        QHeaderView::dropEvent(event);
}
void Singleton::f9();{
        QHeaderView::dragMoveEvent(event);
void PacketListHeader::dropEvent(QDropEvent *event)
    if (! event || ! event->mimeData())
        return;
    /* Moving items around */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Print timing information
static PacketListModel * glbl_plist_model = Q_NULLPTR;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Print timing information
static PacketListModel * glbl_plist_model = Q_NULLPTR;
}
void Singleton::f2();{
    default:
        return false;
    }
    guint num_fields = g_slist_length(sort_cap_file_->cinfo.columns[column].col_custom_fields_ids);
    for (guint i = 0; i < num_fields; i++) {
}
void Singleton::f3();{
        PacketListRecord *record = static_cast<PacketListRecord*>(index.internalPointer());
        if (!record)
            continue;
        frame_data *fdata = record->frameData();
        if (!fdata)
}
void Singleton::f4();{
        if (set) {
            cf_mark_frame(cap_file_, record->frameData());
        } else {
            cf_unmark_frame(cap_file_, record->frameData());
        }
}
void Singleton::f5();{
    if (!record->colorized()) {
        record->columnString(cap_file_, 1, true);
    }
int PacketListModel::visibleIndexOf(frame_data *fdata) const
    int row = 0;
}
void Singleton::f6();{
    }
    switch (sort_cap_file_->cinfo.columns[column].col_fmt) {
    case COL_8021Q_VLAN_ID:  /**< 0) 802.1Q vlan ID */
    case COL_CUMULATIVE_BYTES: /**< 5) Cumulative number of bytes */
    case COL_DELTA_TIME:     /**< 8) Delta time */
}
void Singleton::f7();{
        fdata->ref_time=0;
        cap_file_->ref_time_count--;
    } else {
        fdata->ref_time=1;
        cap_file_->ref_time_count++;
}
void Singleton::f8();{
    if (!cap_file_ || indeces.count() <= 0)
        return;
    int sectionMax = columnCount() - 1;
    foreach (QModelIndex index, indeces) {
        if (! index.isValid())
}
void Singleton::f9();{
    Q_ASSERT(glbl_plist_model == Q_NULLPTR);
    glbl_plist_model = this;
    setCaptureFile(cf);
    physical_rows_.reserve(reserved_packets_);
    visible_rows_.reserve(reserved_packets_);
}
void Singleton::f10();{
            cf_mark_frame(cap_file_, record->frameData());
        } else {
            cf_unmark_frame(cap_file_, record->frameData());
        }
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Print timing information
static PacketListModel * glbl_plist_model = Q_NULLPTR;
}
void Singleton::f2();{
    default:
        return false;
    }
    guint num_fields = g_slist_length(sort_cap_file_->cinfo.columns[column].col_custom_fields_ids);
    for (guint i = 0; i < num_fields; i++) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Print timing information
static PacketListModel * glbl_plist_model = Q_NULLPTR;
}
void Singleton::f2();{
    default:
        return false;
    }
    guint num_fields = g_slist_length(sort_cap_file_->cinfo.columns[column].col_custom_fields_ids);
    for (guint i = 0; i < num_fields; i++) {
}
void Singleton::f3();{
        PacketListRecord *record = static_cast<PacketListRecord*>(index.internalPointer());
        if (!record)
            continue;
        frame_data *fdata = record->frameData();
        if (!fdata)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Print timing information
static PacketListModel * glbl_plist_model = Q_NULLPTR;
}
void Singleton::f2();{
    default:
        return false;
    }
    guint num_fields = g_slist_length(sort_cap_file_->cinfo.columns[column].col_custom_fields_ids);
    for (guint i = 0; i < num_fields; i++) {
}
void Singleton::f3();{
        PacketListRecord *record = static_cast<PacketListRecord*>(index.internalPointer());
        if (!record)
            continue;
        frame_data *fdata = record->frameData();
        if (!fdata)
}
void Singleton::f4();{
        if (set) {
            cf_mark_frame(cap_file_, record->frameData());
        } else {
            cf_unmark_frame(cap_file_, record->frameData());
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Print timing information
static PacketListModel * glbl_plist_model = Q_NULLPTR;
}
void Singleton::f2();{
    default:
        return false;
    }
    guint num_fields = g_slist_length(sort_cap_file_->cinfo.columns[column].col_custom_fields_ids);
    for (guint i = 0; i < num_fields; i++) {
}
void Singleton::f3();{
        PacketListRecord *record = static_cast<PacketListRecord*>(index.internalPointer());
        if (!record)
            continue;
        frame_data *fdata = record->frameData();
        if (!fdata)
}
void Singleton::f4();{
        if (set) {
            cf_mark_frame(cap_file_, record->frameData());
        } else {
            cf_unmark_frame(cap_file_, record->frameData());
        }
}
void Singleton::f5();{
    if (!record->colorized()) {
        record->columnString(cap_file_, 1, true);
    }
int PacketListModel::visibleIndexOf(frame_data *fdata) const
    int row = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Print timing information
static PacketListModel * glbl_plist_model = Q_NULLPTR;
}
void Singleton::f2();{
    default:
        return false;
    }
    guint num_fields = g_slist_length(sort_cap_file_->cinfo.columns[column].col_custom_fields_ids);
    for (guint i = 0; i < num_fields; i++) {
}
void Singleton::f3();{
        PacketListRecord *record = static_cast<PacketListRecord*>(index.internalPointer());
        if (!record)
            continue;
        frame_data *fdata = record->frameData();
        if (!fdata)
}
void Singleton::f4();{
        if (set) {
            cf_mark_frame(cap_file_, record->frameData());
        } else {
            cf_unmark_frame(cap_file_, record->frameData());
        }
}
void Singleton::f5();{
    if (!record->colorized()) {
        record->columnString(cap_file_, 1, true);
    }
int PacketListModel::visibleIndexOf(frame_data *fdata) const
    int row = 0;
}
void Singleton::f6();{
    }
    switch (sort_cap_file_->cinfo.columns[column].col_fmt) {
    case COL_8021Q_VLAN_ID:  /**< 0) 802.1Q vlan ID */
    case COL_CUMULATIVE_BYTES: /**< 5) Cumulative number of bytes */
    case COL_DELTA_TIME:     /**< 8) Delta time */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Print timing information
static PacketListModel * glbl_plist_model = Q_NULLPTR;
}
void Singleton::f2();{
    default:
        return false;
    }
    guint num_fields = g_slist_length(sort_cap_file_->cinfo.columns[column].col_custom_fields_ids);
    for (guint i = 0; i < num_fields; i++) {
}
void Singleton::f3();{
        PacketListRecord *record = static_cast<PacketListRecord*>(index.internalPointer());
        if (!record)
            continue;
        frame_data *fdata = record->frameData();
        if (!fdata)
}
void Singleton::f4();{
        if (set) {
            cf_mark_frame(cap_file_, record->frameData());
        } else {
            cf_unmark_frame(cap_file_, record->frameData());
        }
}
void Singleton::f5();{
    if (!record->colorized()) {
        record->columnString(cap_file_, 1, true);
    }
int PacketListModel::visibleIndexOf(frame_data *fdata) const
    int row = 0;
}
void Singleton::f6();{
    }
    switch (sort_cap_file_->cinfo.columns[column].col_fmt) {
    case COL_8021Q_VLAN_ID:  /**< 0) 802.1Q vlan ID */
    case COL_CUMULATIVE_BYTES: /**< 5) Cumulative number of bytes */
    case COL_DELTA_TIME:     /**< 8) Delta time */
}
void Singleton::f7();{
        fdata->ref_time=0;
        cap_file_->ref_time_count--;
    } else {
        fdata->ref_time=1;
        cap_file_->ref_time_count++;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Print timing information
static PacketListModel * glbl_plist_model = Q_NULLPTR;
}
void Singleton::f2();{
    default:
        return false;
    }
    guint num_fields = g_slist_length(sort_cap_file_->cinfo.columns[column].col_custom_fields_ids);
    for (guint i = 0; i < num_fields; i++) {
}
void Singleton::f3();{
        PacketListRecord *record = static_cast<PacketListRecord*>(index.internalPointer());
        if (!record)
            continue;
        frame_data *fdata = record->frameData();
        if (!fdata)
}
void Singleton::f4();{
        if (set) {
            cf_mark_frame(cap_file_, record->frameData());
        } else {
            cf_unmark_frame(cap_file_, record->frameData());
        }
}
void Singleton::f5();{
    if (!record->colorized()) {
        record->columnString(cap_file_, 1, true);
    }
int PacketListModel::visibleIndexOf(frame_data *fdata) const
    int row = 0;
}
void Singleton::f6();{
    }
    switch (sort_cap_file_->cinfo.columns[column].col_fmt) {
    case COL_8021Q_VLAN_ID:  /**< 0) 802.1Q vlan ID */
    case COL_CUMULATIVE_BYTES: /**< 5) Cumulative number of bytes */
    case COL_DELTA_TIME:     /**< 8) Delta time */
}
void Singleton::f7();{
        fdata->ref_time=0;
        cap_file_->ref_time_count--;
    } else {
        fdata->ref_time=1;
        cap_file_->ref_time_count++;
}
void Singleton::f8();{
    if (!cap_file_ || indeces.count() <= 0)
        return;
    int sectionMax = columnCount() - 1;
    foreach (QModelIndex index, indeces) {
        if (! index.isValid())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Print timing information
static PacketListModel * glbl_plist_model = Q_NULLPTR;
}
void Singleton::f2();{
    default:
        return false;
    }
    guint num_fields = g_slist_length(sort_cap_file_->cinfo.columns[column].col_custom_fields_ids);
    for (guint i = 0; i < num_fields; i++) {
}
void Singleton::f3();{
        PacketListRecord *record = static_cast<PacketListRecord*>(index.internalPointer());
        if (!record)
            continue;
        frame_data *fdata = record->frameData();
        if (!fdata)
}
void Singleton::f4();{
        if (set) {
            cf_mark_frame(cap_file_, record->frameData());
        } else {
            cf_unmark_frame(cap_file_, record->frameData());
        }
}
void Singleton::f5();{
    if (!record->colorized()) {
        record->columnString(cap_file_, 1, true);
    }
int PacketListModel::visibleIndexOf(frame_data *fdata) const
    int row = 0;
}
void Singleton::f6();{
    }
    switch (sort_cap_file_->cinfo.columns[column].col_fmt) {
    case COL_8021Q_VLAN_ID:  /**< 0) 802.1Q vlan ID */
    case COL_CUMULATIVE_BYTES: /**< 5) Cumulative number of bytes */
    case COL_DELTA_TIME:     /**< 8) Delta time */
}
void Singleton::f7();{
        fdata->ref_time=0;
        cap_file_->ref_time_count--;
    } else {
        fdata->ref_time=1;
        cap_file_->ref_time_count++;
}
void Singleton::f8();{
    if (!cap_file_ || indeces.count() <= 0)
        return;
    int sectionMax = columnCount() - 1;
    foreach (QModelIndex index, indeces) {
        if (! index.isValid())
}
void Singleton::f9();{
    Q_ASSERT(glbl_plist_model == Q_NULLPTR);
    glbl_plist_model = this;
    setCaptureFile(cf);
    physical_rows_.reserve(reserved_packets_);
    visible_rows_.reserve(reserved_packets_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
}
void Singleton::f2();{
     * We do if:
     *
     *    we're going to apply a color filter to this packet;
     *
     *    we're need to fill in the columns and we have custom columns
}
void Singleton::f3();{
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
            }
}
void Singleton::f4();{
            col_str = QString(cinfo->col_expr.col_expr_val[column]);
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
}
void Singleton::f5();{
    ws_buffer_init(&buf, 1514);
    if (read_failed_) {
        read_failed_ = !cf_read_record_no_alert(cap_file, fdata_, &rec, &buf);
    } else {
        read_failed_ = !cf_read_record(cap_file, fdata_, &rec, &buf);
}
void Singleton::f6();{
            col_text_ << QString(cinfo->columns[column].col_data);
            continue;
        }
        switch (cinfo->col_fmt[column]) {
        case COL_PROTOCOL:
}
void Singleton::f7();{
            fdata_->color_filter = NULL;
            colorized_ = true;
        }
        ws_buffer_free(&buf);
        wtap_rec_cleanup(&rec);
}
void Singleton::f8();{
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
PacketListRecord::PacketListRecord(frame_data *frameData) :
}
void Singleton::f9();{
    }
void PacketListRecord::dissect(capture_file *cap_file, bool dissect_color)
    // packet_list_store.c:packet_list_dissect_and_cache_record
    epan_dissect_t edt;
    column_info *cinfo = NULL;
}
void Singleton::f10();{
        /*
         * Error reading the record.
         *
         * Don't set the color filter for now (we might want
         * to colorize it in some fashion to warn that the
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
}
void Singleton::f2();{
     * We do if:
     *
     *    we're going to apply a color filter to this packet;
     *
     *    we're need to fill in the columns and we have custom columns
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
}
void Singleton::f2();{
     * We do if:
     *
     *    we're going to apply a color filter to this packet;
     *
     *    we're need to fill in the columns and we have custom columns
}
void Singleton::f3();{
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
}
void Singleton::f2();{
     * We do if:
     *
     *    we're going to apply a color filter to this packet;
     *
     *    we're need to fill in the columns and we have custom columns
}
void Singleton::f3();{
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
            }
}
void Singleton::f4();{
            col_str = QString(cinfo->col_expr.col_expr_val[column]);
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
}
void Singleton::f2();{
     * We do if:
     *
     *    we're going to apply a color filter to this packet;
     *
     *    we're need to fill in the columns and we have custom columns
}
void Singleton::f3();{
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
            }
}
void Singleton::f4();{
            col_str = QString(cinfo->col_expr.col_expr_val[column]);
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
}
void Singleton::f5();{
    ws_buffer_init(&buf, 1514);
    if (read_failed_) {
        read_failed_ = !cf_read_record_no_alert(cap_file, fdata_, &rec, &buf);
    } else {
        read_failed_ = !cf_read_record(cap_file, fdata_, &rec, &buf);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
}
void Singleton::f2();{
     * We do if:
     *
     *    we're going to apply a color filter to this packet;
     *
     *    we're need to fill in the columns and we have custom columns
}
void Singleton::f3();{
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
            }
}
void Singleton::f4();{
            col_str = QString(cinfo->col_expr.col_expr_val[column]);
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
}
void Singleton::f5();{
    ws_buffer_init(&buf, 1514);
    if (read_failed_) {
        read_failed_ = !cf_read_record_no_alert(cap_file, fdata_, &rec, &buf);
    } else {
        read_failed_ = !cf_read_record(cap_file, fdata_, &rec, &buf);
}
void Singleton::f6();{
            col_text_ << QString(cinfo->columns[column].col_data);
            continue;
        }
        switch (cinfo->col_fmt[column]) {
        case COL_PROTOCOL:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
}
void Singleton::f2();{
     * We do if:
     *
     *    we're going to apply a color filter to this packet;
     *
     *    we're need to fill in the columns and we have custom columns
}
void Singleton::f3();{
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
            }
}
void Singleton::f4();{
            col_str = QString(cinfo->col_expr.col_expr_val[column]);
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
}
void Singleton::f5();{
    ws_buffer_init(&buf, 1514);
    if (read_failed_) {
        read_failed_ = !cf_read_record_no_alert(cap_file, fdata_, &rec, &buf);
    } else {
        read_failed_ = !cf_read_record(cap_file, fdata_, &rec, &buf);
}
void Singleton::f6();{
            col_text_ << QString(cinfo->columns[column].col_data);
            continue;
        }
        switch (cinfo->col_fmt[column]) {
        case COL_PROTOCOL:
}
void Singleton::f7();{
            fdata_->color_filter = NULL;
            colorized_ = true;
        }
        ws_buffer_free(&buf);
        wtap_rec_cleanup(&rec);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
}
void Singleton::f2();{
     * We do if:
     *
     *    we're going to apply a color filter to this packet;
     *
     *    we're need to fill in the columns and we have custom columns
}
void Singleton::f3();{
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
            }
}
void Singleton::f4();{
            col_str = QString(cinfo->col_expr.col_expr_val[column]);
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
}
void Singleton::f5();{
    ws_buffer_init(&buf, 1514);
    if (read_failed_) {
        read_failed_ = !cf_read_record_no_alert(cap_file, fdata_, &rec, &buf);
    } else {
        read_failed_ = !cf_read_record(cap_file, fdata_, &rec, &buf);
}
void Singleton::f6();{
            col_text_ << QString(cinfo->columns[column].col_data);
            continue;
        }
        switch (cinfo->col_fmt[column]) {
        case COL_PROTOCOL:
}
void Singleton::f7();{
            fdata_->color_filter = NULL;
            colorized_ = true;
        }
        ws_buffer_free(&buf);
        wtap_rec_cleanup(&rec);
}
void Singleton::f8();{
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
PacketListRecord::PacketListRecord(frame_data *frameData) :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
}
void Singleton::f2();{
     * We do if:
     *
     *    we're going to apply a color filter to this packet;
     *
     *    we're need to fill in the columns and we have custom columns
}
void Singleton::f3();{
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
            }
}
void Singleton::f4();{
            col_str = QString(cinfo->col_expr.col_expr_val[column]);
        } else {
            int text_col = cinfo_column_.value(column, -1);
            if (text_col < 0) {
                col_fill_in_frame_data(fdata_, cinfo, column, FALSE);
}
void Singleton::f5();{
    ws_buffer_init(&buf, 1514);
    if (read_failed_) {
        read_failed_ = !cf_read_record_no_alert(cap_file, fdata_, &rec, &buf);
    } else {
        read_failed_ = !cf_read_record(cap_file, fdata_, &rec, &buf);
}
void Singleton::f6();{
            col_text_ << QString(cinfo->columns[column].col_data);
            continue;
        }
        switch (cinfo->col_fmt[column]) {
        case COL_PROTOCOL:
}
void Singleton::f7();{
            fdata_->color_filter = NULL;
            colorized_ = true;
        }
        ws_buffer_free(&buf);
        wtap_rec_cleanup(&rec);
}
void Singleton::f8();{
 * SPDX-License-Identifier: GPL-2.0-or-later
QMap<int, int> PacketListRecord::cinfo_column_;
unsigned PacketListRecord::col_data_ver_ = 1;
unsigned PacketListRecord::rows_color_ver_ = 1;
PacketListRecord::PacketListRecord(frame_data *frameData) :
}
void Singleton::f9();{
    }
void PacketListRecord::dissect(capture_file *cap_file, bool dissect_color)
    // packet_list_store.c:packet_list_dissect_and_cache_record
    epan_dissect_t edt;
    column_info *cinfo = NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            label_count -= range_->ignored_user_range_cnt;
        }
        pr_ui_->rangeCapturedLabel->setText(QString("%1").arg(label_count));
        label_count = range_->displayed_user_range_cnt;
        if (range_->remove_ignored) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            label_count -= range_->ignored_user_range_cnt;
        }
        pr_ui_->rangeCapturedLabel->setText(QString("%1").arg(label_count));
        label_count = range_->displayed_user_range_cnt;
        if (range_->remove_ignored) {
}
void Singleton::f2();{
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
        pr_ui_->ignoredCapturedLabel->setEnabled(!displayed_checked);
        pr_ui_->ignoredDisplayedLabel->setEnabled(displayed_checked);
    } else {
}
void Singleton::f3();{
    }
    updateCounts();
bool PacketRangeGroupBox::isValid() {
    if (pr_ui_->rangeButton->isChecked() && syntax_state_ != SyntaxLineEdit::Empty) {
        return false;
}
void Singleton::f4();{
        selected_packets = (displayed_ignored_cnt != 0);
    else
        selected_packets = (ignored_cnt != 0);
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
}
void Singleton::f5();{
        if (range_) range_->process_filtered = TRUE;
        updateCounts();
    }
void PacketRangeGroupBox::on_ignoredCheckBox_toggled(bool checked)
    if (range_) range_->remove_ignored = checked ? TRUE : FALSE;
}
void Singleton::f6();{
    // User specified / Captured + Displayed
    pr_ui_->rangeButton->setEnabled(true);
    pr_ui_->rangeCapturedLabel->setEnabled(!displayed_checked);
    pr_ui_->rangeDisplayedLabel->setEnabled(displayed_checked);
    packet_range_convert_str(range_, pr_ui_->rangeLineEdit->text().toUtf8().constData());
}
void Singleton::f7();{
        g_assert_not_reached();
    }
    if (displayed_checked)
        selected_packets = (displayed_ignored_cnt != 0);
    else
}
void Singleton::f8();{
    pr_ui_->setupUi(this);
    setFlat(true);
    pr_ui_->displayedButton->setChecked(true);
    pr_ui_->allButton->setChecked(true);
PacketRangeGroupBox::~PacketRangeGroupBox()
}
void Singleton::f9();{
    // Marked / Captured + Displayed
    if (displayed_checked) {
        selected_packets = (range_->displayed_marked_cnt != 0);
    } else {
        selected_packets = (range_->cf->marked_count > 0);
}
void Singleton::f10();{
        label_count -= range_->ignored_mark_range_cnt;
    }
    pr_ui_->ftlCapturedLabel->setText(QString("%1").arg(label_count));
    label_count = range_->displayed_mark_range_cnt;
    if (range_->remove_ignored) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            label_count -= range_->ignored_user_range_cnt;
        }
        pr_ui_->rangeCapturedLabel->setText(QString("%1").arg(label_count));
        label_count = range_->displayed_user_range_cnt;
        if (range_->remove_ignored) {
}
void Singleton::f2();{
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
        pr_ui_->ignoredCapturedLabel->setEnabled(!displayed_checked);
        pr_ui_->ignoredDisplayedLabel->setEnabled(displayed_checked);
    } else {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            label_count -= range_->ignored_user_range_cnt;
        }
        pr_ui_->rangeCapturedLabel->setText(QString("%1").arg(label_count));
        label_count = range_->displayed_user_range_cnt;
        if (range_->remove_ignored) {
}
void Singleton::f2();{
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
        pr_ui_->ignoredCapturedLabel->setEnabled(!displayed_checked);
        pr_ui_->ignoredDisplayedLabel->setEnabled(displayed_checked);
    } else {
}
void Singleton::f3();{
    }
    updateCounts();
bool PacketRangeGroupBox::isValid() {
    if (pr_ui_->rangeButton->isChecked() && syntax_state_ != SyntaxLineEdit::Empty) {
        return false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            label_count -= range_->ignored_user_range_cnt;
        }
        pr_ui_->rangeCapturedLabel->setText(QString("%1").arg(label_count));
        label_count = range_->displayed_user_range_cnt;
        if (range_->remove_ignored) {
}
void Singleton::f2();{
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
        pr_ui_->ignoredCapturedLabel->setEnabled(!displayed_checked);
        pr_ui_->ignoredDisplayedLabel->setEnabled(displayed_checked);
    } else {
}
void Singleton::f3();{
    }
    updateCounts();
bool PacketRangeGroupBox::isValid() {
    if (pr_ui_->rangeButton->isChecked() && syntax_state_ != SyntaxLineEdit::Empty) {
        return false;
}
void Singleton::f4();{
        selected_packets = (displayed_ignored_cnt != 0);
    else
        selected_packets = (ignored_cnt != 0);
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            label_count -= range_->ignored_user_range_cnt;
        }
        pr_ui_->rangeCapturedLabel->setText(QString("%1").arg(label_count));
        label_count = range_->displayed_user_range_cnt;
        if (range_->remove_ignored) {
}
void Singleton::f2();{
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
        pr_ui_->ignoredCapturedLabel->setEnabled(!displayed_checked);
        pr_ui_->ignoredDisplayedLabel->setEnabled(displayed_checked);
    } else {
}
void Singleton::f3();{
    }
    updateCounts();
bool PacketRangeGroupBox::isValid() {
    if (pr_ui_->rangeButton->isChecked() && syntax_state_ != SyntaxLineEdit::Empty) {
        return false;
}
void Singleton::f4();{
        selected_packets = (displayed_ignored_cnt != 0);
    else
        selected_packets = (ignored_cnt != 0);
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
}
void Singleton::f5();{
        if (range_) range_->process_filtered = TRUE;
        updateCounts();
    }
void PacketRangeGroupBox::on_ignoredCheckBox_toggled(bool checked)
    if (range_) range_->remove_ignored = checked ? TRUE : FALSE;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            label_count -= range_->ignored_user_range_cnt;
        }
        pr_ui_->rangeCapturedLabel->setText(QString("%1").arg(label_count));
        label_count = range_->displayed_user_range_cnt;
        if (range_->remove_ignored) {
}
void Singleton::f2();{
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
        pr_ui_->ignoredCapturedLabel->setEnabled(!displayed_checked);
        pr_ui_->ignoredDisplayedLabel->setEnabled(displayed_checked);
    } else {
}
void Singleton::f3();{
    }
    updateCounts();
bool PacketRangeGroupBox::isValid() {
    if (pr_ui_->rangeButton->isChecked() && syntax_state_ != SyntaxLineEdit::Empty) {
        return false;
}
void Singleton::f4();{
        selected_packets = (displayed_ignored_cnt != 0);
    else
        selected_packets = (ignored_cnt != 0);
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
}
void Singleton::f5();{
        if (range_) range_->process_filtered = TRUE;
        updateCounts();
    }
void PacketRangeGroupBox::on_ignoredCheckBox_toggled(bool checked)
    if (range_) range_->remove_ignored = checked ? TRUE : FALSE;
}
void Singleton::f6();{
    // User specified / Captured + Displayed
    pr_ui_->rangeButton->setEnabled(true);
    pr_ui_->rangeCapturedLabel->setEnabled(!displayed_checked);
    pr_ui_->rangeDisplayedLabel->setEnabled(displayed_checked);
    packet_range_convert_str(range_, pr_ui_->rangeLineEdit->text().toUtf8().constData());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            label_count -= range_->ignored_user_range_cnt;
        }
        pr_ui_->rangeCapturedLabel->setText(QString("%1").arg(label_count));
        label_count = range_->displayed_user_range_cnt;
        if (range_->remove_ignored) {
}
void Singleton::f2();{
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
        pr_ui_->ignoredCapturedLabel->setEnabled(!displayed_checked);
        pr_ui_->ignoredDisplayedLabel->setEnabled(displayed_checked);
    } else {
}
void Singleton::f3();{
    }
    updateCounts();
bool PacketRangeGroupBox::isValid() {
    if (pr_ui_->rangeButton->isChecked() && syntax_state_ != SyntaxLineEdit::Empty) {
        return false;
}
void Singleton::f4();{
        selected_packets = (displayed_ignored_cnt != 0);
    else
        selected_packets = (ignored_cnt != 0);
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
}
void Singleton::f5();{
        if (range_) range_->process_filtered = TRUE;
        updateCounts();
    }
void PacketRangeGroupBox::on_ignoredCheckBox_toggled(bool checked)
    if (range_) range_->remove_ignored = checked ? TRUE : FALSE;
}
void Singleton::f6();{
    // User specified / Captured + Displayed
    pr_ui_->rangeButton->setEnabled(true);
    pr_ui_->rangeCapturedLabel->setEnabled(!displayed_checked);
    pr_ui_->rangeDisplayedLabel->setEnabled(displayed_checked);
    packet_range_convert_str(range_, pr_ui_->rangeLineEdit->text().toUtf8().constData());
}
void Singleton::f7();{
        g_assert_not_reached();
    }
    if (displayed_checked)
        selected_packets = (displayed_ignored_cnt != 0);
    else
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            label_count -= range_->ignored_user_range_cnt;
        }
        pr_ui_->rangeCapturedLabel->setText(QString("%1").arg(label_count));
        label_count = range_->displayed_user_range_cnt;
        if (range_->remove_ignored) {
}
void Singleton::f2();{
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
        pr_ui_->ignoredCapturedLabel->setEnabled(!displayed_checked);
        pr_ui_->ignoredDisplayedLabel->setEnabled(displayed_checked);
    } else {
}
void Singleton::f3();{
    }
    updateCounts();
bool PacketRangeGroupBox::isValid() {
    if (pr_ui_->rangeButton->isChecked() && syntax_state_ != SyntaxLineEdit::Empty) {
        return false;
}
void Singleton::f4();{
        selected_packets = (displayed_ignored_cnt != 0);
    else
        selected_packets = (ignored_cnt != 0);
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
}
void Singleton::f5();{
        if (range_) range_->process_filtered = TRUE;
        updateCounts();
    }
void PacketRangeGroupBox::on_ignoredCheckBox_toggled(bool checked)
    if (range_) range_->remove_ignored = checked ? TRUE : FALSE;
}
void Singleton::f6();{
    // User specified / Captured + Displayed
    pr_ui_->rangeButton->setEnabled(true);
    pr_ui_->rangeCapturedLabel->setEnabled(!displayed_checked);
    pr_ui_->rangeDisplayedLabel->setEnabled(displayed_checked);
    packet_range_convert_str(range_, pr_ui_->rangeLineEdit->text().toUtf8().constData());
}
void Singleton::f7();{
        g_assert_not_reached();
    }
    if (displayed_checked)
        selected_packets = (displayed_ignored_cnt != 0);
    else
}
void Singleton::f8();{
    pr_ui_->setupUi(this);
    setFlat(true);
    pr_ui_->displayedButton->setChecked(true);
    pr_ui_->allButton->setChecked(true);
PacketRangeGroupBox::~PacketRangeGroupBox()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            label_count -= range_->ignored_user_range_cnt;
        }
        pr_ui_->rangeCapturedLabel->setText(QString("%1").arg(label_count));
        label_count = range_->displayed_user_range_cnt;
        if (range_->remove_ignored) {
}
void Singleton::f2();{
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
        pr_ui_->ignoredCapturedLabel->setEnabled(!displayed_checked);
        pr_ui_->ignoredDisplayedLabel->setEnabled(displayed_checked);
    } else {
}
void Singleton::f3();{
    }
    updateCounts();
bool PacketRangeGroupBox::isValid() {
    if (pr_ui_->rangeButton->isChecked() && syntax_state_ != SyntaxLineEdit::Empty) {
        return false;
}
void Singleton::f4();{
        selected_packets = (displayed_ignored_cnt != 0);
    else
        selected_packets = (ignored_cnt != 0);
    if (selected_packets) {
        pr_ui_->ignoredCheckBox->setEnabled(true);
}
void Singleton::f5();{
        if (range_) range_->process_filtered = TRUE;
        updateCounts();
    }
void PacketRangeGroupBox::on_ignoredCheckBox_toggled(bool checked)
    if (range_) range_->remove_ignored = checked ? TRUE : FALSE;
}
void Singleton::f6();{
    // User specified / Captured + Displayed
    pr_ui_->rangeButton->setEnabled(true);
    pr_ui_->rangeCapturedLabel->setEnabled(!displayed_checked);
    pr_ui_->rangeDisplayedLabel->setEnabled(displayed_checked);
    packet_range_convert_str(range_, pr_ui_->rangeLineEdit->text().toUtf8().constData());
}
void Singleton::f7();{
        g_assert_not_reached();
    }
    if (displayed_checked)
        selected_packets = (displayed_ignored_cnt != 0);
    else
}
void Singleton::f8();{
    pr_ui_->setupUi(this);
    setFlat(true);
    pr_ui_->displayedButton->setChecked(true);
    pr_ui_->allButton->setChecked(true);
PacketRangeGroupBox::~PacketRangeGroupBox()
}
void Singleton::f9();{
    // Marked / Captured + Displayed
    if (displayed_checked) {
        selected_packets = (range_->displayed_marked_cnt != 0);
    } else {
        selected_packets = (range_->cf->marked_count > 0);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
PathChooserDelegate::PathChooserDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
PathChooserDelegate::PathChooserDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
}
void Singleton::f2();{
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
    // Grow the item to match the editor. According to the QAbstractItemDelegate
    // documenation we're supposed to reimplement sizeHint but this seems to work.
}
void Singleton::f3();{
        {
            lineEdit->setText(file_name);
            emit commitData(parent);
        }
    }
}
void Singleton::f4();{
        }
    }
    else
        QStyledItemDelegate::setEditorData(editor, idx);
void PathChooserDelegate::setModelData(QWidget *editor, QAbstractItemModel * model, const QModelIndex &idx) const
}
void Singleton::f5();{
    btnBrowse->setText(tr("Browse"));
    hbox->setContentsMargins(0, 0, 0, 0);
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
}
void Singleton::f6();{
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
    pathEditor->setLayout(hbox);
    QLineEdit * lineEdit = new QLineEdit(pathEditor);
}
void Singleton::f7();{
    if (idx.isValid())
    {
        QString content = idx.data().toString();
        QLineEdit * lineEdit = editor->findChild<QLineEdit*>();
        if (lineEdit)
}
void Singleton::f8();{
    }
    delete(qw);
void PathChooserDelegate::setEditorData(QWidget *editor, const QModelIndex &idx) const
    if (idx.isValid())
    {
}
void Singleton::f9();{
    QWidget * qw = new QWidget();
    QString file_name = WiresharkFileDialog::getOpenFileName(qw, tr("Open Pipe"), open_dir);
    if (!file_name.isEmpty())
    {
        QWidget * parent = ((QPushButton *)sender())->parentWidget();
}
void Singleton::f10();{
        {
            lineEdit->setText(content);
        }
    }
    else
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
PathChooserDelegate::PathChooserDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
}
void Singleton::f2();{
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
    // Grow the item to match the editor. According to the QAbstractItemDelegate
    // documenation we're supposed to reimplement sizeHint but this seems to work.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
PathChooserDelegate::PathChooserDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
}
void Singleton::f2();{
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
    // Grow the item to match the editor. According to the QAbstractItemDelegate
    // documenation we're supposed to reimplement sizeHint but this seems to work.
}
void Singleton::f3();{
        {
            lineEdit->setText(file_name);
            emit commitData(parent);
        }
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
PathChooserDelegate::PathChooserDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
}
void Singleton::f2();{
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
    // Grow the item to match the editor. According to the QAbstractItemDelegate
    // documenation we're supposed to reimplement sizeHint but this seems to work.
}
void Singleton::f3();{
        {
            lineEdit->setText(file_name);
            emit commitData(parent);
        }
    }
}
void Singleton::f4();{
        }
    }
    else
        QStyledItemDelegate::setEditorData(editor, idx);
void PathChooserDelegate::setModelData(QWidget *editor, QAbstractItemModel * model, const QModelIndex &idx) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
PathChooserDelegate::PathChooserDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
}
void Singleton::f2();{
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
    // Grow the item to match the editor. According to the QAbstractItemDelegate
    // documenation we're supposed to reimplement sizeHint but this seems to work.
}
void Singleton::f3();{
        {
            lineEdit->setText(file_name);
            emit commitData(parent);
        }
    }
}
void Singleton::f4();{
        }
    }
    else
        QStyledItemDelegate::setEditorData(editor, idx);
void PathChooserDelegate::setModelData(QWidget *editor, QAbstractItemModel * model, const QModelIndex &idx) const
}
void Singleton::f5();{
    btnBrowse->setText(tr("Browse"));
    hbox->setContentsMargins(0, 0, 0, 0);
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
PathChooserDelegate::PathChooserDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
}
void Singleton::f2();{
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
    // Grow the item to match the editor. According to the QAbstractItemDelegate
    // documenation we're supposed to reimplement sizeHint but this seems to work.
}
void Singleton::f3();{
        {
            lineEdit->setText(file_name);
            emit commitData(parent);
        }
    }
}
void Singleton::f4();{
        }
    }
    else
        QStyledItemDelegate::setEditorData(editor, idx);
void PathChooserDelegate::setModelData(QWidget *editor, QAbstractItemModel * model, const QModelIndex &idx) const
}
void Singleton::f5();{
    btnBrowse->setText(tr("Browse"));
    hbox->setContentsMargins(0, 0, 0, 0);
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
}
void Singleton::f6();{
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
    pathEditor->setLayout(hbox);
    QLineEdit * lineEdit = new QLineEdit(pathEditor);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
PathChooserDelegate::PathChooserDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
}
void Singleton::f2();{
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
    // Grow the item to match the editor. According to the QAbstractItemDelegate
    // documenation we're supposed to reimplement sizeHint but this seems to work.
}
void Singleton::f3();{
        {
            lineEdit->setText(file_name);
            emit commitData(parent);
        }
    }
}
void Singleton::f4();{
        }
    }
    else
        QStyledItemDelegate::setEditorData(editor, idx);
void PathChooserDelegate::setModelData(QWidget *editor, QAbstractItemModel * model, const QModelIndex &idx) const
}
void Singleton::f5();{
    btnBrowse->setText(tr("Browse"));
    hbox->setContentsMargins(0, 0, 0, 0);
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
}
void Singleton::f6();{
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
    pathEditor->setLayout(hbox);
    QLineEdit * lineEdit = new QLineEdit(pathEditor);
}
void Singleton::f7();{
    if (idx.isValid())
    {
        QString content = idx.data().toString();
        QLineEdit * lineEdit = editor->findChild<QLineEdit*>();
        if (lineEdit)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
PathChooserDelegate::PathChooserDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
}
void Singleton::f2();{
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
    // Grow the item to match the editor. According to the QAbstractItemDelegate
    // documenation we're supposed to reimplement sizeHint but this seems to work.
}
void Singleton::f3();{
        {
            lineEdit->setText(file_name);
            emit commitData(parent);
        }
    }
}
void Singleton::f4();{
        }
    }
    else
        QStyledItemDelegate::setEditorData(editor, idx);
void PathChooserDelegate::setModelData(QWidget *editor, QAbstractItemModel * model, const QModelIndex &idx) const
}
void Singleton::f5();{
    btnBrowse->setText(tr("Browse"));
    hbox->setContentsMargins(0, 0, 0, 0);
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
}
void Singleton::f6();{
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
    pathEditor->setLayout(hbox);
    QLineEdit * lineEdit = new QLineEdit(pathEditor);
}
void Singleton::f7();{
    if (idx.isValid())
    {
        QString content = idx.data().toString();
        QLineEdit * lineEdit = editor->findChild<QLineEdit*>();
        if (lineEdit)
}
void Singleton::f8();{
    }
    delete(qw);
void PathChooserDelegate::setEditorData(QWidget *editor, const QModelIndex &idx) const
    if (idx.isValid())
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
PathChooserDelegate::PathChooserDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
}
void Singleton::f2();{
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
    // Grow the item to match the editor. According to the QAbstractItemDelegate
    // documenation we're supposed to reimplement sizeHint but this seems to work.
}
void Singleton::f3();{
        {
            lineEdit->setText(file_name);
            emit commitData(parent);
        }
    }
}
void Singleton::f4();{
        }
    }
    else
        QStyledItemDelegate::setEditorData(editor, idx);
void PathChooserDelegate::setModelData(QWidget *editor, QAbstractItemModel * model, const QModelIndex &idx) const
}
void Singleton::f5();{
    btnBrowse->setText(tr("Browse"));
    hbox->setContentsMargins(0, 0, 0, 0);
    hbox->addWidget(lineEdit);
    hbox->addWidget(btnBrowse);
    hbox->setSizeConstraint(QLayout::SetMinimumSize);
}
void Singleton::f6();{
QWidget* PathChooserDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &) const
    QWidget * pathEditor = new QWidget(parent);
    QHBoxLayout *hbox = new QHBoxLayout(pathEditor);
    pathEditor->setLayout(hbox);
    QLineEdit * lineEdit = new QLineEdit(pathEditor);
}
void Singleton::f7();{
    if (idx.isValid())
    {
        QString content = idx.data().toString();
        QLineEdit * lineEdit = editor->findChild<QLineEdit*>();
        if (lineEdit)
}
void Singleton::f8();{
    }
    delete(qw);
void PathChooserDelegate::setEditorData(QWidget *editor, const QModelIndex &idx) const
    if (idx.isValid())
    {
}
void Singleton::f9();{
    QWidget * qw = new QWidget();
    QString file_name = WiresharkFileDialog::getOpenFileName(qw, tr("Open Pipe"), open_dir);
    if (!file_name.isEmpty())
    {
        QWidget * parent = ((QPushButton *)sender())->parentWidget();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
static const int bar_em_width_ = 8;
static const double bar_blend_ = 0.15;
void PercentBarDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
static const int bar_em_width_ = 8;
static const double bar_blend_ = 0.15;
void PercentBarDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
}
void Singleton::f2();{
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    QColor text_color = option_vi.palette.color(cg, QPalette::Text);
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
}
void Singleton::f4();{
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
    if (option_vi.state & QStyle::State_Selected) {
}
void Singleton::f5();{
QSize PercentBarDelegate::sizeHint(const QStyleOptionViewItem &option,
                                   const QModelIndex &index) const
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
}
void Singleton::f6();{
        // doesn't appear to be a more general way to do this.
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText,
                               option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
}
void Singleton::f7();{
    pct_rect.adjust(1, 1, -1, -1);
    pct_rect.setWidth(((pct_rect.width() * value) / 100.0) + 0.5);
    painter->setPen(Qt::NoPen);
    painter->setBrush(bar_color);
    painter->drawRoundedRect(pct_rect, border_radius, border_radius);
}
void Singleton::f8();{
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
    if (option_vi.state & QStyle::State_Selected) {
}
void Singleton::f9();{
    painter->setPen(text_color);
    painter->drawText(option.rect, Qt::AlignCenter, pct_str);
    painter->restore();
QSize PercentBarDelegate::sizeHint(const QStyleOptionViewItem &option,
                                   const QModelIndex &index) const
}
void Singleton::f10();{
    QStyleOptionViewItem option_vi = option;
    QStyledItemDelegate::initStyleOption(&option_vi, index);
    // Paint our rect with no text using the current style, then draw our
    // bar and text over it.
    QStyledItemDelegate::paint(painter, option, index);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
static const int bar_em_width_ = 8;
static const double bar_blend_ = 0.15;
void PercentBarDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
}
void Singleton::f2();{
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
static const int bar_em_width_ = 8;
static const double bar_blend_ = 0.15;
void PercentBarDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
}
void Singleton::f2();{
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    QColor text_color = option_vi.palette.color(cg, QPalette::Text);
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
static const int bar_em_width_ = 8;
static const double bar_blend_ = 0.15;
void PercentBarDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
}
void Singleton::f2();{
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    QColor text_color = option_vi.palette.color(cg, QPalette::Text);
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
}
void Singleton::f4();{
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
    if (option_vi.state & QStyle::State_Selected) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
static const int bar_em_width_ = 8;
static const double bar_blend_ = 0.15;
void PercentBarDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
}
void Singleton::f2();{
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    QColor text_color = option_vi.palette.color(cg, QPalette::Text);
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
}
void Singleton::f4();{
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
    if (option_vi.state & QStyle::State_Selected) {
}
void Singleton::f5();{
QSize PercentBarDelegate::sizeHint(const QStyleOptionViewItem &option,
                                   const QModelIndex &index) const
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
static const int bar_em_width_ = 8;
static const double bar_blend_ = 0.15;
void PercentBarDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
}
void Singleton::f2();{
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    QColor text_color = option_vi.palette.color(cg, QPalette::Text);
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
}
void Singleton::f4();{
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
    if (option_vi.state & QStyle::State_Selected) {
}
void Singleton::f5();{
QSize PercentBarDelegate::sizeHint(const QStyleOptionViewItem &option,
                                   const QModelIndex &index) const
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
}
void Singleton::f6();{
        // doesn't appear to be a more general way to do this.
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText,
                               option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
static const int bar_em_width_ = 8;
static const double bar_blend_ = 0.15;
void PercentBarDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
}
void Singleton::f2();{
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    QColor text_color = option_vi.palette.color(cg, QPalette::Text);
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
}
void Singleton::f4();{
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
    if (option_vi.state & QStyle::State_Selected) {
}
void Singleton::f5();{
QSize PercentBarDelegate::sizeHint(const QStyleOptionViewItem &option,
                                   const QModelIndex &index) const
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
}
void Singleton::f6();{
        // doesn't appear to be a more general way to do this.
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText,
                               option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
}
void Singleton::f7();{
    pct_rect.adjust(1, 1, -1, -1);
    pct_rect.setWidth(((pct_rect.width() * value) / 100.0) + 0.5);
    painter->setPen(Qt::NoPen);
    painter->setBrush(bar_color);
    painter->drawRoundedRect(pct_rect, border_radius, border_radius);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
static const int bar_em_width_ = 8;
static const double bar_blend_ = 0.15;
void PercentBarDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
}
void Singleton::f2();{
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    QColor text_color = option_vi.palette.color(cg, QPalette::Text);
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
}
void Singleton::f4();{
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
    if (option_vi.state & QStyle::State_Selected) {
}
void Singleton::f5();{
QSize PercentBarDelegate::sizeHint(const QStyleOptionViewItem &option,
                                   const QModelIndex &index) const
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
}
void Singleton::f6();{
        // doesn't appear to be a more general way to do this.
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText,
                               option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
}
void Singleton::f7();{
    pct_rect.adjust(1, 1, -1, -1);
    pct_rect.setWidth(((pct_rect.width() * value) / 100.0) + 0.5);
    painter->setPen(Qt::NoPen);
    painter->setBrush(bar_color);
    painter->drawRoundedRect(pct_rect, border_radius, border_radius);
}
void Singleton::f8();{
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
    if (option_vi.state & QStyle::State_Selected) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
static const int bar_em_width_ = 8;
static const double bar_blend_ = 0.15;
void PercentBarDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
}
void Singleton::f2();{
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f3();{
    QColor text_color = option_vi.palette.color(cg, QPalette::Text);
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
}
void Singleton::f4();{
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
    if (option_vi.state & QStyle::State_Selected) {
}
void Singleton::f5();{
QSize PercentBarDelegate::sizeHint(const QStyleOptionViewItem &option,
                                   const QModelIndex &index) const
    return QSize(option.fontMetrics.height() * bar_em_width_,
                 QStyledItemDelegate::sizeHint(option, index).height());
 * Editor modelines
}
void Singleton::f6();{
        // doesn't appear to be a more general way to do this.
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText,
                               option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
}
void Singleton::f7();{
    pct_rect.adjust(1, 1, -1, -1);
    pct_rect.setWidth(((pct_rect.width() * value) / 100.0) + 0.5);
    painter->setPen(Qt::NoPen);
    painter->setBrush(bar_color);
    painter->drawRoundedRect(pct_rect, border_radius, border_radius);
}
void Singleton::f8();{
    QColor bar_color = ColorUtils::alphaBlend(option_vi.palette.windowText(),
                                              option_vi.palette.window(), bar_blend_);
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
    if (option_vi.state & QStyle::State_Selected) {
}
void Singleton::f9();{
    painter->setPen(text_color);
    painter->drawText(option.rect, Qt::AlignCenter, pct_str);
    painter->restore();
QSize PercentBarDelegate::sizeHint(const QStyleOptionViewItem &option,
                                   const QModelIndex &index) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        return;
    listModel->appendRow(new QStandardItem(content));
    if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
    {
        ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        return;
    listModel->appendRow(new QStandardItem(content));
    if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
    {
        ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f2();{
    QStandardItemModel * model = (QStandardItemModel *) ui->logView->model();
    model->appendRow(new QStandardItem(message));
void PluginIFDemo_Main::on_btnSendButtonText_clicked()
    if ( ! _toolbar )
        return;
}
void Singleton::f3();{
        return;
    ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
    if ( ! item || item->item_type != EXT_TOOLBAR_SELECTOR )
        return;
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
}
void Singleton::f4();{
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
        {
            ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f5();{
        return;
    QModelIndexList selIndeces = selModel-> selectedIndexes();
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
}
void Singleton::f6();{
    ext_toolbar_update_value(item, idxData, silent);
    g_free(idxData);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f7();{
    QString entryText = ui->txtEdit->text();
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
    ext_toolbar_update_value(item, (gpointer) entryText.toStdString().c_str(), silent);
void PluginIFDemo_Main::on_chkTestCheckbox_stateChanged(int newState)
    if ( ! _toolbar )
}
void Singleton::f8();{
            return;
        bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
        gchar * value = g_strdup(ui->txtNewItemValue->text().toUtf8().constData());
        gchar * display = g_strdup(ui->txtNewItemDisplay->text().toUtf8().constData());
        ext_toolbar_update_data_add_entry(item, display, value, silent);
}
void Singleton::f9();{
    ui->cmbElements->setModel(proxyModel);
    listModel = new QStandardItemModel(this);
    ui->lstItems->setModel(listModel);
    indexModel = new QStandardItemModel(this);
    ui->cmbEntryIndex->setModel(indexModel);
}
void Singleton::f10();{
    if ( ! _toolbar )
        return;
    ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
    if ( ! item || item->item_type != EXT_TOOLBAR_SELECTOR )
        return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        return;
    listModel->appendRow(new QStandardItem(content));
    if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
    {
        ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f2();{
    QStandardItemModel * model = (QStandardItemModel *) ui->logView->model();
    model->appendRow(new QStandardItem(message));
void PluginIFDemo_Main::on_btnSendButtonText_clicked()
    if ( ! _toolbar )
        return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        return;
    listModel->appendRow(new QStandardItem(content));
    if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
    {
        ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f2();{
    QStandardItemModel * model = (QStandardItemModel *) ui->logView->model();
    model->appendRow(new QStandardItem(message));
void PluginIFDemo_Main::on_btnSendButtonText_clicked()
    if ( ! _toolbar )
        return;
}
void Singleton::f3();{
        return;
    ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
    if ( ! item || item->item_type != EXT_TOOLBAR_SELECTOR )
        return;
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        return;
    listModel->appendRow(new QStandardItem(content));
    if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
    {
        ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f2();{
    QStandardItemModel * model = (QStandardItemModel *) ui->logView->model();
    model->appendRow(new QStandardItem(message));
void PluginIFDemo_Main::on_btnSendButtonText_clicked()
    if ( ! _toolbar )
        return;
}
void Singleton::f3();{
        return;
    ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
    if ( ! item || item->item_type != EXT_TOOLBAR_SELECTOR )
        return;
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
}
void Singleton::f4();{
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
        {
            ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        return;
    listModel->appendRow(new QStandardItem(content));
    if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
    {
        ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f2();{
    QStandardItemModel * model = (QStandardItemModel *) ui->logView->model();
    model->appendRow(new QStandardItem(message));
void PluginIFDemo_Main::on_btnSendButtonText_clicked()
    if ( ! _toolbar )
        return;
}
void Singleton::f3();{
        return;
    ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
    if ( ! item || item->item_type != EXT_TOOLBAR_SELECTOR )
        return;
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
}
void Singleton::f4();{
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
        {
            ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f5();{
        return;
    QModelIndexList selIndeces = selModel-> selectedIndexes();
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        return;
    listModel->appendRow(new QStandardItem(content));
    if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
    {
        ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f2();{
    QStandardItemModel * model = (QStandardItemModel *) ui->logView->model();
    model->appendRow(new QStandardItem(message));
void PluginIFDemo_Main::on_btnSendButtonText_clicked()
    if ( ! _toolbar )
        return;
}
void Singleton::f3();{
        return;
    ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
    if ( ! item || item->item_type != EXT_TOOLBAR_SELECTOR )
        return;
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
}
void Singleton::f4();{
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
        {
            ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f5();{
        return;
    QModelIndexList selIndeces = selModel-> selectedIndexes();
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
}
void Singleton::f6();{
    ext_toolbar_update_value(item, idxData, silent);
    g_free(idxData);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        return;
    listModel->appendRow(new QStandardItem(content));
    if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
    {
        ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f2();{
    QStandardItemModel * model = (QStandardItemModel *) ui->logView->model();
    model->appendRow(new QStandardItem(message));
void PluginIFDemo_Main::on_btnSendButtonText_clicked()
    if ( ! _toolbar )
        return;
}
void Singleton::f3();{
        return;
    ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
    if ( ! item || item->item_type != EXT_TOOLBAR_SELECTOR )
        return;
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
}
void Singleton::f4();{
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
        {
            ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f5();{
        return;
    QModelIndexList selIndeces = selModel-> selectedIndexes();
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
}
void Singleton::f6();{
    ext_toolbar_update_value(item, idxData, silent);
    g_free(idxData);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f7();{
    QString entryText = ui->txtEdit->text();
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
    ext_toolbar_update_value(item, (gpointer) entryText.toStdString().c_str(), silent);
void PluginIFDemo_Main::on_chkTestCheckbox_stateChanged(int newState)
    if ( ! _toolbar )
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        return;
    listModel->appendRow(new QStandardItem(content));
    if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
    {
        ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f2();{
    QStandardItemModel * model = (QStandardItemModel *) ui->logView->model();
    model->appendRow(new QStandardItem(message));
void PluginIFDemo_Main::on_btnSendButtonText_clicked()
    if ( ! _toolbar )
        return;
}
void Singleton::f3();{
        return;
    ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
    if ( ! item || item->item_type != EXT_TOOLBAR_SELECTOR )
        return;
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
}
void Singleton::f4();{
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
        {
            ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f5();{
        return;
    QModelIndexList selIndeces = selModel-> selectedIndexes();
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
}
void Singleton::f6();{
    ext_toolbar_update_value(item, idxData, silent);
    g_free(idxData);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f7();{
    QString entryText = ui->txtEdit->text();
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
    ext_toolbar_update_value(item, (gpointer) entryText.toStdString().c_str(), silent);
void PluginIFDemo_Main::on_chkTestCheckbox_stateChanged(int newState)
    if ( ! _toolbar )
}
void Singleton::f8();{
            return;
        bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
        gchar * value = g_strdup(ui->txtNewItemValue->text().toUtf8().constData());
        gchar * display = g_strdup(ui->txtNewItemDisplay->text().toUtf8().constData());
        ext_toolbar_update_data_add_entry(item, display, value, silent);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        return;
    listModel->appendRow(new QStandardItem(content));
    if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
    {
        ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f2();{
    QStandardItemModel * model = (QStandardItemModel *) ui->logView->model();
    model->appendRow(new QStandardItem(message));
void PluginIFDemo_Main::on_btnSendButtonText_clicked()
    if ( ! _toolbar )
        return;
}
void Singleton::f3();{
        return;
    ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
    if ( ! item || item->item_type != EXT_TOOLBAR_SELECTOR )
        return;
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
}
void Singleton::f4();{
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
        {
            ext_toolbar_t * item = ext_toolbar_entry_by_label(_toolbar, ui->cmbElements->currentText().toStdString().c_str());
}
void Singleton::f5();{
        return;
    QModelIndexList selIndeces = selModel-> selectedIndexes();
    foreach(QModelIndex idx, selIndeces)
    {
        if ( ui->chkAddRemoveImmediate->checkState() == Qt::Checked )
}
void Singleton::f6();{
    ext_toolbar_update_value(item, idxData, silent);
    g_free(idxData);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f7();{
    QString entryText = ui->txtEdit->text();
    bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
    ext_toolbar_update_value(item, (gpointer) entryText.toStdString().c_str(), silent);
void PluginIFDemo_Main::on_chkTestCheckbox_stateChanged(int newState)
    if ( ! _toolbar )
}
void Singleton::f8();{
            return;
        bool silent = ui->chkSilent->checkState() == Qt::Checked ? true : false;
        gchar * value = g_strdup(ui->txtNewItemValue->text().toUtf8().constData());
        gchar * display = g_strdup(ui->txtNewItemDisplay->text().toUtf8().constData());
        ext_toolbar_update_data_add_entry(item, display, value, silent);
}
void Singleton::f9();{
    ui->cmbElements->setModel(proxyModel);
    listModel = new QStandardItemModel(this);
    ui->lstItems->setModel(listModel);
    indexModel = new QStandardItemModel(this);
    ui->cmbEntryIndex->setModel(indexModel);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
            if (moduleWindow != NULL) {
                pd_ui_->stackedWidget->removeWidget(moduleWindow);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
            if (moduleWindow != NULL) {
                pd_ui_->stackedWidget->removeWidget(moduleWindow);
}
void Singleton::f2();{
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
    if (redissect_flags & PREF_EFFECT_FIELDS) {
        wsApp->queueAppSignal(WiresharkApplication::FieldsChanged);
    }
    if (redissect_flags & PREF_EFFECT_DISSECTION) {
}
void Singleton::f3();{
    pd_ui_->splitter->setSizes(sizes);
    pd_ui_->splitter->setStretchFactor(0, 1);
    pd_ui_->advancedView->expandAll();
    pd_ui_->advancedView->setSortingEnabled(true);
    pd_ui_->advancedView->sortByColumn(AdvancedPrefsModel::colName, Qt::AscendingOrder);
}
void Singleton::f4();{
        pref_unstash(pref, &unstashed_data);
    }
    /* If any of them changed, indicate that we must redissect and refilter
       the current capture (if we have one), as the preference change
       could cause packets to be dissected differently. */
}
void Singleton::f5();{
    unsigned int redissect_flags = 0;
    // XXX - We should validate preferences as the user changes them, not here.
    // XXX - We're also too enthusiastic about setting must_redissect.
    prefs_modules_foreach_submodules(NULL, module_prefs_unstash, (gpointer)&redissect_flags);
    if (redissect_flags & PREF_EFFECT_GUI_LAYOUT) {
}
void Singleton::f6();{
    prefs_apply_all();
    /* Fill in capture options with values from the preferences */
    prefs_to_capture_opts();
//    prefs_airpcap_update();
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
}
void Singleton::f7();{
    QList<int> sizes = pd_ui_->splitter->sizes();
    new_prefs_tree_width *= 2;
    pd_ui_->prefsView->resizeColumnToContents(ModulePrefsModel::colName);
    new_prefs_tree_width += pd_ui_->prefsView->columnWidth(ModulePrefsModel::colName);
    pd_ui_->prefsView->setMinimumWidth(new_prefs_tree_width);
}
void Singleton::f8();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
extern "C" {
// Callbacks prefs routines
static guint
}
void Singleton::f9();{
    } else {
        //If not found in prefs_pane_to_item_, it must be an individual module
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
}
void Singleton::f10();{
       Force an expansion */
    pd_ui_->advancedView->expandAll();
void PreferencesDialog::on_buttonBox_accepted()
    gchar* err = NULL;
    unsigned int redissect_flags = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
            if (moduleWindow != NULL) {
                pd_ui_->stackedWidget->removeWidget(moduleWindow);
}
void Singleton::f2();{
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
    if (redissect_flags & PREF_EFFECT_FIELDS) {
        wsApp->queueAppSignal(WiresharkApplication::FieldsChanged);
    }
    if (redissect_flags & PREF_EFFECT_DISSECTION) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
            if (moduleWindow != NULL) {
                pd_ui_->stackedWidget->removeWidget(moduleWindow);
}
void Singleton::f2();{
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
    if (redissect_flags & PREF_EFFECT_FIELDS) {
        wsApp->queueAppSignal(WiresharkApplication::FieldsChanged);
    }
    if (redissect_flags & PREF_EFFECT_DISSECTION) {
}
void Singleton::f3();{
    pd_ui_->splitter->setSizes(sizes);
    pd_ui_->splitter->setStretchFactor(0, 1);
    pd_ui_->advancedView->expandAll();
    pd_ui_->advancedView->setSortingEnabled(true);
    pd_ui_->advancedView->sortByColumn(AdvancedPrefsModel::colName, Qt::AscendingOrder);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
            if (moduleWindow != NULL) {
                pd_ui_->stackedWidget->removeWidget(moduleWindow);
}
void Singleton::f2();{
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
    if (redissect_flags & PREF_EFFECT_FIELDS) {
        wsApp->queueAppSignal(WiresharkApplication::FieldsChanged);
    }
    if (redissect_flags & PREF_EFFECT_DISSECTION) {
}
void Singleton::f3();{
    pd_ui_->splitter->setSizes(sizes);
    pd_ui_->splitter->setStretchFactor(0, 1);
    pd_ui_->advancedView->expandAll();
    pd_ui_->advancedView->setSortingEnabled(true);
    pd_ui_->advancedView->sortByColumn(AdvancedPrefsModel::colName, Qt::AscendingOrder);
}
void Singleton::f4();{
        pref_unstash(pref, &unstashed_data);
    }
    /* If any of them changed, indicate that we must redissect and refilter
       the current capture (if we have one), as the preference change
       could cause packets to be dissected differently. */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
            if (moduleWindow != NULL) {
                pd_ui_->stackedWidget->removeWidget(moduleWindow);
}
void Singleton::f2();{
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
    if (redissect_flags & PREF_EFFECT_FIELDS) {
        wsApp->queueAppSignal(WiresharkApplication::FieldsChanged);
    }
    if (redissect_flags & PREF_EFFECT_DISSECTION) {
}
void Singleton::f3();{
    pd_ui_->splitter->setSizes(sizes);
    pd_ui_->splitter->setStretchFactor(0, 1);
    pd_ui_->advancedView->expandAll();
    pd_ui_->advancedView->setSortingEnabled(true);
    pd_ui_->advancedView->sortByColumn(AdvancedPrefsModel::colName, Qt::AscendingOrder);
}
void Singleton::f4();{
        pref_unstash(pref, &unstashed_data);
    }
    /* If any of them changed, indicate that we must redissect and refilter
       the current capture (if we have one), as the preference change
       could cause packets to be dissected differently. */
}
void Singleton::f5();{
    unsigned int redissect_flags = 0;
    // XXX - We should validate preferences as the user changes them, not here.
    // XXX - We're also too enthusiastic about setting must_redissect.
    prefs_modules_foreach_submodules(NULL, module_prefs_unstash, (gpointer)&redissect_flags);
    if (redissect_flags & PREF_EFFECT_GUI_LAYOUT) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
            if (moduleWindow != NULL) {
                pd_ui_->stackedWidget->removeWidget(moduleWindow);
}
void Singleton::f2();{
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
    if (redissect_flags & PREF_EFFECT_FIELDS) {
        wsApp->queueAppSignal(WiresharkApplication::FieldsChanged);
    }
    if (redissect_flags & PREF_EFFECT_DISSECTION) {
}
void Singleton::f3();{
    pd_ui_->splitter->setSizes(sizes);
    pd_ui_->splitter->setStretchFactor(0, 1);
    pd_ui_->advancedView->expandAll();
    pd_ui_->advancedView->setSortingEnabled(true);
    pd_ui_->advancedView->sortByColumn(AdvancedPrefsModel::colName, Qt::AscendingOrder);
}
void Singleton::f4();{
        pref_unstash(pref, &unstashed_data);
    }
    /* If any of them changed, indicate that we must redissect and refilter
       the current capture (if we have one), as the preference change
       could cause packets to be dissected differently. */
}
void Singleton::f5();{
    unsigned int redissect_flags = 0;
    // XXX - We should validate preferences as the user changes them, not here.
    // XXX - We're also too enthusiastic about setting must_redissect.
    prefs_modules_foreach_submodules(NULL, module_prefs_unstash, (gpointer)&redissect_flags);
    if (redissect_flags & PREF_EFFECT_GUI_LAYOUT) {
}
void Singleton::f6();{
    prefs_apply_all();
    /* Fill in capture options with values from the preferences */
    prefs_to_capture_opts();
//    prefs_airpcap_update();
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
            if (moduleWindow != NULL) {
                pd_ui_->stackedWidget->removeWidget(moduleWindow);
}
void Singleton::f2();{
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
    if (redissect_flags & PREF_EFFECT_FIELDS) {
        wsApp->queueAppSignal(WiresharkApplication::FieldsChanged);
    }
    if (redissect_flags & PREF_EFFECT_DISSECTION) {
}
void Singleton::f3();{
    pd_ui_->splitter->setSizes(sizes);
    pd_ui_->splitter->setStretchFactor(0, 1);
    pd_ui_->advancedView->expandAll();
    pd_ui_->advancedView->setSortingEnabled(true);
    pd_ui_->advancedView->sortByColumn(AdvancedPrefsModel::colName, Qt::AscendingOrder);
}
void Singleton::f4();{
        pref_unstash(pref, &unstashed_data);
    }
    /* If any of them changed, indicate that we must redissect and refilter
       the current capture (if we have one), as the preference change
       could cause packets to be dissected differently. */
}
void Singleton::f5();{
    unsigned int redissect_flags = 0;
    // XXX - We should validate preferences as the user changes them, not here.
    // XXX - We're also too enthusiastic about setting must_redissect.
    prefs_modules_foreach_submodules(NULL, module_prefs_unstash, (gpointer)&redissect_flags);
    if (redissect_flags & PREF_EFFECT_GUI_LAYOUT) {
}
void Singleton::f6();{
    prefs_apply_all();
    /* Fill in capture options with values from the preferences */
    prefs_to_capture_opts();
//    prefs_airpcap_update();
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
}
void Singleton::f7();{
    QList<int> sizes = pd_ui_->splitter->sizes();
    new_prefs_tree_width *= 2;
    pd_ui_->prefsView->resizeColumnToContents(ModulePrefsModel::colName);
    new_prefs_tree_width += pd_ui_->prefsView->columnWidth(ModulePrefsModel::colName);
    pd_ui_->prefsView->setMinimumWidth(new_prefs_tree_width);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
            if (moduleWindow != NULL) {
                pd_ui_->stackedWidget->removeWidget(moduleWindow);
}
void Singleton::f2();{
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
    if (redissect_flags & PREF_EFFECT_FIELDS) {
        wsApp->queueAppSignal(WiresharkApplication::FieldsChanged);
    }
    if (redissect_flags & PREF_EFFECT_DISSECTION) {
}
void Singleton::f3();{
    pd_ui_->splitter->setSizes(sizes);
    pd_ui_->splitter->setStretchFactor(0, 1);
    pd_ui_->advancedView->expandAll();
    pd_ui_->advancedView->setSortingEnabled(true);
    pd_ui_->advancedView->sortByColumn(AdvancedPrefsModel::colName, Qt::AscendingOrder);
}
void Singleton::f4();{
        pref_unstash(pref, &unstashed_data);
    }
    /* If any of them changed, indicate that we must redissect and refilter
       the current capture (if we have one), as the preference change
       could cause packets to be dissected differently. */
}
void Singleton::f5();{
    unsigned int redissect_flags = 0;
    // XXX - We should validate preferences as the user changes them, not here.
    // XXX - We're also too enthusiastic about setting must_redissect.
    prefs_modules_foreach_submodules(NULL, module_prefs_unstash, (gpointer)&redissect_flags);
    if (redissect_flags & PREF_EFFECT_GUI_LAYOUT) {
}
void Singleton::f6();{
    prefs_apply_all();
    /* Fill in capture options with values from the preferences */
    prefs_to_capture_opts();
//    prefs_airpcap_update();
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
}
void Singleton::f7();{
    QList<int> sizes = pd_ui_->splitter->sizes();
    new_prefs_tree_width *= 2;
    pd_ui_->prefsView->resizeColumnToContents(ModulePrefsModel::colName);
    new_prefs_tree_width += pd_ui_->prefsView->columnWidth(ModulePrefsModel::colName);
    pd_ui_->prefsView->setMinimumWidth(new_prefs_tree_width);
}
void Singleton::f8();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
extern "C" {
// Callbacks prefs routines
static guint
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
            if (moduleWindow != NULL) {
                pd_ui_->stackedWidget->removeWidget(moduleWindow);
}
void Singleton::f2();{
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
    if (redissect_flags & PREF_EFFECT_FIELDS) {
        wsApp->queueAppSignal(WiresharkApplication::FieldsChanged);
    }
    if (redissect_flags & PREF_EFFECT_DISSECTION) {
}
void Singleton::f3();{
    pd_ui_->splitter->setSizes(sizes);
    pd_ui_->splitter->setStretchFactor(0, 1);
    pd_ui_->advancedView->expandAll();
    pd_ui_->advancedView->setSortingEnabled(true);
    pd_ui_->advancedView->sortByColumn(AdvancedPrefsModel::colName, Qt::AscendingOrder);
}
void Singleton::f4();{
        pref_unstash(pref, &unstashed_data);
    }
    /* If any of them changed, indicate that we must redissect and refilter
       the current capture (if we have one), as the preference change
       could cause packets to be dissected differently. */
}
void Singleton::f5();{
    unsigned int redissect_flags = 0;
    // XXX - We should validate preferences as the user changes them, not here.
    // XXX - We're also too enthusiastic about setting must_redissect.
    prefs_modules_foreach_submodules(NULL, module_prefs_unstash, (gpointer)&redissect_flags);
    if (redissect_flags & PREF_EFFECT_GUI_LAYOUT) {
}
void Singleton::f6();{
    prefs_apply_all();
    /* Fill in capture options with values from the preferences */
    prefs_to_capture_opts();
//    prefs_airpcap_update();
    wsApp->setMonospaceFont(prefs.gui_qt_font_name);
}
void Singleton::f7();{
    QList<int> sizes = pd_ui_->splitter->sizes();
    new_prefs_tree_width *= 2;
    pd_ui_->prefsView->resizeColumnToContents(ModulePrefsModel::colName);
    new_prefs_tree_width += pd_ui_->prefsView->columnWidth(ModulePrefsModel::colName);
    pd_ui_->prefsView->setMinimumWidth(new_prefs_tree_width);
}
void Singleton::f8();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
extern "C" {
// Callbacks prefs routines
static guint
}
void Singleton::f9();{
    } else {
        //If not found in prefs_pane_to_item_, it must be an individual module
        module_t* module = prefs_find_module(pane.toStdString().c_str());
        if (module != NULL) {
            QWidget* moduleWindow = prefs_pane_to_item_[MODULES_NAME];
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
    ui->modulePreferencesToolButton->setText(tr("Open %1 preferences" UTF8_HORIZONTAL_ELLIPSIS).arg(module_->title));
    pref_stash(pref_, NULL);
    ui->preferenceTitleLabel->setText(QString("%1:").arg(prefs_get_title(pref)));
    // Convert the pref description from plain text to rich text.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
    ui->modulePreferencesToolButton->setText(tr("Open %1 preferences" UTF8_HORIZONTAL_ELLIPSIS).arg(module_->title));
    pref_stash(pref_, NULL);
    ui->preferenceTitleLabel->setText(QString("%1:").arg(prefs_get_title(pref)));
    // Convert the pref description from plain text to rich text.
}
void Singleton::f2();{
        on_buttonBox_accepted();
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
}
void Singleton::f3();{
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Empty);
        } else {
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
}
void Singleton::f4();{
        if (event->key() == Qt::Key_Escape) {
            on_buttonBox_rejected();
        } else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
            if (ui->buttonBox->button(QDialogButtonBox::Ok)->isEnabled()) {
                on_buttonBox_accepted();
}
void Singleton::f5();{
    case PREF_DECODE_AS_UINT:
        apply = prefs_set_uint_value(pref_, new_uint_, pref_stashed);
        break;
    case PREF_STRING:
        apply = prefs_set_string_value(pref_, new_str_.toStdString().c_str(), pref_stashed);
}
void Singleton::f6();{
    disconnect(ui->preferenceLineEdit, 0, 0, 0);
    bool show = false;
    switch (prefs_get_type(pref_)) {
    case PREF_UINT:
    case PREF_DECODE_AS_UINT:
}
void Singleton::f7();{
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
    switch(prefs_get_type(pref_)) {
}
void Singleton::f8();{
                this, SLOT(uintLineEditTextEdited(QString)));
        show = true;
        break;
    case PREF_STRING:
        connect(ui->preferenceLineEdit, SIGNAL(textChanged(QString)),
}
void Singleton::f9();{
        unstashed_data.module = module_;
        unstashed_data.handle_decode_as = TRUE;
        pref_unstash(pref_, &unstashed_data);
        prefs_apply(module_);
        prefs_main_write();
}
void Singleton::f10();{
                on_buttonBox_accepted();
            } else if (ui->preferenceLineEdit->syntaxState() == SyntaxLineEdit::Invalid) {
                wsApp->pushStatus(WiresharkApplication::FilterSyntax, tr("Invalid value."));
            }
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
    ui->modulePreferencesToolButton->setText(tr("Open %1 preferences" UTF8_HORIZONTAL_ELLIPSIS).arg(module_->title));
    pref_stash(pref_, NULL);
    ui->preferenceTitleLabel->setText(QString("%1:").arg(prefs_get_title(pref)));
    // Convert the pref description from plain text to rich text.
}
void Singleton::f2();{
        on_buttonBox_accepted();
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
    ui->modulePreferencesToolButton->setText(tr("Open %1 preferences" UTF8_HORIZONTAL_ELLIPSIS).arg(module_->title));
    pref_stash(pref_, NULL);
    ui->preferenceTitleLabel->setText(QString("%1:").arg(prefs_get_title(pref)));
    // Convert the pref description from plain text to rich text.
}
void Singleton::f2();{
        on_buttonBox_accepted();
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
}
void Singleton::f3();{
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Empty);
        } else {
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
    ui->modulePreferencesToolButton->setText(tr("Open %1 preferences" UTF8_HORIZONTAL_ELLIPSIS).arg(module_->title));
    pref_stash(pref_, NULL);
    ui->preferenceTitleLabel->setText(QString("%1:").arg(prefs_get_title(pref)));
    // Convert the pref description from plain text to rich text.
}
void Singleton::f2();{
        on_buttonBox_accepted();
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
}
void Singleton::f3();{
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Empty);
        } else {
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
}
void Singleton::f4();{
        if (event->key() == Qt::Key_Escape) {
            on_buttonBox_rejected();
        } else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
            if (ui->buttonBox->button(QDialogButtonBox::Ok)->isEnabled()) {
                on_buttonBox_accepted();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
    ui->modulePreferencesToolButton->setText(tr("Open %1 preferences" UTF8_HORIZONTAL_ELLIPSIS).arg(module_->title));
    pref_stash(pref_, NULL);
    ui->preferenceTitleLabel->setText(QString("%1:").arg(prefs_get_title(pref)));
    // Convert the pref description from plain text to rich text.
}
void Singleton::f2();{
        on_buttonBox_accepted();
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
}
void Singleton::f3();{
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Empty);
        } else {
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
}
void Singleton::f4();{
        if (event->key() == Qt::Key_Escape) {
            on_buttonBox_rejected();
        } else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
            if (ui->buttonBox->button(QDialogButtonBox::Ok)->isEnabled()) {
                on_buttonBox_accepted();
}
void Singleton::f5();{
    case PREF_DECODE_AS_UINT:
        apply = prefs_set_uint_value(pref_, new_uint_, pref_stashed);
        break;
    case PREF_STRING:
        apply = prefs_set_string_value(pref_, new_str_.toStdString().c_str(), pref_stashed);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
    ui->modulePreferencesToolButton->setText(tr("Open %1 preferences" UTF8_HORIZONTAL_ELLIPSIS).arg(module_->title));
    pref_stash(pref_, NULL);
    ui->preferenceTitleLabel->setText(QString("%1:").arg(prefs_get_title(pref)));
    // Convert the pref description from plain text to rich text.
}
void Singleton::f2();{
        on_buttonBox_accepted();
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
}
void Singleton::f3();{
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Empty);
        } else {
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
}
void Singleton::f4();{
        if (event->key() == Qt::Key_Escape) {
            on_buttonBox_rejected();
        } else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
            if (ui->buttonBox->button(QDialogButtonBox::Ok)->isEnabled()) {
                on_buttonBox_accepted();
}
void Singleton::f5();{
    case PREF_DECODE_AS_UINT:
        apply = prefs_set_uint_value(pref_, new_uint_, pref_stashed);
        break;
    case PREF_STRING:
        apply = prefs_set_string_value(pref_, new_str_.toStdString().c_str(), pref_stashed);
}
void Singleton::f6();{
    disconnect(ui->preferenceLineEdit, 0, 0, 0);
    bool show = false;
    switch (prefs_get_type(pref_)) {
    case PREF_UINT:
    case PREF_DECODE_AS_UINT:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
    ui->modulePreferencesToolButton->setText(tr("Open %1 preferences" UTF8_HORIZONTAL_ELLIPSIS).arg(module_->title));
    pref_stash(pref_, NULL);
    ui->preferenceTitleLabel->setText(QString("%1:").arg(prefs_get_title(pref)));
    // Convert the pref description from plain text to rich text.
}
void Singleton::f2();{
        on_buttonBox_accepted();
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
}
void Singleton::f3();{
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Empty);
        } else {
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
}
void Singleton::f4();{
        if (event->key() == Qt::Key_Escape) {
            on_buttonBox_rejected();
        } else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
            if (ui->buttonBox->button(QDialogButtonBox::Ok)->isEnabled()) {
                on_buttonBox_accepted();
}
void Singleton::f5();{
    case PREF_DECODE_AS_UINT:
        apply = prefs_set_uint_value(pref_, new_uint_, pref_stashed);
        break;
    case PREF_STRING:
        apply = prefs_set_string_value(pref_, new_str_.toStdString().c_str(), pref_stashed);
}
void Singleton::f6();{
    disconnect(ui->preferenceLineEdit, 0, 0, 0);
    bool show = false;
    switch (prefs_get_type(pref_)) {
    case PREF_UINT:
    case PREF_DECODE_AS_UINT:
}
void Singleton::f7();{
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
    switch(prefs_get_type(pref_)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
    ui->modulePreferencesToolButton->setText(tr("Open %1 preferences" UTF8_HORIZONTAL_ELLIPSIS).arg(module_->title));
    pref_stash(pref_, NULL);
    ui->preferenceTitleLabel->setText(QString("%1:").arg(prefs_get_title(pref)));
    // Convert the pref description from plain text to rich text.
}
void Singleton::f2();{
        on_buttonBox_accepted();
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
}
void Singleton::f3();{
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Empty);
        } else {
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
}
void Singleton::f4();{
        if (event->key() == Qt::Key_Escape) {
            on_buttonBox_rejected();
        } else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
            if (ui->buttonBox->button(QDialogButtonBox::Ok)->isEnabled()) {
                on_buttonBox_accepted();
}
void Singleton::f5();{
    case PREF_DECODE_AS_UINT:
        apply = prefs_set_uint_value(pref_, new_uint_, pref_stashed);
        break;
    case PREF_STRING:
        apply = prefs_set_string_value(pref_, new_str_.toStdString().c_str(), pref_stashed);
}
void Singleton::f6();{
    disconnect(ui->preferenceLineEdit, 0, 0, 0);
    bool show = false;
    switch (prefs_get_type(pref_)) {
    case PREF_UINT:
    case PREF_DECODE_AS_UINT:
}
void Singleton::f7();{
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
    switch(prefs_get_type(pref_)) {
}
void Singleton::f8();{
                this, SLOT(uintLineEditTextEdited(QString)));
        show = true;
        break;
    case PREF_STRING:
        connect(ui->preferenceLineEdit, SIGNAL(textChanged(QString)),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
    ui->modulePreferencesToolButton->setText(tr("Open %1 preferences" UTF8_HORIZONTAL_ELLIPSIS).arg(module_->title));
    pref_stash(pref_, NULL);
    ui->preferenceTitleLabel->setText(QString("%1:").arg(prefs_get_title(pref)));
    // Convert the pref description from plain text to rich text.
}
void Singleton::f2();{
        on_buttonBox_accepted();
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
}
void Singleton::f3();{
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Empty);
        } else {
            ui->preferenceLineEdit->setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
}
void Singleton::f4();{
        if (event->key() == Qt::Key_Escape) {
            on_buttonBox_rejected();
        } else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
            if (ui->buttonBox->button(QDialogButtonBox::Ok)->isEnabled()) {
                on_buttonBox_accepted();
}
void Singleton::f5();{
    case PREF_DECODE_AS_UINT:
        apply = prefs_set_uint_value(pref_, new_uint_, pref_stashed);
        break;
    case PREF_STRING:
        apply = prefs_set_string_value(pref_, new_str_.toStdString().c_str(), pref_stashed);
}
void Singleton::f6();{
    disconnect(ui->preferenceLineEdit, 0, 0, 0);
    bool show = false;
    switch (prefs_get_type(pref_)) {
    case PREF_UINT:
    case PREF_DECODE_AS_UINT:
}
void Singleton::f7();{
    }
void PreferenceEditorFrame::on_buttonBox_accepted()
    unsigned int changed_flags = 0;
    unsigned int apply = 0;
    switch(prefs_get_type(pref_)) {
}
void Singleton::f8();{
                this, SLOT(uintLineEditTextEdited(QString)));
        show = true;
        break;
    case PREF_STRING:
        connect(ui->preferenceLineEdit, SIGNAL(textChanged(QString)),
}
void Singleton::f9();{
        unstashed_data.module = module_;
        unstashed_data.handle_decode_as = TRUE;
        pref_unstash(pref_, &unstashed_data);
        prefs_apply(module_);
        prefs_main_write();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
bool ModulePrefsModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    PrefsItem* left_item = static_cast<PrefsItem*>(source_left.internalPointer());
    PrefsItem* right_item = static_cast<PrefsItem*>(source_right.internalPointer());
    if ((left_item != NULL) && (right_item != NULL)) {
        QString left_name = left_item->getModuleTitle(),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
bool ModulePrefsModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    PrefsItem* left_item = static_cast<PrefsItem*>(source_left.internalPointer());
    PrefsItem* right_item = static_cast<PrefsItem*>(source_right.internalPointer());
    if ((left_item != NULL) && (right_item != NULL)) {
        QString left_name = left_item->getModuleTitle(),
}
void Singleton::f2();{
    } else {
        name = QString(item.getModule()->name ? item.getModule()->name : item.getModule()->parent->name);
        name += QString(".%1").arg(prefs_get_name(item.getPref()));
        tooltip = prefs_get_description(item.getPref());
    }
}
void Singleton::f3();{
    return false;
void AdvancedPrefsModel::setFilter(const QString& filter)
    filter_ = filter;
    invalidateFilter();
ModulePrefsModel::ModulePrefsModel(QObject* parent)
}
void Singleton::f4();{
        return QVariant();
    PrefsItem* item = static_cast<PrefsItem*>(index.internalPointer());
    if (item == NULL)
        return QVariant();
    if (role == Qt::UserRole)
}
void Singleton::f5();{
            if (right_name.compare(advancedPrefName_) == 0) {
                return true;
            }
        }
        if (left_name.compare(right_name, Qt::CaseInsensitive) < 0)
}
void Singleton::f6();{
        {
        case colName:
            return item->getModuleTitle();
        default:
            break;
}
void Singleton::f7();{
        parent_item = static_cast<PrefsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
    return parent_item->childCount();
int PrefsModel::columnCount(const QModelIndex&) const
}
void Singleton::f8();{
    if (!index.isValid())
        return QModelIndex();
    PrefsItem* item = static_cast<PrefsItem*>(index.internalPointer());
    if (item != NULL) {
        PrefsItem* parent_item = item->parentItem();
}
void Singleton::f9();{
        case PREF_BOOL:
            prefs_invert_bool_value(item->getPref(), pref_stashed);
            break;
        case PREF_ENUM:
            prefs_set_enum_value(item->getPref(), value.toInt(), pref_stashed);
}
void Singleton::f10();{
        pref_stash(pref, NULL);
        PrefsItem* item = new PrefsItem(module, pref, module_item);
        module_item->prependChild(item);
        // .uat is a void * so it wins the "useful key value" prize.
        if (prefs_get_uat_value(pref)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
bool ModulePrefsModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    PrefsItem* left_item = static_cast<PrefsItem*>(source_left.internalPointer());
    PrefsItem* right_item = static_cast<PrefsItem*>(source_right.internalPointer());
    if ((left_item != NULL) && (right_item != NULL)) {
        QString left_name = left_item->getModuleTitle(),
}
void Singleton::f2();{
    } else {
        name = QString(item.getModule()->name ? item.getModule()->name : item.getModule()->parent->name);
        name += QString(".%1").arg(prefs_get_name(item.getPref()));
        tooltip = prefs_get_description(item.getPref());
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
bool ModulePrefsModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    PrefsItem* left_item = static_cast<PrefsItem*>(source_left.internalPointer());
    PrefsItem* right_item = static_cast<PrefsItem*>(source_right.internalPointer());
    if ((left_item != NULL) && (right_item != NULL)) {
        QString left_name = left_item->getModuleTitle(),
}
void Singleton::f2();{
    } else {
        name = QString(item.getModule()->name ? item.getModule()->name : item.getModule()->parent->name);
        name += QString(".%1").arg(prefs_get_name(item.getPref()));
        tooltip = prefs_get_description(item.getPref());
    }
}
void Singleton::f3();{
    return false;
void AdvancedPrefsModel::setFilter(const QString& filter)
    filter_ = filter;
    invalidateFilter();
ModulePrefsModel::ModulePrefsModel(QObject* parent)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
bool ModulePrefsModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    PrefsItem* left_item = static_cast<PrefsItem*>(source_left.internalPointer());
    PrefsItem* right_item = static_cast<PrefsItem*>(source_right.internalPointer());
    if ((left_item != NULL) && (right_item != NULL)) {
        QString left_name = left_item->getModuleTitle(),
}
void Singleton::f2();{
    } else {
        name = QString(item.getModule()->name ? item.getModule()->name : item.getModule()->parent->name);
        name += QString(".%1").arg(prefs_get_name(item.getPref()));
        tooltip = prefs_get_description(item.getPref());
    }
}
void Singleton::f3();{
    return false;
void AdvancedPrefsModel::setFilter(const QString& filter)
    filter_ = filter;
    invalidateFilter();
ModulePrefsModel::ModulePrefsModel(QObject* parent)
}
void Singleton::f4();{
        return QVariant();
    PrefsItem* item = static_cast<PrefsItem*>(index.internalPointer());
    if (item == NULL)
        return QVariant();
    if (role == Qt::UserRole)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
bool ModulePrefsModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    PrefsItem* left_item = static_cast<PrefsItem*>(source_left.internalPointer());
    PrefsItem* right_item = static_cast<PrefsItem*>(source_right.internalPointer());
    if ((left_item != NULL) && (right_item != NULL)) {
        QString left_name = left_item->getModuleTitle(),
}
void Singleton::f2();{
    } else {
        name = QString(item.getModule()->name ? item.getModule()->name : item.getModule()->parent->name);
        name += QString(".%1").arg(prefs_get_name(item.getPref()));
        tooltip = prefs_get_description(item.getPref());
    }
}
void Singleton::f3();{
    return false;
void AdvancedPrefsModel::setFilter(const QString& filter)
    filter_ = filter;
    invalidateFilter();
ModulePrefsModel::ModulePrefsModel(QObject* parent)
}
void Singleton::f4();{
        return QVariant();
    PrefsItem* item = static_cast<PrefsItem*>(index.internalPointer());
    if (item == NULL)
        return QVariant();
    if (role == Qt::UserRole)
}
void Singleton::f5();{
            if (right_name.compare(advancedPrefName_) == 0) {
                return true;
            }
        }
        if (left_name.compare(right_name, Qt::CaseInsensitive) < 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
bool ModulePrefsModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    PrefsItem* left_item = static_cast<PrefsItem*>(source_left.internalPointer());
    PrefsItem* right_item = static_cast<PrefsItem*>(source_right.internalPointer());
    if ((left_item != NULL) && (right_item != NULL)) {
        QString left_name = left_item->getModuleTitle(),
}
void Singleton::f2();{
    } else {
        name = QString(item.getModule()->name ? item.getModule()->name : item.getModule()->parent->name);
        name += QString(".%1").arg(prefs_get_name(item.getPref()));
        tooltip = prefs_get_description(item.getPref());
    }
}
void Singleton::f3();{
    return false;
void AdvancedPrefsModel::setFilter(const QString& filter)
    filter_ = filter;
    invalidateFilter();
ModulePrefsModel::ModulePrefsModel(QObject* parent)
}
void Singleton::f4();{
        return QVariant();
    PrefsItem* item = static_cast<PrefsItem*>(index.internalPointer());
    if (item == NULL)
        return QVariant();
    if (role == Qt::UserRole)
}
void Singleton::f5();{
            if (right_name.compare(advancedPrefName_) == 0) {
                return true;
            }
        }
        if (left_name.compare(right_name, Qt::CaseInsensitive) < 0)
}
void Singleton::f6();{
        {
        case colName:
            return item->getModuleTitle();
        default:
            break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
bool ModulePrefsModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    PrefsItem* left_item = static_cast<PrefsItem*>(source_left.internalPointer());
    PrefsItem* right_item = static_cast<PrefsItem*>(source_right.internalPointer());
    if ((left_item != NULL) && (right_item != NULL)) {
        QString left_name = left_item->getModuleTitle(),
}
void Singleton::f2();{
    } else {
        name = QString(item.getModule()->name ? item.getModule()->name : item.getModule()->parent->name);
        name += QString(".%1").arg(prefs_get_name(item.getPref()));
        tooltip = prefs_get_description(item.getPref());
    }
}
void Singleton::f3();{
    return false;
void AdvancedPrefsModel::setFilter(const QString& filter)
    filter_ = filter;
    invalidateFilter();
ModulePrefsModel::ModulePrefsModel(QObject* parent)
}
void Singleton::f4();{
        return QVariant();
    PrefsItem* item = static_cast<PrefsItem*>(index.internalPointer());
    if (item == NULL)
        return QVariant();
    if (role == Qt::UserRole)
}
void Singleton::f5();{
            if (right_name.compare(advancedPrefName_) == 0) {
                return true;
            }
        }
        if (left_name.compare(right_name, Qt::CaseInsensitive) < 0)
}
void Singleton::f6();{
        {
        case colName:
            return item->getModuleTitle();
        default:
            break;
}
void Singleton::f7();{
        parent_item = static_cast<PrefsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
    return parent_item->childCount();
int PrefsModel::columnCount(const QModelIndex&) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
bool ModulePrefsModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    PrefsItem* left_item = static_cast<PrefsItem*>(source_left.internalPointer());
    PrefsItem* right_item = static_cast<PrefsItem*>(source_right.internalPointer());
    if ((left_item != NULL) && (right_item != NULL)) {
        QString left_name = left_item->getModuleTitle(),
}
void Singleton::f2();{
    } else {
        name = QString(item.getModule()->name ? item.getModule()->name : item.getModule()->parent->name);
        name += QString(".%1").arg(prefs_get_name(item.getPref()));
        tooltip = prefs_get_description(item.getPref());
    }
}
void Singleton::f3();{
    return false;
void AdvancedPrefsModel::setFilter(const QString& filter)
    filter_ = filter;
    invalidateFilter();
ModulePrefsModel::ModulePrefsModel(QObject* parent)
}
void Singleton::f4();{
        return QVariant();
    PrefsItem* item = static_cast<PrefsItem*>(index.internalPointer());
    if (item == NULL)
        return QVariant();
    if (role == Qt::UserRole)
}
void Singleton::f5();{
            if (right_name.compare(advancedPrefName_) == 0) {
                return true;
            }
        }
        if (left_name.compare(right_name, Qt::CaseInsensitive) < 0)
}
void Singleton::f6();{
        {
        case colName:
            return item->getModuleTitle();
        default:
            break;
}
void Singleton::f7();{
        parent_item = static_cast<PrefsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
    return parent_item->childCount();
int PrefsModel::columnCount(const QModelIndex&) const
}
void Singleton::f8();{
    if (!index.isValid())
        return QModelIndex();
    PrefsItem* item = static_cast<PrefsItem*>(index.internalPointer());
    if (item != NULL) {
        PrefsItem* parent_item = item->parentItem();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
bool ModulePrefsModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    PrefsItem* left_item = static_cast<PrefsItem*>(source_left.internalPointer());
    PrefsItem* right_item = static_cast<PrefsItem*>(source_right.internalPointer());
    if ((left_item != NULL) && (right_item != NULL)) {
        QString left_name = left_item->getModuleTitle(),
}
void Singleton::f2();{
    } else {
        name = QString(item.getModule()->name ? item.getModule()->name : item.getModule()->parent->name);
        name += QString(".%1").arg(prefs_get_name(item.getPref()));
        tooltip = prefs_get_description(item.getPref());
    }
}
void Singleton::f3();{
    return false;
void AdvancedPrefsModel::setFilter(const QString& filter)
    filter_ = filter;
    invalidateFilter();
ModulePrefsModel::ModulePrefsModel(QObject* parent)
}
void Singleton::f4();{
        return QVariant();
    PrefsItem* item = static_cast<PrefsItem*>(index.internalPointer());
    if (item == NULL)
        return QVariant();
    if (role == Qt::UserRole)
}
void Singleton::f5();{
            if (right_name.compare(advancedPrefName_) == 0) {
                return true;
            }
        }
        if (left_name.compare(right_name, Qt::CaseInsensitive) < 0)
}
void Singleton::f6();{
        {
        case colName:
            return item->getModuleTitle();
        default:
            break;
}
void Singleton::f7();{
        parent_item = static_cast<PrefsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
    return parent_item->childCount();
int PrefsModel::columnCount(const QModelIndex&) const
}
void Singleton::f8();{
    if (!index.isValid())
        return QModelIndex();
    PrefsItem* item = static_cast<PrefsItem*>(index.internalPointer());
    if (item != NULL) {
        PrefsItem* parent_item = item->parentItem();
}
void Singleton::f9();{
        case PREF_BOOL:
            prefs_invert_bool_value(item->getPref(), pref_stashed);
            break;
        case PREF_ENUM:
            prefs_set_enum_value(item->getPref(), value.toInt(), pref_stashed);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
            break;
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
            break;
        }
}
void Singleton::f2();{
QModelIndex PrefModuleTreeView::findModule(QModelIndex& parent, const QString& name)
    QModelIndex findIndex, modelIndex;
    QString module_name;
    for (int row = 0; row < model()->rowCount(parent); row++)
    {
}
void Singleton::f3();{
        moduleName = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (moduleName.compare(appearanceName_) == 0) {
            appearanceIndex = modelIndex;
        } else if (moduleName.compare("Protocols") == 0) {
            protocolIndex = modelIndex;
}
void Singleton::f4();{
/* * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f5();{
    int row;
    //look for the pane name in the main tree before trying children
    for (row = 0; row < model()->rowCount(); row++)
    {
        modelIndex = model()->index(row, ModulePrefsModel::colName);
}
void Singleton::f6();{
            findIndex = findModule(modelIndex, name);
            if (findIndex.isValid())
                break;
        }
    }
}
void Singleton::f7();{
    }
    QTreeView::currentChanged(current, previous);
/* * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f8();{
    {
        modelIndex = model()->index(row, ModulePrefsModel::colName, parent);
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
}
void Singleton::f9();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
PrefModuleTreeView::PrefModuleTreeView(QWidget *parent) : QTreeView(parent),
}
void Singleton::f10();{
    {
        modelIndex = model()->index(row, ModulePrefsModel::colName, parent);
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
            break;
        }
}
void Singleton::f2();{
QModelIndex PrefModuleTreeView::findModule(QModelIndex& parent, const QString& name)
    QModelIndex findIndex, modelIndex;
    QString module_name;
    for (int row = 0; row < model()->rowCount(parent); row++)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
            break;
        }
}
void Singleton::f2();{
QModelIndex PrefModuleTreeView::findModule(QModelIndex& parent, const QString& name)
    QModelIndex findIndex, modelIndex;
    QString module_name;
    for (int row = 0; row < model()->rowCount(parent); row++)
    {
}
void Singleton::f3();{
        moduleName = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (moduleName.compare(appearanceName_) == 0) {
            appearanceIndex = modelIndex;
        } else if (moduleName.compare("Protocols") == 0) {
            protocolIndex = modelIndex;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
            break;
        }
}
void Singleton::f2();{
QModelIndex PrefModuleTreeView::findModule(QModelIndex& parent, const QString& name)
    QModelIndex findIndex, modelIndex;
    QString module_name;
    for (int row = 0; row < model()->rowCount(parent); row++)
    {
}
void Singleton::f3();{
        moduleName = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (moduleName.compare(appearanceName_) == 0) {
            appearanceIndex = modelIndex;
        } else if (moduleName.compare("Protocols") == 0) {
            protocolIndex = modelIndex;
}
void Singleton::f4();{
/* * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
            break;
        }
}
void Singleton::f2();{
QModelIndex PrefModuleTreeView::findModule(QModelIndex& parent, const QString& name)
    QModelIndex findIndex, modelIndex;
    QString module_name;
    for (int row = 0; row < model()->rowCount(parent); row++)
    {
}
void Singleton::f3();{
        moduleName = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (moduleName.compare(appearanceName_) == 0) {
            appearanceIndex = modelIndex;
        } else if (moduleName.compare("Protocols") == 0) {
            protocolIndex = modelIndex;
}
void Singleton::f4();{
/* * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f5();{
    int row;
    //look for the pane name in the main tree before trying children
    for (row = 0; row < model()->rowCount(); row++)
    {
        modelIndex = model()->index(row, ModulePrefsModel::colName);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
            break;
        }
}
void Singleton::f2();{
QModelIndex PrefModuleTreeView::findModule(QModelIndex& parent, const QString& name)
    QModelIndex findIndex, modelIndex;
    QString module_name;
    for (int row = 0; row < model()->rowCount(parent); row++)
    {
}
void Singleton::f3();{
        moduleName = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (moduleName.compare(appearanceName_) == 0) {
            appearanceIndex = modelIndex;
        } else if (moduleName.compare("Protocols") == 0) {
            protocolIndex = modelIndex;
}
void Singleton::f4();{
/* * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f5();{
    int row;
    //look for the pane name in the main tree before trying children
    for (row = 0; row < model()->rowCount(); row++)
    {
        modelIndex = model()->index(row, ModulePrefsModel::colName);
}
void Singleton::f6();{
            findIndex = findModule(modelIndex, name);
            if (findIndex.isValid())
                break;
        }
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
            break;
        }
}
void Singleton::f2();{
QModelIndex PrefModuleTreeView::findModule(QModelIndex& parent, const QString& name)
    QModelIndex findIndex, modelIndex;
    QString module_name;
    for (int row = 0; row < model()->rowCount(parent); row++)
    {
}
void Singleton::f3();{
        moduleName = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (moduleName.compare(appearanceName_) == 0) {
            appearanceIndex = modelIndex;
        } else if (moduleName.compare("Protocols") == 0) {
            protocolIndex = modelIndex;
}
void Singleton::f4();{
/* * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f5();{
    int row;
    //look for the pane name in the main tree before trying children
    for (row = 0; row < model()->rowCount(); row++)
    {
        modelIndex = model()->index(row, ModulePrefsModel::colName);
}
void Singleton::f6();{
            findIndex = findModule(modelIndex, name);
            if (findIndex.isValid())
                break;
        }
    }
}
void Singleton::f7();{
    }
    QTreeView::currentChanged(current, previous);
/* * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
            break;
        }
}
void Singleton::f2();{
QModelIndex PrefModuleTreeView::findModule(QModelIndex& parent, const QString& name)
    QModelIndex findIndex, modelIndex;
    QString module_name;
    for (int row = 0; row < model()->rowCount(parent); row++)
    {
}
void Singleton::f3();{
        moduleName = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (moduleName.compare(appearanceName_) == 0) {
            appearanceIndex = modelIndex;
        } else if (moduleName.compare("Protocols") == 0) {
            protocolIndex = modelIndex;
}
void Singleton::f4();{
/* * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f5();{
    int row;
    //look for the pane name in the main tree before trying children
    for (row = 0; row < model()->rowCount(); row++)
    {
        modelIndex = model()->index(row, ModulePrefsModel::colName);
}
void Singleton::f6();{
            findIndex = findModule(modelIndex, name);
            if (findIndex.isValid())
                break;
        }
    }
}
void Singleton::f7();{
    }
    QTreeView::currentChanged(current, previous);
/* * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f8();{
    {
        modelIndex = model()->index(row, ModulePrefsModel::colName, parent);
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
            break;
        }
}
void Singleton::f2();{
QModelIndex PrefModuleTreeView::findModule(QModelIndex& parent, const QString& name)
    QModelIndex findIndex, modelIndex;
    QString module_name;
    for (int row = 0; row < model()->rowCount(parent); row++)
    {
}
void Singleton::f3();{
        moduleName = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (moduleName.compare(appearanceName_) == 0) {
            appearanceIndex = modelIndex;
        } else if (moduleName.compare("Protocols") == 0) {
            protocolIndex = modelIndex;
}
void Singleton::f4();{
/* * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f5();{
    int row;
    //look for the pane name in the main tree before trying children
    for (row = 0; row < model()->rowCount(); row++)
    {
        modelIndex = model()->index(row, ModulePrefsModel::colName);
}
void Singleton::f6();{
            findIndex = findModule(modelIndex, name);
            if (findIndex.isValid())
                break;
        }
    }
}
void Singleton::f7();{
    }
    QTreeView::currentChanged(current, previous);
/* * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f8();{
    {
        modelIndex = model()->index(row, ModulePrefsModel::colName, parent);
        module_name = model()->data(modelIndex, ModulePrefsModel::ModuleName).toString();
        if (name.compare(module_name) == 0) {
            findIndex = modelIndex;
}
void Singleton::f9();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
PrefModuleTreeView::PrefModuleTreeView(QWidget *parent) : QTreeView(parent),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    connect(pd_ui_->formatGroupBox, SIGNAL(formatChanged()),
            this, SLOT(checkValidity()));
    connect(pd_ui_->formFeedCheckBox, SIGNAL(toggled(bool)),
            preview_, SLOT(updatePreview()));
    checkValidity();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    connect(pd_ui_->formatGroupBox, SIGNAL(formatChanged()),
            this, SLOT(checkValidity()));
    connect(pd_ui_->formFeedCheckBox, SIGNAL(toggled(bool)),
            preview_, SLOT(updatePreview()));
    checkValidity();
}
void Singleton::f2();{
    /* Fill in our print args */
    print_args_.format              = PR_FMT_TEXT;
    print_args_.print_summary       = pd_ui_->formatGroupBox->summaryEnabled();
    print_args_.print_col_headings  = pd_ui_->formatGroupBox->includeColumnHeadingsEnabled();
    print_args_.print_hex           = pd_ui_->formatGroupBox->bytesEnabled();
}
void Singleton::f3();{
    QPageSetupDialog *ps_dlg;
        HANDLE da_ctx;
    switch (pd_ui_->buttonBox->buttonRole(button)) {
    case QDialogButtonBox::ActionRole:
        int result;
}
void Singleton::f4();{
    case Qt::Key_Plus:
    case Qt::Key_Equal:         // Unshifted plus on U.S. keyboards
        preview_->zoomIn();
        break;
    case Qt::Key_0:
}
void Singleton::f5();{
        enable = false;
    }
    print_bt_->setEnabled(enable);
    preview_->updatePreview();
void PrintDialog::on_buttonBox_helpRequested()
}
void Singleton::f6();{
        printHeader();
    }
    out_rect.translate(0, page_pos_);
    cur_painter_->drawText(out_rect, Qt::TextWordWrap, out_line);
    page_pos_ += out_rect.height();
}
void Singleton::f7();{
            // waste space printing it at the top of a page, as the
            // page break suffices as a separator.
            return TRUE;
        }
        printHeader();
}
void Singleton::f8();{
        //
        if (in_preview_) {
            // When generating a preview, only generate the first page;
            // if we're past the first page, stop the printing process.
            return FALSE;
}
void Singleton::f9();{
        da_ctx = set_thread_per_monitor_v2_awareness();
        print_dlg = new QPrintDialog(&printer_, this);
        result = print_dlg->exec();
        revert_thread_per_monitor_v2_awareness(da_ctx);
        if (result == QDialog::Accepted) {
}
void Singleton::f10();{
    cur_painter_ = NULL;
    painter.end();
void PrintDialog::paintPreview(QPrinter *printer)
    printPackets(printer, true);
void PrintDialog::checkValidity()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    connect(pd_ui_->formatGroupBox, SIGNAL(formatChanged()),
            this, SLOT(checkValidity()));
    connect(pd_ui_->formFeedCheckBox, SIGNAL(toggled(bool)),
            preview_, SLOT(updatePreview()));
    checkValidity();
}
void Singleton::f2();{
    /* Fill in our print args */
    print_args_.format              = PR_FMT_TEXT;
    print_args_.print_summary       = pd_ui_->formatGroupBox->summaryEnabled();
    print_args_.print_col_headings  = pd_ui_->formatGroupBox->includeColumnHeadingsEnabled();
    print_args_.print_hex           = pd_ui_->formatGroupBox->bytesEnabled();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    connect(pd_ui_->formatGroupBox, SIGNAL(formatChanged()),
            this, SLOT(checkValidity()));
    connect(pd_ui_->formFeedCheckBox, SIGNAL(toggled(bool)),
            preview_, SLOT(updatePreview()));
    checkValidity();
}
void Singleton::f2();{
    /* Fill in our print args */
    print_args_.format              = PR_FMT_TEXT;
    print_args_.print_summary       = pd_ui_->formatGroupBox->summaryEnabled();
    print_args_.print_col_headings  = pd_ui_->formatGroupBox->includeColumnHeadingsEnabled();
    print_args_.print_hex           = pd_ui_->formatGroupBox->bytesEnabled();
}
void Singleton::f3();{
    QPageSetupDialog *ps_dlg;
        HANDLE da_ctx;
    switch (pd_ui_->buttonBox->buttonRole(button)) {
    case QDialogButtonBox::ActionRole:
        int result;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    connect(pd_ui_->formatGroupBox, SIGNAL(formatChanged()),
            this, SLOT(checkValidity()));
    connect(pd_ui_->formFeedCheckBox, SIGNAL(toggled(bool)),
            preview_, SLOT(updatePreview()));
    checkValidity();
}
void Singleton::f2();{
    /* Fill in our print args */
    print_args_.format              = PR_FMT_TEXT;
    print_args_.print_summary       = pd_ui_->formatGroupBox->summaryEnabled();
    print_args_.print_col_headings  = pd_ui_->formatGroupBox->includeColumnHeadingsEnabled();
    print_args_.print_hex           = pd_ui_->formatGroupBox->bytesEnabled();
}
void Singleton::f3();{
    QPageSetupDialog *ps_dlg;
        HANDLE da_ctx;
    switch (pd_ui_->buttonBox->buttonRole(button)) {
    case QDialogButtonBox::ActionRole:
        int result;
}
void Singleton::f4();{
    case Qt::Key_Plus:
    case Qt::Key_Equal:         // Unshifted plus on U.S. keyboards
        preview_->zoomIn();
        break;
    case Qt::Key_0:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    connect(pd_ui_->formatGroupBox, SIGNAL(formatChanged()),
            this, SLOT(checkValidity()));
    connect(pd_ui_->formFeedCheckBox, SIGNAL(toggled(bool)),
            preview_, SLOT(updatePreview()));
    checkValidity();
}
void Singleton::f2();{
    /* Fill in our print args */
    print_args_.format              = PR_FMT_TEXT;
    print_args_.print_summary       = pd_ui_->formatGroupBox->summaryEnabled();
    print_args_.print_col_headings  = pd_ui_->formatGroupBox->includeColumnHeadingsEnabled();
    print_args_.print_hex           = pd_ui_->formatGroupBox->bytesEnabled();
}
void Singleton::f3();{
    QPageSetupDialog *ps_dlg;
        HANDLE da_ctx;
    switch (pd_ui_->buttonBox->buttonRole(button)) {
    case QDialogButtonBox::ActionRole:
        int result;
}
void Singleton::f4();{
    case Qt::Key_Plus:
    case Qt::Key_Equal:         // Unshifted plus on U.S. keyboards
        preview_->zoomIn();
        break;
    case Qt::Key_0:
}
void Singleton::f5();{
        enable = false;
    }
    print_bt_->setEnabled(enable);
    preview_->updatePreview();
void PrintDialog::on_buttonBox_helpRequested()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    connect(pd_ui_->formatGroupBox, SIGNAL(formatChanged()),
            this, SLOT(checkValidity()));
    connect(pd_ui_->formFeedCheckBox, SIGNAL(toggled(bool)),
            preview_, SLOT(updatePreview()));
    checkValidity();
}
void Singleton::f2();{
    /* Fill in our print args */
    print_args_.format              = PR_FMT_TEXT;
    print_args_.print_summary       = pd_ui_->formatGroupBox->summaryEnabled();
    print_args_.print_col_headings  = pd_ui_->formatGroupBox->includeColumnHeadingsEnabled();
    print_args_.print_hex           = pd_ui_->formatGroupBox->bytesEnabled();
}
void Singleton::f3();{
    QPageSetupDialog *ps_dlg;
        HANDLE da_ctx;
    switch (pd_ui_->buttonBox->buttonRole(button)) {
    case QDialogButtonBox::ActionRole:
        int result;
}
void Singleton::f4();{
    case Qt::Key_Plus:
    case Qt::Key_Equal:         // Unshifted plus on U.S. keyboards
        preview_->zoomIn();
        break;
    case Qt::Key_0:
}
void Singleton::f5();{
        enable = false;
    }
    print_bt_->setEnabled(enable);
    preview_->updatePreview();
void PrintDialog::on_buttonBox_helpRequested()
}
void Singleton::f6();{
        printHeader();
    }
    out_rect.translate(0, page_pos_);
    cur_painter_->drawText(out_rect, Qt::TextWordWrap, out_line);
    page_pos_ += out_rect.height();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    connect(pd_ui_->formatGroupBox, SIGNAL(formatChanged()),
            this, SLOT(checkValidity()));
    connect(pd_ui_->formFeedCheckBox, SIGNAL(toggled(bool)),
            preview_, SLOT(updatePreview()));
    checkValidity();
}
void Singleton::f2();{
    /* Fill in our print args */
    print_args_.format              = PR_FMT_TEXT;
    print_args_.print_summary       = pd_ui_->formatGroupBox->summaryEnabled();
    print_args_.print_col_headings  = pd_ui_->formatGroupBox->includeColumnHeadingsEnabled();
    print_args_.print_hex           = pd_ui_->formatGroupBox->bytesEnabled();
}
void Singleton::f3();{
    QPageSetupDialog *ps_dlg;
        HANDLE da_ctx;
    switch (pd_ui_->buttonBox->buttonRole(button)) {
    case QDialogButtonBox::ActionRole:
        int result;
}
void Singleton::f4();{
    case Qt::Key_Plus:
    case Qt::Key_Equal:         // Unshifted plus on U.S. keyboards
        preview_->zoomIn();
        break;
    case Qt::Key_0:
}
void Singleton::f5();{
        enable = false;
    }
    print_bt_->setEnabled(enable);
    preview_->updatePreview();
void PrintDialog::on_buttonBox_helpRequested()
}
void Singleton::f6();{
        printHeader();
    }
    out_rect.translate(0, page_pos_);
    cur_painter_->drawText(out_rect, Qt::TextWordWrap, out_line);
    page_pos_ += out_rect.height();
}
void Singleton::f7();{
            // waste space printing it at the top of a page, as the
            // page break suffices as a separator.
            return TRUE;
        }
        printHeader();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    connect(pd_ui_->formatGroupBox, SIGNAL(formatChanged()),
            this, SLOT(checkValidity()));
    connect(pd_ui_->formFeedCheckBox, SIGNAL(toggled(bool)),
            preview_, SLOT(updatePreview()));
    checkValidity();
}
void Singleton::f2();{
    /* Fill in our print args */
    print_args_.format              = PR_FMT_TEXT;
    print_args_.print_summary       = pd_ui_->formatGroupBox->summaryEnabled();
    print_args_.print_col_headings  = pd_ui_->formatGroupBox->includeColumnHeadingsEnabled();
    print_args_.print_hex           = pd_ui_->formatGroupBox->bytesEnabled();
}
void Singleton::f3();{
    QPageSetupDialog *ps_dlg;
        HANDLE da_ctx;
    switch (pd_ui_->buttonBox->buttonRole(button)) {
    case QDialogButtonBox::ActionRole:
        int result;
}
void Singleton::f4();{
    case Qt::Key_Plus:
    case Qt::Key_Equal:         // Unshifted plus on U.S. keyboards
        preview_->zoomIn();
        break;
    case Qt::Key_0:
}
void Singleton::f5();{
        enable = false;
    }
    print_bt_->setEnabled(enable);
    preview_->updatePreview();
void PrintDialog::on_buttonBox_helpRequested()
}
void Singleton::f6();{
        printHeader();
    }
    out_rect.translate(0, page_pos_);
    cur_painter_->drawText(out_rect, Qt::TextWordWrap, out_line);
    page_pos_ += out_rect.height();
}
void Singleton::f7();{
            // waste space printing it at the top of a page, as the
            // page break suffices as a separator.
            return TRUE;
        }
        printHeader();
}
void Singleton::f8();{
        //
        if (in_preview_) {
            // When generating a preview, only generate the first page;
            // if we're past the first page, stop the printing process.
            return FALSE;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    connect(pd_ui_->formatGroupBox, SIGNAL(formatChanged()),
            this, SLOT(checkValidity()));
    connect(pd_ui_->formFeedCheckBox, SIGNAL(toggled(bool)),
            preview_, SLOT(updatePreview()));
    checkValidity();
}
void Singleton::f2();{
    /* Fill in our print args */
    print_args_.format              = PR_FMT_TEXT;
    print_args_.print_summary       = pd_ui_->formatGroupBox->summaryEnabled();
    print_args_.print_col_headings  = pd_ui_->formatGroupBox->includeColumnHeadingsEnabled();
    print_args_.print_hex           = pd_ui_->formatGroupBox->bytesEnabled();
}
void Singleton::f3();{
    QPageSetupDialog *ps_dlg;
        HANDLE da_ctx;
    switch (pd_ui_->buttonBox->buttonRole(button)) {
    case QDialogButtonBox::ActionRole:
        int result;
}
void Singleton::f4();{
    case Qt::Key_Plus:
    case Qt::Key_Equal:         // Unshifted plus on U.S. keyboards
        preview_->zoomIn();
        break;
    case Qt::Key_0:
}
void Singleton::f5();{
        enable = false;
    }
    print_bt_->setEnabled(enable);
    preview_->updatePreview();
void PrintDialog::on_buttonBox_helpRequested()
}
void Singleton::f6();{
        printHeader();
    }
    out_rect.translate(0, page_pos_);
    cur_painter_->drawText(out_rect, Qt::TextWordWrap, out_line);
    page_pos_ += out_rect.height();
}
void Singleton::f7();{
            // waste space printing it at the top of a page, as the
            // page break suffices as a separator.
            return TRUE;
        }
        printHeader();
}
void Singleton::f8();{
        //
        if (in_preview_) {
            // When generating a preview, only generate the first page;
            // if we're past the first page, stop the printing process.
            return FALSE;
}
void Singleton::f9();{
        da_ctx = set_thread_per_monitor_v2_awareness();
        print_dlg = new QPrintDialog(&printer_, this);
        result = print_dlg->exec();
        revert_thread_per_monitor_v2_awareness(da_ctx);
        if (result == QDialog::Accepted) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    QModelIndex newIdx = sort_model_->mapFromSource(model_->index(row, 0));
    if (newIdx.data(ProfileModel::DATA_IS_GLOBAL).toBool() != isGlobal)
        newIdx =  sort_model_->mapFromSource(model_->index(0, 0));
    pd_ui_->profileTreeView->setCurrentIndex(newIdx);
    updateWidgets();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    QModelIndex newIdx = sort_model_->mapFromSource(model_->index(row, 0));
    if (newIdx.data(ProfileModel::DATA_IS_GLOBAL).toBool() != isGlobal)
        newIdx =  sort_model_->mapFromSource(model_->index(0, 0));
    pd_ui_->profileTreeView->setCurrentIndex(newIdx);
    updateWidgets();
}
void Singleton::f2();{
        QMessageBox::critical(this, tr("Profile Error"),
                              err_msg,
                              QMessageBox::Ok);
        g_free(err_msg);
        model_->doResetModel();
}
void Singleton::f3();{
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
    QModelIndex ridx = sort_model_->mapFromSource(model_->addNewProfile(tr("New profile")));
    if (ridx.isValid())
}
void Singleton::f4();{
        exportProfiles(true);
        break;
    case EditCurrentProfile:
        item = pd_ui_->profileTreeView->currentIndex();
        if (item.isValid()) {
}
void Singleton::f5();{
    sort_model_->setFilterString();
    QModelIndex current = pd_ui_->profileTreeView->currentIndex();
    if (current.column() != ProfileModel::COL_NAME)
        current = current.sibling(current.row(), ProfileModel::COL_NAME);
    QModelIndex source = sort_model_->mapToSource(current);
}
void Singleton::f6();{
void ProfileDialog::finishImport(QFileInfo fi, int count, int skipped, QStringList import)
    QString msg;
    QMessageBox::Icon icon;
    if (count == 0 && skipped == 0)
    {
}
void Singleton::f7();{
    updateWidgets();
void ProfileDialog::on_newToolButton_clicked()
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
}
void Singleton::f8();{
    }
    storeLastDir(fi.absolutePath());
    if (count > 0)
    {
        import.sort();
}
void Singleton::f9();{
    if (action && action->property(PROFILE_EXPORT_PROPERTY).isValid())
        exportAllPersonalProfiles = action->property(PROFILE_EXPORT_PROPERTY).toString().compare(PROFILE_EXPORT_ALL) == 0;
    QModelIndexList items;
    int skipped = 0;
    if (! exportAllPersonalProfiles)
}
void Singleton::f10();{
    /* If multiple profiles are selected, do not change the selected profile */
    if (index.isValid() && ! item_data_removed && profiles.count() <= 1)
    {
        profileName = model_->data(index).toString();
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    QModelIndex newIdx = sort_model_->mapFromSource(model_->index(row, 0));
    if (newIdx.data(ProfileModel::DATA_IS_GLOBAL).toBool() != isGlobal)
        newIdx =  sort_model_->mapFromSource(model_->index(0, 0));
    pd_ui_->profileTreeView->setCurrentIndex(newIdx);
    updateWidgets();
}
void Singleton::f2();{
        QMessageBox::critical(this, tr("Profile Error"),
                              err_msg,
                              QMessageBox::Ok);
        g_free(err_msg);
        model_->doResetModel();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    QModelIndex newIdx = sort_model_->mapFromSource(model_->index(row, 0));
    if (newIdx.data(ProfileModel::DATA_IS_GLOBAL).toBool() != isGlobal)
        newIdx =  sort_model_->mapFromSource(model_->index(0, 0));
    pd_ui_->profileTreeView->setCurrentIndex(newIdx);
    updateWidgets();
}
void Singleton::f2();{
        QMessageBox::critical(this, tr("Profile Error"),
                              err_msg,
                              QMessageBox::Ok);
        g_free(err_msg);
        model_->doResetModel();
}
void Singleton::f3();{
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
    QModelIndex ridx = sort_model_->mapFromSource(model_->addNewProfile(tr("New profile")));
    if (ridx.isValid())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    QModelIndex newIdx = sort_model_->mapFromSource(model_->index(row, 0));
    if (newIdx.data(ProfileModel::DATA_IS_GLOBAL).toBool() != isGlobal)
        newIdx =  sort_model_->mapFromSource(model_->index(0, 0));
    pd_ui_->profileTreeView->setCurrentIndex(newIdx);
    updateWidgets();
}
void Singleton::f2();{
        QMessageBox::critical(this, tr("Profile Error"),
                              err_msg,
                              QMessageBox::Ok);
        g_free(err_msg);
        model_->doResetModel();
}
void Singleton::f3();{
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
    QModelIndex ridx = sort_model_->mapFromSource(model_->addNewProfile(tr("New profile")));
    if (ridx.isValid())
}
void Singleton::f4();{
        exportProfiles(true);
        break;
    case EditCurrentProfile:
        item = pd_ui_->profileTreeView->currentIndex();
        if (item.isValid()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    QModelIndex newIdx = sort_model_->mapFromSource(model_->index(row, 0));
    if (newIdx.data(ProfileModel::DATA_IS_GLOBAL).toBool() != isGlobal)
        newIdx =  sort_model_->mapFromSource(model_->index(0, 0));
    pd_ui_->profileTreeView->setCurrentIndex(newIdx);
    updateWidgets();
}
void Singleton::f2();{
        QMessageBox::critical(this, tr("Profile Error"),
                              err_msg,
                              QMessageBox::Ok);
        g_free(err_msg);
        model_->doResetModel();
}
void Singleton::f3();{
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
    QModelIndex ridx = sort_model_->mapFromSource(model_->addNewProfile(tr("New profile")));
    if (ridx.isValid())
}
void Singleton::f4();{
        exportProfiles(true);
        break;
    case EditCurrentProfile:
        item = pd_ui_->profileTreeView->currentIndex();
        if (item.isValid()) {
}
void Singleton::f5();{
    sort_model_->setFilterString();
    QModelIndex current = pd_ui_->profileTreeView->currentIndex();
    if (current.column() != ProfileModel::COL_NAME)
        current = current.sibling(current.row(), ProfileModel::COL_NAME);
    QModelIndex source = sort_model_->mapToSource(current);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    QModelIndex newIdx = sort_model_->mapFromSource(model_->index(row, 0));
    if (newIdx.data(ProfileModel::DATA_IS_GLOBAL).toBool() != isGlobal)
        newIdx =  sort_model_->mapFromSource(model_->index(0, 0));
    pd_ui_->profileTreeView->setCurrentIndex(newIdx);
    updateWidgets();
}
void Singleton::f2();{
        QMessageBox::critical(this, tr("Profile Error"),
                              err_msg,
                              QMessageBox::Ok);
        g_free(err_msg);
        model_->doResetModel();
}
void Singleton::f3();{
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
    QModelIndex ridx = sort_model_->mapFromSource(model_->addNewProfile(tr("New profile")));
    if (ridx.isValid())
}
void Singleton::f4();{
        exportProfiles(true);
        break;
    case EditCurrentProfile:
        item = pd_ui_->profileTreeView->currentIndex();
        if (item.isValid()) {
}
void Singleton::f5();{
    sort_model_->setFilterString();
    QModelIndex current = pd_ui_->profileTreeView->currentIndex();
    if (current.column() != ProfileModel::COL_NAME)
        current = current.sibling(current.row(), ProfileModel::COL_NAME);
    QModelIndex source = sort_model_->mapToSource(current);
}
void Singleton::f6();{
void ProfileDialog::finishImport(QFileInfo fi, int count, int skipped, QStringList import)
    QString msg;
    QMessageBox::Icon icon;
    if (count == 0 && skipped == 0)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    QModelIndex newIdx = sort_model_->mapFromSource(model_->index(row, 0));
    if (newIdx.data(ProfileModel::DATA_IS_GLOBAL).toBool() != isGlobal)
        newIdx =  sort_model_->mapFromSource(model_->index(0, 0));
    pd_ui_->profileTreeView->setCurrentIndex(newIdx);
    updateWidgets();
}
void Singleton::f2();{
        QMessageBox::critical(this, tr("Profile Error"),
                              err_msg,
                              QMessageBox::Ok);
        g_free(err_msg);
        model_->doResetModel();
}
void Singleton::f3();{
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
    QModelIndex ridx = sort_model_->mapFromSource(model_->addNewProfile(tr("New profile")));
    if (ridx.isValid())
}
void Singleton::f4();{
        exportProfiles(true);
        break;
    case EditCurrentProfile:
        item = pd_ui_->profileTreeView->currentIndex();
        if (item.isValid()) {
}
void Singleton::f5();{
    sort_model_->setFilterString();
    QModelIndex current = pd_ui_->profileTreeView->currentIndex();
    if (current.column() != ProfileModel::COL_NAME)
        current = current.sibling(current.row(), ProfileModel::COL_NAME);
    QModelIndex source = sort_model_->mapToSource(current);
}
void Singleton::f6();{
void ProfileDialog::finishImport(QFileInfo fi, int count, int skipped, QStringList import)
    QString msg;
    QMessageBox::Icon icon;
    if (count == 0 && skipped == 0)
    {
}
void Singleton::f7();{
    updateWidgets();
void ProfileDialog::on_newToolButton_clicked()
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    QModelIndex newIdx = sort_model_->mapFromSource(model_->index(row, 0));
    if (newIdx.data(ProfileModel::DATA_IS_GLOBAL).toBool() != isGlobal)
        newIdx =  sort_model_->mapFromSource(model_->index(0, 0));
    pd_ui_->profileTreeView->setCurrentIndex(newIdx);
    updateWidgets();
}
void Singleton::f2();{
        QMessageBox::critical(this, tr("Profile Error"),
                              err_msg,
                              QMessageBox::Ok);
        g_free(err_msg);
        model_->doResetModel();
}
void Singleton::f3();{
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
    QModelIndex ridx = sort_model_->mapFromSource(model_->addNewProfile(tr("New profile")));
    if (ridx.isValid())
}
void Singleton::f4();{
        exportProfiles(true);
        break;
    case EditCurrentProfile:
        item = pd_ui_->profileTreeView->currentIndex();
        if (item.isValid()) {
}
void Singleton::f5();{
    sort_model_->setFilterString();
    QModelIndex current = pd_ui_->profileTreeView->currentIndex();
    if (current.column() != ProfileModel::COL_NAME)
        current = current.sibling(current.row(), ProfileModel::COL_NAME);
    QModelIndex source = sort_model_->mapToSource(current);
}
void Singleton::f6();{
void ProfileDialog::finishImport(QFileInfo fi, int count, int skipped, QStringList import)
    QString msg;
    QMessageBox::Icon icon;
    if (count == 0 && skipped == 0)
    {
}
void Singleton::f7();{
    updateWidgets();
void ProfileDialog::on_newToolButton_clicked()
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
}
void Singleton::f8();{
    }
    storeLastDir(fi.absolutePath());
    if (count > 0)
    {
        import.sort();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    QModelIndex newIdx = sort_model_->mapFromSource(model_->index(row, 0));
    if (newIdx.data(ProfileModel::DATA_IS_GLOBAL).toBool() != isGlobal)
        newIdx =  sort_model_->mapFromSource(model_->index(0, 0));
    pd_ui_->profileTreeView->setCurrentIndex(newIdx);
    updateWidgets();
}
void Singleton::f2();{
        QMessageBox::critical(this, tr("Profile Error"),
                              err_msg,
                              QMessageBox::Ok);
        g_free(err_msg);
        model_->doResetModel();
}
void Singleton::f3();{
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
    QModelIndex ridx = sort_model_->mapFromSource(model_->addNewProfile(tr("New profile")));
    if (ridx.isValid())
}
void Singleton::f4();{
        exportProfiles(true);
        break;
    case EditCurrentProfile:
        item = pd_ui_->profileTreeView->currentIndex();
        if (item.isValid()) {
}
void Singleton::f5();{
    sort_model_->setFilterString();
    QModelIndex current = pd_ui_->profileTreeView->currentIndex();
    if (current.column() != ProfileModel::COL_NAME)
        current = current.sibling(current.row(), ProfileModel::COL_NAME);
    QModelIndex source = sort_model_->mapToSource(current);
}
void Singleton::f6();{
void ProfileDialog::finishImport(QFileInfo fi, int count, int skipped, QStringList import)
    QString msg;
    QMessageBox::Icon icon;
    if (count == 0 && skipped == 0)
    {
}
void Singleton::f7();{
    updateWidgets();
void ProfileDialog::on_newToolButton_clicked()
    pd_ui_->lineProfileFilter->setText("");
    pd_ui_->cmbProfileTypes->setCurrentIndex(ProfileSortModel::AllProfiles);
    sort_model_->setFilterString();
}
void Singleton::f8();{
    }
    storeLastDir(fi.absolutePath());
    if (count > 0)
    {
        import.sort();
}
void Singleton::f9();{
    if (action && action->property(PROFILE_EXPORT_PROPERTY).isValid())
        exportAllPersonalProfiles = action->property(PROFILE_EXPORT_PROPERTY).toString().compare(PROFILE_EXPORT_ALL) == 0;
    QModelIndexList items;
    int skipped = 0;
    if (! exportAllPersonalProfiles)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    /* Store preset profile name */
    set_profile_ = get_profile_name();
    reset_default_ = false;
    profiles_imported_ = false;
    last_set_row_ = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    /* Store preset profile name */
    set_profile_ = get_profile_name();
    reset_default_ = false;
    profiles_imported_ = false;
    last_set_row_ = 0;
}
void Singleton::f2();{
bool ProfileModel::importPending() const
    return profiles_imported_;
bool ProfileModel::userProfilesExist() const
    bool user_exists = false;
    for (int cnt = 0; cnt < rowCount() && ! user_exists; cnt++)
}
void Singleton::f3();{
            return ColorUtils::fromColorT(&prefs.gui_text_valid);
    }
    return QVariant();
QVariant ProfileModel::dataToolTipRole(const QModelIndex &idx) const
    if (! idx.isValid() || profiles_.count() <= idx.row())
}
void Singleton::f4();{
    last_set_row_ = -1;
    if (role != Qt::EditRole ||  ! value.isValid() || value.toString().isEmpty())
        return false;
    QString newValue = value.toString();
    profile_def * prof = guard(idx);
}
void Singleton::f5();{
    if (current.compare(newValue) != 0)
    {
        g_free(prof->name);
        prof->name = qstring_strdup(newValue);
        if (prof->reference && g_strcmp0(prof->name, prof->reference) == 0 && ! (prof->status == PROF_STAT_NEW || prof->status == PROF_STAT_COPY)) {
}
void Singleton::f6();{
            reset_default_ = ! reset_default_;
        }
        else
        {
            GList * fl_entry = entry(prof);
}
void Singleton::f7();{
    /* if this would be a copy, but the original is already a new one, this is a copy as well */
    if (new_status == PROF_STAT_COPY && prof->status == PROF_STAT_NEW)
        new_status = PROF_STAT_NEW;
    /* add element */
    add_to_profile_list(new_name.toUtf8().constData(), parent.toUtf8().constData(), new_status, FALSE, prof->from_global ? prof->from_global : prof->is_global, FALSE);
}
void Singleton::f8();{
            result.append(entry);
        }
        else
        {
            if (path.compare(entry.absoluteFilePath()) != 0)
}
void Singleton::f9();{
                profile_path = gchar_free_to_qstring(get_global_profiles_dir());
            } else {
                profile_path = gchar_free_to_qstring(get_profiles_dir());
            }
            profile_path.append("/").append(prof->name);
}
void Singleton::f10();{
            }
            return msg;
        }
    }
    return QVariant();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    /* Store preset profile name */
    set_profile_ = get_profile_name();
    reset_default_ = false;
    profiles_imported_ = false;
    last_set_row_ = 0;
}
void Singleton::f2();{
bool ProfileModel::importPending() const
    return profiles_imported_;
bool ProfileModel::userProfilesExist() const
    bool user_exists = false;
    for (int cnt = 0; cnt < rowCount() && ! user_exists; cnt++)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    /* Store preset profile name */
    set_profile_ = get_profile_name();
    reset_default_ = false;
    profiles_imported_ = false;
    last_set_row_ = 0;
}
void Singleton::f2();{
bool ProfileModel::importPending() const
    return profiles_imported_;
bool ProfileModel::userProfilesExist() const
    bool user_exists = false;
    for (int cnt = 0; cnt < rowCount() && ! user_exists; cnt++)
}
void Singleton::f3();{
            return ColorUtils::fromColorT(&prefs.gui_text_valid);
    }
    return QVariant();
QVariant ProfileModel::dataToolTipRole(const QModelIndex &idx) const
    if (! idx.isValid() || profiles_.count() <= idx.row())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    /* Store preset profile name */
    set_profile_ = get_profile_name();
    reset_default_ = false;
    profiles_imported_ = false;
    last_set_row_ = 0;
}
void Singleton::f2();{
bool ProfileModel::importPending() const
    return profiles_imported_;
bool ProfileModel::userProfilesExist() const
    bool user_exists = false;
    for (int cnt = 0; cnt < rowCount() && ! user_exists; cnt++)
}
void Singleton::f3();{
            return ColorUtils::fromColorT(&prefs.gui_text_valid);
    }
    return QVariant();
QVariant ProfileModel::dataToolTipRole(const QModelIndex &idx) const
    if (! idx.isValid() || profiles_.count() <= idx.row())
}
void Singleton::f4();{
    last_set_row_ = -1;
    if (role != Qt::EditRole ||  ! value.isValid() || value.toString().isEmpty())
        return false;
    QString newValue = value.toString();
    profile_def * prof = guard(idx);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    /* Store preset profile name */
    set_profile_ = get_profile_name();
    reset_default_ = false;
    profiles_imported_ = false;
    last_set_row_ = 0;
}
void Singleton::f2();{
bool ProfileModel::importPending() const
    return profiles_imported_;
bool ProfileModel::userProfilesExist() const
    bool user_exists = false;
    for (int cnt = 0; cnt < rowCount() && ! user_exists; cnt++)
}
void Singleton::f3();{
            return ColorUtils::fromColorT(&prefs.gui_text_valid);
    }
    return QVariant();
QVariant ProfileModel::dataToolTipRole(const QModelIndex &idx) const
    if (! idx.isValid() || profiles_.count() <= idx.row())
}
void Singleton::f4();{
    last_set_row_ = -1;
    if (role != Qt::EditRole ||  ! value.isValid() || value.toString().isEmpty())
        return false;
    QString newValue = value.toString();
    profile_def * prof = guard(idx);
}
void Singleton::f5();{
    if (current.compare(newValue) != 0)
    {
        g_free(prof->name);
        prof->name = qstring_strdup(newValue);
        if (prof->reference && g_strcmp0(prof->name, prof->reference) == 0 && ! (prof->status == PROF_STAT_NEW || prof->status == PROF_STAT_COPY)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    /* Store preset profile name */
    set_profile_ = get_profile_name();
    reset_default_ = false;
    profiles_imported_ = false;
    last_set_row_ = 0;
}
void Singleton::f2();{
bool ProfileModel::importPending() const
    return profiles_imported_;
bool ProfileModel::userProfilesExist() const
    bool user_exists = false;
    for (int cnt = 0; cnt < rowCount() && ! user_exists; cnt++)
}
void Singleton::f3();{
            return ColorUtils::fromColorT(&prefs.gui_text_valid);
    }
    return QVariant();
QVariant ProfileModel::dataToolTipRole(const QModelIndex &idx) const
    if (! idx.isValid() || profiles_.count() <= idx.row())
}
void Singleton::f4();{
    last_set_row_ = -1;
    if (role != Qt::EditRole ||  ! value.isValid() || value.toString().isEmpty())
        return false;
    QString newValue = value.toString();
    profile_def * prof = guard(idx);
}
void Singleton::f5();{
    if (current.compare(newValue) != 0)
    {
        g_free(prof->name);
        prof->name = qstring_strdup(newValue);
        if (prof->reference && g_strcmp0(prof->name, prof->reference) == 0 && ! (prof->status == PROF_STAT_NEW || prof->status == PROF_STAT_COPY)) {
}
void Singleton::f6();{
            reset_default_ = ! reset_default_;
        }
        else
        {
            GList * fl_entry = entry(prof);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    /* Store preset profile name */
    set_profile_ = get_profile_name();
    reset_default_ = false;
    profiles_imported_ = false;
    last_set_row_ = 0;
}
void Singleton::f2();{
bool ProfileModel::importPending() const
    return profiles_imported_;
bool ProfileModel::userProfilesExist() const
    bool user_exists = false;
    for (int cnt = 0; cnt < rowCount() && ! user_exists; cnt++)
}
void Singleton::f3();{
            return ColorUtils::fromColorT(&prefs.gui_text_valid);
    }
    return QVariant();
QVariant ProfileModel::dataToolTipRole(const QModelIndex &idx) const
    if (! idx.isValid() || profiles_.count() <= idx.row())
}
void Singleton::f4();{
    last_set_row_ = -1;
    if (role != Qt::EditRole ||  ! value.isValid() || value.toString().isEmpty())
        return false;
    QString newValue = value.toString();
    profile_def * prof = guard(idx);
}
void Singleton::f5();{
    if (current.compare(newValue) != 0)
    {
        g_free(prof->name);
        prof->name = qstring_strdup(newValue);
        if (prof->reference && g_strcmp0(prof->name, prof->reference) == 0 && ! (prof->status == PROF_STAT_NEW || prof->status == PROF_STAT_COPY)) {
}
void Singleton::f6();{
            reset_default_ = ! reset_default_;
        }
        else
        {
            GList * fl_entry = entry(prof);
}
void Singleton::f7();{
    /* if this would be a copy, but the original is already a new one, this is a copy as well */
    if (new_status == PROF_STAT_COPY && prof->status == PROF_STAT_NEW)
        new_status = PROF_STAT_NEW;
    /* add element */
    add_to_profile_list(new_name.toUtf8().constData(), parent.toUtf8().constData(), new_status, FALSE, prof->from_global ? prof->from_global : prof->is_global, FALSE);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    /* Store preset profile name */
    set_profile_ = get_profile_name();
    reset_default_ = false;
    profiles_imported_ = false;
    last_set_row_ = 0;
}
void Singleton::f2();{
bool ProfileModel::importPending() const
    return profiles_imported_;
bool ProfileModel::userProfilesExist() const
    bool user_exists = false;
    for (int cnt = 0; cnt < rowCount() && ! user_exists; cnt++)
}
void Singleton::f3();{
            return ColorUtils::fromColorT(&prefs.gui_text_valid);
    }
    return QVariant();
QVariant ProfileModel::dataToolTipRole(const QModelIndex &idx) const
    if (! idx.isValid() || profiles_.count() <= idx.row())
}
void Singleton::f4();{
    last_set_row_ = -1;
    if (role != Qt::EditRole ||  ! value.isValid() || value.toString().isEmpty())
        return false;
    QString newValue = value.toString();
    profile_def * prof = guard(idx);
}
void Singleton::f5();{
    if (current.compare(newValue) != 0)
    {
        g_free(prof->name);
        prof->name = qstring_strdup(newValue);
        if (prof->reference && g_strcmp0(prof->name, prof->reference) == 0 && ! (prof->status == PROF_STAT_NEW || prof->status == PROF_STAT_COPY)) {
}
void Singleton::f6();{
            reset_default_ = ! reset_default_;
        }
        else
        {
            GList * fl_entry = entry(prof);
}
void Singleton::f7();{
    /* if this would be a copy, but the original is already a new one, this is a copy as well */
    if (new_status == PROF_STAT_COPY && prof->status == PROF_STAT_NEW)
        new_status = PROF_STAT_NEW;
    /* add element */
    add_to_profile_list(new_name.toUtf8().constData(), parent.toUtf8().constData(), new_status, FALSE, prof->from_global ? prof->from_global : prof->is_global, FALSE);
}
void Singleton::f8();{
            result.append(entry);
        }
        else
        {
            if (path.compare(entry.absoluteFilePath()) != 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    /* Store preset profile name */
    set_profile_ = get_profile_name();
    reset_default_ = false;
    profiles_imported_ = false;
    last_set_row_ = 0;
}
void Singleton::f2();{
bool ProfileModel::importPending() const
    return profiles_imported_;
bool ProfileModel::userProfilesExist() const
    bool user_exists = false;
    for (int cnt = 0; cnt < rowCount() && ! user_exists; cnt++)
}
void Singleton::f3();{
            return ColorUtils::fromColorT(&prefs.gui_text_valid);
    }
    return QVariant();
QVariant ProfileModel::dataToolTipRole(const QModelIndex &idx) const
    if (! idx.isValid() || profiles_.count() <= idx.row())
}
void Singleton::f4();{
    last_set_row_ = -1;
    if (role != Qt::EditRole ||  ! value.isValid() || value.toString().isEmpty())
        return false;
    QString newValue = value.toString();
    profile_def * prof = guard(idx);
}
void Singleton::f5();{
    if (current.compare(newValue) != 0)
    {
        g_free(prof->name);
        prof->name = qstring_strdup(newValue);
        if (prof->reference && g_strcmp0(prof->name, prof->reference) == 0 && ! (prof->status == PROF_STAT_NEW || prof->status == PROF_STAT_COPY)) {
}
void Singleton::f6();{
            reset_default_ = ! reset_default_;
        }
        else
        {
            GList * fl_entry = entry(prof);
}
void Singleton::f7();{
    /* if this would be a copy, but the original is already a new one, this is a copy as well */
    if (new_status == PROF_STAT_COPY && prof->status == PROF_STAT_NEW)
        new_status = PROF_STAT_NEW;
    /* add element */
    add_to_profile_list(new_name.toUtf8().constData(), parent.toUtf8().constData(), new_status, FALSE, prof->from_global ? prof->from_global : prof->is_global, FALSE);
}
void Singleton::f8();{
            result.append(entry);
        }
        else
        {
            if (path.compare(entry.absoluteFilePath()) != 0)
}
void Singleton::f9();{
                profile_path = gchar_free_to_qstring(get_global_profiles_dir());
            } else {
                profile_path = gchar_free_to_qstring(get_profiles_dir());
            }
            profile_path.append("/").append(prof->name);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
ProfileTreeView::ProfileTreeView(QWidget *parent) :
    QTreeView (parent)
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
ProfileTreeView::ProfileTreeView(QWidget *parent) :
    QTreeView (parent)
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
}
void Singleton::f2();{
        QStyledItemDelegate::paint(painter, option, index);
ProfileTreeEditDelegate::ProfileTreeEditDelegate(QWidget *parent) : QItemDelegate(parent), editor_(Q_NULLPTR) {}
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
}
void Singleton::f3();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}
void Singleton::f4();{
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
        QLineEdit * ql = qobject_cast<QLineEdit *>(editor);
        ql->setText(index.data().toString());
}
void Singleton::f5();{
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
    connect(delegate_, SIGNAL(commitData(QWidget *)), this, SIGNAL(itemUpdated()));
ProfileTreeView::~ProfileTreeView()
}
void Singleton::f6();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}
void Singleton::f7();{
    /* Only paint links for valid paths */
    if (index.data(ProfileModel::DATA_INDEX_VALUE_IS_URL).toBool())
    {
        QString path = QDir::toNativeSeparators(index.data().toString());
        QDesktopServices::openUrl(QUrl::fromLocalFile(path));
}
void Singleton::f8();{
        int offColumn = model()->columnCount();
        int idxCount = selectedIndexes().count() / offColumn;
        int dselCount = deselected.count() > 0 ? deselected.at(0).indexes().count() / offColumn : 0;
        /* Ensure, that the last selected row cannot be deselected */
        if (idxCount == 0 && dselCount == 1)
}
void Singleton::f9();{
ProfileTreeEditDelegate::ProfileTreeEditDelegate(QWidget *parent) : QItemDelegate(parent), editor_(Q_NULLPTR) {}
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
        QLineEdit * ql = qobject_cast<QLineEdit *>(editor);
}
void Singleton::f10();{
    if (qobject_cast<QLineEdit *>(editor))
    {
        QLineEdit * ql = qobject_cast<QLineEdit *>(editor);
        ql->setText(index.data().toString());
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
ProfileTreeView::ProfileTreeView(QWidget *parent) :
    QTreeView (parent)
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
}
void Singleton::f2();{
        QStyledItemDelegate::paint(painter, option, index);
ProfileTreeEditDelegate::ProfileTreeEditDelegate(QWidget *parent) : QItemDelegate(parent), editor_(Q_NULLPTR) {}
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
ProfileTreeView::ProfileTreeView(QWidget *parent) :
    QTreeView (parent)
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
}
void Singleton::f2();{
        QStyledItemDelegate::paint(painter, option, index);
ProfileTreeEditDelegate::ProfileTreeEditDelegate(QWidget *parent) : QItemDelegate(parent), editor_(Q_NULLPTR) {}
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
}
void Singleton::f3();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
ProfileTreeView::ProfileTreeView(QWidget *parent) :
    QTreeView (parent)
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
}
void Singleton::f2();{
        QStyledItemDelegate::paint(painter, option, index);
ProfileTreeEditDelegate::ProfileTreeEditDelegate(QWidget *parent) : QItemDelegate(parent), editor_(Q_NULLPTR) {}
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
}
void Singleton::f3();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}
void Singleton::f4();{
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
        QLineEdit * ql = qobject_cast<QLineEdit *>(editor);
        ql->setText(index.data().toString());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
ProfileTreeView::ProfileTreeView(QWidget *parent) :
    QTreeView (parent)
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
}
void Singleton::f2();{
        QStyledItemDelegate::paint(painter, option, index);
ProfileTreeEditDelegate::ProfileTreeEditDelegate(QWidget *parent) : QItemDelegate(parent), editor_(Q_NULLPTR) {}
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
}
void Singleton::f3();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}
void Singleton::f4();{
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
        QLineEdit * ql = qobject_cast<QLineEdit *>(editor);
        ql->setText(index.data().toString());
}
void Singleton::f5();{
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
    connect(delegate_, SIGNAL(commitData(QWidget *)), this, SIGNAL(itemUpdated()));
ProfileTreeView::~ProfileTreeView()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
ProfileTreeView::ProfileTreeView(QWidget *parent) :
    QTreeView (parent)
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
}
void Singleton::f2();{
        QStyledItemDelegate::paint(painter, option, index);
ProfileTreeEditDelegate::ProfileTreeEditDelegate(QWidget *parent) : QItemDelegate(parent), editor_(Q_NULLPTR) {}
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
}
void Singleton::f3();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}
void Singleton::f4();{
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
        QLineEdit * ql = qobject_cast<QLineEdit *>(editor);
        ql->setText(index.data().toString());
}
void Singleton::f5();{
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
    connect(delegate_, SIGNAL(commitData(QWidget *)), this, SIGNAL(itemUpdated()));
ProfileTreeView::~ProfileTreeView()
}
void Singleton::f6();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
ProfileTreeView::ProfileTreeView(QWidget *parent) :
    QTreeView (parent)
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
}
void Singleton::f2();{
        QStyledItemDelegate::paint(painter, option, index);
ProfileTreeEditDelegate::ProfileTreeEditDelegate(QWidget *parent) : QItemDelegate(parent), editor_(Q_NULLPTR) {}
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
}
void Singleton::f3();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}
void Singleton::f4();{
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
        QLineEdit * ql = qobject_cast<QLineEdit *>(editor);
        ql->setText(index.data().toString());
}
void Singleton::f5();{
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
    connect(delegate_, SIGNAL(commitData(QWidget *)), this, SIGNAL(itemUpdated()));
ProfileTreeView::~ProfileTreeView()
}
void Singleton::f6();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}
void Singleton::f7();{
    /* Only paint links for valid paths */
    if (index.data(ProfileModel::DATA_INDEX_VALUE_IS_URL).toBool())
    {
        QString path = QDir::toNativeSeparators(index.data().toString());
        QDesktopServices::openUrl(QUrl::fromLocalFile(path));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
ProfileTreeView::ProfileTreeView(QWidget *parent) :
    QTreeView (parent)
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
}
void Singleton::f2();{
        QStyledItemDelegate::paint(painter, option, index);
ProfileTreeEditDelegate::ProfileTreeEditDelegate(QWidget *parent) : QItemDelegate(parent), editor_(Q_NULLPTR) {}
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
}
void Singleton::f3();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}
void Singleton::f4();{
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
        QLineEdit * ql = qobject_cast<QLineEdit *>(editor);
        ql->setText(index.data().toString());
}
void Singleton::f5();{
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
    connect(delegate_, SIGNAL(commitData(QWidget *)), this, SIGNAL(itemUpdated()));
ProfileTreeView::~ProfileTreeView()
}
void Singleton::f6();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}
void Singleton::f7();{
    /* Only paint links for valid paths */
    if (index.data(ProfileModel::DATA_INDEX_VALUE_IS_URL).toBool())
    {
        QString path = QDir::toNativeSeparators(index.data().toString());
        QDesktopServices::openUrl(QUrl::fromLocalFile(path));
}
void Singleton::f8();{
        int offColumn = model()->columnCount();
        int idxCount = selectedIndexes().count() / offColumn;
        int dselCount = deselected.count() > 0 ? deselected.at(0).indexes().count() / offColumn : 0;
        /* Ensure, that the last selected row cannot be deselected */
        if (idxCount == 0 && dselCount == 1)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
ProfileTreeView::ProfileTreeView(QWidget *parent) :
    QTreeView (parent)
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
}
void Singleton::f2();{
        QStyledItemDelegate::paint(painter, option, index);
ProfileTreeEditDelegate::ProfileTreeEditDelegate(QWidget *parent) : QItemDelegate(parent), editor_(Q_NULLPTR) {}
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
}
void Singleton::f3();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}
void Singleton::f4();{
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
        QLineEdit * ql = qobject_cast<QLineEdit *>(editor);
        ql->setText(index.data().toString());
}
void Singleton::f5();{
    delegate_ = new ProfileTreeEditDelegate();
    setItemDelegateForColumn(ProfileModel::COL_NAME, delegate_);
    connect(this, &QAbstractItemView::clicked, this, &ProfileTreeView::clicked);
    connect(delegate_, SIGNAL(commitData(QWidget *)), this, SIGNAL(itemUpdated()));
ProfileTreeView::~ProfileTreeView()
}
void Singleton::f6();{
                QItemSelection(model()->index(row, 0), model()->index(row, model()->columnCount() -1)),
                QItemSelectionModel::ClearAndSelect);
void ProfileTreeView::mouseDoubleClickEvent(QMouseEvent *ev)
    /* due to the fact, that we allow only row selection, selected rows are always added with all columns */
    if (selectedIndexes().count() <= model()->columnCount())
}
void Singleton::f7();{
    /* Only paint links for valid paths */
    if (index.data(ProfileModel::DATA_INDEX_VALUE_IS_URL).toBool())
    {
        QString path = QDir::toNativeSeparators(index.data().toString());
        QDesktopServices::openUrl(QUrl::fromLocalFile(path));
}
void Singleton::f8();{
        int offColumn = model()->columnCount();
        int idxCount = selectedIndexes().count() / offColumn;
        int dselCount = deselected.count() > 0 ? deselected.at(0).indexes().count() / offColumn : 0;
        /* Ensure, that the last selected row cannot be deselected */
        if (idxCount == 0 && dselCount == 1)
}
void Singleton::f9();{
ProfileTreeEditDelegate::ProfileTreeEditDelegate(QWidget *parent) : QItemDelegate(parent), editor_(Q_NULLPTR) {}
void ProfileTreeEditDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
    if (qobject_cast<QLineEdit *>(editor))
    {
        QLineEdit * ql = qobject_cast<QLineEdit *>(editor);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
// - Start adding the progress bar to dialogs.
// - Don't complain so loudly when the user stops a capture.
progdlg_t *
create_progress_dlg(gpointer top_level_window, const gchar *task_title, const gchar *item_title,
                               gboolean terminate_is_stop, gboolean *stop_flag) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
// - Start adding the progress bar to dialogs.
// - Don't complain so loudly when the user stops a capture.
progdlg_t *
create_progress_dlg(gpointer top_level_window, const gchar *task_title, const gchar *item_title,
                               gboolean terminate_is_stop, gboolean *stop_flag) {
}
void Singleton::f2();{
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
    for (int i = 0; i < layout->count(); i++) {
        if (layout->itemAt(i)->spacerItem()) {
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            "  padding: 0px;"
            "  margin: 0px;"
            "  min-height: 0.8em;"
            "  max-height: 1em;"
            "  min-width: 0.8em;"
}
void Singleton::f5();{
 * Destroy the progress bar.
void
destroy_progress_dlg(progdlg_t *dlg)
    dlg->progress_frame->hide();
ProgressFrame::ProgressFrame(QWidget *parent) :
}
void Singleton::f6();{
    if (!layout) return;
    ProgressFrame *progress_frame = new ProgressFrame(button_box);
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
}
void Singleton::f7();{
  , stop_flag_(nullptr)
  , show_timer_(-1)
  , effect_(nullptr)
  , animation_(nullptr)
  , update_taskbar_(false)
}
void Singleton::f8();{
            );
    effect_ = new QGraphicsOpacityEffect(this);
    animation_ = new QPropertyAnimation(effect_, "opacity", this);
    connect(this, SIGNAL(showRequested(bool,bool,gboolean*)),
            this, SLOT(show(bool,bool,gboolean*)));
}
void Singleton::f9();{
            taskbar_progress_ = taskbar_button->progress();
        }
    }
    if (taskbar_progress_) {
        taskbar_progress_->show();
}
void Singleton::f10();{
            "  background: transparent;"
            "}"));
    ui->progressBar->setStyleSheet(QString(
            "QProgressBar {"
            "  max-width: 20em;"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
// - Start adding the progress bar to dialogs.
// - Don't complain so loudly when the user stops a capture.
progdlg_t *
create_progress_dlg(gpointer top_level_window, const gchar *task_title, const gchar *item_title,
                               gboolean terminate_is_stop, gboolean *stop_flag) {
}
void Singleton::f2();{
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
    for (int i = 0; i < layout->count(); i++) {
        if (layout->itemAt(i)->spacerItem()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
// - Start adding the progress bar to dialogs.
// - Don't complain so loudly when the user stops a capture.
progdlg_t *
create_progress_dlg(gpointer top_level_window, const gchar *task_title, const gchar *item_title,
                               gboolean terminate_is_stop, gboolean *stop_flag) {
}
void Singleton::f2();{
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
    for (int i = 0; i < layout->count(); i++) {
        if (layout->itemAt(i)->spacerItem()) {
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
// - Start adding the progress bar to dialogs.
// - Don't complain so loudly when the user stops a capture.
progdlg_t *
create_progress_dlg(gpointer top_level_window, const gchar *task_title, const gchar *item_title,
                               gboolean terminate_is_stop, gboolean *stop_flag) {
}
void Singleton::f2();{
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
    for (int i = 0; i < layout->count(); i++) {
        if (layout->itemAt(i)->spacerItem()) {
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            "  padding: 0px;"
            "  margin: 0px;"
            "  min-height: 0.8em;"
            "  max-height: 1em;"
            "  min-width: 0.8em;"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
// - Start adding the progress bar to dialogs.
// - Don't complain so loudly when the user stops a capture.
progdlg_t *
create_progress_dlg(gpointer top_level_window, const gchar *task_title, const gchar *item_title,
                               gboolean terminate_is_stop, gboolean *stop_flag) {
}
void Singleton::f2();{
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
    for (int i = 0; i < layout->count(); i++) {
        if (layout->itemAt(i)->spacerItem()) {
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            "  padding: 0px;"
            "  margin: 0px;"
            "  min-height: 0.8em;"
            "  max-height: 1em;"
            "  min-width: 0.8em;"
}
void Singleton::f5();{
 * Destroy the progress bar.
void
destroy_progress_dlg(progdlg_t *dlg)
    dlg->progress_frame->hide();
ProgressFrame::ProgressFrame(QWidget *parent) :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
// - Start adding the progress bar to dialogs.
// - Don't complain so loudly when the user stops a capture.
progdlg_t *
create_progress_dlg(gpointer top_level_window, const gchar *task_title, const gchar *item_title,
                               gboolean terminate_is_stop, gboolean *stop_flag) {
}
void Singleton::f2();{
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
    for (int i = 0; i < layout->count(); i++) {
        if (layout->itemAt(i)->spacerItem()) {
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            "  padding: 0px;"
            "  margin: 0px;"
            "  min-height: 0.8em;"
            "  max-height: 1em;"
            "  min-width: 0.8em;"
}
void Singleton::f5();{
 * Destroy the progress bar.
void
destroy_progress_dlg(progdlg_t *dlg)
    dlg->progress_frame->hide();
ProgressFrame::ProgressFrame(QWidget *parent) :
}
void Singleton::f6();{
    if (!layout) return;
    ProgressFrame *progress_frame = new ProgressFrame(button_box);
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
// - Start adding the progress bar to dialogs.
// - Don't complain so loudly when the user stops a capture.
progdlg_t *
create_progress_dlg(gpointer top_level_window, const gchar *task_title, const gchar *item_title,
                               gboolean terminate_is_stop, gboolean *stop_flag) {
}
void Singleton::f2();{
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
    for (int i = 0; i < layout->count(); i++) {
        if (layout->itemAt(i)->spacerItem()) {
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            "  padding: 0px;"
            "  margin: 0px;"
            "  min-height: 0.8em;"
            "  max-height: 1em;"
            "  min-width: 0.8em;"
}
void Singleton::f5();{
 * Destroy the progress bar.
void
destroy_progress_dlg(progdlg_t *dlg)
    dlg->progress_frame->hide();
ProgressFrame::ProgressFrame(QWidget *parent) :
}
void Singleton::f6();{
    if (!layout) return;
    ProgressFrame *progress_frame = new ProgressFrame(button_box);
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
}
void Singleton::f7();{
  , stop_flag_(nullptr)
  , show_timer_(-1)
  , effect_(nullptr)
  , animation_(nullptr)
  , update_taskbar_(false)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
// - Start adding the progress bar to dialogs.
// - Don't complain so loudly when the user stops a capture.
progdlg_t *
create_progress_dlg(gpointer top_level_window, const gchar *task_title, const gchar *item_title,
                               gboolean terminate_is_stop, gboolean *stop_flag) {
}
void Singleton::f2();{
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
    for (int i = 0; i < layout->count(); i++) {
        if (layout->itemAt(i)->spacerItem()) {
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            "  padding: 0px;"
            "  margin: 0px;"
            "  min-height: 0.8em;"
            "  max-height: 1em;"
            "  min-width: 0.8em;"
}
void Singleton::f5();{
 * Destroy the progress bar.
void
destroy_progress_dlg(progdlg_t *dlg)
    dlg->progress_frame->hide();
ProgressFrame::ProgressFrame(QWidget *parent) :
}
void Singleton::f6();{
    if (!layout) return;
    ProgressFrame *progress_frame = new ProgressFrame(button_box);
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
}
void Singleton::f7();{
  , stop_flag_(nullptr)
  , show_timer_(-1)
  , effect_(nullptr)
  , animation_(nullptr)
  , update_taskbar_(false)
}
void Singleton::f8();{
            );
    effect_ = new QGraphicsOpacityEffect(this);
    animation_ = new QPropertyAnimation(effect_, "opacity", this);
    connect(this, SIGNAL(showRequested(bool,bool,gboolean*)),
            this, SLOT(show(bool,bool,gboolean*)));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
// - Start adding the progress bar to dialogs.
// - Don't complain so loudly when the user stops a capture.
progdlg_t *
create_progress_dlg(gpointer top_level_window, const gchar *task_title, const gchar *item_title,
                               gboolean terminate_is_stop, gboolean *stop_flag) {
}
void Singleton::f2();{
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
    for (int i = 0; i < layout->count(); i++) {
        if (layout->itemAt(i)->spacerItem()) {
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
            "  padding: 0px;"
            "  margin: 0px;"
            "  min-height: 0.8em;"
            "  max-height: 1em;"
            "  min-width: 0.8em;"
}
void Singleton::f5();{
 * Destroy the progress bar.
void
destroy_progress_dlg(progdlg_t *dlg)
    dlg->progress_frame->hide();
ProgressFrame::ProgressFrame(QWidget *parent) :
}
void Singleton::f6();{
    if (!layout) return;
    ProgressFrame *progress_frame = new ProgressFrame(button_box);
    // Insert ourselves after the first spacer we find, otherwise the
    // far right of the button box.
    int idx = layout->count();
}
void Singleton::f7();{
  , stop_flag_(nullptr)
  , show_timer_(-1)
  , effect_(nullptr)
  , animation_(nullptr)
  , update_taskbar_(false)
}
void Singleton::f8();{
            );
    effect_ = new QGraphicsOpacityEffect(this);
    animation_ = new QPropertyAnimation(effect_, "opacity", this);
    connect(this, SIGNAL(showRequested(bool,bool,gboolean*)),
            this, SLOT(show(bool,bool,gboolean*)));
}
void Singleton::f9();{
            taskbar_progress_ = taskbar_button->progress();
        }
    }
    if (taskbar_progress_) {
        taskbar_progress_->show();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    if (close_bt) {
        close_bt->setDefault(true);
    }
    display_filter_ = cap_file_.capFile()->dfilter;
    updateWidgets();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    if (close_bt) {
        close_bt->setDefault(true);
    }
    display_filter_ = cap_file_.capFile()->dfilter;
    updateWidgets();
}
void Singleton::f2();{
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
    }
    cur_action = FilterAction::ActionPrepare;
}
void Singleton::f3();{
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
}
void Singleton::f4();{
 * @file Protocol Hierarchy Statistics dialog
 * Displays tree of protocols with various statistics
 * Allows filtering on tree items
// To do:
// - Make "Copy as YAML" output a tree?
}
void Singleton::f5();{
        if (!first) ++iter;
        first = false;
    }
    wsApp->clipboard()->setText(stream.readAll());
void ProtocolHierarchyDialog::on_buttonBox_helpRequested()
}
void Singleton::f6();{
            return last_bytes_ < other_phtwi.last_bytes_;
        case end_bandwidth_col_:
            return end_bits_s_ < other_phtwi.end_bits_s_;
        default:
            break;
}
void Singleton::f7();{
        }
        setText(protocol_col_, ph_stats_node.hfinfo->name);
        setData(pct_packets_col_, Qt::UserRole, percent_packets_);
        setText(packets_col_, QString::number(total_packets_));
        setData(pct_bytes_col_, Qt::UserRole, percent_bytes_);
}
void Singleton::f8();{
    ui->hierStatsTreeWidget->setItemDelegateForColumn(pct_packets_col_, &percent_bar_delegate_);
    ui->hierStatsTreeWidget->setItemDelegateForColumn(pct_bytes_col_, &percent_bar_delegate_);
    ph_stats_t *ph_stats = ph_stats_new(cap_file_.capFile());
    if (ph_stats) {
        ui->hierStatsTreeWidget->invisibleRootItem()->setData(0, Qt::UserRole, VariantPointer<ph_stats_t>::asQVariant(ph_stats));
}
void Singleton::f9();{
    QString hint = "<small><i>";
    if (display_filter_.isEmpty()) {
        hint += tr("No display filter.");
    } else {
        hint += tr("Display filter: %1").arg(display_filter_);
}
void Singleton::f10();{
    }
    wsApp->clipboard()->setText(stream.readAll());
void ProtocolHierarchyDialog::on_actionCopyAsYaml_triggered()
    QString yaml;
    QTextStream stream(&yaml, QIODevice::Text);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    if (close_bt) {
        close_bt->setDefault(true);
    }
    display_filter_ = cap_file_.capFile()->dfilter;
    updateWidgets();
}
void Singleton::f2();{
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
    }
    cur_action = FilterAction::ActionPrepare;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    if (close_bt) {
        close_bt->setDefault(true);
    }
    display_filter_ = cap_file_.capFile()->dfilter;
    updateWidgets();
}
void Singleton::f2();{
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
    }
    cur_action = FilterAction::ActionPrepare;
}
void Singleton::f3();{
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    if (close_bt) {
        close_bt->setDefault(true);
    }
    display_filter_ = cap_file_.capFile()->dfilter;
    updateWidgets();
}
void Singleton::f2();{
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
    }
    cur_action = FilterAction::ActionPrepare;
}
void Singleton::f3();{
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
}
void Singleton::f4();{
 * @file Protocol Hierarchy Statistics dialog
 * Displays tree of protocols with various statistics
 * Allows filtering on tree items
// To do:
// - Make "Copy as YAML" output a tree?
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    if (close_bt) {
        close_bt->setDefault(true);
    }
    display_filter_ = cap_file_.capFile()->dfilter;
    updateWidgets();
}
void Singleton::f2();{
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
    }
    cur_action = FilterAction::ActionPrepare;
}
void Singleton::f3();{
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
}
void Singleton::f4();{
 * @file Protocol Hierarchy Statistics dialog
 * Displays tree of protocols with various statistics
 * Allows filtering on tree items
// To do:
// - Make "Copy as YAML" output a tree?
}
void Singleton::f5();{
        if (!first) ++iter;
        first = false;
    }
    wsApp->clipboard()->setText(stream.readAll());
void ProtocolHierarchyDialog::on_buttonBox_helpRequested()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    if (close_bt) {
        close_bt->setDefault(true);
    }
    display_filter_ = cap_file_.capFile()->dfilter;
    updateWidgets();
}
void Singleton::f2();{
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
    }
    cur_action = FilterAction::ActionPrepare;
}
void Singleton::f3();{
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
}
void Singleton::f4();{
 * @file Protocol Hierarchy Statistics dialog
 * Displays tree of protocols with various statistics
 * Allows filtering on tree items
// To do:
// - Make "Copy as YAML" output a tree?
}
void Singleton::f5();{
        if (!first) ++iter;
        first = false;
    }
    wsApp->clipboard()->setText(stream.readAll());
void ProtocolHierarchyDialog::on_buttonBox_helpRequested()
}
void Singleton::f6();{
            return last_bytes_ < other_phtwi.last_bytes_;
        case end_bandwidth_col_:
            return end_bits_s_ < other_phtwi.end_bits_s_;
        default:
            break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    if (close_bt) {
        close_bt->setDefault(true);
    }
    display_filter_ = cap_file_.capFile()->dfilter;
    updateWidgets();
}
void Singleton::f2();{
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
    }
    cur_action = FilterAction::ActionPrepare;
}
void Singleton::f3();{
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
}
void Singleton::f4();{
 * @file Protocol Hierarchy Statistics dialog
 * Displays tree of protocols with various statistics
 * Allows filtering on tree items
// To do:
// - Make "Copy as YAML" output a tree?
}
void Singleton::f5();{
        if (!first) ++iter;
        first = false;
    }
    wsApp->clipboard()->setText(stream.readAll());
void ProtocolHierarchyDialog::on_buttonBox_helpRequested()
}
void Singleton::f6();{
            return last_bytes_ < other_phtwi.last_bytes_;
        case end_bandwidth_col_:
            return end_bits_s_ < other_phtwi.end_bits_s_;
        default:
            break;
}
void Singleton::f7();{
        }
        setText(protocol_col_, ph_stats_node.hfinfo->name);
        setData(pct_packets_col_, Qt::UserRole, percent_packets_);
        setText(packets_col_, QString::number(total_packets_));
        setData(pct_bytes_col_, Qt::UserRole, percent_bytes_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    if (close_bt) {
        close_bt->setDefault(true);
    }
    display_filter_ = cap_file_.capFile()->dfilter;
    updateWidgets();
}
void Singleton::f2();{
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
    }
    cur_action = FilterAction::ActionPrepare;
}
void Singleton::f3();{
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
}
void Singleton::f4();{
 * @file Protocol Hierarchy Statistics dialog
 * Displays tree of protocols with various statistics
 * Allows filtering on tree items
// To do:
// - Make "Copy as YAML" output a tree?
}
void Singleton::f5();{
        if (!first) ++iter;
        first = false;
    }
    wsApp->clipboard()->setText(stream.readAll());
void ProtocolHierarchyDialog::on_buttonBox_helpRequested()
}
void Singleton::f6();{
            return last_bytes_ < other_phtwi.last_bytes_;
        case end_bandwidth_col_:
            return end_bits_s_ < other_phtwi.end_bits_s_;
        default:
            break;
}
void Singleton::f7();{
        }
        setText(protocol_col_, ph_stats_node.hfinfo->name);
        setData(pct_packets_col_, Qt::UserRole, percent_packets_);
        setText(packets_col_, QString::number(total_packets_));
        setData(pct_bytes_col_, Qt::UserRole, percent_bytes_);
}
void Singleton::f8();{
    ui->hierStatsTreeWidget->setItemDelegateForColumn(pct_packets_col_, &percent_bar_delegate_);
    ui->hierStatsTreeWidget->setItemDelegateForColumn(pct_bytes_col_, &percent_bar_delegate_);
    ph_stats_t *ph_stats = ph_stats_new(cap_file_.capFile());
    if (ph_stats) {
        ui->hierStatsTreeWidget->invisibleRootItem()->setData(0, Qt::UserRole, VariantPointer<ph_stats_t>::asQVariant(ph_stats));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    if (close_bt) {
        close_bt->setDefault(true);
    }
    display_filter_ = cap_file_.capFile()->dfilter;
    updateWidgets();
}
void Singleton::f2();{
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
    }
    cur_action = FilterAction::ActionPrepare;
}
void Singleton::f3();{
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes()) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
        submenu->addAction(fa);
        connect(fa, SIGNAL(triggered()), this, SLOT(filterActionTriggered()));
}
void Singleton::f4();{
 * @file Protocol Hierarchy Statistics dialog
 * Displays tree of protocols with various statistics
 * Allows filtering on tree items
// To do:
// - Make "Copy as YAML" output a tree?
}
void Singleton::f5();{
        if (!first) ++iter;
        first = false;
    }
    wsApp->clipboard()->setText(stream.readAll());
void ProtocolHierarchyDialog::on_buttonBox_helpRequested()
}
void Singleton::f6();{
            return last_bytes_ < other_phtwi.last_bytes_;
        case end_bandwidth_col_:
            return end_bits_s_ < other_phtwi.end_bits_s_;
        default:
            break;
}
void Singleton::f7();{
        }
        setText(protocol_col_, ph_stats_node.hfinfo->name);
        setData(pct_packets_col_, Qt::UserRole, percent_packets_);
        setText(packets_col_, QString::number(total_packets_));
        setData(pct_bytes_col_, Qt::UserRole, percent_bytes_);
}
void Singleton::f8();{
    ui->hierStatsTreeWidget->setItemDelegateForColumn(pct_packets_col_, &percent_bar_delegate_);
    ui->hierStatsTreeWidget->setItemDelegateForColumn(pct_bytes_col_, &percent_bar_delegate_);
    ph_stats_t *ph_stats = ph_stats_new(cap_file_.capFile());
    if (ph_stats) {
        ui->hierStatsTreeWidget->invisibleRootItem()->setData(0, Qt::UserRole, VariantPointer<ph_stats_t>::asQVariant(ph_stats));
}
void Singleton::f9();{
    QString hint = "<small><i>";
    if (display_filter_.isEmpty()) {
        hint += tr("No display filter.");
    } else {
        hint += tr("Display filter: %1").arg(display_filter_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                connect(epa, SIGNAL(triggered(bool)), this, SLOT(enumPreferenceTriggered()));
                enum_valp++;
            }
        }
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                connect(epa, SIGNAL(triggered(bool)), this, SLOT(enumPreferenceTriggered()));
                enum_valp++;
            }
        }
        break;
}
void Singleton::f2();{
    unsigned int changed_flags = module_->prefs_changed_flags;
    prefs_apply(module_);
    prefs_main_write();
    if (changed_flags & PREF_EFFECT_FIELDS) {
        wsApp->emitAppSignal(WiresharkApplication::FieldsChanged);
}
void Singleton::f3();{
    EditorPreferenceAction(pref_t *pref, QObject *parent=0) :
        QAction(parent),
        pref_(pref)
    {
        QString title = prefs_get_title(pref_);
}
void Singleton::f4();{
        break;
    }
void ProtocolPreferencesMenu::disableProtocolTriggered()
    EnabledProtocolsModel::disableProtocol(protocol_);
void ProtocolPreferencesMenu::modulePreferencesTriggered()
}
void Singleton::f5();{
void ProtocolPreferencesMenu::addMenuItem(preference *pref)
    switch (prefs_get_type(pref)) {
    case PREF_BOOL:
    {
        BoolPreferenceAction *bpa = new BoolPreferenceAction(pref, this);
}
void Singleton::f6();{
    }
    case PREF_CUSTOM:
    case PREF_STATIC_TEXT:
    case PREF_OBSOLETE:
        break;
}
void Singleton::f7();{
        emit showProtocolPreferences(module_name_);
    }
void ProtocolPreferencesMenu::editorPreferenceTriggered()
    EditorPreferenceAction *epa = static_cast<EditorPreferenceAction *>(QObject::sender());
    if (!epa) return;
}
void Singleton::f8();{
        BoolPreferenceAction *bpa = new BoolPreferenceAction(pref, this);
        addAction(bpa);
        connect(bpa, SIGNAL(triggered(bool)), this, SLOT(boolPreferenceTriggered()));
        break;
    }
}
void Singleton::f9();{
    connect(action, SIGNAL(triggered(bool)), this, SLOT(modulePreferencesTriggered()));
    addSeparator();
    prefs_pref_foreach(module_, add_prefs_menu_item, this);
    if (!actions().last()->isSeparator()) {
        addSeparator();
}
void Singleton::f10();{
    wsApp->emitAppSignal(WiresharkApplication::PacketDissectionChanged);
void ProtocolPreferencesMenu::enumPreferenceTriggered()
    EnumPreferenceAction *epa = static_cast<EnumPreferenceAction *>(QObject::sender());
    if (!epa) return;
    unsigned int changed_flags = epa->setEnumValue();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                connect(epa, SIGNAL(triggered(bool)), this, SLOT(enumPreferenceTriggered()));
                enum_valp++;
            }
        }
        break;
}
void Singleton::f2();{
    unsigned int changed_flags = module_->prefs_changed_flags;
    prefs_apply(module_);
    prefs_main_write();
    if (changed_flags & PREF_EFFECT_FIELDS) {
        wsApp->emitAppSignal(WiresharkApplication::FieldsChanged);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                connect(epa, SIGNAL(triggered(bool)), this, SLOT(enumPreferenceTriggered()));
                enum_valp++;
            }
        }
        break;
}
void Singleton::f2();{
    unsigned int changed_flags = module_->prefs_changed_flags;
    prefs_apply(module_);
    prefs_main_write();
    if (changed_flags & PREF_EFFECT_FIELDS) {
        wsApp->emitAppSignal(WiresharkApplication::FieldsChanged);
}
void Singleton::f3();{
    EditorPreferenceAction(pref_t *pref, QObject *parent=0) :
        QAction(parent),
        pref_(pref)
    {
        QString title = prefs_get_title(pref_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                connect(epa, SIGNAL(triggered(bool)), this, SLOT(enumPreferenceTriggered()));
                enum_valp++;
            }
        }
        break;
}
void Singleton::f2();{
    unsigned int changed_flags = module_->prefs_changed_flags;
    prefs_apply(module_);
    prefs_main_write();
    if (changed_flags & PREF_EFFECT_FIELDS) {
        wsApp->emitAppSignal(WiresharkApplication::FieldsChanged);
}
void Singleton::f3();{
    EditorPreferenceAction(pref_t *pref, QObject *parent=0) :
        QAction(parent),
        pref_(pref)
    {
        QString title = prefs_get_title(pref_);
}
void Singleton::f4();{
        break;
    }
void ProtocolPreferencesMenu::disableProtocolTriggered()
    EnabledProtocolsModel::disableProtocol(protocol_);
void ProtocolPreferencesMenu::modulePreferencesTriggered()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                connect(epa, SIGNAL(triggered(bool)), this, SLOT(enumPreferenceTriggered()));
                enum_valp++;
            }
        }
        break;
}
void Singleton::f2();{
    unsigned int changed_flags = module_->prefs_changed_flags;
    prefs_apply(module_);
    prefs_main_write();
    if (changed_flags & PREF_EFFECT_FIELDS) {
        wsApp->emitAppSignal(WiresharkApplication::FieldsChanged);
}
void Singleton::f3();{
    EditorPreferenceAction(pref_t *pref, QObject *parent=0) :
        QAction(parent),
        pref_(pref)
    {
        QString title = prefs_get_title(pref_);
}
void Singleton::f4();{
        break;
    }
void ProtocolPreferencesMenu::disableProtocolTriggered()
    EnabledProtocolsModel::disableProtocol(protocol_);
void ProtocolPreferencesMenu::modulePreferencesTriggered()
}
void Singleton::f5();{
void ProtocolPreferencesMenu::addMenuItem(preference *pref)
    switch (prefs_get_type(pref)) {
    case PREF_BOOL:
    {
        BoolPreferenceAction *bpa = new BoolPreferenceAction(pref, this);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                connect(epa, SIGNAL(triggered(bool)), this, SLOT(enumPreferenceTriggered()));
                enum_valp++;
            }
        }
        break;
}
void Singleton::f2();{
    unsigned int changed_flags = module_->prefs_changed_flags;
    prefs_apply(module_);
    prefs_main_write();
    if (changed_flags & PREF_EFFECT_FIELDS) {
        wsApp->emitAppSignal(WiresharkApplication::FieldsChanged);
}
void Singleton::f3();{
    EditorPreferenceAction(pref_t *pref, QObject *parent=0) :
        QAction(parent),
        pref_(pref)
    {
        QString title = prefs_get_title(pref_);
}
void Singleton::f4();{
        break;
    }
void ProtocolPreferencesMenu::disableProtocolTriggered()
    EnabledProtocolsModel::disableProtocol(protocol_);
void ProtocolPreferencesMenu::modulePreferencesTriggered()
}
void Singleton::f5();{
void ProtocolPreferencesMenu::addMenuItem(preference *pref)
    switch (prefs_get_type(pref)) {
    case PREF_BOOL:
    {
        BoolPreferenceAction *bpa = new BoolPreferenceAction(pref, this);
}
void Singleton::f6();{
    }
    case PREF_CUSTOM:
    case PREF_STATIC_TEXT:
    case PREF_OBSOLETE:
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                connect(epa, SIGNAL(triggered(bool)), this, SLOT(enumPreferenceTriggered()));
                enum_valp++;
            }
        }
        break;
}
void Singleton::f2();{
    unsigned int changed_flags = module_->prefs_changed_flags;
    prefs_apply(module_);
    prefs_main_write();
    if (changed_flags & PREF_EFFECT_FIELDS) {
        wsApp->emitAppSignal(WiresharkApplication::FieldsChanged);
}
void Singleton::f3();{
    EditorPreferenceAction(pref_t *pref, QObject *parent=0) :
        QAction(parent),
        pref_(pref)
    {
        QString title = prefs_get_title(pref_);
}
void Singleton::f4();{
        break;
    }
void ProtocolPreferencesMenu::disableProtocolTriggered()
    EnabledProtocolsModel::disableProtocol(protocol_);
void ProtocolPreferencesMenu::modulePreferencesTriggered()
}
void Singleton::f5();{
void ProtocolPreferencesMenu::addMenuItem(preference *pref)
    switch (prefs_get_type(pref)) {
    case PREF_BOOL:
    {
        BoolPreferenceAction *bpa = new BoolPreferenceAction(pref, this);
}
void Singleton::f6();{
    }
    case PREF_CUSTOM:
    case PREF_STATIC_TEXT:
    case PREF_OBSOLETE:
        break;
}
void Singleton::f7();{
        emit showProtocolPreferences(module_name_);
    }
void ProtocolPreferencesMenu::editorPreferenceTriggered()
    EditorPreferenceAction *epa = static_cast<EditorPreferenceAction *>(QObject::sender());
    if (!epa) return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                connect(epa, SIGNAL(triggered(bool)), this, SLOT(enumPreferenceTriggered()));
                enum_valp++;
            }
        }
        break;
}
void Singleton::f2();{
    unsigned int changed_flags = module_->prefs_changed_flags;
    prefs_apply(module_);
    prefs_main_write();
    if (changed_flags & PREF_EFFECT_FIELDS) {
        wsApp->emitAppSignal(WiresharkApplication::FieldsChanged);
}
void Singleton::f3();{
    EditorPreferenceAction(pref_t *pref, QObject *parent=0) :
        QAction(parent),
        pref_(pref)
    {
        QString title = prefs_get_title(pref_);
}
void Singleton::f4();{
        break;
    }
void ProtocolPreferencesMenu::disableProtocolTriggered()
    EnabledProtocolsModel::disableProtocol(protocol_);
void ProtocolPreferencesMenu::modulePreferencesTriggered()
}
void Singleton::f5();{
void ProtocolPreferencesMenu::addMenuItem(preference *pref)
    switch (prefs_get_type(pref)) {
    case PREF_BOOL:
    {
        BoolPreferenceAction *bpa = new BoolPreferenceAction(pref, this);
}
void Singleton::f6();{
    }
    case PREF_CUSTOM:
    case PREF_STATIC_TEXT:
    case PREF_OBSOLETE:
        break;
}
void Singleton::f7();{
        emit showProtocolPreferences(module_name_);
    }
void ProtocolPreferencesMenu::editorPreferenceTriggered()
    EditorPreferenceAction *epa = static_cast<EditorPreferenceAction *>(QObject::sender());
    if (!epa) return;
}
void Singleton::f8();{
        BoolPreferenceAction *bpa = new BoolPreferenceAction(pref, this);
        addAction(bpa);
        connect(bpa, SIGNAL(triggered(bool)), this, SLOT(boolPreferenceTriggered()));
        break;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                connect(epa, SIGNAL(triggered(bool)), this, SLOT(enumPreferenceTriggered()));
                enum_valp++;
            }
        }
        break;
}
void Singleton::f2();{
    unsigned int changed_flags = module_->prefs_changed_flags;
    prefs_apply(module_);
    prefs_main_write();
    if (changed_flags & PREF_EFFECT_FIELDS) {
        wsApp->emitAppSignal(WiresharkApplication::FieldsChanged);
}
void Singleton::f3();{
    EditorPreferenceAction(pref_t *pref, QObject *parent=0) :
        QAction(parent),
        pref_(pref)
    {
        QString title = prefs_get_title(pref_);
}
void Singleton::f4();{
        break;
    }
void ProtocolPreferencesMenu::disableProtocolTriggered()
    EnabledProtocolsModel::disableProtocol(protocol_);
void ProtocolPreferencesMenu::modulePreferencesTriggered()
}
void Singleton::f5();{
void ProtocolPreferencesMenu::addMenuItem(preference *pref)
    switch (prefs_get_type(pref)) {
    case PREF_BOOL:
    {
        BoolPreferenceAction *bpa = new BoolPreferenceAction(pref, this);
}
void Singleton::f6();{
    }
    case PREF_CUSTOM:
    case PREF_STATIC_TEXT:
    case PREF_OBSOLETE:
        break;
}
void Singleton::f7();{
        emit showProtocolPreferences(module_name_);
    }
void ProtocolPreferencesMenu::editorPreferenceTriggered()
    EditorPreferenceAction *epa = static_cast<EditorPreferenceAction *>(QObject::sender());
    if (!epa) return;
}
void Singleton::f8();{
        BoolPreferenceAction *bpa = new BoolPreferenceAction(pref, this);
        addAction(bpa);
        connect(bpa, SIGNAL(triggered(bool)), this, SLOT(boolPreferenceTriggered()));
        break;
    }
}
void Singleton::f9();{
    connect(action, SIGNAL(triggered(bool)), this, SLOT(modulePreferencesTriggered()));
    addSeparator();
    prefs_pref_foreach(module_, add_prefs_menu_item, this);
    if (!actions().last()->isSeparator()) {
        addSeparator();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    field_info *fi = PNODE_FINFO(node_);
    if (!fi) {
        return QString();
    }
    QString label;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    field_info *fi = PNODE_FINFO(node_);
    if (!fi) {
        return QString();
    }
    QString label;
}
void Singleton::f2();{
ProtoNode ProtoNode::ChildIterator::element()
    return ProtoNode(node);
bool ProtoNode::isHidden(proto_node * node)
    return PROTO_ITEM_IS_HIDDEN(node) && !prefs.display_hidden_proto_items;
 * Editor modelines
}
void Singleton::f3();{
ProtoNode::ChildIterator ProtoNode::children() const
    proto_node *child = node_->first_child;
    while (child && isHidden(child)) {
        child = child->next;
    }
}
void Singleton::f4();{
    node_(node)
bool ProtoNode::isValid() const
    return node_;
bool ProtoNode::isChild() const
    return node_ && node_->parent;
}
void Singleton::f5();{
    node = n;
bool ProtoNode::ChildIterator::hasNext()
    if (! node || node->next == Q_NULLPTR)
        return false;
    return true;
}
void Singleton::f6();{
    return node_ && node_->parent;
ProtoNode ProtoNode::parentNode()
    if (node_) {
        return ProtoNode(node_->parent);
    }
}
void Singleton::f7();{
    // Generated takes precedence.
    if (proto_item_is_generated(node_)) {
        label.prepend("[");
        label.append("]");
    }
}
void Singleton::f8();{
        return -1;
    }
    int cur_row = 0;
    ProtoNode::ChildIterator kids = parentNode().children();
    while (kids.element().isValid())
}
void Singleton::f9();{
    return ProtoNode::ChildIterator(child);
ProtoNode::ChildIterator::ChildIterator(ProtoNode::ChildIterator::NodePtr n)
    node = n;
bool ProtoNode::ChildIterator::hasNext()
    if (! node || node->next == Q_NULLPTR)
}
void Singleton::f10();{
int ProtoNode::row()
    if (!isChild()) {
        return -1;
    }
    int cur_row = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    field_info *fi = PNODE_FINFO(node_);
    if (!fi) {
        return QString();
    }
    QString label;
}
void Singleton::f2();{
ProtoNode ProtoNode::ChildIterator::element()
    return ProtoNode(node);
bool ProtoNode::isHidden(proto_node * node)
    return PROTO_ITEM_IS_HIDDEN(node) && !prefs.display_hidden_proto_items;
 * Editor modelines
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    field_info *fi = PNODE_FINFO(node_);
    if (!fi) {
        return QString();
    }
    QString label;
}
void Singleton::f2();{
ProtoNode ProtoNode::ChildIterator::element()
    return ProtoNode(node);
bool ProtoNode::isHidden(proto_node * node)
    return PROTO_ITEM_IS_HIDDEN(node) && !prefs.display_hidden_proto_items;
 * Editor modelines
}
void Singleton::f3();{
ProtoNode::ChildIterator ProtoNode::children() const
    proto_node *child = node_->first_child;
    while (child && isHidden(child)) {
        child = child->next;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    field_info *fi = PNODE_FINFO(node_);
    if (!fi) {
        return QString();
    }
    QString label;
}
void Singleton::f2();{
ProtoNode ProtoNode::ChildIterator::element()
    return ProtoNode(node);
bool ProtoNode::isHidden(proto_node * node)
    return PROTO_ITEM_IS_HIDDEN(node) && !prefs.display_hidden_proto_items;
 * Editor modelines
}
void Singleton::f3();{
ProtoNode::ChildIterator ProtoNode::children() const
    proto_node *child = node_->first_child;
    while (child && isHidden(child)) {
        child = child->next;
    }
}
void Singleton::f4();{
    node_(node)
bool ProtoNode::isValid() const
    return node_;
bool ProtoNode::isChild() const
    return node_ && node_->parent;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    field_info *fi = PNODE_FINFO(node_);
    if (!fi) {
        return QString();
    }
    QString label;
}
void Singleton::f2();{
ProtoNode ProtoNode::ChildIterator::element()
    return ProtoNode(node);
bool ProtoNode::isHidden(proto_node * node)
    return PROTO_ITEM_IS_HIDDEN(node) && !prefs.display_hidden_proto_items;
 * Editor modelines
}
void Singleton::f3();{
ProtoNode::ChildIterator ProtoNode::children() const
    proto_node *child = node_->first_child;
    while (child && isHidden(child)) {
        child = child->next;
    }
}
void Singleton::f4();{
    node_(node)
bool ProtoNode::isValid() const
    return node_;
bool ProtoNode::isChild() const
    return node_ && node_->parent;
}
void Singleton::f5();{
    node = n;
bool ProtoNode::ChildIterator::hasNext()
    if (! node || node->next == Q_NULLPTR)
        return false;
    return true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    field_info *fi = PNODE_FINFO(node_);
    if (!fi) {
        return QString();
    }
    QString label;
}
void Singleton::f2();{
ProtoNode ProtoNode::ChildIterator::element()
    return ProtoNode(node);
bool ProtoNode::isHidden(proto_node * node)
    return PROTO_ITEM_IS_HIDDEN(node) && !prefs.display_hidden_proto_items;
 * Editor modelines
}
void Singleton::f3();{
ProtoNode::ChildIterator ProtoNode::children() const
    proto_node *child = node_->first_child;
    while (child && isHidden(child)) {
        child = child->next;
    }
}
void Singleton::f4();{
    node_(node)
bool ProtoNode::isValid() const
    return node_;
bool ProtoNode::isChild() const
    return node_ && node_->parent;
}
void Singleton::f5();{
    node = n;
bool ProtoNode::ChildIterator::hasNext()
    if (! node || node->next == Q_NULLPTR)
        return false;
    return true;
}
void Singleton::f6();{
    return node_ && node_->parent;
ProtoNode ProtoNode::parentNode()
    if (node_) {
        return ProtoNode(node_->parent);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    field_info *fi = PNODE_FINFO(node_);
    if (!fi) {
        return QString();
    }
    QString label;
}
void Singleton::f2();{
ProtoNode ProtoNode::ChildIterator::element()
    return ProtoNode(node);
bool ProtoNode::isHidden(proto_node * node)
    return PROTO_ITEM_IS_HIDDEN(node) && !prefs.display_hidden_proto_items;
 * Editor modelines
}
void Singleton::f3();{
ProtoNode::ChildIterator ProtoNode::children() const
    proto_node *child = node_->first_child;
    while (child && isHidden(child)) {
        child = child->next;
    }
}
void Singleton::f4();{
    node_(node)
bool ProtoNode::isValid() const
    return node_;
bool ProtoNode::isChild() const
    return node_ && node_->parent;
}
void Singleton::f5();{
    node = n;
bool ProtoNode::ChildIterator::hasNext()
    if (! node || node->next == Q_NULLPTR)
        return false;
    return true;
}
void Singleton::f6();{
    return node_ && node_->parent;
ProtoNode ProtoNode::parentNode()
    if (node_) {
        return ProtoNode(node_->parent);
    }
}
void Singleton::f7();{
    // Generated takes precedence.
    if (proto_item_is_generated(node_)) {
        label.prepend("[");
        label.append("]");
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    field_info *fi = PNODE_FINFO(node_);
    if (!fi) {
        return QString();
    }
    QString label;
}
void Singleton::f2();{
ProtoNode ProtoNode::ChildIterator::element()
    return ProtoNode(node);
bool ProtoNode::isHidden(proto_node * node)
    return PROTO_ITEM_IS_HIDDEN(node) && !prefs.display_hidden_proto_items;
 * Editor modelines
}
void Singleton::f3();{
ProtoNode::ChildIterator ProtoNode::children() const
    proto_node *child = node_->first_child;
    while (child && isHidden(child)) {
        child = child->next;
    }
}
void Singleton::f4();{
    node_(node)
bool ProtoNode::isValid() const
    return node_;
bool ProtoNode::isChild() const
    return node_ && node_->parent;
}
void Singleton::f5();{
    node = n;
bool ProtoNode::ChildIterator::hasNext()
    if (! node || node->next == Q_NULLPTR)
        return false;
    return true;
}
void Singleton::f6();{
    return node_ && node_->parent;
ProtoNode ProtoNode::parentNode()
    if (node_) {
        return ProtoNode(node_->parent);
    }
}
void Singleton::f7();{
    // Generated takes precedence.
    if (proto_item_is_generated(node_)) {
        label.prepend("[");
        label.append("]");
    }
}
void Singleton::f8();{
        return -1;
    }
    int cur_row = 0;
    ProtoNode::ChildIterator kids = parentNode().children();
    while (kids.element().isValid())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    field_info *fi = PNODE_FINFO(node_);
    if (!fi) {
        return QString();
    }
    QString label;
}
void Singleton::f2();{
ProtoNode ProtoNode::ChildIterator::element()
    return ProtoNode(node);
bool ProtoNode::isHidden(proto_node * node)
    return PROTO_ITEM_IS_HIDDEN(node) && !prefs.display_hidden_proto_items;
 * Editor modelines
}
void Singleton::f3();{
ProtoNode::ChildIterator ProtoNode::children() const
    proto_node *child = node_->first_child;
    while (child && isHidden(child)) {
        child = child->next;
    }
}
void Singleton::f4();{
    node_(node)
bool ProtoNode::isValid() const
    return node_;
bool ProtoNode::isChild() const
    return node_ && node_->parent;
}
void Singleton::f5();{
    node = n;
bool ProtoNode::ChildIterator::hasNext()
    if (! node || node->next == Q_NULLPTR)
        return false;
    return true;
}
void Singleton::f6();{
    return node_ && node_->parent;
ProtoNode ProtoNode::parentNode()
    if (node_) {
        return ProtoNode(node_->parent);
    }
}
void Singleton::f7();{
    // Generated takes precedence.
    if (proto_item_is_generated(node_)) {
        label.prepend("[");
        label.append("]");
    }
}
void Singleton::f8();{
        return -1;
    }
    int cur_row = 0;
    ProtoNode::ChildIterator kids = parentNode().children();
    while (kids.element().isValid())
}
void Singleton::f9();{
    return ProtoNode::ChildIterator(child);
ProtoNode::ChildIterator::ChildIterator(ProtoNode::ChildIterator::NodePtr n)
    node = n;
bool ProtoNode::ChildIterator::hasNext()
    if (! node || node->next == Q_NULLPTR)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    // similar to PacketListModel::data.
    setHeaderHidden(true);
    QPalette default_pal = QApplication::palette();
    default_pal.setCurrentColorGroup(QPalette::Active);
    QColor hover_color = default_pal.highlight().color();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    // similar to PacketListModel::data.
    setHeaderHidden(true);
    QPalette default_pal = QApplication::palette();
    default_pal.setCurrentColorGroup(QPalette::Active);
    QColor hover_color = default_pal.highlight().color();
}
void Singleton::f2();{
    case ProtoTree::Name:
        clip.append(finfo.headerInfo().abbreviation);
        break;
    case ProtoTree::Description:
        clip = idx.data(Qt::DisplayRole).toString();
}
void Singleton::f3();{
// setRootNode sets the new contents for the protocol tree and subsequently
// restores the previously expanded state.
void ProtoTree::setRootNode(proto_node *root_node) {
    // We track item expansion using proto.c:tree_is_expanded.
    // Replace any existing (possibly invalidated) proto tree by the new tree.
}
void Singleton::f4();{
        action = window()->findChild<QAction *>("actionAnalyzeShowPacketBytes");
        ctx_menu.addAction(action);
        action = window()->findChild<QAction *>("actionFileExportPacketBytes");
        ctx_menu.addAction(action);
        ctx_menu.addSeparator();
}
void Singleton::f5();{
        FieldInformation finfo(proto_tree_model_->protoNodeFromIndex(index).protoNode());
        if (finfo.isValid()) {
            emit fieldSelected(&finfo);
        }
    }
}
void Singleton::f6();{
        FieldInformation pref_finfo(node);
        proto_prefs_menu_.setModule(pref_finfo.moduleName());
    }
    ctx_menu.exec(event->globalPos());
void ProtoTree::timerEvent(QTimerEvent *event)
}
void Singleton::f7();{
    emit relatedFrame(related_frame, framenum_type);
void ProtoTree::autoScrollTo(const QModelIndex &index)
    selectionModel()->setCurrentIndex(index, QItemSelectionModel::ClearAndSelect);
    if (!index.isValid()) {
        return;
}
void Singleton::f8();{
            QModelIndex child = proto_tree_model_->index(row, 0, index);
            if (proto_tree_model_->hasChildren(child)) {
                index_stack.push(child);
            }
        }
}
void Singleton::f9();{
        }
    }
    autoScrollTo(cur_index);
QString ProtoTree::traverseTree(const QModelIndex & travTree, int identLevel) const
    QString result = "";
}
void Singleton::f10();{
                    QPixmap pixmap(content->size() * dpr);
                    pixmap.setDevicePixelRatio(dpr);
                    content->render(&pixmap);
                    drag->setPixmap(pixmap);
                    drag->exec(Qt::CopyAction);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    // similar to PacketListModel::data.
    setHeaderHidden(true);
    QPalette default_pal = QApplication::palette();
    default_pal.setCurrentColorGroup(QPalette::Active);
    QColor hover_color = default_pal.highlight().color();
}
void Singleton::f2();{
    case ProtoTree::Name:
        clip.append(finfo.headerInfo().abbreviation);
        break;
    case ProtoTree::Description:
        clip = idx.data(Qt::DisplayRole).toString();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    // similar to PacketListModel::data.
    setHeaderHidden(true);
    QPalette default_pal = QApplication::palette();
    default_pal.setCurrentColorGroup(QPalette::Active);
    QColor hover_color = default_pal.highlight().color();
}
void Singleton::f2();{
    case ProtoTree::Name:
        clip.append(finfo.headerInfo().abbreviation);
        break;
    case ProtoTree::Description:
        clip = idx.data(Qt::DisplayRole).toString();
}
void Singleton::f3();{
// setRootNode sets the new contents for the protocol tree and subsequently
// restores the previously expanded state.
void ProtoTree::setRootNode(proto_node *root_node) {
    // We track item expansion using proto.c:tree_is_expanded.
    // Replace any existing (possibly invalidated) proto tree by the new tree.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    // similar to PacketListModel::data.
    setHeaderHidden(true);
    QPalette default_pal = QApplication::palette();
    default_pal.setCurrentColorGroup(QPalette::Active);
    QColor hover_color = default_pal.highlight().color();
}
void Singleton::f2();{
    case ProtoTree::Name:
        clip.append(finfo.headerInfo().abbreviation);
        break;
    case ProtoTree::Description:
        clip = idx.data(Qt::DisplayRole).toString();
}
void Singleton::f3();{
// setRootNode sets the new contents for the protocol tree and subsequently
// restores the previously expanded state.
void ProtoTree::setRootNode(proto_node *root_node) {
    // We track item expansion using proto.c:tree_is_expanded.
    // Replace any existing (possibly invalidated) proto tree by the new tree.
}
void Singleton::f4();{
        action = window()->findChild<QAction *>("actionAnalyzeShowPacketBytes");
        ctx_menu.addAction(action);
        action = window()->findChild<QAction *>("actionFileExportPacketBytes");
        ctx_menu.addAction(action);
        ctx_menu.addSeparator();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    // similar to PacketListModel::data.
    setHeaderHidden(true);
    QPalette default_pal = QApplication::palette();
    default_pal.setCurrentColorGroup(QPalette::Active);
    QColor hover_color = default_pal.highlight().color();
}
void Singleton::f2();{
    case ProtoTree::Name:
        clip.append(finfo.headerInfo().abbreviation);
        break;
    case ProtoTree::Description:
        clip = idx.data(Qt::DisplayRole).toString();
}
void Singleton::f3();{
// setRootNode sets the new contents for the protocol tree and subsequently
// restores the previously expanded state.
void ProtoTree::setRootNode(proto_node *root_node) {
    // We track item expansion using proto.c:tree_is_expanded.
    // Replace any existing (possibly invalidated) proto tree by the new tree.
}
void Singleton::f4();{
        action = window()->findChild<QAction *>("actionAnalyzeShowPacketBytes");
        ctx_menu.addAction(action);
        action = window()->findChild<QAction *>("actionFileExportPacketBytes");
        ctx_menu.addAction(action);
        ctx_menu.addSeparator();
}
void Singleton::f5();{
        FieldInformation finfo(proto_tree_model_->protoNodeFromIndex(index).protoNode());
        if (finfo.isValid()) {
            emit fieldSelected(&finfo);
        }
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    // similar to PacketListModel::data.
    setHeaderHidden(true);
    QPalette default_pal = QApplication::palette();
    default_pal.setCurrentColorGroup(QPalette::Active);
    QColor hover_color = default_pal.highlight().color();
}
void Singleton::f2();{
    case ProtoTree::Name:
        clip.append(finfo.headerInfo().abbreviation);
        break;
    case ProtoTree::Description:
        clip = idx.data(Qt::DisplayRole).toString();
}
void Singleton::f3();{
// setRootNode sets the new contents for the protocol tree and subsequently
// restores the previously expanded state.
void ProtoTree::setRootNode(proto_node *root_node) {
    // We track item expansion using proto.c:tree_is_expanded.
    // Replace any existing (possibly invalidated) proto tree by the new tree.
}
void Singleton::f4();{
        action = window()->findChild<QAction *>("actionAnalyzeShowPacketBytes");
        ctx_menu.addAction(action);
        action = window()->findChild<QAction *>("actionFileExportPacketBytes");
        ctx_menu.addAction(action);
        ctx_menu.addSeparator();
}
void Singleton::f5();{
        FieldInformation finfo(proto_tree_model_->protoNodeFromIndex(index).protoNode());
        if (finfo.isValid()) {
            emit fieldSelected(&finfo);
        }
    }
}
void Singleton::f6();{
        FieldInformation pref_finfo(node);
        proto_prefs_menu_.setModule(pref_finfo.moduleName());
    }
    ctx_menu.exec(event->globalPos());
void ProtoTree::timerEvent(QTimerEvent *event)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    // similar to PacketListModel::data.
    setHeaderHidden(true);
    QPalette default_pal = QApplication::palette();
    default_pal.setCurrentColorGroup(QPalette::Active);
    QColor hover_color = default_pal.highlight().color();
}
void Singleton::f2();{
    case ProtoTree::Name:
        clip.append(finfo.headerInfo().abbreviation);
        break;
    case ProtoTree::Description:
        clip = idx.data(Qt::DisplayRole).toString();
}
void Singleton::f3();{
// setRootNode sets the new contents for the protocol tree and subsequently
// restores the previously expanded state.
void ProtoTree::setRootNode(proto_node *root_node) {
    // We track item expansion using proto.c:tree_is_expanded.
    // Replace any existing (possibly invalidated) proto tree by the new tree.
}
void Singleton::f4();{
        action = window()->findChild<QAction *>("actionAnalyzeShowPacketBytes");
        ctx_menu.addAction(action);
        action = window()->findChild<QAction *>("actionFileExportPacketBytes");
        ctx_menu.addAction(action);
        ctx_menu.addSeparator();
}
void Singleton::f5();{
        FieldInformation finfo(proto_tree_model_->protoNodeFromIndex(index).protoNode());
        if (finfo.isValid()) {
            emit fieldSelected(&finfo);
        }
    }
}
void Singleton::f6();{
        FieldInformation pref_finfo(node);
        proto_prefs_menu_.setModule(pref_finfo.moduleName());
    }
    ctx_menu.exec(event->globalPos());
void ProtoTree::timerEvent(QTimerEvent *event)
}
void Singleton::f7();{
    emit relatedFrame(related_frame, framenum_type);
void ProtoTree::autoScrollTo(const QModelIndex &index)
    selectionModel()->setCurrentIndex(index, QItemSelectionModel::ClearAndSelect);
    if (!index.isValid()) {
        return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    // similar to PacketListModel::data.
    setHeaderHidden(true);
    QPalette default_pal = QApplication::palette();
    default_pal.setCurrentColorGroup(QPalette::Active);
    QColor hover_color = default_pal.highlight().color();
}
void Singleton::f2();{
    case ProtoTree::Name:
        clip.append(finfo.headerInfo().abbreviation);
        break;
    case ProtoTree::Description:
        clip = idx.data(Qt::DisplayRole).toString();
}
void Singleton::f3();{
// setRootNode sets the new contents for the protocol tree and subsequently
// restores the previously expanded state.
void ProtoTree::setRootNode(proto_node *root_node) {
    // We track item expansion using proto.c:tree_is_expanded.
    // Replace any existing (possibly invalidated) proto tree by the new tree.
}
void Singleton::f4();{
        action = window()->findChild<QAction *>("actionAnalyzeShowPacketBytes");
        ctx_menu.addAction(action);
        action = window()->findChild<QAction *>("actionFileExportPacketBytes");
        ctx_menu.addAction(action);
        ctx_menu.addSeparator();
}
void Singleton::f5();{
        FieldInformation finfo(proto_tree_model_->protoNodeFromIndex(index).protoNode());
        if (finfo.isValid()) {
            emit fieldSelected(&finfo);
        }
    }
}
void Singleton::f6();{
        FieldInformation pref_finfo(node);
        proto_prefs_menu_.setModule(pref_finfo.moduleName());
    }
    ctx_menu.exec(event->globalPos());
void ProtoTree::timerEvent(QTimerEvent *event)
}
void Singleton::f7();{
    emit relatedFrame(related_frame, framenum_type);
void ProtoTree::autoScrollTo(const QModelIndex &index)
    selectionModel()->setCurrentIndex(index, QItemSelectionModel::ClearAndSelect);
    if (!index.isValid()) {
        return;
}
void Singleton::f8();{
            QModelIndex child = proto_tree_model_->index(row, 0, index);
            if (proto_tree_model_->hasChildren(child)) {
                index_stack.push(child);
            }
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    // similar to PacketListModel::data.
    setHeaderHidden(true);
    QPalette default_pal = QApplication::palette();
    default_pal.setCurrentColorGroup(QPalette::Active);
    QColor hover_color = default_pal.highlight().color();
}
void Singleton::f2();{
    case ProtoTree::Name:
        clip.append(finfo.headerInfo().abbreviation);
        break;
    case ProtoTree::Description:
        clip = idx.data(Qt::DisplayRole).toString();
}
void Singleton::f3();{
// setRootNode sets the new contents for the protocol tree and subsequently
// restores the previously expanded state.
void ProtoTree::setRootNode(proto_node *root_node) {
    // We track item expansion using proto.c:tree_is_expanded.
    // Replace any existing (possibly invalidated) proto tree by the new tree.
}
void Singleton::f4();{
        action = window()->findChild<QAction *>("actionAnalyzeShowPacketBytes");
        ctx_menu.addAction(action);
        action = window()->findChild<QAction *>("actionFileExportPacketBytes");
        ctx_menu.addAction(action);
        ctx_menu.addSeparator();
}
void Singleton::f5();{
        FieldInformation finfo(proto_tree_model_->protoNodeFromIndex(index).protoNode());
        if (finfo.isValid()) {
            emit fieldSelected(&finfo);
        }
    }
}
void Singleton::f6();{
        FieldInformation pref_finfo(node);
        proto_prefs_menu_.setModule(pref_finfo.moduleName());
    }
    ctx_menu.exec(event->globalPos());
void ProtoTree::timerEvent(QTimerEvent *event)
}
void Singleton::f7();{
    emit relatedFrame(related_frame, framenum_type);
void ProtoTree::autoScrollTo(const QModelIndex &index)
    selectionModel()->setCurrentIndex(index, QItemSelectionModel::ClearAndSelect);
    if (!index.isValid()) {
        return;
}
void Singleton::f8();{
            QModelIndex child = proto_tree_model_->index(row, 0, index);
            if (proto_tree_model_->hasChildren(child)) {
                index_stack.push(child);
            }
        }
}
void Singleton::f9();{
        }
    }
    autoScrollTo(cur_index);
QString ProtoTree::traverseTree(const QModelIndex & travTree, int identLevel) const
    QString result = "";
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    proto_tree_children_foreach(node, foreachFindField, find_finfo);
QModelIndex ProtoTreeModel::findFieldInformation(FieldInformation *finfo)
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    proto_tree_children_foreach(node, foreachFindField, find_finfo);
QModelIndex ProtoTreeModel::findFieldInformation(FieldInformation *finfo)
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
}
void Singleton::f2();{
    if (!root_node_ || hf_id < 0) return QModelIndex();
    struct find_hfid_ find_hfid;
    find_hfid.hfid = hf_id;
    proto_tree_children_foreach(root_node_, foreachFindHfid, &find_hfid);
    if (find_hfid.node.isValid()) {
}
void Singleton::f3();{
            return ColorUtils::expert_color_error;
        default:
            g_warning("%s:%d Unhandled severity flag: %u", G_STRFUNC, __LINE__, finfo.flag(PI_SEVERITY_MASK));
        }
        if (finfo.headerInfo().type == FT_PROTOCOL) {
}
void Singleton::f4();{
ProtoNode ProtoTreeModel::protoNodeFromIndex(const QModelIndex &index) const
    return ProtoNode(static_cast<proto_node*>(index.internalPointer()));
QModelIndex ProtoTreeModel::indexFromProtoNode(ProtoNode &index_node) const
    int row = index_node.row();
    if (!index_node.isValid() || row < 0) {
}
void Singleton::f5();{
    if (PNODE_FINFO(node)->hfinfo->id == find_hfid->hfid) {
        find_hfid->node = ProtoNode(node);
        return;
    }
    proto_tree_children_foreach(node, foreachFindHfid, find_hfid);
}
void Singleton::f6();{
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
    struct find_field_info_ find_finfo;
    find_finfo.fi = fi;
}
void Singleton::f7();{
    endResetModel();
    if (!root_node) return;
    int row_count = ProtoNode(root_node_).childrenCount();
    if (row_count < 1) return;
    beginInsertRows(QModelIndex(), 0, row_count - 1);
}
void Singleton::f8();{
    int cur_row = 0;
    ProtoNode::ChildIterator kids = parent_node.children();
    while (kids.element().isValid())
    {
        if (cur_row == row)
}
void Singleton::f9();{
        if (cur_row == row)
            break;
        cur_row++;
        kids.next();
    }
}
void Singleton::f10();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    proto_tree_children_foreach(node, foreachFindField, find_finfo);
QModelIndex ProtoTreeModel::findFieldInformation(FieldInformation *finfo)
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
}
void Singleton::f2();{
    if (!root_node_ || hf_id < 0) return QModelIndex();
    struct find_hfid_ find_hfid;
    find_hfid.hfid = hf_id;
    proto_tree_children_foreach(root_node_, foreachFindHfid, &find_hfid);
    if (find_hfid.node.isValid()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    proto_tree_children_foreach(node, foreachFindField, find_finfo);
QModelIndex ProtoTreeModel::findFieldInformation(FieldInformation *finfo)
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
}
void Singleton::f2();{
    if (!root_node_ || hf_id < 0) return QModelIndex();
    struct find_hfid_ find_hfid;
    find_hfid.hfid = hf_id;
    proto_tree_children_foreach(root_node_, foreachFindHfid, &find_hfid);
    if (find_hfid.node.isValid()) {
}
void Singleton::f3();{
            return ColorUtils::expert_color_error;
        default:
            g_warning("%s:%d Unhandled severity flag: %u", G_STRFUNC, __LINE__, finfo.flag(PI_SEVERITY_MASK));
        }
        if (finfo.headerInfo().type == FT_PROTOCOL) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    proto_tree_children_foreach(node, foreachFindField, find_finfo);
QModelIndex ProtoTreeModel::findFieldInformation(FieldInformation *finfo)
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
}
void Singleton::f2();{
    if (!root_node_ || hf_id < 0) return QModelIndex();
    struct find_hfid_ find_hfid;
    find_hfid.hfid = hf_id;
    proto_tree_children_foreach(root_node_, foreachFindHfid, &find_hfid);
    if (find_hfid.node.isValid()) {
}
void Singleton::f3();{
            return ColorUtils::expert_color_error;
        default:
            g_warning("%s:%d Unhandled severity flag: %u", G_STRFUNC, __LINE__, finfo.flag(PI_SEVERITY_MASK));
        }
        if (finfo.headerInfo().type == FT_PROTOCOL) {
}
void Singleton::f4();{
ProtoNode ProtoTreeModel::protoNodeFromIndex(const QModelIndex &index) const
    return ProtoNode(static_cast<proto_node*>(index.internalPointer()));
QModelIndex ProtoTreeModel::indexFromProtoNode(ProtoNode &index_node) const
    int row = index_node.row();
    if (!index_node.isValid() || row < 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    proto_tree_children_foreach(node, foreachFindField, find_finfo);
QModelIndex ProtoTreeModel::findFieldInformation(FieldInformation *finfo)
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
}
void Singleton::f2();{
    if (!root_node_ || hf_id < 0) return QModelIndex();
    struct find_hfid_ find_hfid;
    find_hfid.hfid = hf_id;
    proto_tree_children_foreach(root_node_, foreachFindHfid, &find_hfid);
    if (find_hfid.node.isValid()) {
}
void Singleton::f3();{
            return ColorUtils::expert_color_error;
        default:
            g_warning("%s:%d Unhandled severity flag: %u", G_STRFUNC, __LINE__, finfo.flag(PI_SEVERITY_MASK));
        }
        if (finfo.headerInfo().type == FT_PROTOCOL) {
}
void Singleton::f4();{
ProtoNode ProtoTreeModel::protoNodeFromIndex(const QModelIndex &index) const
    return ProtoNode(static_cast<proto_node*>(index.internalPointer()));
QModelIndex ProtoTreeModel::indexFromProtoNode(ProtoNode &index_node) const
    int row = index_node.row();
    if (!index_node.isValid() || row < 0) {
}
void Singleton::f5();{
    if (PNODE_FINFO(node)->hfinfo->id == find_hfid->hfid) {
        find_hfid->node = ProtoNode(node);
        return;
    }
    proto_tree_children_foreach(node, foreachFindHfid, find_hfid);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    proto_tree_children_foreach(node, foreachFindField, find_finfo);
QModelIndex ProtoTreeModel::findFieldInformation(FieldInformation *finfo)
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
}
void Singleton::f2();{
    if (!root_node_ || hf_id < 0) return QModelIndex();
    struct find_hfid_ find_hfid;
    find_hfid.hfid = hf_id;
    proto_tree_children_foreach(root_node_, foreachFindHfid, &find_hfid);
    if (find_hfid.node.isValid()) {
}
void Singleton::f3();{
            return ColorUtils::expert_color_error;
        default:
            g_warning("%s:%d Unhandled severity flag: %u", G_STRFUNC, __LINE__, finfo.flag(PI_SEVERITY_MASK));
        }
        if (finfo.headerInfo().type == FT_PROTOCOL) {
}
void Singleton::f4();{
ProtoNode ProtoTreeModel::protoNodeFromIndex(const QModelIndex &index) const
    return ProtoNode(static_cast<proto_node*>(index.internalPointer()));
QModelIndex ProtoTreeModel::indexFromProtoNode(ProtoNode &index_node) const
    int row = index_node.row();
    if (!index_node.isValid() || row < 0) {
}
void Singleton::f5();{
    if (PNODE_FINFO(node)->hfinfo->id == find_hfid->hfid) {
        find_hfid->node = ProtoNode(node);
        return;
    }
    proto_tree_children_foreach(node, foreachFindHfid, find_hfid);
}
void Singleton::f6();{
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
    struct find_field_info_ find_finfo;
    find_finfo.fi = fi;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    proto_tree_children_foreach(node, foreachFindField, find_finfo);
QModelIndex ProtoTreeModel::findFieldInformation(FieldInformation *finfo)
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
}
void Singleton::f2();{
    if (!root_node_ || hf_id < 0) return QModelIndex();
    struct find_hfid_ find_hfid;
    find_hfid.hfid = hf_id;
    proto_tree_children_foreach(root_node_, foreachFindHfid, &find_hfid);
    if (find_hfid.node.isValid()) {
}
void Singleton::f3();{
            return ColorUtils::expert_color_error;
        default:
            g_warning("%s:%d Unhandled severity flag: %u", G_STRFUNC, __LINE__, finfo.flag(PI_SEVERITY_MASK));
        }
        if (finfo.headerInfo().type == FT_PROTOCOL) {
}
void Singleton::f4();{
ProtoNode ProtoTreeModel::protoNodeFromIndex(const QModelIndex &index) const
    return ProtoNode(static_cast<proto_node*>(index.internalPointer()));
QModelIndex ProtoTreeModel::indexFromProtoNode(ProtoNode &index_node) const
    int row = index_node.row();
    if (!index_node.isValid() || row < 0) {
}
void Singleton::f5();{
    if (PNODE_FINFO(node)->hfinfo->id == find_hfid->hfid) {
        find_hfid->node = ProtoNode(node);
        return;
    }
    proto_tree_children_foreach(node, foreachFindHfid, find_hfid);
}
void Singleton::f6();{
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
    struct find_field_info_ find_finfo;
    find_finfo.fi = fi;
}
void Singleton::f7();{
    endResetModel();
    if (!root_node) return;
    int row_count = ProtoNode(root_node_).childrenCount();
    if (row_count < 1) return;
    beginInsertRows(QModelIndex(), 0, row_count - 1);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    proto_tree_children_foreach(node, foreachFindField, find_finfo);
QModelIndex ProtoTreeModel::findFieldInformation(FieldInformation *finfo)
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
}
void Singleton::f2();{
    if (!root_node_ || hf_id < 0) return QModelIndex();
    struct find_hfid_ find_hfid;
    find_hfid.hfid = hf_id;
    proto_tree_children_foreach(root_node_, foreachFindHfid, &find_hfid);
    if (find_hfid.node.isValid()) {
}
void Singleton::f3();{
            return ColorUtils::expert_color_error;
        default:
            g_warning("%s:%d Unhandled severity flag: %u", G_STRFUNC, __LINE__, finfo.flag(PI_SEVERITY_MASK));
        }
        if (finfo.headerInfo().type == FT_PROTOCOL) {
}
void Singleton::f4();{
ProtoNode ProtoTreeModel::protoNodeFromIndex(const QModelIndex &index) const
    return ProtoNode(static_cast<proto_node*>(index.internalPointer()));
QModelIndex ProtoTreeModel::indexFromProtoNode(ProtoNode &index_node) const
    int row = index_node.row();
    if (!index_node.isValid() || row < 0) {
}
void Singleton::f5();{
    if (PNODE_FINFO(node)->hfinfo->id == find_hfid->hfid) {
        find_hfid->node = ProtoNode(node);
        return;
    }
    proto_tree_children_foreach(node, foreachFindHfid, find_hfid);
}
void Singleton::f6();{
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
    struct find_field_info_ find_finfo;
    find_finfo.fi = fi;
}
void Singleton::f7();{
    endResetModel();
    if (!root_node) return;
    int row_count = ProtoNode(root_node_).childrenCount();
    if (row_count < 1) return;
    beginInsertRows(QModelIndex(), 0, row_count - 1);
}
void Singleton::f8();{
    int cur_row = 0;
    ProtoNode::ChildIterator kids = parent_node.children();
    while (kids.element().isValid())
    {
        if (cur_row == row)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    proto_tree_children_foreach(node, foreachFindField, find_finfo);
QModelIndex ProtoTreeModel::findFieldInformation(FieldInformation *finfo)
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
}
void Singleton::f2();{
    if (!root_node_ || hf_id < 0) return QModelIndex();
    struct find_hfid_ find_hfid;
    find_hfid.hfid = hf_id;
    proto_tree_children_foreach(root_node_, foreachFindHfid, &find_hfid);
    if (find_hfid.node.isValid()) {
}
void Singleton::f3();{
            return ColorUtils::expert_color_error;
        default:
            g_warning("%s:%d Unhandled severity flag: %u", G_STRFUNC, __LINE__, finfo.flag(PI_SEVERITY_MASK));
        }
        if (finfo.headerInfo().type == FT_PROTOCOL) {
}
void Singleton::f4();{
ProtoNode ProtoTreeModel::protoNodeFromIndex(const QModelIndex &index) const
    return ProtoNode(static_cast<proto_node*>(index.internalPointer()));
QModelIndex ProtoTreeModel::indexFromProtoNode(ProtoNode &index_node) const
    int row = index_node.row();
    if (!index_node.isValid() || row < 0) {
}
void Singleton::f5();{
    if (PNODE_FINFO(node)->hfinfo->id == find_hfid->hfid) {
        find_hfid->node = ProtoNode(node);
        return;
    }
    proto_tree_children_foreach(node, foreachFindHfid, find_hfid);
}
void Singleton::f6();{
    if (!root_node_ || !finfo) return QModelIndex();
    field_info * fi = finfo->fieldInfo();
    if (!fi) return QModelIndex();
    struct find_field_info_ find_finfo;
    find_finfo.fi = fi;
}
void Singleton::f7();{
    endResetModel();
    if (!root_node) return;
    int row_count = ProtoNode(root_node_).childrenCount();
    if (row_count < 1) return;
    beginInsertRows(QModelIndex(), 0, row_count - 1);
}
void Singleton::f8();{
    int cur_row = 0;
    ProtoNode::ChildIterator kids = parent_node.children();
    while (kids.element().isValid())
    {
        if (cur_row == row)
}
void Singleton::f9();{
        if (cur_row == row)
            break;
        cur_row++;
        kids.next();
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
  \seebaseclassmethod
double QCPAxisTickerLog::getTickStep(const QCPRange &range)
  // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method
  Q_UNUSED(range)
  return 1.0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
  \seebaseclassmethod
double QCPAxisTickerLog::getTickStep(const QCPRange &range)
  // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method
  Q_UNUSED(range)
  return 1.0;
}
void Singleton::f2();{
  [multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot.
  If instead a cross should be shown (as is usual in the USA), the third char of \a formatCode can
  be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the
  cross and 183 (0xB7) for the dot.
  Examples for \a formatCode:
}
void Singleton::f3();{
  Returns true if the element was added successfully, i.e. if the cell at \a row and \a column
  didn't already have an element.
  Use the overload of this method without explicit row/column index to place the element according
  to the configured fill order and wrapping settings.
  \see element, hasElement, take, remove
}
void Singleton::f4();{
  If a pixmap was provided via \ref setBackground, this function buffers the scaled version
  depending on \ref setBackgroundScaled and \ref setBackgroundScaledMode and then draws it inside
  the viewport with the provided \a painter. The scaled version is buffered in
  mScaledBackgroundPixmap to prevent expensive rescaling at every redraw. It is only updated, when
  the axis rect has changed in a way that requires a rescale of the background pixmap (this is
}
void Singleton::f5();{
  QBrush brushBackup = painter->brush();
  QPen miterPen = penBackup;
  miterPen.setJoinStyle(Qt::MiterJoin); // to make arrow heads spikey
  QBrush brush(painter->pen().color(), Qt::SolidPattern);
  switch (mStyle)
}
void Singleton::f6();{
QCPColorMapData &QCPColorMapData::operator=(const QCPColorMapData &other)
  if (&other != this)
    const int keySize = other.keySize();
    const int valueSize = other.valueSize();
    if (!other.mAlpha && mAlpha)
}
void Singleton::f7();{
      painter->setPen(mPenNegative);
      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.bottomRight().toPoint()));
      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));
}
void Singleton::f8();{
  if (mMapData->isEmpty()) return;
  if (!mKeyAxis || !mValueAxis) return;
  applyDefaultAntialiasingHint(painter);
  if (mMapData->mDataModified || mMapImageInvalidated)
    updateMapImage();
}
void Singleton::f9();{
      sanitizedRange.upper = -rangeFac;
    else
      sanitizedRange.upper = sanitizedRange.lower*rangeFac;
  } else if (sanitizedRange.lower < 0 && sanitizedRange.upper > 0)
    // find out whether negative or positive interval is wider to decide which sign domain will be chosen
}
void Singleton::f10();{
  Returns all axes of this axis rect.
QList<QCPAxis*> QCPAxisRect::axes() const
  QList<QCPAxis*> result;
  QHashIterator<QCPAxis::AxisType, QList<QCPAxis*> > it(mAxes);
  while (it.hasNext())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
  \seebaseclassmethod
double QCPAxisTickerLog::getTickStep(const QCPRange &range)
  // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method
  Q_UNUSED(range)
  return 1.0;
}
void Singleton::f2();{
  [multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot.
  If instead a cross should be shown (as is usual in the USA), the third char of \a formatCode can
  be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the
  cross and 183 (0xB7) for the dot.
  Examples for \a formatCode:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
  \seebaseclassmethod
double QCPAxisTickerLog::getTickStep(const QCPRange &range)
  // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method
  Q_UNUSED(range)
  return 1.0;
}
void Singleton::f2();{
  [multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot.
  If instead a cross should be shown (as is usual in the USA), the third char of \a formatCode can
  be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the
  cross and 183 (0xB7) for the dot.
  Examples for \a formatCode:
}
void Singleton::f3();{
  Returns true if the element was added successfully, i.e. if the cell at \a row and \a column
  didn't already have an element.
  Use the overload of this method without explicit row/column index to place the element according
  to the configured fill order and wrapping settings.
  \see element, hasElement, take, remove
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
  \seebaseclassmethod
double QCPAxisTickerLog::getTickStep(const QCPRange &range)
  // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method
  Q_UNUSED(range)
  return 1.0;
}
void Singleton::f2();{
  [multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot.
  If instead a cross should be shown (as is usual in the USA), the third char of \a formatCode can
  be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the
  cross and 183 (0xB7) for the dot.
  Examples for \a formatCode:
}
void Singleton::f3();{
  Returns true if the element was added successfully, i.e. if the cell at \a row and \a column
  didn't already have an element.
  Use the overload of this method without explicit row/column index to place the element according
  to the configured fill order and wrapping settings.
  \see element, hasElement, take, remove
}
void Singleton::f4();{
  If a pixmap was provided via \ref setBackground, this function buffers the scaled version
  depending on \ref setBackgroundScaled and \ref setBackgroundScaledMode and then draws it inside
  the viewport with the provided \a painter. The scaled version is buffered in
  mScaledBackgroundPixmap to prevent expensive rescaling at every redraw. It is only updated, when
  the axis rect has changed in a way that requires a rescale of the background pixmap (this is
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
  \seebaseclassmethod
double QCPAxisTickerLog::getTickStep(const QCPRange &range)
  // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method
  Q_UNUSED(range)
  return 1.0;
}
void Singleton::f2();{
  [multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot.
  If instead a cross should be shown (as is usual in the USA), the third char of \a formatCode can
  be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the
  cross and 183 (0xB7) for the dot.
  Examples for \a formatCode:
}
void Singleton::f3();{
  Returns true if the element was added successfully, i.e. if the cell at \a row and \a column
  didn't already have an element.
  Use the overload of this method without explicit row/column index to place the element according
  to the configured fill order and wrapping settings.
  \see element, hasElement, take, remove
}
void Singleton::f4();{
  If a pixmap was provided via \ref setBackground, this function buffers the scaled version
  depending on \ref setBackgroundScaled and \ref setBackgroundScaledMode and then draws it inside
  the viewport with the provided \a painter. The scaled version is buffered in
  mScaledBackgroundPixmap to prevent expensive rescaling at every redraw. It is only updated, when
  the axis rect has changed in a way that requires a rescale of the background pixmap (this is
}
void Singleton::f5();{
  QBrush brushBackup = painter->brush();
  QPen miterPen = penBackup;
  miterPen.setJoinStyle(Qt::MiterJoin); // to make arrow heads spikey
  QBrush brush(painter->pen().color(), Qt::SolidPattern);
  switch (mStyle)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
  \seebaseclassmethod
double QCPAxisTickerLog::getTickStep(const QCPRange &range)
  // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method
  Q_UNUSED(range)
  return 1.0;
}
void Singleton::f2();{
  [multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot.
  If instead a cross should be shown (as is usual in the USA), the third char of \a formatCode can
  be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the
  cross and 183 (0xB7) for the dot.
  Examples for \a formatCode:
}
void Singleton::f3();{
  Returns true if the element was added successfully, i.e. if the cell at \a row and \a column
  didn't already have an element.
  Use the overload of this method without explicit row/column index to place the element according
  to the configured fill order and wrapping settings.
  \see element, hasElement, take, remove
}
void Singleton::f4();{
  If a pixmap was provided via \ref setBackground, this function buffers the scaled version
  depending on \ref setBackgroundScaled and \ref setBackgroundScaledMode and then draws it inside
  the viewport with the provided \a painter. The scaled version is buffered in
  mScaledBackgroundPixmap to prevent expensive rescaling at every redraw. It is only updated, when
  the axis rect has changed in a way that requires a rescale of the background pixmap (this is
}
void Singleton::f5();{
  QBrush brushBackup = painter->brush();
  QPen miterPen = penBackup;
  miterPen.setJoinStyle(Qt::MiterJoin); // to make arrow heads spikey
  QBrush brush(painter->pen().color(), Qt::SolidPattern);
  switch (mStyle)
}
void Singleton::f6();{
QCPColorMapData &QCPColorMapData::operator=(const QCPColorMapData &other)
  if (&other != this)
    const int keySize = other.keySize();
    const int valueSize = other.valueSize();
    if (!other.mAlpha && mAlpha)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
  \seebaseclassmethod
double QCPAxisTickerLog::getTickStep(const QCPRange &range)
  // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method
  Q_UNUSED(range)
  return 1.0;
}
void Singleton::f2();{
  [multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot.
  If instead a cross should be shown (as is usual in the USA), the third char of \a formatCode can
  be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the
  cross and 183 (0xB7) for the dot.
  Examples for \a formatCode:
}
void Singleton::f3();{
  Returns true if the element was added successfully, i.e. if the cell at \a row and \a column
  didn't already have an element.
  Use the overload of this method without explicit row/column index to place the element according
  to the configured fill order and wrapping settings.
  \see element, hasElement, take, remove
}
void Singleton::f4();{
  If a pixmap was provided via \ref setBackground, this function buffers the scaled version
  depending on \ref setBackgroundScaled and \ref setBackgroundScaledMode and then draws it inside
  the viewport with the provided \a painter. The scaled version is buffered in
  mScaledBackgroundPixmap to prevent expensive rescaling at every redraw. It is only updated, when
  the axis rect has changed in a way that requires a rescale of the background pixmap (this is
}
void Singleton::f5();{
  QBrush brushBackup = painter->brush();
  QPen miterPen = penBackup;
  miterPen.setJoinStyle(Qt::MiterJoin); // to make arrow heads spikey
  QBrush brush(painter->pen().color(), Qt::SolidPattern);
  switch (mStyle)
}
void Singleton::f6();{
QCPColorMapData &QCPColorMapData::operator=(const QCPColorMapData &other)
  if (&other != this)
    const int keySize = other.keySize();
    const int valueSize = other.valueSize();
    if (!other.mAlpha && mAlpha)
}
void Singleton::f7();{
      painter->setPen(mPenNegative);
      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.bottomRight().toPoint()));
      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
  \seebaseclassmethod
double QCPAxisTickerLog::getTickStep(const QCPRange &range)
  // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method
  Q_UNUSED(range)
  return 1.0;
}
void Singleton::f2();{
  [multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot.
  If instead a cross should be shown (as is usual in the USA), the third char of \a formatCode can
  be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the
  cross and 183 (0xB7) for the dot.
  Examples for \a formatCode:
}
void Singleton::f3();{
  Returns true if the element was added successfully, i.e. if the cell at \a row and \a column
  didn't already have an element.
  Use the overload of this method without explicit row/column index to place the element according
  to the configured fill order and wrapping settings.
  \see element, hasElement, take, remove
}
void Singleton::f4();{
  If a pixmap was provided via \ref setBackground, this function buffers the scaled version
  depending on \ref setBackgroundScaled and \ref setBackgroundScaledMode and then draws it inside
  the viewport with the provided \a painter. The scaled version is buffered in
  mScaledBackgroundPixmap to prevent expensive rescaling at every redraw. It is only updated, when
  the axis rect has changed in a way that requires a rescale of the background pixmap (this is
}
void Singleton::f5();{
  QBrush brushBackup = painter->brush();
  QPen miterPen = penBackup;
  miterPen.setJoinStyle(Qt::MiterJoin); // to make arrow heads spikey
  QBrush brush(painter->pen().color(), Qt::SolidPattern);
  switch (mStyle)
}
void Singleton::f6();{
QCPColorMapData &QCPColorMapData::operator=(const QCPColorMapData &other)
  if (&other != this)
    const int keySize = other.keySize();
    const int valueSize = other.valueSize();
    if (!other.mAlpha && mAlpha)
}
void Singleton::f7();{
      painter->setPen(mPenNegative);
      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.bottomRight().toPoint()));
      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));
}
void Singleton::f8();{
  if (mMapData->isEmpty()) return;
  if (!mKeyAxis || !mValueAxis) return;
  applyDefaultAntialiasingHint(painter);
  if (mMapData->mDataModified || mMapImageInvalidated)
    updateMapImage();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
  \seebaseclassmethod
double QCPAxisTickerLog::getTickStep(const QCPRange &range)
  // Logarithmic axis ticker has unequal tick spacing, so doesn't need this method
  Q_UNUSED(range)
  return 1.0;
}
void Singleton::f2();{
  [multiplication sign] 10 [superscript] 9". By default, the multiplication sign is a centered dot.
  If instead a cross should be shown (as is usual in the USA), the third char of \a formatCode can
  be set to 'c'. The inserted multiplication signs are the UTF-8 characters 215 (0xD7) for the
  cross and 183 (0xB7) for the dot.
  Examples for \a formatCode:
}
void Singleton::f3();{
  Returns true if the element was added successfully, i.e. if the cell at \a row and \a column
  didn't already have an element.
  Use the overload of this method without explicit row/column index to place the element according
  to the configured fill order and wrapping settings.
  \see element, hasElement, take, remove
}
void Singleton::f4();{
  If a pixmap was provided via \ref setBackground, this function buffers the scaled version
  depending on \ref setBackgroundScaled and \ref setBackgroundScaledMode and then draws it inside
  the viewport with the provided \a painter. The scaled version is buffered in
  mScaledBackgroundPixmap to prevent expensive rescaling at every redraw. It is only updated, when
  the axis rect has changed in a way that requires a rescale of the background pixmap (this is
}
void Singleton::f5();{
  QBrush brushBackup = painter->brush();
  QPen miterPen = penBackup;
  miterPen.setJoinStyle(Qt::MiterJoin); // to make arrow heads spikey
  QBrush brush(painter->pen().color(), Qt::SolidPattern);
  switch (mStyle)
}
void Singleton::f6();{
QCPColorMapData &QCPColorMapData::operator=(const QCPColorMapData &other)
  if (&other != this)
    const int keySize = other.keySize();
    const int valueSize = other.valueSize();
    if (!other.mAlpha && mAlpha)
}
void Singleton::f7();{
      painter->setPen(mPenNegative);
      painter->setClipRegion(QRegion(QPolygon() << rect.bottomLeft().toPoint() << rect.topRight().toPoint() << rect.bottomRight().toPoint()));
      painter->drawLine(QLineF(0, rect.height()*0.5, rect.width(), rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.2, rect.height()*0.3, rect.width()*0.2, rect.height()*0.5).translated(rect.topLeft()));
      painter->drawLine(QLineF(rect.width()*0.8, rect.height()*0.5, rect.width()*0.8, rect.height()*0.7).translated(rect.topLeft()));
}
void Singleton::f8();{
  if (mMapData->isEmpty()) return;
  if (!mKeyAxis || !mValueAxis) return;
  applyDefaultAntialiasingHint(painter);
  if (mMapData->mDataModified || mMapImageInvalidated)
    updateMapImage();
}
void Singleton::f9();{
      sanitizedRange.upper = -rangeFac;
    else
      sanitizedRange.upper = sanitizedRange.lower*rangeFac;
  } else if (sanitizedRange.lower < 0 && sanitizedRange.upper > 0)
    // find out whether negative or positive interval is wider to decide which sign domain will be chosen
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
QByteArray gchar_free_to_qbytearray(gchar *glib_string)
    QByteArray qt_bytearray(glib_string);
    g_free(glib_string);
    return qt_bytearray;
QByteArray gstring_free_to_qbytearray(GString *glib_gstring)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
QByteArray gchar_free_to_qbytearray(gchar *glib_string)
    QByteArray qt_bytearray(glib_string);
    g_free(glib_string);
    return qt_bytearray;
QByteArray gstring_free_to_qbytearray(GString *glib_gstring)
}
void Singleton::f2();{
const QString address_to_qstring(const _address *address, bool enclose)
    QString address_qstr = QString();
    if (address) {
        if (enclose && address->type == AT_IPv6) address_qstr += "[";
        gchar *address_gchar_p = address_to_str(NULL, address);
}
void Singleton::f3();{
    QStringList script_args;
    QString escaped_path = file_path;
    escaped_path.replace('"', "\\\"");
    script_args << "-e"
               << QString("tell application \"Finder\" to reveal POSIX file \"%1\"")
}
void Singleton::f4();{
// https://stackoverflow.com/questions/3490336/how-to-reveal-in-finder-or-show-in-explorer-with-qt
void desktop_show_in_folder(const QString file_path)
    bool success = false;
    QString path = QDir::toNativeSeparators(file_path);
    QStringList explorer_args = QStringList() << "/select," + path;
}
void Singleton::f5();{
        QProcess::execute("/usr/bin/osascript", script_args);
    }
    // Is there a way to highlight the file using xdg-open?
    if (!success) { // Last resort
        QFileInfo file_info = file_path;
}
void Singleton::f6();{
    if (QProcess::execute("/usr/bin/osascript", script_args) == 0) {
        success = true;
        script_args.clear();
        script_args << "-e"
                   << "tell application \"Finder\" to activate";
}
void Singleton::f7();{
    if (address) {
        gchar *address_gchar_p = address_to_display(NULL, address);
        address_qstr = address_gchar_p;
        wmem_free(NULL, address_gchar_p);
    }
}
void Singleton::f8();{
    return time_str;
QString html_escape(const QString plain_string) {
    return plain_string.toHtmlEscaped();
void smooth_font_size(QFont &font) {
    QFontDatabase fdb;
}
void Singleton::f9();{
        break;
    }
    int_qstr += QString("%1").arg(value, field_width, base, QChar('0'));
    return int_qstr;
const QString address_to_qstring(const _address *address, bool enclose)
}
void Singleton::f10();{
                format_size(bits_s, format_size_unit_none|format_size_prefix_si));
const QString file_size_to_qstring(const gint64 size)
    return gchar_free_to_qstring(
                format_size(size, format_size_unit_bytes|format_size_prefix_si));
const QString time_t_to_qstring(time_t ti_time)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
QByteArray gchar_free_to_qbytearray(gchar *glib_string)
    QByteArray qt_bytearray(glib_string);
    g_free(glib_string);
    return qt_bytearray;
QByteArray gstring_free_to_qbytearray(GString *glib_gstring)
}
void Singleton::f2();{
const QString address_to_qstring(const _address *address, bool enclose)
    QString address_qstr = QString();
    if (address) {
        if (enclose && address->type == AT_IPv6) address_qstr += "[";
        gchar *address_gchar_p = address_to_str(NULL, address);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
QByteArray gchar_free_to_qbytearray(gchar *glib_string)
    QByteArray qt_bytearray(glib_string);
    g_free(glib_string);
    return qt_bytearray;
QByteArray gstring_free_to_qbytearray(GString *glib_gstring)
}
void Singleton::f2();{
const QString address_to_qstring(const _address *address, bool enclose)
    QString address_qstr = QString();
    if (address) {
        if (enclose && address->type == AT_IPv6) address_qstr += "[";
        gchar *address_gchar_p = address_to_str(NULL, address);
}
void Singleton::f3();{
    QStringList script_args;
    QString escaped_path = file_path;
    escaped_path.replace('"', "\\\"");
    script_args << "-e"
               << QString("tell application \"Finder\" to reveal POSIX file \"%1\"")
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
QByteArray gchar_free_to_qbytearray(gchar *glib_string)
    QByteArray qt_bytearray(glib_string);
    g_free(glib_string);
    return qt_bytearray;
QByteArray gstring_free_to_qbytearray(GString *glib_gstring)
}
void Singleton::f2();{
const QString address_to_qstring(const _address *address, bool enclose)
    QString address_qstr = QString();
    if (address) {
        if (enclose && address->type == AT_IPv6) address_qstr += "[";
        gchar *address_gchar_p = address_to_str(NULL, address);
}
void Singleton::f3();{
    QStringList script_args;
    QString escaped_path = file_path;
    escaped_path.replace('"', "\\\"");
    script_args << "-e"
               << QString("tell application \"Finder\" to reveal POSIX file \"%1\"")
}
void Singleton::f4();{
// https://stackoverflow.com/questions/3490336/how-to-reveal-in-finder-or-show-in-explorer-with-qt
void desktop_show_in_folder(const QString file_path)
    bool success = false;
    QString path = QDir::toNativeSeparators(file_path);
    QStringList explorer_args = QStringList() << "/select," + path;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
QByteArray gchar_free_to_qbytearray(gchar *glib_string)
    QByteArray qt_bytearray(glib_string);
    g_free(glib_string);
    return qt_bytearray;
QByteArray gstring_free_to_qbytearray(GString *glib_gstring)
}
void Singleton::f2();{
const QString address_to_qstring(const _address *address, bool enclose)
    QString address_qstr = QString();
    if (address) {
        if (enclose && address->type == AT_IPv6) address_qstr += "[";
        gchar *address_gchar_p = address_to_str(NULL, address);
}
void Singleton::f3();{
    QStringList script_args;
    QString escaped_path = file_path;
    escaped_path.replace('"', "\\\"");
    script_args << "-e"
               << QString("tell application \"Finder\" to reveal POSIX file \"%1\"")
}
void Singleton::f4();{
// https://stackoverflow.com/questions/3490336/how-to-reveal-in-finder-or-show-in-explorer-with-qt
void desktop_show_in_folder(const QString file_path)
    bool success = false;
    QString path = QDir::toNativeSeparators(file_path);
    QStringList explorer_args = QStringList() << "/select," + path;
}
void Singleton::f5();{
        QProcess::execute("/usr/bin/osascript", script_args);
    }
    // Is there a way to highlight the file using xdg-open?
    if (!success) { // Last resort
        QFileInfo file_info = file_path;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
QByteArray gchar_free_to_qbytearray(gchar *glib_string)
    QByteArray qt_bytearray(glib_string);
    g_free(glib_string);
    return qt_bytearray;
QByteArray gstring_free_to_qbytearray(GString *glib_gstring)
}
void Singleton::f2();{
const QString address_to_qstring(const _address *address, bool enclose)
    QString address_qstr = QString();
    if (address) {
        if (enclose && address->type == AT_IPv6) address_qstr += "[";
        gchar *address_gchar_p = address_to_str(NULL, address);
}
void Singleton::f3();{
    QStringList script_args;
    QString escaped_path = file_path;
    escaped_path.replace('"', "\\\"");
    script_args << "-e"
               << QString("tell application \"Finder\" to reveal POSIX file \"%1\"")
}
void Singleton::f4();{
// https://stackoverflow.com/questions/3490336/how-to-reveal-in-finder-or-show-in-explorer-with-qt
void desktop_show_in_folder(const QString file_path)
    bool success = false;
    QString path = QDir::toNativeSeparators(file_path);
    QStringList explorer_args = QStringList() << "/select," + path;
}
void Singleton::f5();{
        QProcess::execute("/usr/bin/osascript", script_args);
    }
    // Is there a way to highlight the file using xdg-open?
    if (!success) { // Last resort
        QFileInfo file_info = file_path;
}
void Singleton::f6();{
    if (QProcess::execute("/usr/bin/osascript", script_args) == 0) {
        success = true;
        script_args.clear();
        script_args << "-e"
                   << "tell application \"Finder\" to activate";
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
QByteArray gchar_free_to_qbytearray(gchar *glib_string)
    QByteArray qt_bytearray(glib_string);
    g_free(glib_string);
    return qt_bytearray;
QByteArray gstring_free_to_qbytearray(GString *glib_gstring)
}
void Singleton::f2();{
const QString address_to_qstring(const _address *address, bool enclose)
    QString address_qstr = QString();
    if (address) {
        if (enclose && address->type == AT_IPv6) address_qstr += "[";
        gchar *address_gchar_p = address_to_str(NULL, address);
}
void Singleton::f3();{
    QStringList script_args;
    QString escaped_path = file_path;
    escaped_path.replace('"', "\\\"");
    script_args << "-e"
               << QString("tell application \"Finder\" to reveal POSIX file \"%1\"")
}
void Singleton::f4();{
// https://stackoverflow.com/questions/3490336/how-to-reveal-in-finder-or-show-in-explorer-with-qt
void desktop_show_in_folder(const QString file_path)
    bool success = false;
    QString path = QDir::toNativeSeparators(file_path);
    QStringList explorer_args = QStringList() << "/select," + path;
}
void Singleton::f5();{
        QProcess::execute("/usr/bin/osascript", script_args);
    }
    // Is there a way to highlight the file using xdg-open?
    if (!success) { // Last resort
        QFileInfo file_info = file_path;
}
void Singleton::f6();{
    if (QProcess::execute("/usr/bin/osascript", script_args) == 0) {
        success = true;
        script_args.clear();
        script_args << "-e"
                   << "tell application \"Finder\" to activate";
}
void Singleton::f7();{
    if (address) {
        gchar *address_gchar_p = address_to_display(NULL, address);
        address_qstr = address_gchar_p;
        wmem_free(NULL, address_gchar_p);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
QByteArray gchar_free_to_qbytearray(gchar *glib_string)
    QByteArray qt_bytearray(glib_string);
    g_free(glib_string);
    return qt_bytearray;
QByteArray gstring_free_to_qbytearray(GString *glib_gstring)
}
void Singleton::f2();{
const QString address_to_qstring(const _address *address, bool enclose)
    QString address_qstr = QString();
    if (address) {
        if (enclose && address->type == AT_IPv6) address_qstr += "[";
        gchar *address_gchar_p = address_to_str(NULL, address);
}
void Singleton::f3();{
    QStringList script_args;
    QString escaped_path = file_path;
    escaped_path.replace('"', "\\\"");
    script_args << "-e"
               << QString("tell application \"Finder\" to reveal POSIX file \"%1\"")
}
void Singleton::f4();{
// https://stackoverflow.com/questions/3490336/how-to-reveal-in-finder-or-show-in-explorer-with-qt
void desktop_show_in_folder(const QString file_path)
    bool success = false;
    QString path = QDir::toNativeSeparators(file_path);
    QStringList explorer_args = QStringList() << "/select," + path;
}
void Singleton::f5();{
        QProcess::execute("/usr/bin/osascript", script_args);
    }
    // Is there a way to highlight the file using xdg-open?
    if (!success) { // Last resort
        QFileInfo file_info = file_path;
}
void Singleton::f6();{
    if (QProcess::execute("/usr/bin/osascript", script_args) == 0) {
        success = true;
        script_args.clear();
        script_args << "-e"
                   << "tell application \"Finder\" to activate";
}
void Singleton::f7();{
    if (address) {
        gchar *address_gchar_p = address_to_display(NULL, address);
        address_qstr = address_gchar_p;
        wmem_free(NULL, address_gchar_p);
    }
}
void Singleton::f8();{
    return time_str;
QString html_escape(const QString plain_string) {
    return plain_string.toHtmlEscaped();
void smooth_font_size(QFont &font) {
    QFontDatabase fdb;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
QByteArray gchar_free_to_qbytearray(gchar *glib_string)
    QByteArray qt_bytearray(glib_string);
    g_free(glib_string);
    return qt_bytearray;
QByteArray gstring_free_to_qbytearray(GString *glib_gstring)
}
void Singleton::f2();{
const QString address_to_qstring(const _address *address, bool enclose)
    QString address_qstr = QString();
    if (address) {
        if (enclose && address->type == AT_IPv6) address_qstr += "[";
        gchar *address_gchar_p = address_to_str(NULL, address);
}
void Singleton::f3();{
    QStringList script_args;
    QString escaped_path = file_path;
    escaped_path.replace('"', "\\\"");
    script_args << "-e"
               << QString("tell application \"Finder\" to reveal POSIX file \"%1\"")
}
void Singleton::f4();{
// https://stackoverflow.com/questions/3490336/how-to-reveal-in-finder-or-show-in-explorer-with-qt
void desktop_show_in_folder(const QString file_path)
    bool success = false;
    QString path = QDir::toNativeSeparators(file_path);
    QStringList explorer_args = QStringList() << "/select," + path;
}
void Singleton::f5();{
        QProcess::execute("/usr/bin/osascript", script_args);
    }
    // Is there a way to highlight the file using xdg-open?
    if (!success) { // Last resort
        QFileInfo file_info = file_path;
}
void Singleton::f6();{
    if (QProcess::execute("/usr/bin/osascript", script_args) == 0) {
        success = true;
        script_args.clear();
        script_args << "-e"
                   << "tell application \"Finder\" to activate";
}
void Singleton::f7();{
    if (address) {
        gchar *address_gchar_p = address_to_display(NULL, address);
        address_qstr = address_gchar_p;
        wmem_free(NULL, address_gchar_p);
    }
}
void Singleton::f8();{
    return time_str;
QString html_escape(const QString plain_string) {
    return plain_string.toHtmlEscaped();
void smooth_font_size(QFont &font) {
    QFontDatabase fdb;
}
void Singleton::f9();{
        break;
    }
    int_qstr += QString("%1").arg(value, field_width, base, QChar('0'));
    return int_qstr;
const QString address_to_qstring(const _address *address, bool enclose)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
    foreach (ft_framenum_type_t framenum_type, related_frames_) {
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
    foreach (ft_framenum_type_t framenum_type, related_frames_) {
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
}
void Singleton::f2();{
    painter->drawLine(tail.x(), tail.y(), head.x() + (head_size * x_mul), head.y());
    painter->drawPolygon(head_points, 3);
void RelatedPacketDelegate::drawChevrons(QPainter *painter, const QPoint tail, const QPoint head, int head_size) const
    int x_mul = head.x() > tail.x() ? -1 : 1;
    QPoint head_points1[] = {
}
void Singleton::f3();{
        }
        case FT_FRAMENUM_ACK:
        {
            QRect bbox (2 - en_w, height / 3, em_w - 2, height / 2);
            drawCheckMark(painter, bbox);
}
void Singleton::f4();{
        if (mw && mw->selectedRows().count() > 1)
            return QStyledItemDelegate::sizeHint(option, index);
    }
    return QSize(option.fontMetrics.height() + QStyledItemDelegate::sizeHint(option, index).width(),
                 QStyledItemDelegate::sizeHint(option, index).height());
}
void Singleton::f5();{
    related_frames_.clear();
    current_frame_ = 0;
    conv_ = NULL;
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
}
void Singleton::f6();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    QColor fg;
}
void Singleton::f7();{
            QPoint end_line[] = {
                QPoint(en_w - 1, height / 2),
                QPoint(0, height / 2),
                QPoint(0, 0)
            };
}
void Singleton::f8();{
            painter->drawPolyline(end_line, 3);
        }
    }
    // Related packet indicator. Rightward arrow for requests, leftward
    // arrow for responses, circle for others.
}
void Singleton::f9();{
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
void RelatedPacketDelegate::addRelatedFrame(int frame_num, ft_framenum_type_t framenum_type)
    if (frame_num != -1 && !related_frames_.contains(frame_num))
        related_frames_[frame_num] = framenum_type;
}
void Singleton::f10();{
                              ? QPalette::Normal : QPalette::Disabled;
    QColor fg;
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
        cg = QPalette::Inactive;
    if (option_vi.state & QStyle::State_MouseOver) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
    foreach (ft_framenum_type_t framenum_type, related_frames_) {
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
}
void Singleton::f2();{
    painter->drawLine(tail.x(), tail.y(), head.x() + (head_size * x_mul), head.y());
    painter->drawPolygon(head_points, 3);
void RelatedPacketDelegate::drawChevrons(QPainter *painter, const QPoint tail, const QPoint head, int head_size) const
    int x_mul = head.x() > tail.x() ? -1 : 1;
    QPoint head_points1[] = {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
    foreach (ft_framenum_type_t framenum_type, related_frames_) {
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
}
void Singleton::f2();{
    painter->drawLine(tail.x(), tail.y(), head.x() + (head_size * x_mul), head.y());
    painter->drawPolygon(head_points, 3);
void RelatedPacketDelegate::drawChevrons(QPainter *painter, const QPoint tail, const QPoint head, int head_size) const
    int x_mul = head.x() > tail.x() ? -1 : 1;
    QPoint head_points1[] = {
}
void Singleton::f3();{
        }
        case FT_FRAMENUM_ACK:
        {
            QRect bbox (2 - en_w, height / 3, em_w - 2, height / 2);
            drawCheckMark(painter, bbox);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
    foreach (ft_framenum_type_t framenum_type, related_frames_) {
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
}
void Singleton::f2();{
    painter->drawLine(tail.x(), tail.y(), head.x() + (head_size * x_mul), head.y());
    painter->drawPolygon(head_points, 3);
void RelatedPacketDelegate::drawChevrons(QPainter *painter, const QPoint tail, const QPoint head, int head_size) const
    int x_mul = head.x() > tail.x() ? -1 : 1;
    QPoint head_points1[] = {
}
void Singleton::f3();{
        }
        case FT_FRAMENUM_ACK:
        {
            QRect bbox (2 - en_w, height / 3, em_w - 2, height / 2);
            drawCheckMark(painter, bbox);
}
void Singleton::f4();{
        if (mw && mw->selectedRows().count() > 1)
            return QStyledItemDelegate::sizeHint(option, index);
    }
    return QSize(option.fontMetrics.height() + QStyledItemDelegate::sizeHint(option, index).width(),
                 QStyledItemDelegate::sizeHint(option, index).height());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
    foreach (ft_framenum_type_t framenum_type, related_frames_) {
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
}
void Singleton::f2();{
    painter->drawLine(tail.x(), tail.y(), head.x() + (head_size * x_mul), head.y());
    painter->drawPolygon(head_points, 3);
void RelatedPacketDelegate::drawChevrons(QPainter *painter, const QPoint tail, const QPoint head, int head_size) const
    int x_mul = head.x() > tail.x() ? -1 : 1;
    QPoint head_points1[] = {
}
void Singleton::f3();{
        }
        case FT_FRAMENUM_ACK:
        {
            QRect bbox (2 - en_w, height / 3, em_w - 2, height / 2);
            drawCheckMark(painter, bbox);
}
void Singleton::f4();{
        if (mw && mw->selectedRows().count() > 1)
            return QStyledItemDelegate::sizeHint(option, index);
    }
    return QSize(option.fontMetrics.height() + QStyledItemDelegate::sizeHint(option, index).width(),
                 QStyledItemDelegate::sizeHint(option, index).height());
}
void Singleton::f5();{
    related_frames_.clear();
    current_frame_ = 0;
    conv_ = NULL;
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
    foreach (ft_framenum_type_t framenum_type, related_frames_) {
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
}
void Singleton::f2();{
    painter->drawLine(tail.x(), tail.y(), head.x() + (head_size * x_mul), head.y());
    painter->drawPolygon(head_points, 3);
void RelatedPacketDelegate::drawChevrons(QPainter *painter, const QPoint tail, const QPoint head, int head_size) const
    int x_mul = head.x() > tail.x() ? -1 : 1;
    QPoint head_points1[] = {
}
void Singleton::f3();{
        }
        case FT_FRAMENUM_ACK:
        {
            QRect bbox (2 - en_w, height / 3, em_w - 2, height / 2);
            drawCheckMark(painter, bbox);
}
void Singleton::f4();{
        if (mw && mw->selectedRows().count() > 1)
            return QStyledItemDelegate::sizeHint(option, index);
    }
    return QSize(option.fontMetrics.height() + QStyledItemDelegate::sizeHint(option, index).width(),
                 QStyledItemDelegate::sizeHint(option, index).height());
}
void Singleton::f5();{
    related_frames_.clear();
    current_frame_ = 0;
    conv_ = NULL;
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
}
void Singleton::f6();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    QColor fg;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
    foreach (ft_framenum_type_t framenum_type, related_frames_) {
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
}
void Singleton::f2();{
    painter->drawLine(tail.x(), tail.y(), head.x() + (head_size * x_mul), head.y());
    painter->drawPolygon(head_points, 3);
void RelatedPacketDelegate::drawChevrons(QPainter *painter, const QPoint tail, const QPoint head, int head_size) const
    int x_mul = head.x() > tail.x() ? -1 : 1;
    QPoint head_points1[] = {
}
void Singleton::f3();{
        }
        case FT_FRAMENUM_ACK:
        {
            QRect bbox (2 - en_w, height / 3, em_w - 2, height / 2);
            drawCheckMark(painter, bbox);
}
void Singleton::f4();{
        if (mw && mw->selectedRows().count() > 1)
            return QStyledItemDelegate::sizeHint(option, index);
    }
    return QSize(option.fontMetrics.height() + QStyledItemDelegate::sizeHint(option, index).width(),
                 QStyledItemDelegate::sizeHint(option, index).height());
}
void Singleton::f5();{
    related_frames_.clear();
    current_frame_ = 0;
    conv_ = NULL;
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
}
void Singleton::f6();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    QColor fg;
}
void Singleton::f7();{
            QPoint end_line[] = {
                QPoint(en_w - 1, height / 2),
                QPoint(0, height / 2),
                QPoint(0, 0)
            };
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
    foreach (ft_framenum_type_t framenum_type, related_frames_) {
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
}
void Singleton::f2();{
    painter->drawLine(tail.x(), tail.y(), head.x() + (head_size * x_mul), head.y());
    painter->drawPolygon(head_points, 3);
void RelatedPacketDelegate::drawChevrons(QPainter *painter, const QPoint tail, const QPoint head, int head_size) const
    int x_mul = head.x() > tail.x() ? -1 : 1;
    QPoint head_points1[] = {
}
void Singleton::f3();{
        }
        case FT_FRAMENUM_ACK:
        {
            QRect bbox (2 - en_w, height / 3, em_w - 2, height / 2);
            drawCheckMark(painter, bbox);
}
void Singleton::f4();{
        if (mw && mw->selectedRows().count() > 1)
            return QStyledItemDelegate::sizeHint(option, index);
    }
    return QSize(option.fontMetrics.height() + QStyledItemDelegate::sizeHint(option, index).width(),
                 QStyledItemDelegate::sizeHint(option, index).height());
}
void Singleton::f5();{
    related_frames_.clear();
    current_frame_ = 0;
    conv_ = NULL;
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
}
void Singleton::f6();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    QColor fg;
}
void Singleton::f7();{
            QPoint end_line[] = {
                QPoint(en_w - 1, height / 2),
                QPoint(0, height / 2),
                QPoint(0, 0)
            };
}
void Singleton::f8();{
            painter->drawPolyline(end_line, 3);
        }
    }
    // Related packet indicator. Rightward arrow for requests, leftward
    // arrow for responses, circle for others.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
    foreach (ft_framenum_type_t framenum_type, related_frames_) {
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
}
void Singleton::f2();{
    painter->drawLine(tail.x(), tail.y(), head.x() + (head_size * x_mul), head.y());
    painter->drawPolygon(head_points, 3);
void RelatedPacketDelegate::drawChevrons(QPainter *painter, const QPoint tail, const QPoint head, int head_size) const
    int x_mul = head.x() > tail.x() ? -1 : 1;
    QPoint head_points1[] = {
}
void Singleton::f3();{
        }
        case FT_FRAMENUM_ACK:
        {
            QRect bbox (2 - en_w, height / 3, em_w - 2, height / 2);
            drawCheckMark(painter, bbox);
}
void Singleton::f4();{
        if (mw && mw->selectedRows().count() > 1)
            return QStyledItemDelegate::sizeHint(option, index);
    }
    return QSize(option.fontMetrics.height() + QStyledItemDelegate::sizeHint(option, index).width(),
                 QStyledItemDelegate::sizeHint(option, index).height());
}
void Singleton::f5();{
    related_frames_.clear();
    current_frame_ = 0;
    conv_ = NULL;
void RelatedPacketDelegate::setCurrentFrame(guint32 current_frame)
    current_frame_ = current_frame;
}
void Singleton::f6();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    QColor fg;
}
void Singleton::f7();{
            QPoint end_line[] = {
                QPoint(en_w - 1, height / 2),
                QPoint(0, height / 2),
                QPoint(0, 0)
            };
}
void Singleton::f8();{
            painter->drawPolyline(end_line, 3);
        }
    }
    // Related packet indicator. Rightward arrow for requests, leftward
    // arrow for responses, circle for others.
}
void Singleton::f9();{
        addRelatedFrame(-1, framenum_type); /* No need to check if this element belongs to the hash... */
    }
void RelatedPacketDelegate::addRelatedFrame(int frame_num, ft_framenum_type_t framenum_type)
    if (frame_num != -1 && !related_frames_.contains(frame_num))
        related_frames_[frame_num] = framenum_type;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                                              global_remote_opts.remote_host_opts.remote_port,
                                              global_remote_opts.remote_host_opts.auth_type,
                                              global_remote_opts.remote_host_opts.auth_username,
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                                              global_remote_opts.remote_host_opts.remote_port,
                                              global_remote_opts.remote_host_opts.auth_type,
                                              global_remote_opts.remote_host_opts.auth_username,
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
}
void Singleton::f2();{
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
}
void Singleton::f3();{
    } else {
        global_remote_opts.remote_host_opts.auth_type = CAPTURE_AUTH_NULL;
    }
    QString user = ui->userText->text();
    global_remote_opts.remote_host_opts.auth_username = qstring_strdup(user);
}
void Singleton::f4();{
        rh->remote_port = qstring_strdup(port);
        rh->auth_type = global_remote_opts.remote_host_opts.auth_type;
        rh->auth_password = g_strdup("");
        rh->auth_username = g_strdup("");
        recent_add_remote_host(global_remote_opts.remote_host_opts.remote_host, rh);
}
void Singleton::f5();{
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
    if (rlist == NULL) {
        if (err == 0)
            QMessageBox::warning(this, tr("Error"), tr("No remote interfaces found."));
}
void Singleton::f6();{
    }
void RemoteCaptureDialog::apply_remote()
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
}
void Singleton::f7();{
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
    global_remote_opts.remote_host_opts.remote_host = qstring_strdup(host);
}
void Singleton::f8();{
        ui->hostCombo->insertItem(0, host);
    }
    struct remote_host *rh = recent_get_remote_host(host.toUtf8().constData());
    if (!rh) {
        rh = (struct remote_host *)g_malloc (sizeof (*rh));
}
void Singleton::f9();{
    global_remote_opts.remote_host_opts.auth_username = qstring_strdup(user);
    QString pw = ui->pwText->text();
    global_remote_opts.remote_host_opts.auth_password = qstring_strdup(pw);
    global_remote_opts.remote_host_opts.datatx_udp  = FALSE;
    global_remote_opts.remote_host_opts.nocap_rpcap = TRUE;
}
void Singleton::f10();{
void RemoteCaptureDialog::fillComboBox()
    int remote_host_list_size;
    ui->hostCombo->addItem(QString(""));
    remote_host_list_size = recent_get_remote_host_list_size();
    if (remote_host_list_size > 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                                              global_remote_opts.remote_host_opts.remote_port,
                                              global_remote_opts.remote_host_opts.auth_type,
                                              global_remote_opts.remote_host_opts.auth_username,
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
}
void Singleton::f2();{
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                                              global_remote_opts.remote_host_opts.remote_port,
                                              global_remote_opts.remote_host_opts.auth_type,
                                              global_remote_opts.remote_host_opts.auth_username,
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
}
void Singleton::f2();{
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
}
void Singleton::f3();{
    } else {
        global_remote_opts.remote_host_opts.auth_type = CAPTURE_AUTH_NULL;
    }
    QString user = ui->userText->text();
    global_remote_opts.remote_host_opts.auth_username = qstring_strdup(user);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                                              global_remote_opts.remote_host_opts.remote_port,
                                              global_remote_opts.remote_host_opts.auth_type,
                                              global_remote_opts.remote_host_opts.auth_username,
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
}
void Singleton::f2();{
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
}
void Singleton::f3();{
    } else {
        global_remote_opts.remote_host_opts.auth_type = CAPTURE_AUTH_NULL;
    }
    QString user = ui->userText->text();
    global_remote_opts.remote_host_opts.auth_username = qstring_strdup(user);
}
void Singleton::f4();{
        rh->remote_port = qstring_strdup(port);
        rh->auth_type = global_remote_opts.remote_host_opts.auth_type;
        rh->auth_password = g_strdup("");
        rh->auth_username = g_strdup("");
        recent_add_remote_host(global_remote_opts.remote_host_opts.remote_host, rh);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                                              global_remote_opts.remote_host_opts.remote_port,
                                              global_remote_opts.remote_host_opts.auth_type,
                                              global_remote_opts.remote_host_opts.auth_username,
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
}
void Singleton::f2();{
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
}
void Singleton::f3();{
    } else {
        global_remote_opts.remote_host_opts.auth_type = CAPTURE_AUTH_NULL;
    }
    QString user = ui->userText->text();
    global_remote_opts.remote_host_opts.auth_username = qstring_strdup(user);
}
void Singleton::f4();{
        rh->remote_port = qstring_strdup(port);
        rh->auth_type = global_remote_opts.remote_host_opts.auth_type;
        rh->auth_password = g_strdup("");
        rh->auth_username = g_strdup("");
        recent_add_remote_host(global_remote_opts.remote_host_opts.remote_host, rh);
}
void Singleton::f5();{
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
    if (rlist == NULL) {
        if (err == 0)
            QMessageBox::warning(this, tr("Error"), tr("No remote interfaces found."));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                                              global_remote_opts.remote_host_opts.remote_port,
                                              global_remote_opts.remote_host_opts.auth_type,
                                              global_remote_opts.remote_host_opts.auth_username,
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
}
void Singleton::f2();{
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
}
void Singleton::f3();{
    } else {
        global_remote_opts.remote_host_opts.auth_type = CAPTURE_AUTH_NULL;
    }
    QString user = ui->userText->text();
    global_remote_opts.remote_host_opts.auth_username = qstring_strdup(user);
}
void Singleton::f4();{
        rh->remote_port = qstring_strdup(port);
        rh->auth_type = global_remote_opts.remote_host_opts.auth_type;
        rh->auth_password = g_strdup("");
        rh->auth_username = g_strdup("");
        recent_add_remote_host(global_remote_opts.remote_host_opts.remote_host, rh);
}
void Singleton::f5();{
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
    if (rlist == NULL) {
        if (err == 0)
            QMessageBox::warning(this, tr("Error"), tr("No remote interfaces found."));
}
void Singleton::f6();{
    }
void RemoteCaptureDialog::apply_remote()
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                                              global_remote_opts.remote_host_opts.remote_port,
                                              global_remote_opts.remote_host_opts.auth_type,
                                              global_remote_opts.remote_host_opts.auth_username,
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
}
void Singleton::f2();{
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
}
void Singleton::f3();{
    } else {
        global_remote_opts.remote_host_opts.auth_type = CAPTURE_AUTH_NULL;
    }
    QString user = ui->userText->text();
    global_remote_opts.remote_host_opts.auth_username = qstring_strdup(user);
}
void Singleton::f4();{
        rh->remote_port = qstring_strdup(port);
        rh->auth_type = global_remote_opts.remote_host_opts.auth_type;
        rh->auth_password = g_strdup("");
        rh->auth_username = g_strdup("");
        recent_add_remote_host(global_remote_opts.remote_host_opts.remote_host, rh);
}
void Singleton::f5();{
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
    if (rlist == NULL) {
        if (err == 0)
            QMessageBox::warning(this, tr("Error"), tr("No remote interfaces found."));
}
void Singleton::f6();{
    }
void RemoteCaptureDialog::apply_remote()
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
}
void Singleton::f7();{
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
    global_remote_opts.remote_host_opts.remote_host = qstring_strdup(host);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                                              global_remote_opts.remote_host_opts.remote_port,
                                              global_remote_opts.remote_host_opts.auth_type,
                                              global_remote_opts.remote_host_opts.auth_username,
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
}
void Singleton::f2();{
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
}
void Singleton::f3();{
    } else {
        global_remote_opts.remote_host_opts.auth_type = CAPTURE_AUTH_NULL;
    }
    QString user = ui->userText->text();
    global_remote_opts.remote_host_opts.auth_username = qstring_strdup(user);
}
void Singleton::f4();{
        rh->remote_port = qstring_strdup(port);
        rh->auth_type = global_remote_opts.remote_host_opts.auth_type;
        rh->auth_password = g_strdup("");
        rh->auth_username = g_strdup("");
        recent_add_remote_host(global_remote_opts.remote_host_opts.remote_host, rh);
}
void Singleton::f5();{
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
    if (rlist == NULL) {
        if (err == 0)
            QMessageBox::warning(this, tr("Error"), tr("No remote interfaces found."));
}
void Singleton::f6();{
    }
void RemoteCaptureDialog::apply_remote()
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
}
void Singleton::f7();{
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
    global_remote_opts.remote_host_opts.remote_host = qstring_strdup(host);
}
void Singleton::f8();{
        ui->hostCombo->insertItem(0, host);
    }
    struct remote_host *rh = recent_get_remote_host(host.toUtf8().constData());
    if (!rh) {
        rh = (struct remote_host *)g_malloc (sizeof (*rh));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                                              global_remote_opts.remote_host_opts.remote_port,
                                              global_remote_opts.remote_host_opts.auth_type,
                                              global_remote_opts.remote_host_opts.auth_username,
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
}
void Singleton::f2();{
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
}
void Singleton::f3();{
    } else {
        global_remote_opts.remote_host_opts.auth_type = CAPTURE_AUTH_NULL;
    }
    QString user = ui->userText->text();
    global_remote_opts.remote_host_opts.auth_username = qstring_strdup(user);
}
void Singleton::f4();{
        rh->remote_port = qstring_strdup(port);
        rh->auth_type = global_remote_opts.remote_host_opts.auth_type;
        rh->auth_password = g_strdup("");
        rh->auth_username = g_strdup("");
        recent_add_remote_host(global_remote_opts.remote_host_opts.remote_host, rh);
}
void Singleton::f5();{
                                              global_remote_opts.remote_host_opts.auth_password,
                                              &err, &err_str);
    if (rlist == NULL) {
        if (err == 0)
            QMessageBox::warning(this, tr("Error"), tr("No remote interfaces found."));
}
void Singleton::f6();{
    }
void RemoteCaptureDialog::apply_remote()
    int err;
    gchar *err_str;
    remote_options global_remote_opts;
}
void Singleton::f7();{
    gchar *err_str;
    remote_options global_remote_opts;
    QString host = ui->hostCombo->currentText();
    global_remote_opts.src_type = CAPTURE_IFREMOTE;
    global_remote_opts.remote_host_opts.remote_host = qstring_strdup(host);
}
void Singleton::f8();{
        ui->hostCombo->insertItem(0, host);
    }
    struct remote_host *rh = recent_get_remote_host(host.toUtf8().constData());
    if (!rh) {
        rh = (struct remote_host *)g_malloc (sizeof (*rh));
}
void Singleton::f9();{
    global_remote_opts.remote_host_opts.auth_username = qstring_strdup(user);
    QString pw = ui->pwText->text();
    global_remote_opts.remote_host_opts.auth_password = qstring_strdup(pw);
    global_remote_opts.remote_host_opts.datatx_udp  = FALSE;
    global_remote_opts.remote_host_opts.nocap_rpcap = TRUE;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        filter.clear();
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterNone, 0);
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        filter.clear();
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterNone, 0);
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
}
void Singleton::f2();{
    portTypeModel->setColumnToFilter(2);
    ui->tblPorts->setModel(portTypeModel);
    ui->tblPorts->resizeColumnsToContents();
    ui->tblPorts->horizontalHeader()->setStretchLastSection(true);
    ui->tblPorts->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f3();{
    portSortModel->setColumnAsNumeric(1);
    portSortModel->setColumnToFilter(0);
    portSortModel->setColumnToFilter(1);
    portSortModel->setFilterCaseSensitivity(Qt::CaseInsensitive);
    portTypeModel->setSourceModel(portSortModel);
}
void Singleton::f4();{
            char *str;
            /*
                * XXX - support multiple comments.
                */
            if (wtap_block_get_nth_string_option_value(nrb_hdr, OPT_COMMENT, 0, &str) == WTAP_OPTTYPE_SUCCESS) {
}
void Singleton::f5();{
    ethTypeModel->setColumnToHide(0);
    ui->tblAddresses->setModel(ethTypeModel);
    ui->tblAddresses->resizeColumnsToContents();
    ui->tblAddresses->horizontalHeader()->setStretchLastSection(true);
    ui->tblAddresses->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f6();{
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
    ethTypeModel->setFilter(filter);
void ResolvedAddressesDialog::on_txtSearchFilter_textChanged(QString)
}
void Singleton::f7();{
            char *str;
            /*
                * XXX - support multiple comments.
                */
            if (wtap_block_get_nth_string_option_value(nrb_hdr, OPT_COMMENT, 0, &str) == WTAP_OPTTYPE_SUCCESS) {
}
void Singleton::f8();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f9();{
    ethTypeModel->setSourceModel(ethSortModel);
    ethTypeModel->setColumnToFilter(0);
    ethTypeModel->setColumnToHide(0);
    ui->tblAddresses->setModel(ethTypeModel);
    ui->tblAddresses->resizeColumnsToContents();
}
void Singleton::f10();{
    ethTypeModel->setColumnToHide(0);
    ui->tblAddresses->setModel(ethTypeModel);
    ui->tblAddresses->resizeColumnsToContents();
    ui->tblAddresses->horizontalHeader()->setStretchLastSection(true);
    ui->tblAddresses->sortByColumn(1, Qt::AscendingOrder);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        filter.clear();
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterNone, 0);
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
}
void Singleton::f2();{
    portTypeModel->setColumnToFilter(2);
    ui->tblPorts->setModel(portTypeModel);
    ui->tblPorts->resizeColumnsToContents();
    ui->tblPorts->horizontalHeader()->setStretchLastSection(true);
    ui->tblPorts->sortByColumn(1, Qt::AscendingOrder);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        filter.clear();
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterNone, 0);
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
}
void Singleton::f2();{
    portTypeModel->setColumnToFilter(2);
    ui->tblPorts->setModel(portTypeModel);
    ui->tblPorts->resizeColumnsToContents();
    ui->tblPorts->horizontalHeader()->setStretchLastSection(true);
    ui->tblPorts->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f3();{
    portSortModel->setColumnAsNumeric(1);
    portSortModel->setColumnToFilter(0);
    portSortModel->setColumnToFilter(1);
    portSortModel->setFilterCaseSensitivity(Qt::CaseInsensitive);
    portTypeModel->setSourceModel(portSortModel);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        filter.clear();
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterNone, 0);
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
}
void Singleton::f2();{
    portTypeModel->setColumnToFilter(2);
    ui->tblPorts->setModel(portTypeModel);
    ui->tblPorts->resizeColumnsToContents();
    ui->tblPorts->horizontalHeader()->setStretchLastSection(true);
    ui->tblPorts->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f3();{
    portSortModel->setColumnAsNumeric(1);
    portSortModel->setColumnToFilter(0);
    portSortModel->setColumnToFilter(1);
    portSortModel->setFilterCaseSensitivity(Qt::CaseInsensitive);
    portTypeModel->setSourceModel(portSortModel);
}
void Singleton::f4();{
            char *str;
            /*
                * XXX - support multiple comments.
                */
            if (wtap_block_get_nth_string_option_value(nrb_hdr, OPT_COMMENT, 0, &str) == WTAP_OPTTYPE_SUCCESS) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        filter.clear();
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterNone, 0);
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
}
void Singleton::f2();{
    portTypeModel->setColumnToFilter(2);
    ui->tblPorts->setModel(portTypeModel);
    ui->tblPorts->resizeColumnsToContents();
    ui->tblPorts->horizontalHeader()->setStretchLastSection(true);
    ui->tblPorts->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f3();{
    portSortModel->setColumnAsNumeric(1);
    portSortModel->setColumnToFilter(0);
    portSortModel->setColumnToFilter(1);
    portSortModel->setFilterCaseSensitivity(Qt::CaseInsensitive);
    portTypeModel->setSourceModel(portSortModel);
}
void Singleton::f4();{
            char *str;
            /*
                * XXX - support multiple comments.
                */
            if (wtap_block_get_nth_string_option_value(nrb_hdr, OPT_COMMENT, 0, &str) == WTAP_OPTTYPE_SUCCESS) {
}
void Singleton::f5();{
    ethTypeModel->setColumnToHide(0);
    ui->tblAddresses->setModel(ethTypeModel);
    ui->tblAddresses->resizeColumnsToContents();
    ui->tblAddresses->horizontalHeader()->setStretchLastSection(true);
    ui->tblAddresses->sortByColumn(1, Qt::AscendingOrder);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        filter.clear();
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterNone, 0);
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
}
void Singleton::f2();{
    portTypeModel->setColumnToFilter(2);
    ui->tblPorts->setModel(portTypeModel);
    ui->tblPorts->resizeColumnsToContents();
    ui->tblPorts->horizontalHeader()->setStretchLastSection(true);
    ui->tblPorts->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f3();{
    portSortModel->setColumnAsNumeric(1);
    portSortModel->setColumnToFilter(0);
    portSortModel->setColumnToFilter(1);
    portSortModel->setFilterCaseSensitivity(Qt::CaseInsensitive);
    portTypeModel->setSourceModel(portSortModel);
}
void Singleton::f4();{
            char *str;
            /*
                * XXX - support multiple comments.
                */
            if (wtap_block_get_nth_string_option_value(nrb_hdr, OPT_COMMENT, 0, &str) == WTAP_OPTTYPE_SUCCESS) {
}
void Singleton::f5();{
    ethTypeModel->setColumnToHide(0);
    ui->tblAddresses->setModel(ethTypeModel);
    ui->tblAddresses->resizeColumnsToContents();
    ui->tblAddresses->horizontalHeader()->setStretchLastSection(true);
    ui->tblAddresses->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f6();{
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
    ethTypeModel->setFilter(filter);
void ResolvedAddressesDialog::on_txtSearchFilter_textChanged(QString)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        filter.clear();
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterNone, 0);
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
}
void Singleton::f2();{
    portTypeModel->setColumnToFilter(2);
    ui->tblPorts->setModel(portTypeModel);
    ui->tblPorts->resizeColumnsToContents();
    ui->tblPorts->horizontalHeader()->setStretchLastSection(true);
    ui->tblPorts->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f3();{
    portSortModel->setColumnAsNumeric(1);
    portSortModel->setColumnToFilter(0);
    portSortModel->setColumnToFilter(1);
    portSortModel->setFilterCaseSensitivity(Qt::CaseInsensitive);
    portTypeModel->setSourceModel(portSortModel);
}
void Singleton::f4();{
            char *str;
            /*
                * XXX - support multiple comments.
                */
            if (wtap_block_get_nth_string_option_value(nrb_hdr, OPT_COMMENT, 0, &str) == WTAP_OPTTYPE_SUCCESS) {
}
void Singleton::f5();{
    ethTypeModel->setColumnToHide(0);
    ui->tblAddresses->setModel(ethTypeModel);
    ui->tblAddresses->resizeColumnsToContents();
    ui->tblAddresses->horizontalHeader()->setStretchLastSection(true);
    ui->tblAddresses->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f6();{
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
    ethTypeModel->setFilter(filter);
void ResolvedAddressesDialog::on_txtSearchFilter_textChanged(QString)
}
void Singleton::f7();{
            char *str;
            /*
                * XXX - support multiple comments.
                */
            if (wtap_block_get_nth_string_option_value(nrb_hdr, OPT_COMMENT, 0, &str) == WTAP_OPTTYPE_SUCCESS) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        filter.clear();
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterNone, 0);
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
}
void Singleton::f2();{
    portTypeModel->setColumnToFilter(2);
    ui->tblPorts->setModel(portTypeModel);
    ui->tblPorts->resizeColumnsToContents();
    ui->tblPorts->horizontalHeader()->setStretchLastSection(true);
    ui->tblPorts->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f3();{
    portSortModel->setColumnAsNumeric(1);
    portSortModel->setColumnToFilter(0);
    portSortModel->setColumnToFilter(1);
    portSortModel->setFilterCaseSensitivity(Qt::CaseInsensitive);
    portTypeModel->setSourceModel(portSortModel);
}
void Singleton::f4();{
            char *str;
            /*
                * XXX - support multiple comments.
                */
            if (wtap_block_get_nth_string_option_value(nrb_hdr, OPT_COMMENT, 0, &str) == WTAP_OPTTYPE_SUCCESS) {
}
void Singleton::f5();{
    ethTypeModel->setColumnToHide(0);
    ui->tblAddresses->setModel(ethTypeModel);
    ui->tblAddresses->resizeColumnsToContents();
    ui->tblAddresses->horizontalHeader()->setStretchLastSection(true);
    ui->tblAddresses->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f6();{
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
    ethTypeModel->setFilter(filter);
void ResolvedAddressesDialog::on_txtSearchFilter_textChanged(QString)
}
void Singleton::f7();{
            char *str;
            /*
                * XXX - support multiple comments.
                */
            if (wtap_block_get_nth_string_option_value(nrb_hdr, OPT_COMMENT, 0, &str) == WTAP_OPTTYPE_SUCCESS) {
}
void Singleton::f8();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        filter.clear();
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterNone, 0);
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
}
void Singleton::f2();{
    portTypeModel->setColumnToFilter(2);
    ui->tblPorts->setModel(portTypeModel);
    ui->tblPorts->resizeColumnsToContents();
    ui->tblPorts->horizontalHeader()->setStretchLastSection(true);
    ui->tblPorts->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f3();{
    portSortModel->setColumnAsNumeric(1);
    portSortModel->setColumnToFilter(0);
    portSortModel->setColumnToFilter(1);
    portSortModel->setFilterCaseSensitivity(Qt::CaseInsensitive);
    portTypeModel->setSourceModel(portSortModel);
}
void Singleton::f4();{
            char *str;
            /*
                * XXX - support multiple comments.
                */
            if (wtap_block_get_nth_string_option_value(nrb_hdr, OPT_COMMENT, 0, &str) == WTAP_OPTTYPE_SUCCESS) {
}
void Singleton::f5();{
    ethTypeModel->setColumnToHide(0);
    ui->tblAddresses->setModel(ethTypeModel);
    ui->tblAddresses->resizeColumnsToContents();
    ui->tblAddresses->horizontalHeader()->setStretchLastSection(true);
    ui->tblAddresses->sortByColumn(1, Qt::AscendingOrder);
}
void Singleton::f6();{
    }
    else
        ethTypeModel->setFilterType(AStringListListSortFilterProxyModel::FilterByEquivalent, 0);
    ethTypeModel->setFilter(filter);
void ResolvedAddressesDialog::on_txtSearchFilter_textChanged(QString)
}
void Singleton::f7();{
            char *str;
            /*
                * XXX - support multiple comments.
                */
            if (wtap_block_get_nth_string_option_value(nrb_hdr, OPT_COMMENT, 0, &str) == WTAP_OPTTYPE_SUCCESS) {
}
void Singleton::f8();{
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
}
void Singleton::f9();{
    ethTypeModel->setSourceModel(ethSortModel);
    ethTypeModel->setColumnToFilter(0);
    ethTypeModel->setColumnToHide(0);
    ui->tblAddresses->setModel(ethTypeModel);
    ui->tblAddresses->resizeColumnsToContents();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
}
void Singleton::f2();{
    guint eth_as_guint = GPOINTER_TO_UINT(key);
    QString entry = QString("%1:%2:%3 %4")
            .arg((eth_as_guint >> 16 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint >>  8 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint & 0xff), 2, 16, QChar('0'))
}
void Singleton::f3();{
QStringList PortsModel::headerColumns() const
    return QStringList() << tr("Name") << tr("Port") << tr("Type");
void PortsModel::populate()
    QStringList values;
    wmem_map_t *serv_port_hashtable = get_serv_port_hashtable();
}
void Singleton::f4();{
            .arg(eth_addr[2], 2, 16, QChar('0'))
            .arg(eth_addr[3], 2, 16, QChar('0'))
            .arg(eth_addr[4], 2, 16, QChar('0'))
            .arg(eth_addr[5], 2, 16, QChar('0'))
            .arg(name);
}
void Singleton::f5();{
wka_hash_to_qstringlist(gpointer key, gpointer value, gpointer sl_ptr)
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
}
void Singleton::f6();{
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
            .arg(eth_addr[1], 2, 16, QChar('0'))
}
void Singleton::f7();{
    if (wmem_map_t *eth_hashtable = get_wka_hashtable()) {
        wmem_map_foreach(eth_hashtable, wka_hash_to_qstringlist, &values);
    }
    const QString &wka_label = tr("Ethernet Well-Known Addresses");
    foreach (const QString &line, values)
}
void Singleton::f8();{
    if (serv_port->tcp_name) entries << QString("%1 %2 tcp").arg(serv_port->tcp_name).arg(port);
    if (serv_port->udp_name) entries << QString("%1 %2 udp").arg(serv_port->udp_name).arg(port);
    if (serv_port->sctp_name) entries << QString("%1 %2 sctp").arg(serv_port->sctp_name).arg(port);
    if (serv_port->dccp_name) entries << QString("%1 %2 dccp").arg(serv_port->dccp_name).arg(port);
    if (!entries.isEmpty()) *string_list << entries.join("\n");
}
void Singleton::f9();{
manuf_hash_to_qstringlist(gpointer key, gpointer value, gpointer sl_ptr)
    QStringList *string_list = (QStringList *) sl_ptr;
    hashmanuf_t *manuf = (hashmanuf_t*)value;
    guint eth_as_guint = GPOINTER_TO_UINT(key);
    QString entry = QString("%1:%2:%3 %4")
}
void Singleton::f10();{
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
            .arg(eth_addr[1], 2, 16, QChar('0'))
            .arg(eth_addr[2], 2, 16, QChar('0'))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
}
void Singleton::f2();{
    guint eth_as_guint = GPOINTER_TO_UINT(key);
    QString entry = QString("%1:%2:%3 %4")
            .arg((eth_as_guint >> 16 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint >>  8 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint & 0xff), 2, 16, QChar('0'))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
}
void Singleton::f2();{
    guint eth_as_guint = GPOINTER_TO_UINT(key);
    QString entry = QString("%1:%2:%3 %4")
            .arg((eth_as_guint >> 16 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint >>  8 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint & 0xff), 2, 16, QChar('0'))
}
void Singleton::f3();{
QStringList PortsModel::headerColumns() const
    return QStringList() << tr("Name") << tr("Port") << tr("Type");
void PortsModel::populate()
    QStringList values;
    wmem_map_t *serv_port_hashtable = get_serv_port_hashtable();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
}
void Singleton::f2();{
    guint eth_as_guint = GPOINTER_TO_UINT(key);
    QString entry = QString("%1:%2:%3 %4")
            .arg((eth_as_guint >> 16 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint >>  8 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint & 0xff), 2, 16, QChar('0'))
}
void Singleton::f3();{
QStringList PortsModel::headerColumns() const
    return QStringList() << tr("Name") << tr("Port") << tr("Type");
void PortsModel::populate()
    QStringList values;
    wmem_map_t *serv_port_hashtable = get_serv_port_hashtable();
}
void Singleton::f4();{
            .arg(eth_addr[2], 2, 16, QChar('0'))
            .arg(eth_addr[3], 2, 16, QChar('0'))
            .arg(eth_addr[4], 2, 16, QChar('0'))
            .arg(eth_addr[5], 2, 16, QChar('0'))
            .arg(name);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
}
void Singleton::f2();{
    guint eth_as_guint = GPOINTER_TO_UINT(key);
    QString entry = QString("%1:%2:%3 %4")
            .arg((eth_as_guint >> 16 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint >>  8 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint & 0xff), 2, 16, QChar('0'))
}
void Singleton::f3();{
QStringList PortsModel::headerColumns() const
    return QStringList() << tr("Name") << tr("Port") << tr("Type");
void PortsModel::populate()
    QStringList values;
    wmem_map_t *serv_port_hashtable = get_serv_port_hashtable();
}
void Singleton::f4();{
            .arg(eth_addr[2], 2, 16, QChar('0'))
            .arg(eth_addr[3], 2, 16, QChar('0'))
            .arg(eth_addr[4], 2, 16, QChar('0'))
            .arg(eth_addr[5], 2, 16, QChar('0'))
            .arg(name);
}
void Singleton::f5();{
wka_hash_to_qstringlist(gpointer key, gpointer value, gpointer sl_ptr)
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
}
void Singleton::f2();{
    guint eth_as_guint = GPOINTER_TO_UINT(key);
    QString entry = QString("%1:%2:%3 %4")
            .arg((eth_as_guint >> 16 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint >>  8 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint & 0xff), 2, 16, QChar('0'))
}
void Singleton::f3();{
QStringList PortsModel::headerColumns() const
    return QStringList() << tr("Name") << tr("Port") << tr("Type");
void PortsModel::populate()
    QStringList values;
    wmem_map_t *serv_port_hashtable = get_serv_port_hashtable();
}
void Singleton::f4();{
            .arg(eth_addr[2], 2, 16, QChar('0'))
            .arg(eth_addr[3], 2, 16, QChar('0'))
            .arg(eth_addr[4], 2, 16, QChar('0'))
            .arg(eth_addr[5], 2, 16, QChar('0'))
            .arg(name);
}
void Singleton::f5();{
wka_hash_to_qstringlist(gpointer key, gpointer value, gpointer sl_ptr)
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
}
void Singleton::f6();{
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
            .arg(eth_addr[1], 2, 16, QChar('0'))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
}
void Singleton::f2();{
    guint eth_as_guint = GPOINTER_TO_UINT(key);
    QString entry = QString("%1:%2:%3 %4")
            .arg((eth_as_guint >> 16 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint >>  8 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint & 0xff), 2, 16, QChar('0'))
}
void Singleton::f3();{
QStringList PortsModel::headerColumns() const
    return QStringList() << tr("Name") << tr("Port") << tr("Type");
void PortsModel::populate()
    QStringList values;
    wmem_map_t *serv_port_hashtable = get_serv_port_hashtable();
}
void Singleton::f4();{
            .arg(eth_addr[2], 2, 16, QChar('0'))
            .arg(eth_addr[3], 2, 16, QChar('0'))
            .arg(eth_addr[4], 2, 16, QChar('0'))
            .arg(eth_addr[5], 2, 16, QChar('0'))
            .arg(name);
}
void Singleton::f5();{
wka_hash_to_qstringlist(gpointer key, gpointer value, gpointer sl_ptr)
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
}
void Singleton::f6();{
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
            .arg(eth_addr[1], 2, 16, QChar('0'))
}
void Singleton::f7();{
    if (wmem_map_t *eth_hashtable = get_wka_hashtable()) {
        wmem_map_foreach(eth_hashtable, wka_hash_to_qstringlist, &values);
    }
    const QString &wka_label = tr("Ethernet Well-Known Addresses");
    foreach (const QString &line, values)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
}
void Singleton::f2();{
    guint eth_as_guint = GPOINTER_TO_UINT(key);
    QString entry = QString("%1:%2:%3 %4")
            .arg((eth_as_guint >> 16 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint >>  8 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint & 0xff), 2, 16, QChar('0'))
}
void Singleton::f3();{
QStringList PortsModel::headerColumns() const
    return QStringList() << tr("Name") << tr("Port") << tr("Type");
void PortsModel::populate()
    QStringList values;
    wmem_map_t *serv_port_hashtable = get_serv_port_hashtable();
}
void Singleton::f4();{
            .arg(eth_addr[2], 2, 16, QChar('0'))
            .arg(eth_addr[3], 2, 16, QChar('0'))
            .arg(eth_addr[4], 2, 16, QChar('0'))
            .arg(eth_addr[5], 2, 16, QChar('0'))
            .arg(name);
}
void Singleton::f5();{
wka_hash_to_qstringlist(gpointer key, gpointer value, gpointer sl_ptr)
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
}
void Singleton::f6();{
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
            .arg(eth_addr[1], 2, 16, QChar('0'))
}
void Singleton::f7();{
    if (wmem_map_t *eth_hashtable = get_wka_hashtable()) {
        wmem_map_foreach(eth_hashtable, wka_hash_to_qstringlist, &values);
    }
    const QString &wka_label = tr("Ethernet Well-Known Addresses");
    foreach (const QString &line, values)
}
void Singleton::f8();{
    if (serv_port->tcp_name) entries << QString("%1 %2 tcp").arg(serv_port->tcp_name).arg(port);
    if (serv_port->udp_name) entries << QString("%1 %2 udp").arg(serv_port->udp_name).arg(port);
    if (serv_port->sctp_name) entries << QString("%1 %2 sctp").arg(serv_port->sctp_name).arg(port);
    if (serv_port->dccp_name) entries << QString("%1 %2 dccp").arg(serv_port->dccp_name).arg(port);
    if (!entries.isEmpty()) *string_list << entries.join("\n");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
}
void Singleton::f2();{
    guint eth_as_guint = GPOINTER_TO_UINT(key);
    QString entry = QString("%1:%2:%3 %4")
            .arg((eth_as_guint >> 16 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint >>  8 & 0xff), 2, 16, QChar('0'))
            .arg((eth_as_guint & 0xff), 2, 16, QChar('0'))
}
void Singleton::f3();{
QStringList PortsModel::headerColumns() const
    return QStringList() << tr("Name") << tr("Port") << tr("Type");
void PortsModel::populate()
    QStringList values;
    wmem_map_t *serv_port_hashtable = get_serv_port_hashtable();
}
void Singleton::f4();{
            .arg(eth_addr[2], 2, 16, QChar('0'))
            .arg(eth_addr[3], 2, 16, QChar('0'))
            .arg(eth_addr[4], 2, 16, QChar('0'))
            .arg(eth_addr[5], 2, 16, QChar('0'))
            .arg(name);
}
void Singleton::f5();{
wka_hash_to_qstringlist(gpointer key, gpointer value, gpointer sl_ptr)
    QStringList *string_list = (QStringList *) sl_ptr;
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
}
void Singleton::f6();{
    gchar *name = (gchar *)value;
    guint8 *eth_addr = (guint8*)key;
    QString entry = QString("%1:%2:%3:%4:%5:%6 %7")
            .arg(eth_addr[0], 2, 16, QChar('0'))
            .arg(eth_addr[1], 2, 16, QChar('0'))
}
void Singleton::f7();{
    if (wmem_map_t *eth_hashtable = get_wka_hashtable()) {
        wmem_map_foreach(eth_hashtable, wka_hash_to_qstringlist, &values);
    }
    const QString &wka_label = tr("Ethernet Well-Known Addresses");
    foreach (const QString &line, values)
}
void Singleton::f8();{
    if (serv_port->tcp_name) entries << QString("%1 %2 tcp").arg(serv_port->tcp_name).arg(port);
    if (serv_port->udp_name) entries << QString("%1 %2 udp").arg(serv_port->udp_name).arg(port);
    if (serv_port->sctp_name) entries << QString("%1 %2 sctp").arg(serv_port->sctp_name).arg(port);
    if (serv_port->dccp_name) entries << QString("%1 %2 dccp").arg(serv_port->dccp_name).arg(port);
    if (!entries.isEmpty()) *string_list << entries.join("\n");
}
void Singleton::f9();{
manuf_hash_to_qstringlist(gpointer key, gpointer value, gpointer sl_ptr)
    QStringList *string_list = (QStringList *) sl_ptr;
    hashmanuf_t *manuf = (hashmanuf_t*)value;
    guint eth_as_guint = GPOINTER_TO_UINT(key);
    QString entry = QString("%1:%2:%3 %4")
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
    void draw() {
        setText(col_messages_, QString::number(timestat_->rtd->num));
        setText(col_min_srt_, QString::number(nstime_to_sec(&timestat_->rtd->min), 'f', 6));
        setText(col_max_srt_, QString::number(nstime_to_sec(&timestat_->rtd->max), 'f', 6));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
    void draw() {
        setText(col_messages_, QString::number(timestat_->rtd->num));
        setText(col_min_srt_, QString::number(nstime_to_sec(&timestat_->rtd->min), 'f', 6));
        setText(col_max_srt_, QString::number(nstime_to_sec(&timestat_->rtd->max), 'f', 6));
}
void Singleton::f2();{
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
    statsTreeWidget()->setSortingEnabled(true);
    removeTapListeners();
    free_rtd_table(&rtd_data.stat_table);
QList<QVariant> ResponseTimeDelayDialog::treeItemData(QTreeWidgetItem *ti) const
}
void Singleton::f3();{
            << tr("Min SRT") << tr("Max SRT") << tr("Avg SRT")
            << tr("Min in Frame") << tr("Max in Frame")
            << tr("Open Requests") << tr("Discarded Responses")
            << tr("Repeated Requests") << tr("Repeated Responses");
    statsTreeWidget()->setHeaderLabels(header_names);
}
void Singleton::f4();{
    {
        if (other.type() != rtd_time_stat_type_) return QTreeWidgetItem::operator< (other);
        const RtdTimeStatTreeWidgetItem *other_row = static_cast<const RtdTimeStatTreeWidgetItem *>(&other);
        switch (treeWidget()->sortColumn()) {
        case col_messages_:
}
void Singleton::f5();{
    }
    statsTreeWidget()->setSortingEnabled(false);
    cap_file_.retapPackets();
    tapDraw(&rtd_data);
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
}
void Singleton::f6();{
    if (!rtd_dlg) return;
    reset_rtd_table(&rtdd->stat_table);
    rtd_dlg->statsTreeWidget()->clear();
    rtd_dlg->addRtdTable(&rtdd->stat_table);
void ResponseTimeDelayDialog::tapDraw(void *rtdd_ptr)
}
void Singleton::f7();{
    QList<QVariant> tid;
    if (ti->type() == rtd_time_stat_type_) {
        RtdTimeStatTreeWidgetItem *rtd_ts_ti = static_cast<RtdTimeStatTreeWidgetItem *>(ti);
        tid << rtd_ts_ti->rowData();
    }
}
void Singleton::f8();{
    }
TapParameterDialog *ResponseTimeDelayDialog::createRtdDialog(QWidget &parent, const QString cfg_str, const QString filter, CaptureFile &cf)
    if (!cfg_str_to_rtd_.contains(cfg_str)) {
        // XXX MessageBox?
        return NULL;
}
void Singleton::f9();{
    rtd_dlg->statsTreeWidget()->clear();
    rtd_dlg->addRtdTable(&rtdd->stat_table);
void ResponseTimeDelayDialog::tapDraw(void *rtdd_ptr)
    rtd_data_t *rtdd = (rtd_data_t*) rtdd_ptr;
    ResponseTimeDelayDialog *rtd_dlg = static_cast<ResponseTimeDelayDialog *>(rtdd->user_data);
}
void Singleton::f10();{
        const RtdTimeStatTreeWidgetItem *other_row = static_cast<const RtdTimeStatTreeWidgetItem *>(&other);
        switch (treeWidget()->sortColumn()) {
        case col_messages_:
            return timestat_->rtd->num < other_row->timestat_->rtd->num;
        case col_min_srt_:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
    void draw() {
        setText(col_messages_, QString::number(timestat_->rtd->num));
        setText(col_min_srt_, QString::number(nstime_to_sec(&timestat_->rtd->min), 'f', 6));
        setText(col_max_srt_, QString::number(nstime_to_sec(&timestat_->rtd->max), 'f', 6));
}
void Singleton::f2();{
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
    statsTreeWidget()->setSortingEnabled(true);
    removeTapListeners();
    free_rtd_table(&rtd_data.stat_table);
QList<QVariant> ResponseTimeDelayDialog::treeItemData(QTreeWidgetItem *ti) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
    void draw() {
        setText(col_messages_, QString::number(timestat_->rtd->num));
        setText(col_min_srt_, QString::number(nstime_to_sec(&timestat_->rtd->min), 'f', 6));
        setText(col_max_srt_, QString::number(nstime_to_sec(&timestat_->rtd->max), 'f', 6));
}
void Singleton::f2();{
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
    statsTreeWidget()->setSortingEnabled(true);
    removeTapListeners();
    free_rtd_table(&rtd_data.stat_table);
QList<QVariant> ResponseTimeDelayDialog::treeItemData(QTreeWidgetItem *ti) const
}
void Singleton::f3();{
            << tr("Min SRT") << tr("Max SRT") << tr("Avg SRT")
            << tr("Min in Frame") << tr("Max in Frame")
            << tr("Open Requests") << tr("Discarded Responses")
            << tr("Repeated Requests") << tr("Repeated Responses");
    statsTreeWidget()->setHeaderLabels(header_names);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
    void draw() {
        setText(col_messages_, QString::number(timestat_->rtd->num));
        setText(col_min_srt_, QString::number(nstime_to_sec(&timestat_->rtd->min), 'f', 6));
        setText(col_max_srt_, QString::number(nstime_to_sec(&timestat_->rtd->max), 'f', 6));
}
void Singleton::f2();{
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
    statsTreeWidget()->setSortingEnabled(true);
    removeTapListeners();
    free_rtd_table(&rtd_data.stat_table);
QList<QVariant> ResponseTimeDelayDialog::treeItemData(QTreeWidgetItem *ti) const
}
void Singleton::f3();{
            << tr("Min SRT") << tr("Max SRT") << tr("Avg SRT")
            << tr("Min in Frame") << tr("Max in Frame")
            << tr("Open Requests") << tr("Discarded Responses")
            << tr("Repeated Requests") << tr("Repeated Responses");
    statsTreeWidget()->setHeaderLabels(header_names);
}
void Singleton::f4();{
    {
        if (other.type() != rtd_time_stat_type_) return QTreeWidgetItem::operator< (other);
        const RtdTimeStatTreeWidgetItem *other_row = static_cast<const RtdTimeStatTreeWidgetItem *>(&other);
        switch (treeWidget()->sortColumn()) {
        case col_messages_:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
    void draw() {
        setText(col_messages_, QString::number(timestat_->rtd->num));
        setText(col_min_srt_, QString::number(nstime_to_sec(&timestat_->rtd->min), 'f', 6));
        setText(col_max_srt_, QString::number(nstime_to_sec(&timestat_->rtd->max), 'f', 6));
}
void Singleton::f2();{
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
    statsTreeWidget()->setSortingEnabled(true);
    removeTapListeners();
    free_rtd_table(&rtd_data.stat_table);
QList<QVariant> ResponseTimeDelayDialog::treeItemData(QTreeWidgetItem *ti) const
}
void Singleton::f3();{
            << tr("Min SRT") << tr("Max SRT") << tr("Avg SRT")
            << tr("Min in Frame") << tr("Max in Frame")
            << tr("Open Requests") << tr("Discarded Responses")
            << tr("Repeated Requests") << tr("Repeated Responses");
    statsTreeWidget()->setHeaderLabels(header_names);
}
void Singleton::f4();{
    {
        if (other.type() != rtd_time_stat_type_) return QTreeWidgetItem::operator< (other);
        const RtdTimeStatTreeWidgetItem *other_row = static_cast<const RtdTimeStatTreeWidgetItem *>(&other);
        switch (treeWidget()->sortColumn()) {
        case col_messages_:
}
void Singleton::f5();{
    }
    statsTreeWidget()->setSortingEnabled(false);
    cap_file_.retapPackets();
    tapDraw(&rtd_data);
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
    void draw() {
        setText(col_messages_, QString::number(timestat_->rtd->num));
        setText(col_min_srt_, QString::number(nstime_to_sec(&timestat_->rtd->min), 'f', 6));
        setText(col_max_srt_, QString::number(nstime_to_sec(&timestat_->rtd->max), 'f', 6));
}
void Singleton::f2();{
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
    statsTreeWidget()->setSortingEnabled(true);
    removeTapListeners();
    free_rtd_table(&rtd_data.stat_table);
QList<QVariant> ResponseTimeDelayDialog::treeItemData(QTreeWidgetItem *ti) const
}
void Singleton::f3();{
            << tr("Min SRT") << tr("Max SRT") << tr("Avg SRT")
            << tr("Min in Frame") << tr("Max in Frame")
            << tr("Open Requests") << tr("Discarded Responses")
            << tr("Repeated Requests") << tr("Repeated Responses");
    statsTreeWidget()->setHeaderLabels(header_names);
}
void Singleton::f4();{
    {
        if (other.type() != rtd_time_stat_type_) return QTreeWidgetItem::operator< (other);
        const RtdTimeStatTreeWidgetItem *other_row = static_cast<const RtdTimeStatTreeWidgetItem *>(&other);
        switch (treeWidget()->sortColumn()) {
        case col_messages_:
}
void Singleton::f5();{
    }
    statsTreeWidget()->setSortingEnabled(false);
    cap_file_.retapPackets();
    tapDraw(&rtd_data);
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
}
void Singleton::f6();{
    if (!rtd_dlg) return;
    reset_rtd_table(&rtdd->stat_table);
    rtd_dlg->statsTreeWidget()->clear();
    rtd_dlg->addRtdTable(&rtdd->stat_table);
void ResponseTimeDelayDialog::tapDraw(void *rtdd_ptr)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
    void draw() {
        setText(col_messages_, QString::number(timestat_->rtd->num));
        setText(col_min_srt_, QString::number(nstime_to_sec(&timestat_->rtd->min), 'f', 6));
        setText(col_max_srt_, QString::number(nstime_to_sec(&timestat_->rtd->max), 'f', 6));
}
void Singleton::f2();{
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
    statsTreeWidget()->setSortingEnabled(true);
    removeTapListeners();
    free_rtd_table(&rtd_data.stat_table);
QList<QVariant> ResponseTimeDelayDialog::treeItemData(QTreeWidgetItem *ti) const
}
void Singleton::f3();{
            << tr("Min SRT") << tr("Max SRT") << tr("Avg SRT")
            << tr("Min in Frame") << tr("Max in Frame")
            << tr("Open Requests") << tr("Discarded Responses")
            << tr("Repeated Requests") << tr("Repeated Responses");
    statsTreeWidget()->setHeaderLabels(header_names);
}
void Singleton::f4();{
    {
        if (other.type() != rtd_time_stat_type_) return QTreeWidgetItem::operator< (other);
        const RtdTimeStatTreeWidgetItem *other_row = static_cast<const RtdTimeStatTreeWidgetItem *>(&other);
        switch (treeWidget()->sortColumn()) {
        case col_messages_:
}
void Singleton::f5();{
    }
    statsTreeWidget()->setSortingEnabled(false);
    cap_file_.retapPackets();
    tapDraw(&rtd_data);
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
}
void Singleton::f6();{
    if (!rtd_dlg) return;
    reset_rtd_table(&rtdd->stat_table);
    rtd_dlg->statsTreeWidget()->clear();
    rtd_dlg->addRtdTable(&rtdd->stat_table);
void ResponseTimeDelayDialog::tapDraw(void *rtdd_ptr)
}
void Singleton::f7();{
    QList<QVariant> tid;
    if (ti->type() == rtd_time_stat_type_) {
        RtdTimeStatTreeWidgetItem *rtd_ts_ti = static_cast<RtdTimeStatTreeWidgetItem *>(ti);
        tid << rtd_ts_ti->rowData();
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
    void draw() {
        setText(col_messages_, QString::number(timestat_->rtd->num));
        setText(col_min_srt_, QString::number(nstime_to_sec(&timestat_->rtd->min), 'f', 6));
        setText(col_max_srt_, QString::number(nstime_to_sec(&timestat_->rtd->max), 'f', 6));
}
void Singleton::f2();{
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
    statsTreeWidget()->setSortingEnabled(true);
    removeTapListeners();
    free_rtd_table(&rtd_data.stat_table);
QList<QVariant> ResponseTimeDelayDialog::treeItemData(QTreeWidgetItem *ti) const
}
void Singleton::f3();{
            << tr("Min SRT") << tr("Max SRT") << tr("Avg SRT")
            << tr("Min in Frame") << tr("Max in Frame")
            << tr("Open Requests") << tr("Discarded Responses")
            << tr("Repeated Requests") << tr("Repeated Responses");
    statsTreeWidget()->setHeaderLabels(header_names);
}
void Singleton::f4();{
    {
        if (other.type() != rtd_time_stat_type_) return QTreeWidgetItem::operator< (other);
        const RtdTimeStatTreeWidgetItem *other_row = static_cast<const RtdTimeStatTreeWidgetItem *>(&other);
        switch (treeWidget()->sortColumn()) {
        case col_messages_:
}
void Singleton::f5();{
    }
    statsTreeWidget()->setSortingEnabled(false);
    cap_file_.retapPackets();
    tapDraw(&rtd_data);
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
}
void Singleton::f6();{
    if (!rtd_dlg) return;
    reset_rtd_table(&rtdd->stat_table);
    rtd_dlg->statsTreeWidget()->clear();
    rtd_dlg->addRtdTable(&rtdd->stat_table);
void ResponseTimeDelayDialog::tapDraw(void *rtdd_ptr)
}
void Singleton::f7();{
    QList<QVariant> tid;
    if (ti->type() == rtd_time_stat_type_) {
        RtdTimeStatTreeWidgetItem *rtd_ts_ti = static_cast<RtdTimeStatTreeWidgetItem *>(ti);
        tid << rtd_ts_ti->rowData();
    }
}
void Singleton::f8();{
    }
TapParameterDialog *ResponseTimeDelayDialog::createRtdDialog(QWidget &parent, const QString cfg_str, const QString filter, CaptureFile &cf)
    if (!cfg_str_to_rtd_.contains(cfg_str)) {
        // XXX MessageBox?
        return NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
    void draw() {
        setText(col_messages_, QString::number(timestat_->rtd->num));
        setText(col_min_srt_, QString::number(nstime_to_sec(&timestat_->rtd->min), 'f', 6));
        setText(col_max_srt_, QString::number(nstime_to_sec(&timestat_->rtd->max), 'f', 6));
}
void Singleton::f2();{
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
    statsTreeWidget()->setSortingEnabled(true);
    removeTapListeners();
    free_rtd_table(&rtd_data.stat_table);
QList<QVariant> ResponseTimeDelayDialog::treeItemData(QTreeWidgetItem *ti) const
}
void Singleton::f3();{
            << tr("Min SRT") << tr("Max SRT") << tr("Avg SRT")
            << tr("Min in Frame") << tr("Max in Frame")
            << tr("Open Requests") << tr("Discarded Responses")
            << tr("Repeated Requests") << tr("Repeated Responses");
    statsTreeWidget()->setHeaderLabels(header_names);
}
void Singleton::f4();{
    {
        if (other.type() != rtd_time_stat_type_) return QTreeWidgetItem::operator< (other);
        const RtdTimeStatTreeWidgetItem *other_row = static_cast<const RtdTimeStatTreeWidgetItem *>(&other);
        switch (treeWidget()->sortColumn()) {
        case col_messages_:
}
void Singleton::f5();{
    }
    statsTreeWidget()->setSortingEnabled(false);
    cap_file_.retapPackets();
    tapDraw(&rtd_data);
    statsTreeWidget()->sortItems(col_type_, Qt::AscendingOrder);
}
void Singleton::f6();{
    if (!rtd_dlg) return;
    reset_rtd_table(&rtdd->stat_table);
    rtd_dlg->statsTreeWidget()->clear();
    rtd_dlg->addRtdTable(&rtdd->stat_table);
void ResponseTimeDelayDialog::tapDraw(void *rtdd_ptr)
}
void Singleton::f7();{
    QList<QVariant> tid;
    if (ti->type() == rtd_time_stat_type_) {
        RtdTimeStatTreeWidgetItem *rtd_ts_ti = static_cast<RtdTimeStatTreeWidgetItem *>(ti);
        tid << rtd_ts_ti->rowData();
    }
}
void Singleton::f8();{
    }
TapParameterDialog *ResponseTimeDelayDialog::createRtdDialog(QWidget &parent, const QString cfg_str, const QString filter, CaptureFile &cf)
    if (!cfg_str_to_rtd_.contains(cfg_str)) {
        // XXX MessageBox?
        return NULL;
}
void Singleton::f9();{
    rtd_dlg->statsTreeWidget()->clear();
    rtd_dlg->addRtdTable(&rtdd->stat_table);
void ResponseTimeDelayDialog::tapDraw(void *rtdd_ptr)
    rtd_data_t *rtdd = (rtd_data_t*) rtdd_ptr;
    ResponseTimeDelayDialog *rtd_dlg = static_cast<ResponseTimeDelayDialog *>(rtdd->user_data);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    setRetapOnShow(false);
    setHint(tr("<small><i>Select a program and version and enter a filter if desired, then press Apply.</i></small>"));
    QHBoxLayout *filter_layout = filterLayout();
    program_combo_ = new QComboBox(this);
    version_combo_ = new QComboBox(this);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    setRetapOnShow(false);
    setHint(tr("<small><i>Select a program and version and enter a filter if desired, then press Apply.</i></small>"));
    QHBoxLayout *filter_layout = filterLayout();
    program_combo_ = new QComboBox(this);
    version_combo_ = new QComboBox(this);
}
void Singleton::f2();{
                  uuid.data4[0] = d4_0;
                  uuid.data4[1] = d4_1;
                  uuid.data4[2] = d4_2;
                  uuid.data4[3] = d4_3;
                  uuid.data4[4] = d4_4;
}
void Singleton::f3();{
            onc_rpc_dlg->setRpcNameAndVersion(program_name, version);
        }
    }
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
}
void Singleton::f4();{
    RpcServiceResponseTimeDialog *dce_rpc_dlg = new RpcServiceResponseTimeDialog(parent, cf, get_srt_table_by_name("dcerpc"), DceRpc, filter);
    if (have_args) {
        if (program_name.isEmpty()) {
            dce_rpc_dlg->setDceRpcUuidAndVersion(&uuid, version);
        } else {
}
void Singleton::f5();{
            program_combo_->setCurrentIndex(pi);
            for (int vi = 0; vi < version_combo_->count(); vi++) {
                if (version == (int) version_combo_->itemData(vi).toUInt()) {
                    version_combo_->setCurrentIndex(vi);
                    found = true;
}
void Singleton::f6();{
        unsigned d1, d2, d3, d4_0, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7;
        if (sscanf(args_l[0].toUtf8().constData(),
                  "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                  &d1, &d2, &d3,
                  &d4_0, &d4_1, &d4_2, &d4_3, &d4_4, &d4_5, &d4_6, &d4_7) == 11) {
}
void Singleton::f7();{
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
void RpcServiceResponseTimeDialog::addDceRpcProgram(_guid_key *key, _dcerpc_uuid_value *value)
    dce_name_to_uuid_key_.insert(value->name, key);
void RpcServiceResponseTimeDialog::addDceRpcProgramVersion(_guid_key *key)
}
void Singleton::f8();{
// - Don't assume that the user knows what programs+versions are in the
//   capture. I.e. combine this dialog with the ONC-RPC Programs dialog,
//   with two lists: programs on top, procedures on the bottom.
// - Allow the display of multiple programs and versions.
// - Expose the DCE-RPC UUIDs and ONC-RPC program numbers e.g. in an extra
}
void Singleton::f9();{
        if (!onc_name_to_program_.contains(program_name)) return;
        rpcstat_tap_data_t *otap_data = g_new0(rpcstat_tap_data_t, 1);
        otap_data->program = onc_name_to_program_[program_name];
        otap_data->prog = rpc_prog_name(otap_data->program);
        otap_data->version = (guint32) version_combo_->itemData(version_combo_->currentIndex()).toUInt();
}
void Singleton::f10();{
        // This is a loooooong list. The GTK+ UI addresses this by making
        // the program combo a tree instead of a list. We might want to add a
        // full-height list to the left of the stats tree instead.
        QStringList programs = dce_name_to_uuid_key_.keys();
        std::sort(programs.begin(), programs.end(), qStringCaseLessThan);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    setRetapOnShow(false);
    setHint(tr("<small><i>Select a program and version and enter a filter if desired, then press Apply.</i></small>"));
    QHBoxLayout *filter_layout = filterLayout();
    program_combo_ = new QComboBox(this);
    version_combo_ = new QComboBox(this);
}
void Singleton::f2();{
                  uuid.data4[0] = d4_0;
                  uuid.data4[1] = d4_1;
                  uuid.data4[2] = d4_2;
                  uuid.data4[3] = d4_3;
                  uuid.data4[4] = d4_4;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    setRetapOnShow(false);
    setHint(tr("<small><i>Select a program and version and enter a filter if desired, then press Apply.</i></small>"));
    QHBoxLayout *filter_layout = filterLayout();
    program_combo_ = new QComboBox(this);
    version_combo_ = new QComboBox(this);
}
void Singleton::f2();{
                  uuid.data4[0] = d4_0;
                  uuid.data4[1] = d4_1;
                  uuid.data4[2] = d4_2;
                  uuid.data4[3] = d4_3;
                  uuid.data4[4] = d4_4;
}
void Singleton::f3();{
            onc_rpc_dlg->setRpcNameAndVersion(program_name, version);
        }
    }
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    setRetapOnShow(false);
    setHint(tr("<small><i>Select a program and version and enter a filter if desired, then press Apply.</i></small>"));
    QHBoxLayout *filter_layout = filterLayout();
    program_combo_ = new QComboBox(this);
    version_combo_ = new QComboBox(this);
}
void Singleton::f2();{
                  uuid.data4[0] = d4_0;
                  uuid.data4[1] = d4_1;
                  uuid.data4[2] = d4_2;
                  uuid.data4[3] = d4_3;
                  uuid.data4[4] = d4_4;
}
void Singleton::f3();{
            onc_rpc_dlg->setRpcNameAndVersion(program_name, version);
        }
    }
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
}
void Singleton::f4();{
    RpcServiceResponseTimeDialog *dce_rpc_dlg = new RpcServiceResponseTimeDialog(parent, cf, get_srt_table_by_name("dcerpc"), DceRpc, filter);
    if (have_args) {
        if (program_name.isEmpty()) {
            dce_rpc_dlg->setDceRpcUuidAndVersion(&uuid, version);
        } else {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    setRetapOnShow(false);
    setHint(tr("<small><i>Select a program and version and enter a filter if desired, then press Apply.</i></small>"));
    QHBoxLayout *filter_layout = filterLayout();
    program_combo_ = new QComboBox(this);
    version_combo_ = new QComboBox(this);
}
void Singleton::f2();{
                  uuid.data4[0] = d4_0;
                  uuid.data4[1] = d4_1;
                  uuid.data4[2] = d4_2;
                  uuid.data4[3] = d4_3;
                  uuid.data4[4] = d4_4;
}
void Singleton::f3();{
            onc_rpc_dlg->setRpcNameAndVersion(program_name, version);
        }
    }
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
}
void Singleton::f4();{
    RpcServiceResponseTimeDialog *dce_rpc_dlg = new RpcServiceResponseTimeDialog(parent, cf, get_srt_table_by_name("dcerpc"), DceRpc, filter);
    if (have_args) {
        if (program_name.isEmpty()) {
            dce_rpc_dlg->setDceRpcUuidAndVersion(&uuid, version);
        } else {
}
void Singleton::f5();{
            program_combo_->setCurrentIndex(pi);
            for (int vi = 0; vi < version_combo_->count(); vi++) {
                if (version == (int) version_combo_->itemData(vi).toUInt()) {
                    version_combo_->setCurrentIndex(vi);
                    found = true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    setRetapOnShow(false);
    setHint(tr("<small><i>Select a program and version and enter a filter if desired, then press Apply.</i></small>"));
    QHBoxLayout *filter_layout = filterLayout();
    program_combo_ = new QComboBox(this);
    version_combo_ = new QComboBox(this);
}
void Singleton::f2();{
                  uuid.data4[0] = d4_0;
                  uuid.data4[1] = d4_1;
                  uuid.data4[2] = d4_2;
                  uuid.data4[3] = d4_3;
                  uuid.data4[4] = d4_4;
}
void Singleton::f3();{
            onc_rpc_dlg->setRpcNameAndVersion(program_name, version);
        }
    }
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
}
void Singleton::f4();{
    RpcServiceResponseTimeDialog *dce_rpc_dlg = new RpcServiceResponseTimeDialog(parent, cf, get_srt_table_by_name("dcerpc"), DceRpc, filter);
    if (have_args) {
        if (program_name.isEmpty()) {
            dce_rpc_dlg->setDceRpcUuidAndVersion(&uuid, version);
        } else {
}
void Singleton::f5();{
            program_combo_->setCurrentIndex(pi);
            for (int vi = 0; vi < version_combo_->count(); vi++) {
                if (version == (int) version_combo_->itemData(vi).toUInt()) {
                    version_combo_->setCurrentIndex(vi);
                    found = true;
}
void Singleton::f6();{
        unsigned d1, d2, d3, d4_0, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7;
        if (sscanf(args_l[0].toUtf8().constData(),
                  "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                  &d1, &d2, &d3,
                  &d4_0, &d4_1, &d4_2, &d4_3, &d4_4, &d4_5, &d4_6, &d4_7) == 11) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    setRetapOnShow(false);
    setHint(tr("<small><i>Select a program and version and enter a filter if desired, then press Apply.</i></small>"));
    QHBoxLayout *filter_layout = filterLayout();
    program_combo_ = new QComboBox(this);
    version_combo_ = new QComboBox(this);
}
void Singleton::f2();{
                  uuid.data4[0] = d4_0;
                  uuid.data4[1] = d4_1;
                  uuid.data4[2] = d4_2;
                  uuid.data4[3] = d4_3;
                  uuid.data4[4] = d4_4;
}
void Singleton::f3();{
            onc_rpc_dlg->setRpcNameAndVersion(program_name, version);
        }
    }
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
}
void Singleton::f4();{
    RpcServiceResponseTimeDialog *dce_rpc_dlg = new RpcServiceResponseTimeDialog(parent, cf, get_srt_table_by_name("dcerpc"), DceRpc, filter);
    if (have_args) {
        if (program_name.isEmpty()) {
            dce_rpc_dlg->setDceRpcUuidAndVersion(&uuid, version);
        } else {
}
void Singleton::f5();{
            program_combo_->setCurrentIndex(pi);
            for (int vi = 0; vi < version_combo_->count(); vi++) {
                if (version == (int) version_combo_->itemData(vi).toUInt()) {
                    version_combo_->setCurrentIndex(vi);
                    found = true;
}
void Singleton::f6();{
        unsigned d1, d2, d3, d4_0, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7;
        if (sscanf(args_l[0].toUtf8().constData(),
                  "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                  &d1, &d2, &d3,
                  &d4_0, &d4_1, &d4_2, &d4_3, &d4_4, &d4_5, &d4_6, &d4_7) == 11) {
}
void Singleton::f7();{
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
void RpcServiceResponseTimeDialog::addDceRpcProgram(_guid_key *key, _dcerpc_uuid_value *value)
    dce_name_to_uuid_key_.insert(value->name, key);
void RpcServiceResponseTimeDialog::addDceRpcProgramVersion(_guid_key *key)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    setRetapOnShow(false);
    setHint(tr("<small><i>Select a program and version and enter a filter if desired, then press Apply.</i></small>"));
    QHBoxLayout *filter_layout = filterLayout();
    program_combo_ = new QComboBox(this);
    version_combo_ = new QComboBox(this);
}
void Singleton::f2();{
                  uuid.data4[0] = d4_0;
                  uuid.data4[1] = d4_1;
                  uuid.data4[2] = d4_2;
                  uuid.data4[3] = d4_3;
                  uuid.data4[4] = d4_4;
}
void Singleton::f3();{
            onc_rpc_dlg->setRpcNameAndVersion(program_name, version);
        }
    }
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
}
void Singleton::f4();{
    RpcServiceResponseTimeDialog *dce_rpc_dlg = new RpcServiceResponseTimeDialog(parent, cf, get_srt_table_by_name("dcerpc"), DceRpc, filter);
    if (have_args) {
        if (program_name.isEmpty()) {
            dce_rpc_dlg->setDceRpcUuidAndVersion(&uuid, version);
        } else {
}
void Singleton::f5();{
            program_combo_->setCurrentIndex(pi);
            for (int vi = 0; vi < version_combo_->count(); vi++) {
                if (version == (int) version_combo_->itemData(vi).toUInt()) {
                    version_combo_->setCurrentIndex(vi);
                    found = true;
}
void Singleton::f6();{
        unsigned d1, d2, d3, d4_0, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7;
        if (sscanf(args_l[0].toUtf8().constData(),
                  "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                  &d1, &d2, &d3,
                  &d4_0, &d4_1, &d4_2, &d4_3, &d4_4, &d4_5, &d4_6, &d4_7) == 11) {
}
void Singleton::f7();{
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
void RpcServiceResponseTimeDialog::addDceRpcProgram(_guid_key *key, _dcerpc_uuid_value *value)
    dce_name_to_uuid_key_.insert(value->name, key);
void RpcServiceResponseTimeDialog::addDceRpcProgramVersion(_guid_key *key)
}
void Singleton::f8();{
// - Don't assume that the user knows what programs+versions are in the
//   capture. I.e. combine this dialog with the ONC-RPC Programs dialog,
//   with two lists: programs on top, procedures on the bottom.
// - Allow the display of multiple programs and versions.
// - Expose the DCE-RPC UUIDs and ONC-RPC program numbers e.g. in an extra
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    setRetapOnShow(false);
    setHint(tr("<small><i>Select a program and version and enter a filter if desired, then press Apply.</i></small>"));
    QHBoxLayout *filter_layout = filterLayout();
    program_combo_ = new QComboBox(this);
    version_combo_ = new QComboBox(this);
}
void Singleton::f2();{
                  uuid.data4[0] = d4_0;
                  uuid.data4[1] = d4_1;
                  uuid.data4[2] = d4_2;
                  uuid.data4[3] = d4_3;
                  uuid.data4[4] = d4_4;
}
void Singleton::f3();{
            onc_rpc_dlg->setRpcNameAndVersion(program_name, version);
        }
    }
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
}
void Singleton::f4();{
    RpcServiceResponseTimeDialog *dce_rpc_dlg = new RpcServiceResponseTimeDialog(parent, cf, get_srt_table_by_name("dcerpc"), DceRpc, filter);
    if (have_args) {
        if (program_name.isEmpty()) {
            dce_rpc_dlg->setDceRpcUuidAndVersion(&uuid, version);
        } else {
}
void Singleton::f5();{
            program_combo_->setCurrentIndex(pi);
            for (int vi = 0; vi < version_combo_->count(); vi++) {
                if (version == (int) version_combo_->itemData(vi).toUInt()) {
                    version_combo_->setCurrentIndex(vi);
                    found = true;
}
void Singleton::f6();{
        unsigned d1, d2, d3, d4_0, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7;
        if (sscanf(args_l[0].toUtf8().constData(),
                  "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                  &d1, &d2, &d3,
                  &d4_0, &d4_1, &d4_2, &d4_3, &d4_4, &d4_5, &d4_6, &d4_7) == 11) {
}
void Singleton::f7();{
    // Else the GTK+ UI throws an error.
    return onc_rpc_dlg;
void RpcServiceResponseTimeDialog::addDceRpcProgram(_guid_key *key, _dcerpc_uuid_value *value)
    dce_name_to_uuid_key_.insert(value->name, key);
void RpcServiceResponseTimeDialog::addDceRpcProgramVersion(_guid_key *key)
}
void Singleton::f8();{
// - Don't assume that the user knows what programs+versions are in the
//   capture. I.e. combine this dialog with the ONC-RPC Programs dialog,
//   with two lists: programs on top, procedures on the bottom.
// - Allow the display of multiple programs and versions.
// - Expose the DCE-RPC UUIDs and ONC-RPC program numbers e.g. in an extra
}
void Singleton::f9();{
        if (!onc_name_to_program_.contains(program_name)) return;
        rpcstat_tap_data_t *otap_data = g_new0(rpcstat_tap_data_t, 1);
        otap_data->program = onc_name_to_program_[program_name];
        otap_data->prog = rpc_prog_name(otap_data->program);
        otap_data->version = (guint32) version_combo_->itemData(version_combo_->currentIndex()).toUInt();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        // For keys other than pkcs11, try to verify the key without password.
        // possible that an already unlocked token will not trigger a prompt).
        key_ok = verifyKey(qPrintable(item), NULL, &needs_pin, error);
    }
    QString pin;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        // For keys other than pkcs11, try to verify the key without password.
        // possible that an already unlocked token will not trigger a prompt).
        key_ok = verifyKey(qPrintable(item), NULL, &needs_pin, error);
    }
    QString pin;
}
void Singleton::f2();{
    ui->setupUi(this);
    ui->addFileButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
}
void Singleton::f3();{
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->libsView->setModel(pkcs11_libs_model_);
}
void Singleton::f4();{
    ui->deleteLibraryButton->setEnabled(current.isValid());
void RsaKeysFrame::on_addLibraryButton_clicked()
    if (!pkcs11_libs_model_) return;
    QString filter(tr("Libraries (*.dll)"));
    QString filter(tr("Libraries (*.so)"));
}
void Singleton::f5();{
    QString pin;
    while (!key_ok && needs_pin) {
        // A PIN is possibly needed, prompt for one.
        QString msg;
        if (!error.isEmpty()) {
}
void Singleton::f6();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * vi: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f7();{
    g_free(error_c);
    return key_ok;
void RsaKeysFrame::addKey(const QString &uri, const QString &password)
    // Create a new UAT entry with the given URI and PIN/password.
    int row = rsa_keys_model_->rowCount();
}
void Singleton::f8();{
        return;
    }
    QString file = pkcs11_libs_model_->data(current, 0).toString();
    pkcs11_libs_model_->removeRows(current.row(), 1);
    // Due to technical limitations of GnuTLS, libraries cannot be unloaded or
}
void Singleton::f9();{
void RsaKeysFrame::on_deleteItemButton_clicked()
    const QModelIndex &current = ui->keysView->currentIndex();
    if (rsa_keys_model_ && current.isValid()) {
        rsa_keys_model_->removeRows(current.row(), 1);
    }
}
void Singleton::f10();{
RsaKeysFrame::~RsaKeysFrame()
    delete ui;
gboolean RsaKeysFrame::verifyKey(const char *uri, const char *password, gboolean *need_password, QString &error)
    char *error_c = NULL;
    gboolean key_ok = secrets_verify_key(qPrintable(uri), qPrintable(password), need_password, &error_c);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        // For keys other than pkcs11, try to verify the key without password.
        // possible that an already unlocked token will not trigger a prompt).
        key_ok = verifyKey(qPrintable(item), NULL, &needs_pin, error);
    }
    QString pin;
}
void Singleton::f2();{
    ui->setupUi(this);
    ui->addFileButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        // For keys other than pkcs11, try to verify the key without password.
        // possible that an already unlocked token will not trigger a prompt).
        key_ok = verifyKey(qPrintable(item), NULL, &needs_pin, error);
    }
    QString pin;
}
void Singleton::f2();{
    ui->setupUi(this);
    ui->addFileButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
}
void Singleton::f3();{
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->libsView->setModel(pkcs11_libs_model_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        // For keys other than pkcs11, try to verify the key without password.
        // possible that an already unlocked token will not trigger a prompt).
        key_ok = verifyKey(qPrintable(item), NULL, &needs_pin, error);
    }
    QString pin;
}
void Singleton::f2();{
    ui->setupUi(this);
    ui->addFileButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
}
void Singleton::f3();{
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->libsView->setModel(pkcs11_libs_model_);
}
void Singleton::f4();{
    ui->deleteLibraryButton->setEnabled(current.isValid());
void RsaKeysFrame::on_addLibraryButton_clicked()
    if (!pkcs11_libs_model_) return;
    QString filter(tr("Libraries (*.dll)"));
    QString filter(tr("Libraries (*.so)"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        // For keys other than pkcs11, try to verify the key without password.
        // possible that an already unlocked token will not trigger a prompt).
        key_ok = verifyKey(qPrintable(item), NULL, &needs_pin, error);
    }
    QString pin;
}
void Singleton::f2();{
    ui->setupUi(this);
    ui->addFileButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
}
void Singleton::f3();{
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->libsView->setModel(pkcs11_libs_model_);
}
void Singleton::f4();{
    ui->deleteLibraryButton->setEnabled(current.isValid());
void RsaKeysFrame::on_addLibraryButton_clicked()
    if (!pkcs11_libs_model_) return;
    QString filter(tr("Libraries (*.dll)"));
    QString filter(tr("Libraries (*.so)"));
}
void Singleton::f5();{
    QString pin;
    while (!key_ok && needs_pin) {
        // A PIN is possibly needed, prompt for one.
        QString msg;
        if (!error.isEmpty()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        // For keys other than pkcs11, try to verify the key without password.
        // possible that an already unlocked token will not trigger a prompt).
        key_ok = verifyKey(qPrintable(item), NULL, &needs_pin, error);
    }
    QString pin;
}
void Singleton::f2();{
    ui->setupUi(this);
    ui->addFileButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
}
void Singleton::f3();{
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->libsView->setModel(pkcs11_libs_model_);
}
void Singleton::f4();{
    ui->deleteLibraryButton->setEnabled(current.isValid());
void RsaKeysFrame::on_addLibraryButton_clicked()
    if (!pkcs11_libs_model_) return;
    QString filter(tr("Libraries (*.dll)"));
    QString filter(tr("Libraries (*.so)"));
}
void Singleton::f5();{
    QString pin;
    while (!key_ok && needs_pin) {
        // A PIN is possibly needed, prompt for one.
        QString msg;
        if (!error.isEmpty()) {
}
void Singleton::f6();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * vi: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        // For keys other than pkcs11, try to verify the key without password.
        // possible that an already unlocked token will not trigger a prompt).
        key_ok = verifyKey(qPrintable(item), NULL, &needs_pin, error);
    }
    QString pin;
}
void Singleton::f2();{
    ui->setupUi(this);
    ui->addFileButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
}
void Singleton::f3();{
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->libsView->setModel(pkcs11_libs_model_);
}
void Singleton::f4();{
    ui->deleteLibraryButton->setEnabled(current.isValid());
void RsaKeysFrame::on_addLibraryButton_clicked()
    if (!pkcs11_libs_model_) return;
    QString filter(tr("Libraries (*.dll)"));
    QString filter(tr("Libraries (*.so)"));
}
void Singleton::f5();{
    QString pin;
    while (!key_ok && needs_pin) {
        // A PIN is possibly needed, prompt for one.
        QString msg;
        if (!error.isEmpty()) {
}
void Singleton::f6();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * vi: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f7();{
    g_free(error_c);
    return key_ok;
void RsaKeysFrame::addKey(const QString &uri, const QString &password)
    // Create a new UAT entry with the given URI and PIN/password.
    int row = rsa_keys_model_->rowCount();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        // For keys other than pkcs11, try to verify the key without password.
        // possible that an already unlocked token will not trigger a prompt).
        key_ok = verifyKey(qPrintable(item), NULL, &needs_pin, error);
    }
    QString pin;
}
void Singleton::f2();{
    ui->setupUi(this);
    ui->addFileButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
}
void Singleton::f3();{
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->libsView->setModel(pkcs11_libs_model_);
}
void Singleton::f4();{
    ui->deleteLibraryButton->setEnabled(current.isValid());
void RsaKeysFrame::on_addLibraryButton_clicked()
    if (!pkcs11_libs_model_) return;
    QString filter(tr("Libraries (*.dll)"));
    QString filter(tr("Libraries (*.so)"));
}
void Singleton::f5();{
    QString pin;
    while (!key_ok && needs_pin) {
        // A PIN is possibly needed, prompt for one.
        QString msg;
        if (!error.isEmpty()) {
}
void Singleton::f6();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * vi: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f7();{
    g_free(error_c);
    return key_ok;
void RsaKeysFrame::addKey(const QString &uri, const QString &password)
    // Create a new UAT entry with the given URI and PIN/password.
    int row = rsa_keys_model_->rowCount();
}
void Singleton::f8();{
        return;
    }
    QString file = pkcs11_libs_model_->data(current, 0).toString();
    pkcs11_libs_model_->removeRows(current.row(), 1);
    // Due to technical limitations of GnuTLS, libraries cannot be unloaded or
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        // For keys other than pkcs11, try to verify the key without password.
        // possible that an already unlocked token will not trigger a prompt).
        key_ok = verifyKey(qPrintable(item), NULL, &needs_pin, error);
    }
    QString pin;
}
void Singleton::f2();{
    ui->setupUi(this);
    ui->addFileButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
}
void Singleton::f3();{
    ui->addItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteItemButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->addLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteLibraryButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->libsView->setModel(pkcs11_libs_model_);
}
void Singleton::f4();{
    ui->deleteLibraryButton->setEnabled(current.isValid());
void RsaKeysFrame::on_addLibraryButton_clicked()
    if (!pkcs11_libs_model_) return;
    QString filter(tr("Libraries (*.dll)"));
    QString filter(tr("Libraries (*.so)"));
}
void Singleton::f5();{
    QString pin;
    while (!key_ok && needs_pin) {
        // A PIN is possibly needed, prompt for one.
        QString msg;
        if (!error.isEmpty()) {
}
void Singleton::f6();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * vi: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f7();{
    g_free(error_c);
    return key_ok;
void RsaKeysFrame::addKey(const QString &uri, const QString &password)
    // Create a new UAT entry with the given URI and PIN/password.
    int row = rsa_keys_model_->rowCount();
}
void Singleton::f8();{
        return;
    }
    QString file = pkcs11_libs_model_->data(current, 0).toString();
    pkcs11_libs_model_->removeRows(current.row(), 1);
    // Due to technical limitations of GnuTLS, libraries cannot be unloaded or
}
void Singleton::f9();{
void RsaKeysFrame::on_deleteItemButton_clicked()
    const QModelIndex &current = ui->keysView->currentIndex();
    if (rsa_keys_model_ && current.isValid()) {
        rsa_keys_model_->removeRows(current.row(), 1);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
class RtpAnalysisTreeWidgetItem : public QTreeWidgetItem
public:
    RtpAnalysisTreeWidgetItem(QTreeWidget *tree, tap_rtp_stat_t *statinfo, packet_info *pinfo, const struct _rtp_info *rtpinfo) :
        QTreeWidgetItem(tree, rtp_analysis_type_)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
class RtpAnalysisTreeWidgetItem : public QTreeWidgetItem
public:
    RtpAnalysisTreeWidgetItem(QTreeWidget *tree, tap_rtp_stat_t *statinfo, packet_info *pinfo, const struct _rtp_info *rtpinfo) :
        QTreeWidgetItem(tree, rtp_analysis_type_)
    {
}
void Singleton::f2();{
            else if (sae_unsupported_rate_) {
                QMessageBox::warning(this, tr("Warning"), tr("Codec rate is not supported, file is incomplete"));
            }
            else {
                QMessageBox::warning(this, tr("Warning"), tr("Unknown error occured"));
}
void Singleton::f3();{
    if ((rtpinfo->info_payload_type == PT_CN) ||
        (rtpinfo->info_payload_type == PT_CN_OLD)) {
    } else { /* All other payloads */
        const char *data;
        int64_t nchars;
}
void Singleton::f4();{
    switch (direction) {
        case dir_forward_: {
            phton32(pd, 1);
            break;
        }
}
void Singleton::f5();{
    header_end=save_file->pos();
    bool two_channels = rev_statinfo_.rtp_stats.total_nr && (save_payload_error_ == TAP_RTP_NO_ERROR);
    double t_min = MIN(fwd_statinfo_.rtp_stats.start_time, rev_statinfo_.rtp_stats.start_time);
    double t_fwd_diff = fwd_statinfo_.rtp_stats.start_time - t_min;
    double t_rev_diff = rev_statinfo_.rtp_stats.start_time - t_min;
}
void Singleton::f6();{
    }
    g_hash_table_destroy(decoders_hash);
    return true;
bool RtpAnalysisDialog::saveAudioAUBidir(tap_rtp_stat_t &fwd_statinfo, tap_rtp_stat_t &rev_statinfo, const gchar *fwd_payload_type_names[256], const gchar *rev_payload_type_names[256], QTemporaryFile *fwd_tempfile, QTemporaryFile *rev_tempfile, QFile *save_file, int64_t header_end, gboolean *stop_flag, size_t prefix_silence_fwd, size_t prefix_silence_rev)
    if (!saveAudioAUUnidir(fwd_statinfo, fwd_payload_type_names, fwd_tempfile, save_file, header_end, stop_flag, true, prefix_silence_fwd)) {
}
void Singleton::f7();{
    stats_tables += QString("<tr><th align=\"left\">Seq Errs</th><td>%1</td></tr>")
            .arg(fwd_statinfo_.rtp_stats.sequence);
    stats_tables += QString("<tr><th align=\"left\">Start at</th><td>%1 s @ %2</td></tr>")
            .arg(fwd_statinfo_.rtp_stats.start_time / 1000.0, 0, 'f', 6)
            .arg(fwd_statinfo_.rtp_stats.first_packet_num);
}
void Singleton::f8();{
    QTreeWidgetItem *test_ti = cur_tree->itemBelow(sel_ti);
    if (!test_ti) test_ti = cur_tree->topLevelItem(0);
    while (test_ti != sel_ti) {
        RtpAnalysisTreeWidgetItem *ra_ti = dynamic_cast<RtpAnalysisTreeWidgetItem *>((RtpAnalysisTreeWidgetItem *)test_ti);
        if (!ra_ti->frameStatus()) {
}
void Singleton::f9();{
        setTextAlignment(bandwidth_col_, Qt::AlignRight);
        setTextAlignment(marker_col_, Qt::AlignCenter);
        if (bg_color.isValid()) {
            for (int col = 0; col < columnCount(); col++) {
                setBackground(col, bg_color);
}
void Singleton::f10();{
    fwd_jitter_vals_.clear();
    fwd_diff_vals_.clear();
    fwd_delta_vals_.clear();
    rev_time_vals_.clear();
    rev_jitter_vals_.clear();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
class RtpAnalysisTreeWidgetItem : public QTreeWidgetItem
public:
    RtpAnalysisTreeWidgetItem(QTreeWidget *tree, tap_rtp_stat_t *statinfo, packet_info *pinfo, const struct _rtp_info *rtpinfo) :
        QTreeWidgetItem(tree, rtp_analysis_type_)
    {
}
void Singleton::f2();{
            else if (sae_unsupported_rate_) {
                QMessageBox::warning(this, tr("Warning"), tr("Codec rate is not supported, file is incomplete"));
            }
            else {
                QMessageBox::warning(this, tr("Warning"), tr("Unknown error occured"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
class RtpAnalysisTreeWidgetItem : public QTreeWidgetItem
public:
    RtpAnalysisTreeWidgetItem(QTreeWidget *tree, tap_rtp_stat_t *statinfo, packet_info *pinfo, const struct _rtp_info *rtpinfo) :
        QTreeWidgetItem(tree, rtp_analysis_type_)
    {
}
void Singleton::f2();{
            else if (sae_unsupported_rate_) {
                QMessageBox::warning(this, tr("Warning"), tr("Codec rate is not supported, file is incomplete"));
            }
            else {
                QMessageBox::warning(this, tr("Warning"), tr("Unknown error occured"));
}
void Singleton::f3();{
    if ((rtpinfo->info_payload_type == PT_CN) ||
        (rtpinfo->info_payload_type == PT_CN_OLD)) {
    } else { /* All other payloads */
        const char *data;
        int64_t nchars;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
class RtpAnalysisTreeWidgetItem : public QTreeWidgetItem
public:
    RtpAnalysisTreeWidgetItem(QTreeWidget *tree, tap_rtp_stat_t *statinfo, packet_info *pinfo, const struct _rtp_info *rtpinfo) :
        QTreeWidgetItem(tree, rtp_analysis_type_)
    {
}
void Singleton::f2();{
            else if (sae_unsupported_rate_) {
                QMessageBox::warning(this, tr("Warning"), tr("Codec rate is not supported, file is incomplete"));
            }
            else {
                QMessageBox::warning(this, tr("Warning"), tr("Unknown error occured"));
}
void Singleton::f3();{
    if ((rtpinfo->info_payload_type == PT_CN) ||
        (rtpinfo->info_payload_type == PT_CN_OLD)) {
    } else { /* All other payloads */
        const char *data;
        int64_t nchars;
}
void Singleton::f4();{
    switch (direction) {
        case dir_forward_: {
            phton32(pd, 1);
            break;
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
class RtpAnalysisTreeWidgetItem : public QTreeWidgetItem
public:
    RtpAnalysisTreeWidgetItem(QTreeWidget *tree, tap_rtp_stat_t *statinfo, packet_info *pinfo, const struct _rtp_info *rtpinfo) :
        QTreeWidgetItem(tree, rtp_analysis_type_)
    {
}
void Singleton::f2();{
            else if (sae_unsupported_rate_) {
                QMessageBox::warning(this, tr("Warning"), tr("Codec rate is not supported, file is incomplete"));
            }
            else {
                QMessageBox::warning(this, tr("Warning"), tr("Unknown error occured"));
}
void Singleton::f3();{
    if ((rtpinfo->info_payload_type == PT_CN) ||
        (rtpinfo->info_payload_type == PT_CN_OLD)) {
    } else { /* All other payloads */
        const char *data;
        int64_t nchars;
}
void Singleton::f4();{
    switch (direction) {
        case dir_forward_: {
            phton32(pd, 1);
            break;
        }
}
void Singleton::f5();{
    header_end=save_file->pos();
    bool two_channels = rev_statinfo_.rtp_stats.total_nr && (save_payload_error_ == TAP_RTP_NO_ERROR);
    double t_min = MIN(fwd_statinfo_.rtp_stats.start_time, rev_statinfo_.rtp_stats.start_time);
    double t_fwd_diff = fwd_statinfo_.rtp_stats.start_time - t_min;
    double t_rev_diff = rev_statinfo_.rtp_stats.start_time - t_min;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
class RtpAnalysisTreeWidgetItem : public QTreeWidgetItem
public:
    RtpAnalysisTreeWidgetItem(QTreeWidget *tree, tap_rtp_stat_t *statinfo, packet_info *pinfo, const struct _rtp_info *rtpinfo) :
        QTreeWidgetItem(tree, rtp_analysis_type_)
    {
}
void Singleton::f2();{
            else if (sae_unsupported_rate_) {
                QMessageBox::warning(this, tr("Warning"), tr("Codec rate is not supported, file is incomplete"));
            }
            else {
                QMessageBox::warning(this, tr("Warning"), tr("Unknown error occured"));
}
void Singleton::f3();{
    if ((rtpinfo->info_payload_type == PT_CN) ||
        (rtpinfo->info_payload_type == PT_CN_OLD)) {
    } else { /* All other payloads */
        const char *data;
        int64_t nchars;
}
void Singleton::f4();{
    switch (direction) {
        case dir_forward_: {
            phton32(pd, 1);
            break;
        }
}
void Singleton::f5();{
    header_end=save_file->pos();
    bool two_channels = rev_statinfo_.rtp_stats.total_nr && (save_payload_error_ == TAP_RTP_NO_ERROR);
    double t_min = MIN(fwd_statinfo_.rtp_stats.start_time, rev_statinfo_.rtp_stats.start_time);
    double t_fwd_diff = fwd_statinfo_.rtp_stats.start_time - t_min;
    double t_rev_diff = rev_statinfo_.rtp_stats.start_time - t_min;
}
void Singleton::f6();{
    }
    g_hash_table_destroy(decoders_hash);
    return true;
bool RtpAnalysisDialog::saveAudioAUBidir(tap_rtp_stat_t &fwd_statinfo, tap_rtp_stat_t &rev_statinfo, const gchar *fwd_payload_type_names[256], const gchar *rev_payload_type_names[256], QTemporaryFile *fwd_tempfile, QTemporaryFile *rev_tempfile, QFile *save_file, int64_t header_end, gboolean *stop_flag, size_t prefix_silence_fwd, size_t prefix_silence_rev)
    if (!saveAudioAUUnidir(fwd_statinfo, fwd_payload_type_names, fwd_tempfile, save_file, header_end, stop_flag, true, prefix_silence_fwd)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
class RtpAnalysisTreeWidgetItem : public QTreeWidgetItem
public:
    RtpAnalysisTreeWidgetItem(QTreeWidget *tree, tap_rtp_stat_t *statinfo, packet_info *pinfo, const struct _rtp_info *rtpinfo) :
        QTreeWidgetItem(tree, rtp_analysis_type_)
    {
}
void Singleton::f2();{
            else if (sae_unsupported_rate_) {
                QMessageBox::warning(this, tr("Warning"), tr("Codec rate is not supported, file is incomplete"));
            }
            else {
                QMessageBox::warning(this, tr("Warning"), tr("Unknown error occured"));
}
void Singleton::f3();{
    if ((rtpinfo->info_payload_type == PT_CN) ||
        (rtpinfo->info_payload_type == PT_CN_OLD)) {
    } else { /* All other payloads */
        const char *data;
        int64_t nchars;
}
void Singleton::f4();{
    switch (direction) {
        case dir_forward_: {
            phton32(pd, 1);
            break;
        }
}
void Singleton::f5();{
    header_end=save_file->pos();
    bool two_channels = rev_statinfo_.rtp_stats.total_nr && (save_payload_error_ == TAP_RTP_NO_ERROR);
    double t_min = MIN(fwd_statinfo_.rtp_stats.start_time, rev_statinfo_.rtp_stats.start_time);
    double t_fwd_diff = fwd_statinfo_.rtp_stats.start_time - t_min;
    double t_rev_diff = rev_statinfo_.rtp_stats.start_time - t_min;
}
void Singleton::f6();{
    }
    g_hash_table_destroy(decoders_hash);
    return true;
bool RtpAnalysisDialog::saveAudioAUBidir(tap_rtp_stat_t &fwd_statinfo, tap_rtp_stat_t &rev_statinfo, const gchar *fwd_payload_type_names[256], const gchar *rev_payload_type_names[256], QTemporaryFile *fwd_tempfile, QTemporaryFile *rev_tempfile, QFile *save_file, int64_t header_end, gboolean *stop_flag, size_t prefix_silence_fwd, size_t prefix_silence_rev)
    if (!saveAudioAUUnidir(fwd_statinfo, fwd_payload_type_names, fwd_tempfile, save_file, header_end, stop_flag, true, prefix_silence_fwd)) {
}
void Singleton::f7();{
    stats_tables += QString("<tr><th align=\"left\">Seq Errs</th><td>%1</td></tr>")
            .arg(fwd_statinfo_.rtp_stats.sequence);
    stats_tables += QString("<tr><th align=\"left\">Start at</th><td>%1 s @ %2</td></tr>")
            .arg(fwd_statinfo_.rtp_stats.start_time / 1000.0, 0, 'f', 6)
            .arg(fwd_statinfo_.rtp_stats.first_packet_num);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
class RtpAnalysisTreeWidgetItem : public QTreeWidgetItem
public:
    RtpAnalysisTreeWidgetItem(QTreeWidget *tree, tap_rtp_stat_t *statinfo, packet_info *pinfo, const struct _rtp_info *rtpinfo) :
        QTreeWidgetItem(tree, rtp_analysis_type_)
    {
}
void Singleton::f2();{
            else if (sae_unsupported_rate_) {
                QMessageBox::warning(this, tr("Warning"), tr("Codec rate is not supported, file is incomplete"));
            }
            else {
                QMessageBox::warning(this, tr("Warning"), tr("Unknown error occured"));
}
void Singleton::f3();{
    if ((rtpinfo->info_payload_type == PT_CN) ||
        (rtpinfo->info_payload_type == PT_CN_OLD)) {
    } else { /* All other payloads */
        const char *data;
        int64_t nchars;
}
void Singleton::f4();{
    switch (direction) {
        case dir_forward_: {
            phton32(pd, 1);
            break;
        }
}
void Singleton::f5();{
    header_end=save_file->pos();
    bool two_channels = rev_statinfo_.rtp_stats.total_nr && (save_payload_error_ == TAP_RTP_NO_ERROR);
    double t_min = MIN(fwd_statinfo_.rtp_stats.start_time, rev_statinfo_.rtp_stats.start_time);
    double t_fwd_diff = fwd_statinfo_.rtp_stats.start_time - t_min;
    double t_rev_diff = rev_statinfo_.rtp_stats.start_time - t_min;
}
void Singleton::f6();{
    }
    g_hash_table_destroy(decoders_hash);
    return true;
bool RtpAnalysisDialog::saveAudioAUBidir(tap_rtp_stat_t &fwd_statinfo, tap_rtp_stat_t &rev_statinfo, const gchar *fwd_payload_type_names[256], const gchar *rev_payload_type_names[256], QTemporaryFile *fwd_tempfile, QTemporaryFile *rev_tempfile, QFile *save_file, int64_t header_end, gboolean *stop_flag, size_t prefix_silence_fwd, size_t prefix_silence_rev)
    if (!saveAudioAUUnidir(fwd_statinfo, fwd_payload_type_names, fwd_tempfile, save_file, header_end, stop_flag, true, prefix_silence_fwd)) {
}
void Singleton::f7();{
    stats_tables += QString("<tr><th align=\"left\">Seq Errs</th><td>%1</td></tr>")
            .arg(fwd_statinfo_.rtp_stats.sequence);
    stats_tables += QString("<tr><th align=\"left\">Start at</th><td>%1 s @ %2</td></tr>")
            .arg(fwd_statinfo_.rtp_stats.start_time / 1000.0, 0, 'f', 6)
            .arg(fwd_statinfo_.rtp_stats.first_packet_num);
}
void Singleton::f8();{
    QTreeWidgetItem *test_ti = cur_tree->itemBelow(sel_ti);
    if (!test_ti) test_ti = cur_tree->topLevelItem(0);
    while (test_ti != sel_ti) {
        RtpAnalysisTreeWidgetItem *ra_ti = dynamic_cast<RtpAnalysisTreeWidgetItem *>((RtpAnalysisTreeWidgetItem *)test_ti);
        if (!ra_ti->frameStatus()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
class RtpAnalysisTreeWidgetItem : public QTreeWidgetItem
public:
    RtpAnalysisTreeWidgetItem(QTreeWidget *tree, tap_rtp_stat_t *statinfo, packet_info *pinfo, const struct _rtp_info *rtpinfo) :
        QTreeWidgetItem(tree, rtp_analysis_type_)
    {
}
void Singleton::f2();{
            else if (sae_unsupported_rate_) {
                QMessageBox::warning(this, tr("Warning"), tr("Codec rate is not supported, file is incomplete"));
            }
            else {
                QMessageBox::warning(this, tr("Warning"), tr("Unknown error occured"));
}
void Singleton::f3();{
    if ((rtpinfo->info_payload_type == PT_CN) ||
        (rtpinfo->info_payload_type == PT_CN_OLD)) {
    } else { /* All other payloads */
        const char *data;
        int64_t nchars;
}
void Singleton::f4();{
    switch (direction) {
        case dir_forward_: {
            phton32(pd, 1);
            break;
        }
}
void Singleton::f5();{
    header_end=save_file->pos();
    bool two_channels = rev_statinfo_.rtp_stats.total_nr && (save_payload_error_ == TAP_RTP_NO_ERROR);
    double t_min = MIN(fwd_statinfo_.rtp_stats.start_time, rev_statinfo_.rtp_stats.start_time);
    double t_fwd_diff = fwd_statinfo_.rtp_stats.start_time - t_min;
    double t_rev_diff = rev_statinfo_.rtp_stats.start_time - t_min;
}
void Singleton::f6();{
    }
    g_hash_table_destroy(decoders_hash);
    return true;
bool RtpAnalysisDialog::saveAudioAUBidir(tap_rtp_stat_t &fwd_statinfo, tap_rtp_stat_t &rev_statinfo, const gchar *fwd_payload_type_names[256], const gchar *rev_payload_type_names[256], QTemporaryFile *fwd_tempfile, QTemporaryFile *rev_tempfile, QFile *save_file, int64_t header_end, gboolean *stop_flag, size_t prefix_silence_fwd, size_t prefix_silence_rev)
    if (!saveAudioAUUnidir(fwd_statinfo, fwd_payload_type_names, fwd_tempfile, save_file, header_end, stop_flag, true, prefix_silence_fwd)) {
}
void Singleton::f7();{
    stats_tables += QString("<tr><th align=\"left\">Seq Errs</th><td>%1</td></tr>")
            .arg(fwd_statinfo_.rtp_stats.sequence);
    stats_tables += QString("<tr><th align=\"left\">Start at</th><td>%1 s @ %2</td></tr>")
            .arg(fwd_statinfo_.rtp_stats.start_time / 1000.0, 0, 'f', 6)
            .arg(fwd_statinfo_.rtp_stats.first_packet_num);
}
void Singleton::f8();{
    QTreeWidgetItem *test_ti = cur_tree->itemBelow(sel_ti);
    if (!test_ti) test_ti = cur_tree->topLevelItem(0);
    while (test_ti != sel_ti) {
        RtpAnalysisTreeWidgetItem *ra_ti = dynamic_cast<RtpAnalysisTreeWidgetItem *>((RtpAnalysisTreeWidgetItem *)test_ti);
        if (!ra_ti->frameStatus()) {
}
void Singleton::f9();{
        setTextAlignment(bandwidth_col_, Qt::AlignRight);
        setTextAlignment(marker_col_, Qt::AlignCenter);
        if (bg_color.isValid()) {
            for (int col = 0; col < columnCount(); col++) {
                setBackground(col, bg_color);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
void RtpAudioStream::writeSilence(qint64 samples)
    if (samples < 1 || audio_out_rate_ == 0) return;
    qint64 silence_bytes = samples * sample_bytes_;
    char *silence_buff = (char *) g_malloc0(silence_bytes);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
void RtpAudioStream::writeSilence(qint64 samples)
    if (samples < 1 || audio_out_rate_ == 0) return;
    qint64 silence_bytes = samples * sample_bytes_;
    char *silence_buff = (char *) g_malloc0(silence_bytes);
}
void Singleton::f2();{
    double rtp_time_prev = 0.0;
    double arrive_time_prev = 0.0;
    double pack_period = 0.0;
    double start_time = 0.0;
    double start_rtp_time = 0.0;
}
void Singleton::f3();{
void RtpAudioStream::addRtpPacket(const struct _packet_info *pinfo, const struct _rtp_info *rtp_info)
    // gtk/rtp_player.c:decode_rtp_packet
    if (!rtp_info) return;
    rtp_packet_t *rtp_packet = g_new0(rtp_packet_t, 1);
    rtp_packet->info = (struct _rtp_info *) g_memdup(rtp_info, sizeof(struct _rtp_info));
}
void Singleton::f4();{
    QString fmt_descr = QString("%1 Hz, ").arg(format.sampleRate());
    switch (format.sampleType()) {
    case QAudioFormat::SignedInt:
        fmt_descr += "Int";
        break;
}
void Singleton::f5();{
    // Silence is inserted to audio file only.
    // If inserted to visual_samples_ too, it shifts whole waveset
    //QVector<qint16> visual_fill(samples * visual_sample_rate_ / audio_out_rate_, 0);
    //visual_samples_ += visual_fill;
void RtpAudioStream::outputStateChanged(QAudio::State new_state)
}
void Singleton::f6();{
        start_abs_offset_ = nstime_to_sec(&pinfo->abs_ts) - start_rel_time_;
        start_rel_time_ = stop_rel_time_ = nstime_to_sec(&pinfo->rel_ts);
    }
    rtp_packet->frame_num = pinfo->num;
    rtp_packet->arrive_offset = nstime_to_sec(&pinfo->rel_ts) - start_rel_time_;
}
void Singleton::f7();{
        && rtpstream_id_equal_pinfo_rtp_info(&id_, pinfo, rtp_info))
        return true;
    return false;
// XXX We add multiple RTP streams here because that's what the GTK+ UI does.
// Should we make these distinct, with their own waveforms? It seems like
}
void Singleton::f8();{
        }
        if (audio_out_rate_ == 0) {
            // Use the first non-zero rate we find. Ajust it to match our audio hardware.
            QAudioDeviceInfo cur_out_device = QAudioDeviceInfo::defaultOutputDevice();
            QString cur_out_name = parent()->property("currentOutputDeviceName").toString();
}
void Singleton::f9();{
            last_sequence = rtp_packet->info->info_seq_num;
            g_free(decode_buff);
            continue;
        }
        if (audio_out_rate_ == 0) {
}
void Singleton::f10();{
        for (unsigned i = 0; i < out_len; i++) {
            packet_timestamps_[stop_rel_time_ + (double) i / visual_out_rate] = rtp_packet->frame_num;
            if (qAbs(resample_buff[i]) > max_sample_val_) max_sample_val_ = qAbs(resample_buff[i]);
            visual_samples_.append(resample_buff[i]);
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
void RtpAudioStream::writeSilence(qint64 samples)
    if (samples < 1 || audio_out_rate_ == 0) return;
    qint64 silence_bytes = samples * sample_bytes_;
    char *silence_buff = (char *) g_malloc0(silence_bytes);
}
void Singleton::f2();{
    double rtp_time_prev = 0.0;
    double arrive_time_prev = 0.0;
    double pack_period = 0.0;
    double start_time = 0.0;
    double start_rtp_time = 0.0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
void RtpAudioStream::writeSilence(qint64 samples)
    if (samples < 1 || audio_out_rate_ == 0) return;
    qint64 silence_bytes = samples * sample_bytes_;
    char *silence_buff = (char *) g_malloc0(silence_bytes);
}
void Singleton::f2();{
    double rtp_time_prev = 0.0;
    double arrive_time_prev = 0.0;
    double pack_period = 0.0;
    double start_time = 0.0;
    double start_rtp_time = 0.0;
}
void Singleton::f3();{
void RtpAudioStream::addRtpPacket(const struct _packet_info *pinfo, const struct _rtp_info *rtp_info)
    // gtk/rtp_player.c:decode_rtp_packet
    if (!rtp_info) return;
    rtp_packet_t *rtp_packet = g_new0(rtp_packet_t, 1);
    rtp_packet->info = (struct _rtp_info *) g_memdup(rtp_info, sizeof(struct _rtp_info));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
void RtpAudioStream::writeSilence(qint64 samples)
    if (samples < 1 || audio_out_rate_ == 0) return;
    qint64 silence_bytes = samples * sample_bytes_;
    char *silence_buff = (char *) g_malloc0(silence_bytes);
}
void Singleton::f2();{
    double rtp_time_prev = 0.0;
    double arrive_time_prev = 0.0;
    double pack_period = 0.0;
    double start_time = 0.0;
    double start_rtp_time = 0.0;
}
void Singleton::f3();{
void RtpAudioStream::addRtpPacket(const struct _packet_info *pinfo, const struct _rtp_info *rtp_info)
    // gtk/rtp_player.c:decode_rtp_packet
    if (!rtp_info) return;
    rtp_packet_t *rtp_packet = g_new0(rtp_packet_t, 1);
    rtp_packet->info = (struct _rtp_info *) g_memdup(rtp_info, sizeof(struct _rtp_info));
}
void Singleton::f4();{
    QString fmt_descr = QString("%1 Hz, ").arg(format.sampleRate());
    switch (format.sampleType()) {
    case QAudioFormat::SignedInt:
        fmt_descr += "Int";
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
void RtpAudioStream::writeSilence(qint64 samples)
    if (samples < 1 || audio_out_rate_ == 0) return;
    qint64 silence_bytes = samples * sample_bytes_;
    char *silence_buff = (char *) g_malloc0(silence_bytes);
}
void Singleton::f2();{
    double rtp_time_prev = 0.0;
    double arrive_time_prev = 0.0;
    double pack_period = 0.0;
    double start_time = 0.0;
    double start_rtp_time = 0.0;
}
void Singleton::f3();{
void RtpAudioStream::addRtpPacket(const struct _packet_info *pinfo, const struct _rtp_info *rtp_info)
    // gtk/rtp_player.c:decode_rtp_packet
    if (!rtp_info) return;
    rtp_packet_t *rtp_packet = g_new0(rtp_packet_t, 1);
    rtp_packet->info = (struct _rtp_info *) g_memdup(rtp_info, sizeof(struct _rtp_info));
}
void Singleton::f4();{
    QString fmt_descr = QString("%1 Hz, ").arg(format.sampleRate());
    switch (format.sampleType()) {
    case QAudioFormat::SignedInt:
        fmt_descr += "Int";
        break;
}
void Singleton::f5();{
    // Silence is inserted to audio file only.
    // If inserted to visual_samples_ too, it shifts whole waveset
    //QVector<qint16> visual_fill(samples * visual_sample_rate_ / audio_out_rate_, 0);
    //visual_samples_ += visual_fill;
void RtpAudioStream::outputStateChanged(QAudio::State new_state)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
void RtpAudioStream::writeSilence(qint64 samples)
    if (samples < 1 || audio_out_rate_ == 0) return;
    qint64 silence_bytes = samples * sample_bytes_;
    char *silence_buff = (char *) g_malloc0(silence_bytes);
}
void Singleton::f2();{
    double rtp_time_prev = 0.0;
    double arrive_time_prev = 0.0;
    double pack_period = 0.0;
    double start_time = 0.0;
    double start_rtp_time = 0.0;
}
void Singleton::f3();{
void RtpAudioStream::addRtpPacket(const struct _packet_info *pinfo, const struct _rtp_info *rtp_info)
    // gtk/rtp_player.c:decode_rtp_packet
    if (!rtp_info) return;
    rtp_packet_t *rtp_packet = g_new0(rtp_packet_t, 1);
    rtp_packet->info = (struct _rtp_info *) g_memdup(rtp_info, sizeof(struct _rtp_info));
}
void Singleton::f4();{
    QString fmt_descr = QString("%1 Hz, ").arg(format.sampleRate());
    switch (format.sampleType()) {
    case QAudioFormat::SignedInt:
        fmt_descr += "Int";
        break;
}
void Singleton::f5();{
    // Silence is inserted to audio file only.
    // If inserted to visual_samples_ too, it shifts whole waveset
    //QVector<qint16> visual_fill(samples * visual_sample_rate_ / audio_out_rate_, 0);
    //visual_samples_ += visual_fill;
void RtpAudioStream::outputStateChanged(QAudio::State new_state)
}
void Singleton::f6();{
        start_abs_offset_ = nstime_to_sec(&pinfo->abs_ts) - start_rel_time_;
        start_rel_time_ = stop_rel_time_ = nstime_to_sec(&pinfo->rel_ts);
    }
    rtp_packet->frame_num = pinfo->num;
    rtp_packet->arrive_offset = nstime_to_sec(&pinfo->rel_ts) - start_rel_time_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
void RtpAudioStream::writeSilence(qint64 samples)
    if (samples < 1 || audio_out_rate_ == 0) return;
    qint64 silence_bytes = samples * sample_bytes_;
    char *silence_buff = (char *) g_malloc0(silence_bytes);
}
void Singleton::f2();{
    double rtp_time_prev = 0.0;
    double arrive_time_prev = 0.0;
    double pack_period = 0.0;
    double start_time = 0.0;
    double start_rtp_time = 0.0;
}
void Singleton::f3();{
void RtpAudioStream::addRtpPacket(const struct _packet_info *pinfo, const struct _rtp_info *rtp_info)
    // gtk/rtp_player.c:decode_rtp_packet
    if (!rtp_info) return;
    rtp_packet_t *rtp_packet = g_new0(rtp_packet_t, 1);
    rtp_packet->info = (struct _rtp_info *) g_memdup(rtp_info, sizeof(struct _rtp_info));
}
void Singleton::f4();{
    QString fmt_descr = QString("%1 Hz, ").arg(format.sampleRate());
    switch (format.sampleType()) {
    case QAudioFormat::SignedInt:
        fmt_descr += "Int";
        break;
}
void Singleton::f5();{
    // Silence is inserted to audio file only.
    // If inserted to visual_samples_ too, it shifts whole waveset
    //QVector<qint16> visual_fill(samples * visual_sample_rate_ / audio_out_rate_, 0);
    //visual_samples_ += visual_fill;
void RtpAudioStream::outputStateChanged(QAudio::State new_state)
}
void Singleton::f6();{
        start_abs_offset_ = nstime_to_sec(&pinfo->abs_ts) - start_rel_time_;
        start_rel_time_ = stop_rel_time_ = nstime_to_sec(&pinfo->rel_ts);
    }
    rtp_packet->frame_num = pinfo->num;
    rtp_packet->arrive_offset = nstime_to_sec(&pinfo->rel_ts) - start_rel_time_;
}
void Singleton::f7();{
        && rtpstream_id_equal_pinfo_rtp_info(&id_, pinfo, rtp_info))
        return true;
    return false;
// XXX We add multiple RTP streams here because that's what the GTK+ UI does.
// Should we make these distinct, with their own waveforms? It seems like
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
void RtpAudioStream::writeSilence(qint64 samples)
    if (samples < 1 || audio_out_rate_ == 0) return;
    qint64 silence_bytes = samples * sample_bytes_;
    char *silence_buff = (char *) g_malloc0(silence_bytes);
}
void Singleton::f2();{
    double rtp_time_prev = 0.0;
    double arrive_time_prev = 0.0;
    double pack_period = 0.0;
    double start_time = 0.0;
    double start_rtp_time = 0.0;
}
void Singleton::f3();{
void RtpAudioStream::addRtpPacket(const struct _packet_info *pinfo, const struct _rtp_info *rtp_info)
    // gtk/rtp_player.c:decode_rtp_packet
    if (!rtp_info) return;
    rtp_packet_t *rtp_packet = g_new0(rtp_packet_t, 1);
    rtp_packet->info = (struct _rtp_info *) g_memdup(rtp_info, sizeof(struct _rtp_info));
}
void Singleton::f4();{
    QString fmt_descr = QString("%1 Hz, ").arg(format.sampleRate());
    switch (format.sampleType()) {
    case QAudioFormat::SignedInt:
        fmt_descr += "Int";
        break;
}
void Singleton::f5();{
    // Silence is inserted to audio file only.
    // If inserted to visual_samples_ too, it shifts whole waveset
    //QVector<qint16> visual_fill(samples * visual_sample_rate_ / audio_out_rate_, 0);
    //visual_samples_ += visual_fill;
void RtpAudioStream::outputStateChanged(QAudio::State new_state)
}
void Singleton::f6();{
        start_abs_offset_ = nstime_to_sec(&pinfo->abs_ts) - start_rel_time_;
        start_rel_time_ = stop_rel_time_ = nstime_to_sec(&pinfo->rel_ts);
    }
    rtp_packet->frame_num = pinfo->num;
    rtp_packet->arrive_offset = nstime_to_sec(&pinfo->rel_ts) - start_rel_time_;
}
void Singleton::f7();{
        && rtpstream_id_equal_pinfo_rtp_info(&id_, pinfo, rtp_info))
        return true;
    return false;
// XXX We add multiple RTP streams here because that's what the GTK+ UI does.
// Should we make these distinct, with their own waveforms? It seems like
}
void Singleton::f8();{
        }
        if (audio_out_rate_ == 0) {
            // Use the first non-zero rate we find. Ajust it to match our audio hardware.
            QAudioDeviceInfo cur_out_device = QAudioDeviceInfo::defaultOutputDevice();
            QString cur_out_name = parent()->property("currentOutputDeviceName").toString();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
void RtpAudioStream::writeSilence(qint64 samples)
    if (samples < 1 || audio_out_rate_ == 0) return;
    qint64 silence_bytes = samples * sample_bytes_;
    char *silence_buff = (char *) g_malloc0(silence_bytes);
}
void Singleton::f2();{
    double rtp_time_prev = 0.0;
    double arrive_time_prev = 0.0;
    double pack_period = 0.0;
    double start_time = 0.0;
    double start_rtp_time = 0.0;
}
void Singleton::f3();{
void RtpAudioStream::addRtpPacket(const struct _packet_info *pinfo, const struct _rtp_info *rtp_info)
    // gtk/rtp_player.c:decode_rtp_packet
    if (!rtp_info) return;
    rtp_packet_t *rtp_packet = g_new0(rtp_packet_t, 1);
    rtp_packet->info = (struct _rtp_info *) g_memdup(rtp_info, sizeof(struct _rtp_info));
}
void Singleton::f4();{
    QString fmt_descr = QString("%1 Hz, ").arg(format.sampleRate());
    switch (format.sampleType()) {
    case QAudioFormat::SignedInt:
        fmt_descr += "Int";
        break;
}
void Singleton::f5();{
    // Silence is inserted to audio file only.
    // If inserted to visual_samples_ too, it shifts whole waveset
    //QVector<qint16> visual_fill(samples * visual_sample_rate_ / audio_out_rate_, 0);
    //visual_samples_ += visual_fill;
void RtpAudioStream::outputStateChanged(QAudio::State new_state)
}
void Singleton::f6();{
        start_abs_offset_ = nstime_to_sec(&pinfo->abs_ts) - start_rel_time_;
        start_rel_time_ = stop_rel_time_ = nstime_to_sec(&pinfo->rel_ts);
    }
    rtp_packet->frame_num = pinfo->num;
    rtp_packet->arrive_offset = nstime_to_sec(&pinfo->rel_ts) - start_rel_time_;
}
void Singleton::f7();{
        && rtpstream_id_equal_pinfo_rtp_info(&id_, pinfo, rtp_info))
        return true;
    return false;
// XXX We add multiple RTP streams here because that's what the GTK+ UI does.
// Should we make these distinct, with their own waveforms? It seems like
}
void Singleton::f8();{
        }
        if (audio_out_rate_ == 0) {
            // Use the first non-zero rate we find. Ajust it to match our audio hardware.
            QAudioDeviceInfo cur_out_device = QAudioDeviceInfo::defaultOutputDevice();
            QString cur_out_name = parent()->property("currentOutputDeviceName").toString();
}
void Singleton::f9();{
            last_sequence = rtp_packet->info->info_seq_num;
            g_free(decode_buff);
            continue;
        }
        if (audio_out_rate_ == 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    cur_play_pos_->setVisible(false);
    start_marker_pos_ = new QCPItemStraightLine(ui->audioPlot);
    start_marker_pos_->setPen(QPen(Qt::green,4));
    setStartPlayMarker(0);
    drawStartPlayMarker();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    cur_play_pos_->setVisible(false);
    start_marker_pos_ = new QCPItemStraightLine(ui->audioPlot);
    start_marker_pos_->setPen(QPen(Qt::green,4));
    setStartPlayMarker(0);
    drawStartPlayMarker();
}
void Singleton::f2();{
        if (audio_stream->jitterDropped() > 0) {
            // Jitter drops
            QCPGraph *seq_graph = ui->audioPlot->addGraph();
            seq_graph->setLineStyle(QCPGraph::lsNone);
            seq_graph->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, tango_scarlet_red_5, Qt::white, 4)); // Arbitrary
}
void Singleton::f3();{
    ui->audioPlot->setEnabled(true);
    ui->audioPlot->setInteractions(
                QCP::iRangeDrag |
                QCP::iRangeZoom
                );
}
void Singleton::f4();{
        QTreeWidgetItem *ti = ui->streamTreeWidget->topLevelItem(row);
        QCPGraph *audio_graph = ti->data(graph_data_col_, Qt::UserRole).value<QCPGraph*>();
        if (audio_graph) {
            audio_graph->setSelection(ti->isSelected() ? QCPDataSelection(QCPDataRange()) : QCPDataSelection());
        }
}
void Singleton::f5();{
    ui->outputDeviceComboBox->setEnabled(enable_play);
    ui->stopButton->setEnabled(enable_stop);
    cur_play_pos_->setVisible(enable_stop);
    ui->jitterSpinBox->setEnabled(enable_timing);
    ui->timingComboBox->setEnabled(enable_timing);
}
void Singleton::f6();{
    double move;
    rescanPackets();
    if (ui->todCheckBox->isChecked()) {
       // rel -> abs
       // based on abs time of first sample
}
void Singleton::f7();{
QString RtpPlayerDialog::currentOutputDeviceName()
    return ui->outputDeviceComboBox->currentText();
void RtpPlayerDialog::on_outputDeviceComboBox_currentIndexChanged(const QString &)
    rescanPackets();
void RtpPlayerDialog::on_jitterSpinBox_valueChanged(double)
}
void Singleton::f8();{
    x_axis->moveRange(move);
    drawStartPlayMarker();
    ui->audioPlot->replot();
void RtpPlayerDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_TELEPHONY_RTP_PLAYER_DIALOG);
}
void Singleton::f9();{
        ti->setData(graph_data_col_, Qt::UserRole, QVariant::fromValue<QCPGraph *>(audio_graph));
        RTP_STREAM_DEBUG("Plotting %s, %d samples", ti->text(src_addr_col_).toUtf8().constData(), audio_graph->data()->size());
        QString span_str = QString("%1 - %2 (%3)")
                .arg(QString::number(audio_stream->startRelTime(), 'g', 3))
                .arg(QString::number(audio_stream->stopRelTime(), 'g', 3))
}
void Singleton::f10();{
    playback_error_.clear();
    if (ui->todCheckBox->isChecked()) {
        start_time = start_marker_time_;
    } else {
        start_time = start_marker_time_ - first_stream_rel_start_time_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    cur_play_pos_->setVisible(false);
    start_marker_pos_ = new QCPItemStraightLine(ui->audioPlot);
    start_marker_pos_->setPen(QPen(Qt::green,4));
    setStartPlayMarker(0);
    drawStartPlayMarker();
}
void Singleton::f2();{
        if (audio_stream->jitterDropped() > 0) {
            // Jitter drops
            QCPGraph *seq_graph = ui->audioPlot->addGraph();
            seq_graph->setLineStyle(QCPGraph::lsNone);
            seq_graph->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, tango_scarlet_red_5, Qt::white, 4)); // Arbitrary
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    cur_play_pos_->setVisible(false);
    start_marker_pos_ = new QCPItemStraightLine(ui->audioPlot);
    start_marker_pos_->setPen(QPen(Qt::green,4));
    setStartPlayMarker(0);
    drawStartPlayMarker();
}
void Singleton::f2();{
        if (audio_stream->jitterDropped() > 0) {
            // Jitter drops
            QCPGraph *seq_graph = ui->audioPlot->addGraph();
            seq_graph->setLineStyle(QCPGraph::lsNone);
            seq_graph->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, tango_scarlet_red_5, Qt::white, 4)); // Arbitrary
}
void Singleton::f3();{
    ui->audioPlot->setEnabled(true);
    ui->audioPlot->setInteractions(
                QCP::iRangeDrag |
                QCP::iRangeZoom
                );
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    cur_play_pos_->setVisible(false);
    start_marker_pos_ = new QCPItemStraightLine(ui->audioPlot);
    start_marker_pos_->setPen(QPen(Qt::green,4));
    setStartPlayMarker(0);
    drawStartPlayMarker();
}
void Singleton::f2();{
        if (audio_stream->jitterDropped() > 0) {
            // Jitter drops
            QCPGraph *seq_graph = ui->audioPlot->addGraph();
            seq_graph->setLineStyle(QCPGraph::lsNone);
            seq_graph->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, tango_scarlet_red_5, Qt::white, 4)); // Arbitrary
}
void Singleton::f3();{
    ui->audioPlot->setEnabled(true);
    ui->audioPlot->setInteractions(
                QCP::iRangeDrag |
                QCP::iRangeZoom
                );
}
void Singleton::f4();{
        QTreeWidgetItem *ti = ui->streamTreeWidget->topLevelItem(row);
        QCPGraph *audio_graph = ti->data(graph_data_col_, Qt::UserRole).value<QCPGraph*>();
        if (audio_graph) {
            audio_graph->setSelection(ti->isSelected() ? QCPDataSelection(QCPDataRange()) : QCPDataSelection());
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    cur_play_pos_->setVisible(false);
    start_marker_pos_ = new QCPItemStraightLine(ui->audioPlot);
    start_marker_pos_->setPen(QPen(Qt::green,4));
    setStartPlayMarker(0);
    drawStartPlayMarker();
}
void Singleton::f2();{
        if (audio_stream->jitterDropped() > 0) {
            // Jitter drops
            QCPGraph *seq_graph = ui->audioPlot->addGraph();
            seq_graph->setLineStyle(QCPGraph::lsNone);
            seq_graph->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, tango_scarlet_red_5, Qt::white, 4)); // Arbitrary
}
void Singleton::f3();{
    ui->audioPlot->setEnabled(true);
    ui->audioPlot->setInteractions(
                QCP::iRangeDrag |
                QCP::iRangeZoom
                );
}
void Singleton::f4();{
        QTreeWidgetItem *ti = ui->streamTreeWidget->topLevelItem(row);
        QCPGraph *audio_graph = ti->data(graph_data_col_, Qt::UserRole).value<QCPGraph*>();
        if (audio_graph) {
            audio_graph->setSelection(ti->isSelected() ? QCPDataSelection(QCPDataRange()) : QCPDataSelection());
        }
}
void Singleton::f5();{
    ui->outputDeviceComboBox->setEnabled(enable_play);
    ui->stopButton->setEnabled(enable_stop);
    cur_play_pos_->setVisible(enable_stop);
    ui->jitterSpinBox->setEnabled(enable_timing);
    ui->timingComboBox->setEnabled(enable_timing);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    cur_play_pos_->setVisible(false);
    start_marker_pos_ = new QCPItemStraightLine(ui->audioPlot);
    start_marker_pos_->setPen(QPen(Qt::green,4));
    setStartPlayMarker(0);
    drawStartPlayMarker();
}
void Singleton::f2();{
        if (audio_stream->jitterDropped() > 0) {
            // Jitter drops
            QCPGraph *seq_graph = ui->audioPlot->addGraph();
            seq_graph->setLineStyle(QCPGraph::lsNone);
            seq_graph->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, tango_scarlet_red_5, Qt::white, 4)); // Arbitrary
}
void Singleton::f3();{
    ui->audioPlot->setEnabled(true);
    ui->audioPlot->setInteractions(
                QCP::iRangeDrag |
                QCP::iRangeZoom
                );
}
void Singleton::f4();{
        QTreeWidgetItem *ti = ui->streamTreeWidget->topLevelItem(row);
        QCPGraph *audio_graph = ti->data(graph_data_col_, Qt::UserRole).value<QCPGraph*>();
        if (audio_graph) {
            audio_graph->setSelection(ti->isSelected() ? QCPDataSelection(QCPDataRange()) : QCPDataSelection());
        }
}
void Singleton::f5();{
    ui->outputDeviceComboBox->setEnabled(enable_play);
    ui->stopButton->setEnabled(enable_stop);
    cur_play_pos_->setVisible(enable_stop);
    ui->jitterSpinBox->setEnabled(enable_timing);
    ui->timingComboBox->setEnabled(enable_timing);
}
void Singleton::f6();{
    double move;
    rescanPackets();
    if (ui->todCheckBox->isChecked()) {
       // rel -> abs
       // based on abs time of first sample
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    cur_play_pos_->setVisible(false);
    start_marker_pos_ = new QCPItemStraightLine(ui->audioPlot);
    start_marker_pos_->setPen(QPen(Qt::green,4));
    setStartPlayMarker(0);
    drawStartPlayMarker();
}
void Singleton::f2();{
        if (audio_stream->jitterDropped() > 0) {
            // Jitter drops
            QCPGraph *seq_graph = ui->audioPlot->addGraph();
            seq_graph->setLineStyle(QCPGraph::lsNone);
            seq_graph->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, tango_scarlet_red_5, Qt::white, 4)); // Arbitrary
}
void Singleton::f3();{
    ui->audioPlot->setEnabled(true);
    ui->audioPlot->setInteractions(
                QCP::iRangeDrag |
                QCP::iRangeZoom
                );
}
void Singleton::f4();{
        QTreeWidgetItem *ti = ui->streamTreeWidget->topLevelItem(row);
        QCPGraph *audio_graph = ti->data(graph_data_col_, Qt::UserRole).value<QCPGraph*>();
        if (audio_graph) {
            audio_graph->setSelection(ti->isSelected() ? QCPDataSelection(QCPDataRange()) : QCPDataSelection());
        }
}
void Singleton::f5();{
    ui->outputDeviceComboBox->setEnabled(enable_play);
    ui->stopButton->setEnabled(enable_stop);
    cur_play_pos_->setVisible(enable_stop);
    ui->jitterSpinBox->setEnabled(enable_timing);
    ui->timingComboBox->setEnabled(enable_timing);
}
void Singleton::f6();{
    double move;
    rescanPackets();
    if (ui->todCheckBox->isChecked()) {
       // rel -> abs
       // based on abs time of first sample
}
void Singleton::f7();{
QString RtpPlayerDialog::currentOutputDeviceName()
    return ui->outputDeviceComboBox->currentText();
void RtpPlayerDialog::on_outputDeviceComboBox_currentIndexChanged(const QString &)
    rescanPackets();
void RtpPlayerDialog::on_jitterSpinBox_valueChanged(double)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    cur_play_pos_->setVisible(false);
    start_marker_pos_ = new QCPItemStraightLine(ui->audioPlot);
    start_marker_pos_->setPen(QPen(Qt::green,4));
    setStartPlayMarker(0);
    drawStartPlayMarker();
}
void Singleton::f2();{
        if (audio_stream->jitterDropped() > 0) {
            // Jitter drops
            QCPGraph *seq_graph = ui->audioPlot->addGraph();
            seq_graph->setLineStyle(QCPGraph::lsNone);
            seq_graph->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, tango_scarlet_red_5, Qt::white, 4)); // Arbitrary
}
void Singleton::f3();{
    ui->audioPlot->setEnabled(true);
    ui->audioPlot->setInteractions(
                QCP::iRangeDrag |
                QCP::iRangeZoom
                );
}
void Singleton::f4();{
        QTreeWidgetItem *ti = ui->streamTreeWidget->topLevelItem(row);
        QCPGraph *audio_graph = ti->data(graph_data_col_, Qt::UserRole).value<QCPGraph*>();
        if (audio_graph) {
            audio_graph->setSelection(ti->isSelected() ? QCPDataSelection(QCPDataRange()) : QCPDataSelection());
        }
}
void Singleton::f5();{
    ui->outputDeviceComboBox->setEnabled(enable_play);
    ui->stopButton->setEnabled(enable_stop);
    cur_play_pos_->setVisible(enable_stop);
    ui->jitterSpinBox->setEnabled(enable_timing);
    ui->timingComboBox->setEnabled(enable_timing);
}
void Singleton::f6();{
    double move;
    rescanPackets();
    if (ui->todCheckBox->isChecked()) {
       // rel -> abs
       // based on abs time of first sample
}
void Singleton::f7();{
QString RtpPlayerDialog::currentOutputDeviceName()
    return ui->outputDeviceComboBox->currentText();
void RtpPlayerDialog::on_outputDeviceComboBox_currentIndexChanged(const QString &)
    rescanPackets();
void RtpPlayerDialog::on_jitterSpinBox_valueChanged(double)
}
void Singleton::f8();{
    x_axis->moveRange(move);
    drawStartPlayMarker();
    ui->audioPlot->replot();
void RtpPlayerDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_TELEPHONY_RTP_PLAYER_DIALOG);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    cur_play_pos_->setVisible(false);
    start_marker_pos_ = new QCPItemStraightLine(ui->audioPlot);
    start_marker_pos_->setPen(QPen(Qt::green,4));
    setStartPlayMarker(0);
    drawStartPlayMarker();
}
void Singleton::f2();{
        if (audio_stream->jitterDropped() > 0) {
            // Jitter drops
            QCPGraph *seq_graph = ui->audioPlot->addGraph();
            seq_graph->setLineStyle(QCPGraph::lsNone);
            seq_graph->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, tango_scarlet_red_5, Qt::white, 4)); // Arbitrary
}
void Singleton::f3();{
    ui->audioPlot->setEnabled(true);
    ui->audioPlot->setInteractions(
                QCP::iRangeDrag |
                QCP::iRangeZoom
                );
}
void Singleton::f4();{
        QTreeWidgetItem *ti = ui->streamTreeWidget->topLevelItem(row);
        QCPGraph *audio_graph = ti->data(graph_data_col_, Qt::UserRole).value<QCPGraph*>();
        if (audio_graph) {
            audio_graph->setSelection(ti->isSelected() ? QCPDataSelection(QCPDataRange()) : QCPDataSelection());
        }
}
void Singleton::f5();{
    ui->outputDeviceComboBox->setEnabled(enable_play);
    ui->stopButton->setEnabled(enable_stop);
    cur_play_pos_->setVisible(enable_stop);
    ui->jitterSpinBox->setEnabled(enable_timing);
    ui->timingComboBox->setEnabled(enable_timing);
}
void Singleton::f6();{
    double move;
    rescanPackets();
    if (ui->todCheckBox->isChecked()) {
       // rel -> abs
       // based on abs time of first sample
}
void Singleton::f7();{
QString RtpPlayerDialog::currentOutputDeviceName()
    return ui->outputDeviceComboBox->currentText();
void RtpPlayerDialog::on_outputDeviceComboBox_currentIndexChanged(const QString &)
    rescanPackets();
void RtpPlayerDialog::on_jitterSpinBox_valueChanged(double)
}
void Singleton::f8();{
    x_axis->moveRange(move);
    drawStartPlayMarker();
    ui->audioPlot->replot();
void RtpPlayerDialog::on_buttonBox_helpRequested()
    wsApp->helpTopicAction(HELP_TELEPHONY_RTP_PLAYER_DIALOG);
}
void Singleton::f9();{
        ti->setData(graph_data_col_, Qt::UserRole, QVariant::fromValue<QCPGraph *>(audio_graph));
        RTP_STREAM_DEBUG("Plotting %s, %d samples", ti->text(src_addr_col_).toUtf8().constData(), audio_graph->data()->size());
        QString span_str = QString("%1 - %2 (%3)")
                .arg(QString::number(audio_stream->startRelTime(), 'g', 3))
                .arg(QString::number(audio_stream->stopRelTime(), 'g', 3))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    tapinfo_.tap_data = this;
    tapinfo_.mode = TAP_ANALYSE;
    register_tap_listener_rtpstream(&tapinfo_, NULL, show_tap_registration_error);
    /* Scan for RTP streams (redissect all packets) */
    rtpstream_scan(&tapinfo_, cf.capFile(), NULL);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    tapinfo_.tap_data = this;
    tapinfo_.mode = TAP_ANALYSE;
    register_tap_listener_rtpstream(&tapinfo_, NULL, show_tap_registration_error);
    /* Scan for RTP streams (redissect all packets) */
    rtpstream_scan(&tapinfo_, cf.capFile(), NULL);
}
void Singleton::f2();{
    return false;
void RtpStreamDialog::tapReset(rtpstream_tapinfo_t *tapinfo)
    RtpStreamDialog *rtp_stream_dialog = dynamic_cast<RtpStreamDialog *>((RtpStreamDialog *)tapinfo->tap_data);
    if (rtp_stream_dialog) {
        /* invalidate items which refer to old strinfo_list items. */
}
void Singleton::f3();{
        QString filter = stream_filters.join(" || ");
        remove_tap_listener_rtpstream(&tapinfo_);
        emit updateFilter(filter);
    }
void RtpStreamDialog::on_actionSelectNone_triggered()
}
void Singleton::f4();{
        default:
            break;
        }
    }
    return false;
}
void Singleton::f5();{
    setWindowSubtitle(tr("RTP Streams"));
    ui->streamTreeWidget->installEventFilter(this);
    ctx_menu_.addAction(ui->actionSelectNone);
    ctx_menu_.addAction(ui->actionFindReverse);
    ctx_menu_.addAction(ui->actionGoToSetup);
}
void Singleton::f6();{
    }
    if (stream_a == NULL && stream_b == NULL) return;
    // XXX Mark the setup frame as well?
    need_redraw_ = false;
    rtpstream_mark(&tapinfo_, cap_file_.capFile(), stream_a, stream_b);
}
void Singleton::f7();{
    ui->actionGoToSetup->setEnabled(enable);
    ui->actionMarkPackets->setEnabled(enable);
    ui->actionPrepareFilter->setEnabled(enable);
    ui->actionExportAsRtpDump->setEnabled(enable);
    ui->actionCopyAsCsv->setEnabled(has_data);
}
void Singleton::f8();{
        case Qt::Key_A:
            // XXX "Shift+Ctrl+A" is a fairly standard shortcut for "select none".
            // However, the main window uses this for displaying the profile dialog.
//            if (keyEvent.modifiers() == (Qt::ControlModifier | Qt::ShiftModifier))
//                on_actionSelectNone_triggered();
}
void Singleton::f9();{
    ctx_menu_.addAction(ui->actionGoToSetup);
    ctx_menu_.addAction(ui->actionMarkPackets);
    ctx_menu_.addAction(ui->actionPrepareFilter);
    ctx_menu_.addAction(ui->actionExportAsRtpDump);
    ctx_menu_.addAction(ui->actionCopyAsCsv);
}
void Singleton::f10();{
    hint += "</i></small>";
    ui->hintLabel->setText(hint);
    bool enable = selected && !file_closed_;
    bool has_data = ui->streamTreeWidget->topLevelItemCount() > 0;
    find_reverse_button_->setEnabled(enable);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    tapinfo_.tap_data = this;
    tapinfo_.mode = TAP_ANALYSE;
    register_tap_listener_rtpstream(&tapinfo_, NULL, show_tap_registration_error);
    /* Scan for RTP streams (redissect all packets) */
    rtpstream_scan(&tapinfo_, cf.capFile(), NULL);
}
void Singleton::f2();{
    return false;
void RtpStreamDialog::tapReset(rtpstream_tapinfo_t *tapinfo)
    RtpStreamDialog *rtp_stream_dialog = dynamic_cast<RtpStreamDialog *>((RtpStreamDialog *)tapinfo->tap_data);
    if (rtp_stream_dialog) {
        /* invalidate items which refer to old strinfo_list items. */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    tapinfo_.tap_data = this;
    tapinfo_.mode = TAP_ANALYSE;
    register_tap_listener_rtpstream(&tapinfo_, NULL, show_tap_registration_error);
    /* Scan for RTP streams (redissect all packets) */
    rtpstream_scan(&tapinfo_, cf.capFile(), NULL);
}
void Singleton::f2();{
    return false;
void RtpStreamDialog::tapReset(rtpstream_tapinfo_t *tapinfo)
    RtpStreamDialog *rtp_stream_dialog = dynamic_cast<RtpStreamDialog *>((RtpStreamDialog *)tapinfo->tap_data);
    if (rtp_stream_dialog) {
        /* invalidate items which refer to old strinfo_list items. */
}
void Singleton::f3();{
        QString filter = stream_filters.join(" || ");
        remove_tap_listener_rtpstream(&tapinfo_);
        emit updateFilter(filter);
    }
void RtpStreamDialog::on_actionSelectNone_triggered()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    tapinfo_.tap_data = this;
    tapinfo_.mode = TAP_ANALYSE;
    register_tap_listener_rtpstream(&tapinfo_, NULL, show_tap_registration_error);
    /* Scan for RTP streams (redissect all packets) */
    rtpstream_scan(&tapinfo_, cf.capFile(), NULL);
}
void Singleton::f2();{
    return false;
void RtpStreamDialog::tapReset(rtpstream_tapinfo_t *tapinfo)
    RtpStreamDialog *rtp_stream_dialog = dynamic_cast<RtpStreamDialog *>((RtpStreamDialog *)tapinfo->tap_data);
    if (rtp_stream_dialog) {
        /* invalidate items which refer to old strinfo_list items. */
}
void Singleton::f3();{
        QString filter = stream_filters.join(" || ");
        remove_tap_listener_rtpstream(&tapinfo_);
        emit updateFilter(filter);
    }
void RtpStreamDialog::on_actionSelectNone_triggered()
}
void Singleton::f4();{
        default:
            break;
        }
    }
    return false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    tapinfo_.tap_data = this;
    tapinfo_.mode = TAP_ANALYSE;
    register_tap_listener_rtpstream(&tapinfo_, NULL, show_tap_registration_error);
    /* Scan for RTP streams (redissect all packets) */
    rtpstream_scan(&tapinfo_, cf.capFile(), NULL);
}
void Singleton::f2();{
    return false;
void RtpStreamDialog::tapReset(rtpstream_tapinfo_t *tapinfo)
    RtpStreamDialog *rtp_stream_dialog = dynamic_cast<RtpStreamDialog *>((RtpStreamDialog *)tapinfo->tap_data);
    if (rtp_stream_dialog) {
        /* invalidate items which refer to old strinfo_list items. */
}
void Singleton::f3();{
        QString filter = stream_filters.join(" || ");
        remove_tap_listener_rtpstream(&tapinfo_);
        emit updateFilter(filter);
    }
void RtpStreamDialog::on_actionSelectNone_triggered()
}
void Singleton::f4();{
        default:
            break;
        }
    }
    return false;
}
void Singleton::f5();{
    setWindowSubtitle(tr("RTP Streams"));
    ui->streamTreeWidget->installEventFilter(this);
    ctx_menu_.addAction(ui->actionSelectNone);
    ctx_menu_.addAction(ui->actionFindReverse);
    ctx_menu_.addAction(ui->actionGoToSetup);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    tapinfo_.tap_data = this;
    tapinfo_.mode = TAP_ANALYSE;
    register_tap_listener_rtpstream(&tapinfo_, NULL, show_tap_registration_error);
    /* Scan for RTP streams (redissect all packets) */
    rtpstream_scan(&tapinfo_, cf.capFile(), NULL);
}
void Singleton::f2();{
    return false;
void RtpStreamDialog::tapReset(rtpstream_tapinfo_t *tapinfo)
    RtpStreamDialog *rtp_stream_dialog = dynamic_cast<RtpStreamDialog *>((RtpStreamDialog *)tapinfo->tap_data);
    if (rtp_stream_dialog) {
        /* invalidate items which refer to old strinfo_list items. */
}
void Singleton::f3();{
        QString filter = stream_filters.join(" || ");
        remove_tap_listener_rtpstream(&tapinfo_);
        emit updateFilter(filter);
    }
void RtpStreamDialog::on_actionSelectNone_triggered()
}
void Singleton::f4();{
        default:
            break;
        }
    }
    return false;
}
void Singleton::f5();{
    setWindowSubtitle(tr("RTP Streams"));
    ui->streamTreeWidget->installEventFilter(this);
    ctx_menu_.addAction(ui->actionSelectNone);
    ctx_menu_.addAction(ui->actionFindReverse);
    ctx_menu_.addAction(ui->actionGoToSetup);
}
void Singleton::f6();{
    }
    if (stream_a == NULL && stream_b == NULL) return;
    // XXX Mark the setup frame as well?
    need_redraw_ = false;
    rtpstream_mark(&tapinfo_, cap_file_.capFile(), stream_a, stream_b);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    tapinfo_.tap_data = this;
    tapinfo_.mode = TAP_ANALYSE;
    register_tap_listener_rtpstream(&tapinfo_, NULL, show_tap_registration_error);
    /* Scan for RTP streams (redissect all packets) */
    rtpstream_scan(&tapinfo_, cf.capFile(), NULL);
}
void Singleton::f2();{
    return false;
void RtpStreamDialog::tapReset(rtpstream_tapinfo_t *tapinfo)
    RtpStreamDialog *rtp_stream_dialog = dynamic_cast<RtpStreamDialog *>((RtpStreamDialog *)tapinfo->tap_data);
    if (rtp_stream_dialog) {
        /* invalidate items which refer to old strinfo_list items. */
}
void Singleton::f3();{
        QString filter = stream_filters.join(" || ");
        remove_tap_listener_rtpstream(&tapinfo_);
        emit updateFilter(filter);
    }
void RtpStreamDialog::on_actionSelectNone_triggered()
}
void Singleton::f4();{
        default:
            break;
        }
    }
    return false;
}
void Singleton::f5();{
    setWindowSubtitle(tr("RTP Streams"));
    ui->streamTreeWidget->installEventFilter(this);
    ctx_menu_.addAction(ui->actionSelectNone);
    ctx_menu_.addAction(ui->actionFindReverse);
    ctx_menu_.addAction(ui->actionGoToSetup);
}
void Singleton::f6();{
    }
    if (stream_a == NULL && stream_b == NULL) return;
    // XXX Mark the setup frame as well?
    need_redraw_ = false;
    rtpstream_mark(&tapinfo_, cap_file_.capFile(), stream_a, stream_b);
}
void Singleton::f7();{
    ui->actionGoToSetup->setEnabled(enable);
    ui->actionMarkPackets->setEnabled(enable);
    ui->actionPrepareFilter->setEnabled(enable);
    ui->actionExportAsRtpDump->setEnabled(enable);
    ui->actionCopyAsCsv->setEnabled(has_data);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    tapinfo_.tap_data = this;
    tapinfo_.mode = TAP_ANALYSE;
    register_tap_listener_rtpstream(&tapinfo_, NULL, show_tap_registration_error);
    /* Scan for RTP streams (redissect all packets) */
    rtpstream_scan(&tapinfo_, cf.capFile(), NULL);
}
void Singleton::f2();{
    return false;
void RtpStreamDialog::tapReset(rtpstream_tapinfo_t *tapinfo)
    RtpStreamDialog *rtp_stream_dialog = dynamic_cast<RtpStreamDialog *>((RtpStreamDialog *)tapinfo->tap_data);
    if (rtp_stream_dialog) {
        /* invalidate items which refer to old strinfo_list items. */
}
void Singleton::f3();{
        QString filter = stream_filters.join(" || ");
        remove_tap_listener_rtpstream(&tapinfo_);
        emit updateFilter(filter);
    }
void RtpStreamDialog::on_actionSelectNone_triggered()
}
void Singleton::f4();{
        default:
            break;
        }
    }
    return false;
}
void Singleton::f5();{
    setWindowSubtitle(tr("RTP Streams"));
    ui->streamTreeWidget->installEventFilter(this);
    ctx_menu_.addAction(ui->actionSelectNone);
    ctx_menu_.addAction(ui->actionFindReverse);
    ctx_menu_.addAction(ui->actionGoToSetup);
}
void Singleton::f6();{
    }
    if (stream_a == NULL && stream_b == NULL) return;
    // XXX Mark the setup frame as well?
    need_redraw_ = false;
    rtpstream_mark(&tapinfo_, cap_file_.capFile(), stream_a, stream_b);
}
void Singleton::f7();{
    ui->actionGoToSetup->setEnabled(enable);
    ui->actionMarkPackets->setEnabled(enable);
    ui->actionPrepareFilter->setEnabled(enable);
    ui->actionExportAsRtpDump->setEnabled(enable);
    ui->actionCopyAsCsv->setEnabled(has_data);
}
void Singleton::f8();{
        case Qt::Key_A:
            // XXX "Shift+Ctrl+A" is a fairly standard shortcut for "select none".
            // However, the main window uses this for displaying the profile dialog.
//            if (keyEvent.modifiers() == (Qt::ControlModifier | Qt::ShiftModifier))
//                on_actionSelectNone_triggered();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    tapinfo_.tap_data = this;
    tapinfo_.mode = TAP_ANALYSE;
    register_tap_listener_rtpstream(&tapinfo_, NULL, show_tap_registration_error);
    /* Scan for RTP streams (redissect all packets) */
    rtpstream_scan(&tapinfo_, cf.capFile(), NULL);
}
void Singleton::f2();{
    return false;
void RtpStreamDialog::tapReset(rtpstream_tapinfo_t *tapinfo)
    RtpStreamDialog *rtp_stream_dialog = dynamic_cast<RtpStreamDialog *>((RtpStreamDialog *)tapinfo->tap_data);
    if (rtp_stream_dialog) {
        /* invalidate items which refer to old strinfo_list items. */
}
void Singleton::f3();{
        QString filter = stream_filters.join(" || ");
        remove_tap_listener_rtpstream(&tapinfo_);
        emit updateFilter(filter);
    }
void RtpStreamDialog::on_actionSelectNone_triggered()
}
void Singleton::f4();{
        default:
            break;
        }
    }
    return false;
}
void Singleton::f5();{
    setWindowSubtitle(tr("RTP Streams"));
    ui->streamTreeWidget->installEventFilter(this);
    ctx_menu_.addAction(ui->actionSelectNone);
    ctx_menu_.addAction(ui->actionFindReverse);
    ctx_menu_.addAction(ui->actionGoToSetup);
}
void Singleton::f6();{
    }
    if (stream_a == NULL && stream_b == NULL) return;
    // XXX Mark the setup frame as well?
    need_redraw_ = false;
    rtpstream_mark(&tapinfo_, cap_file_.capFile(), stream_a, stream_b);
}
void Singleton::f7();{
    ui->actionGoToSetup->setEnabled(enable);
    ui->actionMarkPackets->setEnabled(enable);
    ui->actionPrepareFilter->setEnabled(enable);
    ui->actionExportAsRtpDump->setEnabled(enable);
    ui->actionCopyAsCsv->setEnabled(has_data);
}
void Singleton::f8();{
        case Qt::Key_A:
            // XXX "Shift+Ctrl+A" is a fairly standard shortcut for "select none".
            // However, the main window uses this for displaying the profile dialog.
//            if (keyEvent.modifiers() == (Qt::ControlModifier | Qt::ShiftModifier))
//                on_actionSelectNone_triggered();
}
void Singleton::f9();{
    ctx_menu_.addAction(ui->actionGoToSetup);
    ctx_menu_.addAction(ui->actionMarkPackets);
    ctx_menu_.addAction(ui->actionPrepareFilter);
    ctx_menu_.addAction(ui->actionExportAsRtpDump);
    ctx_menu_.addAction(ui->actionCopyAsCsv);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
        friend class Client;
        ClientImpl() : conn(0), cbIndex(0), maxBufSize(65535), minSsf(0), maxSsf(65535), externalSsf(0), secret(0) {}
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
        friend class Client;
        ClientImpl() : conn(0), cbIndex(0), maxBufSize(65535), minSsf(0), maxSsf(65535), externalSsf(0), secret(0) {}
}
void Singleton::f2();{
        uint32_t maxBufSize;
        uint32_t minSsf;
        uint32_t maxSsf;
        uint32_t externalSsf;
        sasl_secret_t* secret;
}
void Singleton::f3();{
            return false;
        }
    }
    return true;
bool ClientImpl::setAttr(const string& key, const string& value)
}
void Singleton::f4();{
        userName = value;
    else if (key == "authname")
        authName = value;
    else if (key == "password") {
        password = value;
}
void Singleton::f5();{
    if (id == SASL_CB_USER || (id == SASL_CB_AUTHNAME && impl->authName.empty())) {
        *result = impl->userName.c_str();
        //*len    = impl->userName.length();
    } else if (id == SASL_CB_AUTHNAME) {
        *result = impl->authName.c_str();
}
void Singleton::f6();{
 * under the License.
using namespace std;
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
}
void Singleton::f7();{
            setError("sasl_setprop(SASL_AUTH_EXTERNAL)", result);
            sasl_dispose(&conn);
            conn = 0;
            return false;
        }
}
void Singleton::f8();{
Client::Client() : impl(new ClientImpl()) {}
Client::~Client() { delete impl; }
bool Client::setAttr(const string& key, const string& value) { return impl->setAttr(key, value); }
bool Client::setAttr(const string& key, uint32_t value) { return impl->setAttr(key, value); }
bool Client::init() { return impl->init(); }
}
void Singleton::f9();{
bool ClientImpl::getUserId(output_string& userId)
    int result;
    const char* operName;
    result = sasl_getprop(conn, SASL_USERNAME, (const void**) &operName);
    if (result != SASL_OK) {
}
void Singleton::f10();{
        }
    }
    return true;
bool ClientImpl::setAttr(const string& key, const string& value)
    if (key == "service")
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
        friend class Client;
        ClientImpl() : conn(0), cbIndex(0), maxBufSize(65535), minSsf(0), maxSsf(65535), externalSsf(0), secret(0) {}
}
void Singleton::f2();{
        uint32_t maxBufSize;
        uint32_t minSsf;
        uint32_t maxSsf;
        uint32_t externalSsf;
        sasl_secret_t* secret;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
        friend class Client;
        ClientImpl() : conn(0), cbIndex(0), maxBufSize(65535), minSsf(0), maxSsf(65535), externalSsf(0), secret(0) {}
}
void Singleton::f2();{
        uint32_t maxBufSize;
        uint32_t minSsf;
        uint32_t maxSsf;
        uint32_t externalSsf;
        sasl_secret_t* secret;
}
void Singleton::f3();{
            return false;
        }
    }
    return true;
bool ClientImpl::setAttr(const string& key, const string& value)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
        friend class Client;
        ClientImpl() : conn(0), cbIndex(0), maxBufSize(65535), minSsf(0), maxSsf(65535), externalSsf(0), secret(0) {}
}
void Singleton::f2();{
        uint32_t maxBufSize;
        uint32_t minSsf;
        uint32_t maxSsf;
        uint32_t externalSsf;
        sasl_secret_t* secret;
}
void Singleton::f3();{
            return false;
        }
    }
    return true;
bool ClientImpl::setAttr(const string& key, const string& value)
}
void Singleton::f4();{
        userName = value;
    else if (key == "authname")
        authName = value;
    else if (key == "password") {
        password = value;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
        friend class Client;
        ClientImpl() : conn(0), cbIndex(0), maxBufSize(65535), minSsf(0), maxSsf(65535), externalSsf(0), secret(0) {}
}
void Singleton::f2();{
        uint32_t maxBufSize;
        uint32_t minSsf;
        uint32_t maxSsf;
        uint32_t externalSsf;
        sasl_secret_t* secret;
}
void Singleton::f3();{
            return false;
        }
    }
    return true;
bool ClientImpl::setAttr(const string& key, const string& value)
}
void Singleton::f4();{
        userName = value;
    else if (key == "authname")
        authName = value;
    else if (key == "password") {
        password = value;
}
void Singleton::f5();{
    if (id == SASL_CB_USER || (id == SASL_CB_AUTHNAME && impl->authName.empty())) {
        *result = impl->userName.c_str();
        //*len    = impl->userName.length();
    } else if (id == SASL_CB_AUTHNAME) {
        *result = impl->authName.c_str();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
        friend class Client;
        ClientImpl() : conn(0), cbIndex(0), maxBufSize(65535), minSsf(0), maxSsf(65535), externalSsf(0), secret(0) {}
}
void Singleton::f2();{
        uint32_t maxBufSize;
        uint32_t minSsf;
        uint32_t maxSsf;
        uint32_t externalSsf;
        sasl_secret_t* secret;
}
void Singleton::f3();{
            return false;
        }
    }
    return true;
bool ClientImpl::setAttr(const string& key, const string& value)
}
void Singleton::f4();{
        userName = value;
    else if (key == "authname")
        authName = value;
    else if (key == "password") {
        password = value;
}
void Singleton::f5();{
    if (id == SASL_CB_USER || (id == SASL_CB_AUTHNAME && impl->authName.empty())) {
        *result = impl->userName.c_str();
        //*len    = impl->userName.length();
    } else if (id == SASL_CB_AUTHNAME) {
        *result = impl->authName.c_str();
}
void Singleton::f6();{
 * under the License.
using namespace std;
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
        friend class Client;
        ClientImpl() : conn(0), cbIndex(0), maxBufSize(65535), minSsf(0), maxSsf(65535), externalSsf(0), secret(0) {}
}
void Singleton::f2();{
        uint32_t maxBufSize;
        uint32_t minSsf;
        uint32_t maxSsf;
        uint32_t externalSsf;
        sasl_secret_t* secret;
}
void Singleton::f3();{
            return false;
        }
    }
    return true;
bool ClientImpl::setAttr(const string& key, const string& value)
}
void Singleton::f4();{
        userName = value;
    else if (key == "authname")
        authName = value;
    else if (key == "password") {
        password = value;
}
void Singleton::f5();{
    if (id == SASL_CB_USER || (id == SASL_CB_AUTHNAME && impl->authName.empty())) {
        *result = impl->userName.c_str();
        //*len    = impl->userName.length();
    } else if (id == SASL_CB_AUTHNAME) {
        *result = impl->authName.c_str();
}
void Singleton::f6();{
 * under the License.
using namespace std;
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
}
void Singleton::f7();{
            setError("sasl_setprop(SASL_AUTH_EXTERNAL)", result);
            sasl_dispose(&conn);
            conn = 0;
            return false;
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
        friend class Client;
        ClientImpl() : conn(0), cbIndex(0), maxBufSize(65535), minSsf(0), maxSsf(65535), externalSsf(0), secret(0) {}
}
void Singleton::f2();{
        uint32_t maxBufSize;
        uint32_t minSsf;
        uint32_t maxSsf;
        uint32_t externalSsf;
        sasl_secret_t* secret;
}
void Singleton::f3();{
            return false;
        }
    }
    return true;
bool ClientImpl::setAttr(const string& key, const string& value)
}
void Singleton::f4();{
        userName = value;
    else if (key == "authname")
        authName = value;
    else if (key == "password") {
        password = value;
}
void Singleton::f5();{
    if (id == SASL_CB_USER || (id == SASL_CB_AUTHNAME && impl->authName.empty())) {
        *result = impl->userName.c_str();
        //*len    = impl->userName.length();
    } else if (id == SASL_CB_AUTHNAME) {
        *result = impl->authName.c_str();
}
void Singleton::f6();{
 * under the License.
using namespace std;
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
}
void Singleton::f7();{
            setError("sasl_setprop(SASL_AUTH_EXTERNAL)", result);
            sasl_dispose(&conn);
            conn = 0;
            return false;
        }
}
void Singleton::f8();{
Client::Client() : impl(new ClientImpl()) {}
Client::~Client() { delete impl; }
bool Client::setAttr(const string& key, const string& value) { return impl->setAttr(key, value); }
bool Client::setAttr(const string& key, uint32_t value) { return impl->setAttr(key, value); }
bool Client::init() { return impl->init(); }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
        friend class Client;
        ClientImpl() : conn(0), cbIndex(0), maxBufSize(65535), minSsf(0), maxSsf(65535), externalSsf(0), secret(0) {}
}
void Singleton::f2();{
        uint32_t maxBufSize;
        uint32_t minSsf;
        uint32_t maxSsf;
        uint32_t externalSsf;
        sasl_secret_t* secret;
}
void Singleton::f3();{
            return false;
        }
    }
    return true;
bool ClientImpl::setAttr(const string& key, const string& value)
}
void Singleton::f4();{
        userName = value;
    else if (key == "authname")
        authName = value;
    else if (key == "password") {
        password = value;
}
void Singleton::f5();{
    if (id == SASL_CB_USER || (id == SASL_CB_AUTHNAME && impl->authName.empty())) {
        *result = impl->userName.c_str();
        //*len    = impl->userName.length();
    } else if (id == SASL_CB_AUTHNAME) {
        *result = impl->authName.c_str();
}
void Singleton::f6();{
 * under the License.
using namespace std;
using namespace saslwrapper;
namespace saslwrapper {
    class ClientImpl {
}
void Singleton::f7();{
            setError("sasl_setprop(SASL_AUTH_EXTERNAL)", result);
            sasl_dispose(&conn);
            conn = 0;
            return false;
        }
}
void Singleton::f8();{
Client::Client() : impl(new ClientImpl()) {}
Client::~Client() { delete impl; }
bool Client::setAttr(const string& key, const string& value) { return impl->setAttr(key, value); }
bool Client::setAttr(const string& key, uint32_t value) { return impl->setAttr(key, value); }
bool Client::init() { return impl->init(); }
}
void Singleton::f9();{
bool ClientImpl::getUserId(output_string& userId)
    int result;
    const char* operName;
    result = sasl_getprop(conn, SASL_USERNAME, (const void**) &operName);
    if (result != SASL_OK) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    ui(new Ui::SCTPAllAssocsDialog),
    cap_file_(cf)
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    ui(new Ui::SCTPAllAssocsDialog),
    cap_file_(cf)
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
}
void Singleton::f2();{
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    fillTable();
SCTPAllAssocsDialog::~SCTPAllAssocsDialog()
}
void Singleton::f3();{
    ui->assocList->setColumnWidth(3,  150);
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
}
void Singleton::f4();{
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
        /*  (redissect all packets) */
}
void Singleton::f5();{
    }
    numAssocs = 0;
    ui->assocList->setRowCount(static_cast<int>(g_list_length(sctp_assocs->assoc_info_list)));
    list = g_list_first(sctp_assocs->assoc_info_list);
    while (list) {
}
void Singleton::f6();{
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
}
void Singleton::f7();{
    GList *list;
    const sctp_assoc_info_t* assinfo;
    int numAssocs;
    ui->assocList->setColumnHidden(0, true);
    ui->assocList->setColumnWidth(1,  85);
}
void Singleton::f8();{
        register_tap_listener_sctp_stat();
        /*  (redissect all packets) */
        cf_retap_packets(cap_file_);
    }
    numAssocs = 0;
}
void Singleton::f9();{
    int numAssocs;
    ui->assocList->setColumnHidden(0, true);
    ui->assocList->setColumnWidth(1,  85);
    ui->assocList->setColumnWidth(2,  85);
    ui->assocList->setColumnWidth(3,  150);
}
void Singleton::f10();{
    sctp_analyse->raise();
    sctp_analyse->activateWindow();
void SCTPAllAssocsDialog::on_setFilterButton_clicked()
    QString newFilter = QString("sctp.assoc_index==%1").arg(selected_assoc_id);
    emit filterPackets(newFilter, false);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    ui(new Ui::SCTPAllAssocsDialog),
    cap_file_(cf)
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
}
void Singleton::f2();{
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    fillTable();
SCTPAllAssocsDialog::~SCTPAllAssocsDialog()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    ui(new Ui::SCTPAllAssocsDialog),
    cap_file_(cf)
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
}
void Singleton::f2();{
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    fillTable();
SCTPAllAssocsDialog::~SCTPAllAssocsDialog()
}
void Singleton::f3();{
    ui->assocList->setColumnWidth(3,  150);
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    ui(new Ui::SCTPAllAssocsDialog),
    cap_file_(cf)
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
}
void Singleton::f2();{
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    fillTable();
SCTPAllAssocsDialog::~SCTPAllAssocsDialog()
}
void Singleton::f3();{
    ui->assocList->setColumnWidth(3,  150);
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
}
void Singleton::f4();{
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
        /*  (redissect all packets) */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    ui(new Ui::SCTPAllAssocsDialog),
    cap_file_(cf)
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
}
void Singleton::f2();{
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    fillTable();
SCTPAllAssocsDialog::~SCTPAllAssocsDialog()
}
void Singleton::f3();{
    ui->assocList->setColumnWidth(3,  150);
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
}
void Singleton::f4();{
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
        /*  (redissect all packets) */
}
void Singleton::f5();{
    }
    numAssocs = 0;
    ui->assocList->setRowCount(static_cast<int>(g_list_length(sctp_assocs->assoc_info_list)));
    list = g_list_first(sctp_assocs->assoc_info_list);
    while (list) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    ui(new Ui::SCTPAllAssocsDialog),
    cap_file_(cf)
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
}
void Singleton::f2();{
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    fillTable();
SCTPAllAssocsDialog::~SCTPAllAssocsDialog()
}
void Singleton::f3();{
    ui->assocList->setColumnWidth(3,  150);
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
}
void Singleton::f4();{
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
        /*  (redissect all packets) */
}
void Singleton::f5();{
    }
    numAssocs = 0;
    ui->assocList->setRowCount(static_cast<int>(g_list_length(sctp_assocs->assoc_info_list)));
    list = g_list_first(sctp_assocs->assoc_info_list);
    while (list) {
}
void Singleton::f6();{
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    ui(new Ui::SCTPAllAssocsDialog),
    cap_file_(cf)
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
}
void Singleton::f2();{
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    fillTable();
SCTPAllAssocsDialog::~SCTPAllAssocsDialog()
}
void Singleton::f3();{
    ui->assocList->setColumnWidth(3,  150);
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
}
void Singleton::f4();{
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
        /*  (redissect all packets) */
}
void Singleton::f5();{
    }
    numAssocs = 0;
    ui->assocList->setRowCount(static_cast<int>(g_list_length(sctp_assocs->assoc_info_list)));
    list = g_list_first(sctp_assocs->assoc_info_list);
    while (list) {
}
void Singleton::f6();{
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
}
void Singleton::f7();{
    GList *list;
    const sctp_assoc_info_t* assinfo;
    int numAssocs;
    ui->assocList->setColumnHidden(0, true);
    ui->assocList->setColumnWidth(1,  85);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    ui(new Ui::SCTPAllAssocsDialog),
    cap_file_(cf)
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
}
void Singleton::f2();{
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    fillTable();
SCTPAllAssocsDialog::~SCTPAllAssocsDialog()
}
void Singleton::f3();{
    ui->assocList->setColumnWidth(3,  150);
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
}
void Singleton::f4();{
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
        /*  (redissect all packets) */
}
void Singleton::f5();{
    }
    numAssocs = 0;
    ui->assocList->setRowCount(static_cast<int>(g_list_length(sctp_assocs->assoc_info_list)));
    list = g_list_first(sctp_assocs->assoc_info_list);
    while (list) {
}
void Singleton::f6();{
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
}
void Singleton::f7();{
    GList *list;
    const sctp_assoc_info_t* assinfo;
    int numAssocs;
    ui->assocList->setColumnHidden(0, true);
    ui->assocList->setColumnWidth(1,  85);
}
void Singleton::f8();{
        register_tap_listener_sctp_stat();
        /*  (redissect all packets) */
        cf_retap_packets(cap_file_);
    }
    numAssocs = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    ui(new Ui::SCTPAllAssocsDialog),
    cap_file_(cf)
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
}
void Singleton::f2();{
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    fillTable();
SCTPAllAssocsDialog::~SCTPAllAssocsDialog()
}
void Singleton::f3();{
    ui->assocList->setColumnWidth(3,  150);
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
}
void Singleton::f4();{
    ui->assocList->setColumnWidth(4,  150);
    sctp_assocs = sctp_stat_get_info();
    if (sctp_assocs->is_registered == FALSE) {
        register_tap_listener_sctp_stat();
        /*  (redissect all packets) */
}
void Singleton::f5();{
    }
    numAssocs = 0;
    ui->assocList->setRowCount(static_cast<int>(g_list_length(sctp_assocs->assoc_info_list)));
    list = g_list_first(sctp_assocs->assoc_info_list);
    while (list) {
}
void Singleton::f6();{
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
}
void Singleton::f7();{
    GList *list;
    const sctp_assoc_info_t* assinfo;
    int numAssocs;
    ui->assocList->setColumnHidden(0, true);
    ui->assocList->setColumnWidth(1,  85);
}
void Singleton::f8();{
        register_tap_listener_sctp_stat();
        /*  (redissect all packets) */
        cf_retap_packets(cap_file_);
    }
    numAssocs = 0;
}
void Singleton::f9();{
    int numAssocs;
    ui->assocList->setColumnHidden(0, true);
    ui->assocList->setColumnWidth(1,  85);
    ui->assocList->setColumnWidth(2,  85);
    ui->assocList->setColumnWidth(3,  150);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    fillTabs(assoc);
SCTPAssocAnalyseDialog::~SCTPAssocAnalyseDialog()
    delete ui;
const sctp_assoc_info_t* SCTPAssocAnalyseDialog::findAssocForPacket(capture_file* cf)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    fillTabs(assoc);
SCTPAssocAnalyseDialog::~SCTPAssocAnalyseDialog()
    delete ui;
const sctp_assoc_info_t* SCTPAssocAnalyseDialog::findAssocForPacket(capture_file* cf)
}
void Singleton::f2();{
            fn = GPOINTER_TO_UINT(framelist->data);
            if (fn == fdata->num) {
                frame_found = TRUE;
                break;
            }
}
void Singleton::f3();{
/* sctp_assoc_analyse_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
                                               selected_assoc->outstream2 : selected_assoc->instream1)));
        ui->label_215->setText(QString(tr("Provided Number of Outbound Streams:")));
        ui->label_225->setText(QString("%1").arg(selected_assoc->outstream1));
        ui->label_216->setText(QString(tr("Minimum Number of Outbound Streams:")));
        ui->label_226->setText(QString("%1").arg(((selected_assoc->outstream1 > selected_assoc->instream2) ?
}
void Singleton::f5();{
        ui->label_215->setText(QString(""));
        ui->label_225->setText(QString(""));
        ui->label_216->setText(QString(""));
        ui->label_226->setText(QString(""));
    }
}
void Singleton::f6();{
    openGraphDialog(2);
void SCTPAssocAnalyseDialog::on_GraphTSN_1_clicked()
    openGraphDialog(1);
void SCTPAssocAnalyseDialog::on_chunkStatisticsButton_clicked()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
}
void Singleton::f7();{
        ui->label_326->setText(QString("%1").arg(((selected_assoc->outstream2 > selected_assoc->instream1) ?
                                                      selected_assoc->instream1 : selected_assoc->outstream2)));
    } else {
        ui->label_313->setText(QString(tr("Used Number of Inbound Streams:")));
        ui->label_323->setText(QString("%1").arg(selected_assoc->instream2));
}
void Singleton::f8();{
    /* Tab Endpoint 2 */
    if ((selected_assoc->initack) && (selected_assoc->initack_dir == 2))
        ui->labelEP2->setText(QString(tr("Complete list of IP-Addresses as provided in the INITACK-Chunk")));
    else
        ui->labelEP2->setText(QString(tr("List of used IP-Addresses")));
}
void Singleton::f9();{
    if (selected_assoc->init)
            ui->labelEP1->setText(QString(tr("Complete list of IP-Addresses as provided in the INIT-Chunk")));
        else if ((selected_assoc->initack) && (selected_assoc->initack_dir == 1))
            ui->labelEP1->setText(QString(tr("Complete list of IP-Addresses as provided in the INITACK-Chunk")));
        else
}
void Singleton::f10();{
    ui(new Ui::SCTPAssocAnalyseDialog),
    cap_file_(cf)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    fillTabs(assoc);
SCTPAssocAnalyseDialog::~SCTPAssocAnalyseDialog()
    delete ui;
const sctp_assoc_info_t* SCTPAssocAnalyseDialog::findAssocForPacket(capture_file* cf)
}
void Singleton::f2();{
            fn = GPOINTER_TO_UINT(framelist->data);
            if (fn == fdata->num) {
                frame_found = TRUE;
                break;
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    fillTabs(assoc);
SCTPAssocAnalyseDialog::~SCTPAssocAnalyseDialog()
    delete ui;
const sctp_assoc_info_t* SCTPAssocAnalyseDialog::findAssocForPacket(capture_file* cf)
}
void Singleton::f2();{
            fn = GPOINTER_TO_UINT(framelist->data);
            if (fn == fdata->num) {
                frame_found = TRUE;
                break;
            }
}
void Singleton::f3();{
/* sctp_assoc_analyse_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    fillTabs(assoc);
SCTPAssocAnalyseDialog::~SCTPAssocAnalyseDialog()
    delete ui;
const sctp_assoc_info_t* SCTPAssocAnalyseDialog::findAssocForPacket(capture_file* cf)
}
void Singleton::f2();{
            fn = GPOINTER_TO_UINT(framelist->data);
            if (fn == fdata->num) {
                frame_found = TRUE;
                break;
            }
}
void Singleton::f3();{
/* sctp_assoc_analyse_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
                                               selected_assoc->outstream2 : selected_assoc->instream1)));
        ui->label_215->setText(QString(tr("Provided Number of Outbound Streams:")));
        ui->label_225->setText(QString("%1").arg(selected_assoc->outstream1));
        ui->label_216->setText(QString(tr("Minimum Number of Outbound Streams:")));
        ui->label_226->setText(QString("%1").arg(((selected_assoc->outstream1 > selected_assoc->instream2) ?
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    fillTabs(assoc);
SCTPAssocAnalyseDialog::~SCTPAssocAnalyseDialog()
    delete ui;
const sctp_assoc_info_t* SCTPAssocAnalyseDialog::findAssocForPacket(capture_file* cf)
}
void Singleton::f2();{
            fn = GPOINTER_TO_UINT(framelist->data);
            if (fn == fdata->num) {
                frame_found = TRUE;
                break;
            }
}
void Singleton::f3();{
/* sctp_assoc_analyse_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
                                               selected_assoc->outstream2 : selected_assoc->instream1)));
        ui->label_215->setText(QString(tr("Provided Number of Outbound Streams:")));
        ui->label_225->setText(QString("%1").arg(selected_assoc->outstream1));
        ui->label_216->setText(QString(tr("Minimum Number of Outbound Streams:")));
        ui->label_226->setText(QString("%1").arg(((selected_assoc->outstream1 > selected_assoc->instream2) ?
}
void Singleton::f5();{
        ui->label_215->setText(QString(""));
        ui->label_225->setText(QString(""));
        ui->label_216->setText(QString(""));
        ui->label_226->setText(QString(""));
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    fillTabs(assoc);
SCTPAssocAnalyseDialog::~SCTPAssocAnalyseDialog()
    delete ui;
const sctp_assoc_info_t* SCTPAssocAnalyseDialog::findAssocForPacket(capture_file* cf)
}
void Singleton::f2();{
            fn = GPOINTER_TO_UINT(framelist->data);
            if (fn == fdata->num) {
                frame_found = TRUE;
                break;
            }
}
void Singleton::f3();{
/* sctp_assoc_analyse_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
                                               selected_assoc->outstream2 : selected_assoc->instream1)));
        ui->label_215->setText(QString(tr("Provided Number of Outbound Streams:")));
        ui->label_225->setText(QString("%1").arg(selected_assoc->outstream1));
        ui->label_216->setText(QString(tr("Minimum Number of Outbound Streams:")));
        ui->label_226->setText(QString("%1").arg(((selected_assoc->outstream1 > selected_assoc->instream2) ?
}
void Singleton::f5();{
        ui->label_215->setText(QString(""));
        ui->label_225->setText(QString(""));
        ui->label_216->setText(QString(""));
        ui->label_226->setText(QString(""));
    }
}
void Singleton::f6();{
    openGraphDialog(2);
void SCTPAssocAnalyseDialog::on_GraphTSN_1_clicked()
    openGraphDialog(1);
void SCTPAssocAnalyseDialog::on_chunkStatisticsButton_clicked()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    fillTabs(assoc);
SCTPAssocAnalyseDialog::~SCTPAssocAnalyseDialog()
    delete ui;
const sctp_assoc_info_t* SCTPAssocAnalyseDialog::findAssocForPacket(capture_file* cf)
}
void Singleton::f2();{
            fn = GPOINTER_TO_UINT(framelist->data);
            if (fn == fdata->num) {
                frame_found = TRUE;
                break;
            }
}
void Singleton::f3();{
/* sctp_assoc_analyse_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
                                               selected_assoc->outstream2 : selected_assoc->instream1)));
        ui->label_215->setText(QString(tr("Provided Number of Outbound Streams:")));
        ui->label_225->setText(QString("%1").arg(selected_assoc->outstream1));
        ui->label_216->setText(QString(tr("Minimum Number of Outbound Streams:")));
        ui->label_226->setText(QString("%1").arg(((selected_assoc->outstream1 > selected_assoc->instream2) ?
}
void Singleton::f5();{
        ui->label_215->setText(QString(""));
        ui->label_225->setText(QString(""));
        ui->label_216->setText(QString(""));
        ui->label_226->setText(QString(""));
    }
}
void Singleton::f6();{
    openGraphDialog(2);
void SCTPAssocAnalyseDialog::on_GraphTSN_1_clicked()
    openGraphDialog(1);
void SCTPAssocAnalyseDialog::on_chunkStatisticsButton_clicked()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
}
void Singleton::f7();{
        ui->label_326->setText(QString("%1").arg(((selected_assoc->outstream2 > selected_assoc->instream1) ?
                                                      selected_assoc->instream1 : selected_assoc->outstream2)));
    } else {
        ui->label_313->setText(QString(tr("Used Number of Inbound Streams:")));
        ui->label_323->setText(QString("%1").arg(selected_assoc->instream2));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    fillTabs(assoc);
SCTPAssocAnalyseDialog::~SCTPAssocAnalyseDialog()
    delete ui;
const sctp_assoc_info_t* SCTPAssocAnalyseDialog::findAssocForPacket(capture_file* cf)
}
void Singleton::f2();{
            fn = GPOINTER_TO_UINT(framelist->data);
            if (fn == fdata->num) {
                frame_found = TRUE;
                break;
            }
}
void Singleton::f3();{
/* sctp_assoc_analyse_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
                                               selected_assoc->outstream2 : selected_assoc->instream1)));
        ui->label_215->setText(QString(tr("Provided Number of Outbound Streams:")));
        ui->label_225->setText(QString("%1").arg(selected_assoc->outstream1));
        ui->label_216->setText(QString(tr("Minimum Number of Outbound Streams:")));
        ui->label_226->setText(QString("%1").arg(((selected_assoc->outstream1 > selected_assoc->instream2) ?
}
void Singleton::f5();{
        ui->label_215->setText(QString(""));
        ui->label_225->setText(QString(""));
        ui->label_216->setText(QString(""));
        ui->label_226->setText(QString(""));
    }
}
void Singleton::f6();{
    openGraphDialog(2);
void SCTPAssocAnalyseDialog::on_GraphTSN_1_clicked()
    openGraphDialog(1);
void SCTPAssocAnalyseDialog::on_chunkStatisticsButton_clicked()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
}
void Singleton::f7();{
        ui->label_326->setText(QString("%1").arg(((selected_assoc->outstream2 > selected_assoc->instream1) ?
                                                      selected_assoc->instream1 : selected_assoc->outstream2)));
    } else {
        ui->label_313->setText(QString(tr("Used Number of Inbound Streams:")));
        ui->label_323->setText(QString("%1").arg(selected_assoc->instream2));
}
void Singleton::f8();{
    /* Tab Endpoint 2 */
    if ((selected_assoc->initack) && (selected_assoc->initack_dir == 2))
        ui->labelEP2->setText(QString(tr("Complete list of IP-Addresses as provided in the INITACK-Chunk")));
    else
        ui->labelEP2->setText(QString(tr("List of used IP-Addresses")));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    fillTabs(assoc);
SCTPAssocAnalyseDialog::~SCTPAssocAnalyseDialog()
    delete ui;
const sctp_assoc_info_t* SCTPAssocAnalyseDialog::findAssocForPacket(capture_file* cf)
}
void Singleton::f2();{
            fn = GPOINTER_TO_UINT(framelist->data);
            if (fn == fdata->num) {
                frame_found = TRUE;
                break;
            }
}
void Singleton::f3();{
/* sctp_assoc_analyse_dialog.cpp
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
}
void Singleton::f4();{
                                               selected_assoc->outstream2 : selected_assoc->instream1)));
        ui->label_215->setText(QString(tr("Provided Number of Outbound Streams:")));
        ui->label_225->setText(QString("%1").arg(selected_assoc->outstream1));
        ui->label_216->setText(QString(tr("Minimum Number of Outbound Streams:")));
        ui->label_226->setText(QString("%1").arg(((selected_assoc->outstream1 > selected_assoc->instream2) ?
}
void Singleton::f5();{
        ui->label_215->setText(QString(""));
        ui->label_225->setText(QString(""));
        ui->label_216->setText(QString(""));
        ui->label_226->setText(QString(""));
    }
}
void Singleton::f6();{
    openGraphDialog(2);
void SCTPAssocAnalyseDialog::on_GraphTSN_1_clicked()
    openGraphDialog(1);
void SCTPAssocAnalyseDialog::on_chunkStatisticsButton_clicked()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
}
void Singleton::f7();{
        ui->label_326->setText(QString("%1").arg(((selected_assoc->outstream2 > selected_assoc->instream1) ?
                                                      selected_assoc->instream1 : selected_assoc->outstream2)));
    } else {
        ui->label_313->setText(QString(tr("Used Number of Inbound Streams:")));
        ui->label_323->setText(QString("%1").arg(selected_assoc->instream2));
}
void Singleton::f8();{
    /* Tab Endpoint 2 */
    if ((selected_assoc->initack) && (selected_assoc->initack_dir == 2))
        ui->labelEP2->setText(QString(tr("Complete list of IP-Addresses as provided in the INITACK-Chunk")));
    else
        ui->labelEP2->setText(QString(tr("List of used IP-Addresses")));
}
void Singleton::f9();{
    if (selected_assoc->init)
            ui->labelEP1->setText(QString(tr("Complete list of IP-Addresses as provided in the INIT-Chunk")));
        else if ((selected_assoc->initack) && (selected_assoc->initack_dir == 1))
            ui->labelEP1->setText(QString(tr("Complete list of IP-Addresses as provided in the INITACK-Chunk")));
        else
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        return;
    }
    uat_t *uat = prefs_get_uat_value(pref);
    gchar* fname = uat_get_actual_filename(uat,TRUE);
    bool init = false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        return;
    }
    uat_t *uat = prefs_get_uat_value(pref);
    gchar* fname = uat_get_actual_filename(uat,TRUE);
    bool init = false;
}
void Singleton::f2();{
                return;
            }
        }
    }
    g_free (fname);
}
void Singleton::f3();{
            return;
        }
        fp = ws_fopen(fname,"w");
    }
    if (!fp) {
}
void Singleton::f4();{
                g_log(NULL, G_LOG_LEVEL_ERROR, "Can't open %s: %s", fname, g_strerror(errno));
                return;
            }
        }
    }
}
void Singleton::f5();{
            g_free (pf_dir_path);
            return;
        }
        fp = ws_fopen(fname,"w");
    }
}
void Singleton::f6();{
    pref_t *pref = prefs_find_preference(prefs_find_module("sctp"),"statistics_chunk_types");
    if (!pref) {
        g_log(NULL, G_LOG_LEVEL_ERROR, "Can't find preference sctp/statistics_chunk_types");
        return;
    }
}
void Singleton::f7();{
            temp.hide = 0;
            temp.name[0] = '\0';
            while (token != NULL) {
                token = strtok(NULL, ",");
                if (token) {
}
void Singleton::f8();{
    ui->tableWidget->verticalHeader()->setSectionsClickable(true);
    ui->tableWidget->verticalHeader()->setSectionsMovable(true);
    ui->tableWidget->setSelectionBehavior(QAbstractItemView::SelectRows);
    ui->tableWidget->setSelectionMode(QAbstractItemView::SingleSelection);
    ui->tableWidget->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
}
void Singleton::f9();{
    fp = ws_fopen(fname,"w");
    if (!fp && errno == ENOENT) {
        gchar *pf_dir_path = NULL;
        if (create_persconffile_dir(&pf_dir_path) != 0) {
            g_free (pf_dir_path);
}
void Singleton::f10();{
        return;
    }
    uat_t *uat = prefs_get_uat_value(pref);
    gchar* fname = uat_get_actual_filename(uat,TRUE);
    bool init = false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        return;
    }
    uat_t *uat = prefs_get_uat_value(pref);
    gchar* fname = uat_get_actual_filename(uat,TRUE);
    bool init = false;
}
void Singleton::f2();{
                return;
            }
        }
    }
    g_free (fname);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        return;
    }
    uat_t *uat = prefs_get_uat_value(pref);
    gchar* fname = uat_get_actual_filename(uat,TRUE);
    bool init = false;
}
void Singleton::f2();{
                return;
            }
        }
    }
    g_free (fname);
}
void Singleton::f3();{
            return;
        }
        fp = ws_fopen(fname,"w");
    }
    if (!fp) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        return;
    }
    uat_t *uat = prefs_get_uat_value(pref);
    gchar* fname = uat_get_actual_filename(uat,TRUE);
    bool init = false;
}
void Singleton::f2();{
                return;
            }
        }
    }
    g_free (fname);
}
void Singleton::f3();{
            return;
        }
        fp = ws_fopen(fname,"w");
    }
    if (!fp) {
}
void Singleton::f4();{
                g_log(NULL, G_LOG_LEVEL_ERROR, "Can't open %s: %s", fname, g_strerror(errno));
                return;
            }
        }
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        return;
    }
    uat_t *uat = prefs_get_uat_value(pref);
    gchar* fname = uat_get_actual_filename(uat,TRUE);
    bool init = false;
}
void Singleton::f2();{
                return;
            }
        }
    }
    g_free (fname);
}
void Singleton::f3();{
            return;
        }
        fp = ws_fopen(fname,"w");
    }
    if (!fp) {
}
void Singleton::f4();{
                g_log(NULL, G_LOG_LEVEL_ERROR, "Can't open %s: %s", fname, g_strerror(errno));
                return;
            }
        }
    }
}
void Singleton::f5();{
            g_free (pf_dir_path);
            return;
        }
        fp = ws_fopen(fname,"w");
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        return;
    }
    uat_t *uat = prefs_get_uat_value(pref);
    gchar* fname = uat_get_actual_filename(uat,TRUE);
    bool init = false;
}
void Singleton::f2();{
                return;
            }
        }
    }
    g_free (fname);
}
void Singleton::f3();{
            return;
        }
        fp = ws_fopen(fname,"w");
    }
    if (!fp) {
}
void Singleton::f4();{
                g_log(NULL, G_LOG_LEVEL_ERROR, "Can't open %s: %s", fname, g_strerror(errno));
                return;
            }
        }
    }
}
void Singleton::f5();{
            g_free (pf_dir_path);
            return;
        }
        fp = ws_fopen(fname,"w");
    }
}
void Singleton::f6();{
    pref_t *pref = prefs_find_preference(prefs_find_module("sctp"),"statistics_chunk_types");
    if (!pref) {
        g_log(NULL, G_LOG_LEVEL_ERROR, "Can't find preference sctp/statistics_chunk_types");
        return;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        return;
    }
    uat_t *uat = prefs_get_uat_value(pref);
    gchar* fname = uat_get_actual_filename(uat,TRUE);
    bool init = false;
}
void Singleton::f2();{
                return;
            }
        }
    }
    g_free (fname);
}
void Singleton::f3();{
            return;
        }
        fp = ws_fopen(fname,"w");
    }
    if (!fp) {
}
void Singleton::f4();{
                g_log(NULL, G_LOG_LEVEL_ERROR, "Can't open %s: %s", fname, g_strerror(errno));
                return;
            }
        }
    }
}
void Singleton::f5();{
            g_free (pf_dir_path);
            return;
        }
        fp = ws_fopen(fname,"w");
    }
}
void Singleton::f6();{
    pref_t *pref = prefs_find_preference(prefs_find_module("sctp"),"statistics_chunk_types");
    if (!pref) {
        g_log(NULL, G_LOG_LEVEL_ERROR, "Can't find preference sctp/statistics_chunk_types");
        return;
    }
}
void Singleton::f7();{
            temp.hide = 0;
            temp.name[0] = '\0';
            while (token != NULL) {
                token = strtok(NULL, ",");
                if (token) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        return;
    }
    uat_t *uat = prefs_get_uat_value(pref);
    gchar* fname = uat_get_actual_filename(uat,TRUE);
    bool init = false;
}
void Singleton::f2();{
                return;
            }
        }
    }
    g_free (fname);
}
void Singleton::f3();{
            return;
        }
        fp = ws_fopen(fname,"w");
    }
    if (!fp) {
}
void Singleton::f4();{
                g_log(NULL, G_LOG_LEVEL_ERROR, "Can't open %s: %s", fname, g_strerror(errno));
                return;
            }
        }
    }
}
void Singleton::f5();{
            g_free (pf_dir_path);
            return;
        }
        fp = ws_fopen(fname,"w");
    }
}
void Singleton::f6();{
    pref_t *pref = prefs_find_preference(prefs_find_module("sctp"),"statistics_chunk_types");
    if (!pref) {
        g_log(NULL, G_LOG_LEVEL_ERROR, "Can't find preference sctp/statistics_chunk_types");
        return;
    }
}
void Singleton::f7();{
            temp.hide = 0;
            temp.name[0] = '\0';
            while (token != NULL) {
                token = strtok(NULL, ",");
                if (token) {
}
void Singleton::f8();{
    ui->tableWidget->verticalHeader()->setSectionsClickable(true);
    ui->tableWidget->verticalHeader()->setSectionsMovable(true);
    ui->tableWidget->setSelectionBehavior(QAbstractItemView::SelectRows);
    ui->tableWidget->setSelectionMode(QAbstractItemView::SingleSelection);
    ui->tableWidget->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        return;
    }
    uat_t *uat = prefs_get_uat_value(pref);
    gchar* fname = uat_get_actual_filename(uat,TRUE);
    bool init = false;
}
void Singleton::f2();{
                return;
            }
        }
    }
    g_free (fname);
}
void Singleton::f3();{
            return;
        }
        fp = ws_fopen(fname,"w");
    }
    if (!fp) {
}
void Singleton::f4();{
                g_log(NULL, G_LOG_LEVEL_ERROR, "Can't open %s: %s", fname, g_strerror(errno));
                return;
            }
        }
    }
}
void Singleton::f5();{
            g_free (pf_dir_path);
            return;
        }
        fp = ws_fopen(fname,"w");
    }
}
void Singleton::f6();{
    pref_t *pref = prefs_find_preference(prefs_find_module("sctp"),"statistics_chunk_types");
    if (!pref) {
        g_log(NULL, G_LOG_LEVEL_ERROR, "Can't find preference sctp/statistics_chunk_types");
        return;
    }
}
void Singleton::f7();{
            temp.hide = 0;
            temp.name[0] = '\0';
            while (token != NULL) {
                token = strtok(NULL, ",");
                if (token) {
}
void Singleton::f8();{
    ui->tableWidget->verticalHeader()->setSectionsClickable(true);
    ui->tableWidget->verticalHeader()->setSectionsMovable(true);
    ui->tableWidget->setSelectionBehavior(QAbstractItemView::SelectRows);
    ui->tableWidget->setSelectionMode(QAbstractItemView::SingleSelection);
    ui->tableWidget->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
}
void Singleton::f9();{
    fp = ws_fopen(fname,"w");
    if (!fp && errno == ENOENT) {
        gchar *pf_dir_path = NULL;
        if (create_persconffile_dir(&pf_dir_path) != 0) {
            g_free (pf_dir_path);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        }
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        }
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
}
void Singleton::f2();{
        tlist = g_list_first(tsn->tsns);
        while (tlist) {
            type = gxx_list_data(struct chunk_header *, tlist)->type;
            if (type == SCTP_SACK_CHUNK_ID) {
                sack_header = gxx_list_data(struct sack_chunk_header *, tlist);
}
void Singleton::f3();{
        double times = ui->sctpPlot->xAxis->pixelToCoord(event->pos().x());
        int i=0;
        for (i = 0; i < xa.size(); i++) {
            if (times <= xa.value(i)) {
                frame_num = fa.at(i);
}
void Singleton::f4();{
        drawGraph(assoc);
    }
SCTPGraphArwndDialog::~SCTPGraphArwndDialog()
    delete ui;
void SCTPGraphArwndDialog::drawArwndGraph(const sctp_assoc_info_t *selected_assoc)
}
void Singleton::f5();{
                nr_sack_header = gxx_list_data(struct nr_sack_chunk_header *, tlist);
                arwnd = g_ntohl(nr_sack_header->a_rwnd);
            }
            if (detect_max_arwnd && startArwnd < arwnd) {
                startArwnd = arwnd;
}
void Singleton::f6();{
    guint8 type;
    guint32 arwnd=0;
    if (direction == 1) {
        listSACK = g_list_last(selected_assoc->sack1);
        startArwnd = selected_assoc->arwnd2;
}
void Singleton::f7();{
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
    myScatter.setSize(3);
}
void Singleton::f8();{
    struct nr_sack_chunk_header *nr_sack_header;
    tsn_t *tsn;
    guint8 type;
    guint32 arwnd=0;
    if (direction == 1) {
}
void Singleton::f9();{
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    this->setWindowTitle(QString(tr("SCTP Data and Adv. Rec. Window over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
}
void Singleton::f10();{
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
            | Qt::WindowMinimizeButtonHint
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        }
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
}
void Singleton::f2();{
        tlist = g_list_first(tsn->tsns);
        while (tlist) {
            type = gxx_list_data(struct chunk_header *, tlist)->type;
            if (type == SCTP_SACK_CHUNK_ID) {
                sack_header = gxx_list_data(struct sack_chunk_header *, tlist);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        }
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
}
void Singleton::f2();{
        tlist = g_list_first(tsn->tsns);
        while (tlist) {
            type = gxx_list_data(struct chunk_header *, tlist)->type;
            if (type == SCTP_SACK_CHUNK_ID) {
                sack_header = gxx_list_data(struct sack_chunk_header *, tlist);
}
void Singleton::f3();{
        double times = ui->sctpPlot->xAxis->pixelToCoord(event->pos().x());
        int i=0;
        for (i = 0; i < xa.size(); i++) {
            if (times <= xa.value(i)) {
                frame_num = fa.at(i);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        }
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
}
void Singleton::f2();{
        tlist = g_list_first(tsn->tsns);
        while (tlist) {
            type = gxx_list_data(struct chunk_header *, tlist)->type;
            if (type == SCTP_SACK_CHUNK_ID) {
                sack_header = gxx_list_data(struct sack_chunk_header *, tlist);
}
void Singleton::f3();{
        double times = ui->sctpPlot->xAxis->pixelToCoord(event->pos().x());
        int i=0;
        for (i = 0; i < xa.size(); i++) {
            if (times <= xa.value(i)) {
                frame_num = fa.at(i);
}
void Singleton::f4();{
        drawGraph(assoc);
    }
SCTPGraphArwndDialog::~SCTPGraphArwndDialog()
    delete ui;
void SCTPGraphArwndDialog::drawArwndGraph(const sctp_assoc_info_t *selected_assoc)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        }
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
}
void Singleton::f2();{
        tlist = g_list_first(tsn->tsns);
        while (tlist) {
            type = gxx_list_data(struct chunk_header *, tlist)->type;
            if (type == SCTP_SACK_CHUNK_ID) {
                sack_header = gxx_list_data(struct sack_chunk_header *, tlist);
}
void Singleton::f3();{
        double times = ui->sctpPlot->xAxis->pixelToCoord(event->pos().x());
        int i=0;
        for (i = 0; i < xa.size(); i++) {
            if (times <= xa.value(i)) {
                frame_num = fa.at(i);
}
void Singleton::f4();{
        drawGraph(assoc);
    }
SCTPGraphArwndDialog::~SCTPGraphArwndDialog()
    delete ui;
void SCTPGraphArwndDialog::drawArwndGraph(const sctp_assoc_info_t *selected_assoc)
}
void Singleton::f5();{
                nr_sack_header = gxx_list_data(struct nr_sack_chunk_header *, tlist);
                arwnd = g_ntohl(nr_sack_header->a_rwnd);
            }
            if (detect_max_arwnd && startArwnd < arwnd) {
                startArwnd = arwnd;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        }
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
}
void Singleton::f2();{
        tlist = g_list_first(tsn->tsns);
        while (tlist) {
            type = gxx_list_data(struct chunk_header *, tlist)->type;
            if (type == SCTP_SACK_CHUNK_ID) {
                sack_header = gxx_list_data(struct sack_chunk_header *, tlist);
}
void Singleton::f3();{
        double times = ui->sctpPlot->xAxis->pixelToCoord(event->pos().x());
        int i=0;
        for (i = 0; i < xa.size(); i++) {
            if (times <= xa.value(i)) {
                frame_num = fa.at(i);
}
void Singleton::f4();{
        drawGraph(assoc);
    }
SCTPGraphArwndDialog::~SCTPGraphArwndDialog()
    delete ui;
void SCTPGraphArwndDialog::drawArwndGraph(const sctp_assoc_info_t *selected_assoc)
}
void Singleton::f5();{
                nr_sack_header = gxx_list_data(struct nr_sack_chunk_header *, tlist);
                arwnd = g_ntohl(nr_sack_header->a_rwnd);
            }
            if (detect_max_arwnd && startArwnd < arwnd) {
                startArwnd = arwnd;
}
void Singleton::f6();{
    guint8 type;
    guint32 arwnd=0;
    if (direction == 1) {
        listSACK = g_list_last(selected_assoc->sack1);
        startArwnd = selected_assoc->arwnd2;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        }
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
}
void Singleton::f2();{
        tlist = g_list_first(tsn->tsns);
        while (tlist) {
            type = gxx_list_data(struct chunk_header *, tlist)->type;
            if (type == SCTP_SACK_CHUNK_ID) {
                sack_header = gxx_list_data(struct sack_chunk_header *, tlist);
}
void Singleton::f3();{
        double times = ui->sctpPlot->xAxis->pixelToCoord(event->pos().x());
        int i=0;
        for (i = 0; i < xa.size(); i++) {
            if (times <= xa.value(i)) {
                frame_num = fa.at(i);
}
void Singleton::f4();{
        drawGraph(assoc);
    }
SCTPGraphArwndDialog::~SCTPGraphArwndDialog()
    delete ui;
void SCTPGraphArwndDialog::drawArwndGraph(const sctp_assoc_info_t *selected_assoc)
}
void Singleton::f5();{
                nr_sack_header = gxx_list_data(struct nr_sack_chunk_header *, tlist);
                arwnd = g_ntohl(nr_sack_header->a_rwnd);
            }
            if (detect_max_arwnd && startArwnd < arwnd) {
                startArwnd = arwnd;
}
void Singleton::f6();{
    guint8 type;
    guint32 arwnd=0;
    if (direction == 1) {
        listSACK = g_list_last(selected_assoc->sack1);
        startArwnd = selected_assoc->arwnd2;
}
void Singleton::f7();{
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
    myScatter.setSize(3);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        }
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
}
void Singleton::f2();{
        tlist = g_list_first(tsn->tsns);
        while (tlist) {
            type = gxx_list_data(struct chunk_header *, tlist)->type;
            if (type == SCTP_SACK_CHUNK_ID) {
                sack_header = gxx_list_data(struct sack_chunk_header *, tlist);
}
void Singleton::f3();{
        double times = ui->sctpPlot->xAxis->pixelToCoord(event->pos().x());
        int i=0;
        for (i = 0; i < xa.size(); i++) {
            if (times <= xa.value(i)) {
                frame_num = fa.at(i);
}
void Singleton::f4();{
        drawGraph(assoc);
    }
SCTPGraphArwndDialog::~SCTPGraphArwndDialog()
    delete ui;
void SCTPGraphArwndDialog::drawArwndGraph(const sctp_assoc_info_t *selected_assoc)
}
void Singleton::f5();{
                nr_sack_header = gxx_list_data(struct nr_sack_chunk_header *, tlist);
                arwnd = g_ntohl(nr_sack_header->a_rwnd);
            }
            if (detect_max_arwnd && startArwnd < arwnd) {
                startArwnd = arwnd;
}
void Singleton::f6();{
    guint8 type;
    guint32 arwnd=0;
    if (direction == 1) {
        listSACK = g_list_last(selected_assoc->sack1);
        startArwnd = selected_assoc->arwnd2;
}
void Singleton::f7();{
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
    myScatter.setSize(3);
}
void Singleton::f8();{
    struct nr_sack_chunk_header *nr_sack_header;
    tsn_t *tsn;
    guint8 type;
    guint32 arwnd=0;
    if (direction == 1) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        }
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
}
void Singleton::f2();{
        tlist = g_list_first(tsn->tsns);
        while (tlist) {
            type = gxx_list_data(struct chunk_header *, tlist)->type;
            if (type == SCTP_SACK_CHUNK_ID) {
                sack_header = gxx_list_data(struct sack_chunk_header *, tlist);
}
void Singleton::f3();{
        double times = ui->sctpPlot->xAxis->pixelToCoord(event->pos().x());
        int i=0;
        for (i = 0; i < xa.size(); i++) {
            if (times <= xa.value(i)) {
                frame_num = fa.at(i);
}
void Singleton::f4();{
        drawGraph(assoc);
    }
SCTPGraphArwndDialog::~SCTPGraphArwndDialog()
    delete ui;
void SCTPGraphArwndDialog::drawArwndGraph(const sctp_assoc_info_t *selected_assoc)
}
void Singleton::f5();{
                nr_sack_header = gxx_list_data(struct nr_sack_chunk_header *, tlist);
                arwnd = g_ntohl(nr_sack_header->a_rwnd);
            }
            if (detect_max_arwnd && startArwnd < arwnd) {
                startArwnd = arwnd;
}
void Singleton::f6();{
    guint8 type;
    guint32 arwnd=0;
    if (direction == 1) {
        listSACK = g_list_last(selected_assoc->sack1);
        startArwnd = selected_assoc->arwnd2;
}
void Singleton::f7();{
        listSACK = gxx_list_previous(listSACK);
    }
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
    myScatter.setSize(3);
}
void Singleton::f8();{
    struct nr_sack_chunk_header *nr_sack_header;
    tsn_t *tsn;
    guint8 type;
    guint32 arwnd=0;
    if (direction == 1) {
}
void Singleton::f9();{
            | Qt::WindowMaximizeButtonHint
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    this->setWindowTitle(QString(tr("SCTP Data and Adv. Rec. Window over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        maxBytes = selected_assoc->n_data_bytes_ep1;
        listTSN = g_list_last(selected_assoc->tsn1);
    } else {
        maxBytes = selected_assoc->n_data_bytes_ep2;
        listTSN = g_list_last(selected_assoc->tsn2);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        maxBytes = selected_assoc->n_data_bytes_ep1;
        listTSN = g_list_last(selected_assoc->tsn1);
    } else {
        maxBytes = selected_assoc->n_data_bytes_ep2;
        listTSN = g_list_last(selected_assoc->tsn2);
}
void Singleton::f2();{
        listTSN = g_list_last(selected_assoc->tsn2);
    }
    while (listTSN) {
        tsn = gxx_list_data(tsn_t*, listTSN);
        tlist = g_list_first(tsn->tsns);
}
void Singleton::f3();{
    ui->sctpPlot->xAxis->setRange(myXByteRange);
    ui->sctpPlot->yAxis->setRange(myYByteRange);
void SCTPGraphByteDialog::drawGraph()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
    if (!selected_assoc) return;
}
void Singleton::f4();{
    frame_num(0),
    direction(dir)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
}
void Singleton::f5();{
    QDialog(parent),
    ui(new Ui::SCTPGraphByteDialog),
    cap_file_(cf),
    frame_num(0),
    direction(dir)
}
void Singleton::f6();{
    this->setWindowTitle(QString(tr("SCTP Data and Adv. Rec. Window over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    if ((direction == 1 && assoc->n_array_tsn1 == 0) || (direction == 2 && assoc->n_array_tsn2 == 0)) {
        QMessageBox msgBox;
        msgBox.setText(tr("No Data Chunks sent"));
}
void Singleton::f7();{
    direction(dir)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
}
void Singleton::f8();{
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
    myScatter.setSize(3);
    // create graph and assign data to it:
    // Add Bytes graph
}
void Singleton::f9();{
                length = g_ntohs(gxx_list_data(struct data_chunk_header *, tlist)->length);
                if (type == SCTP_DATA_CHUNK_ID)
                    length -= DATA_CHUNK_HEADER_LENGTH;
                else
                    length -= I_DATA_CHUNK_HEADER_LENGTH;
}
void Singleton::f10();{
void SCTPGraphByteDialog::graphClicked(QCPAbstractPlottable* plottable, QMouseEvent* event)
    if (plottable->name().contains(tr("Bytes"), Qt::CaseInsensitive)) {
        double bytes = ui->sctpPlot->yAxis->pixelToCoord(event->pos().y());
        int i;
        for (i = 0; i < yb.size(); i++) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        maxBytes = selected_assoc->n_data_bytes_ep1;
        listTSN = g_list_last(selected_assoc->tsn1);
    } else {
        maxBytes = selected_assoc->n_data_bytes_ep2;
        listTSN = g_list_last(selected_assoc->tsn2);
}
void Singleton::f2();{
        listTSN = g_list_last(selected_assoc->tsn2);
    }
    while (listTSN) {
        tsn = gxx_list_data(tsn_t*, listTSN);
        tlist = g_list_first(tsn->tsns);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        maxBytes = selected_assoc->n_data_bytes_ep1;
        listTSN = g_list_last(selected_assoc->tsn1);
    } else {
        maxBytes = selected_assoc->n_data_bytes_ep2;
        listTSN = g_list_last(selected_assoc->tsn2);
}
void Singleton::f2();{
        listTSN = g_list_last(selected_assoc->tsn2);
    }
    while (listTSN) {
        tsn = gxx_list_data(tsn_t*, listTSN);
        tlist = g_list_first(tsn->tsns);
}
void Singleton::f3();{
    ui->sctpPlot->xAxis->setRange(myXByteRange);
    ui->sctpPlot->yAxis->setRange(myYByteRange);
void SCTPGraphByteDialog::drawGraph()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
    if (!selected_assoc) return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        maxBytes = selected_assoc->n_data_bytes_ep1;
        listTSN = g_list_last(selected_assoc->tsn1);
    } else {
        maxBytes = selected_assoc->n_data_bytes_ep2;
        listTSN = g_list_last(selected_assoc->tsn2);
}
void Singleton::f2();{
        listTSN = g_list_last(selected_assoc->tsn2);
    }
    while (listTSN) {
        tsn = gxx_list_data(tsn_t*, listTSN);
        tlist = g_list_first(tsn->tsns);
}
void Singleton::f3();{
    ui->sctpPlot->xAxis->setRange(myXByteRange);
    ui->sctpPlot->yAxis->setRange(myYByteRange);
void SCTPGraphByteDialog::drawGraph()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
    if (!selected_assoc) return;
}
void Singleton::f4();{
    frame_num(0),
    direction(dir)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        maxBytes = selected_assoc->n_data_bytes_ep1;
        listTSN = g_list_last(selected_assoc->tsn1);
    } else {
        maxBytes = selected_assoc->n_data_bytes_ep2;
        listTSN = g_list_last(selected_assoc->tsn2);
}
void Singleton::f2();{
        listTSN = g_list_last(selected_assoc->tsn2);
    }
    while (listTSN) {
        tsn = gxx_list_data(tsn_t*, listTSN);
        tlist = g_list_first(tsn->tsns);
}
void Singleton::f3();{
    ui->sctpPlot->xAxis->setRange(myXByteRange);
    ui->sctpPlot->yAxis->setRange(myYByteRange);
void SCTPGraphByteDialog::drawGraph()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
    if (!selected_assoc) return;
}
void Singleton::f4();{
    frame_num(0),
    direction(dir)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
}
void Singleton::f5();{
    QDialog(parent),
    ui(new Ui::SCTPGraphByteDialog),
    cap_file_(cf),
    frame_num(0),
    direction(dir)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        maxBytes = selected_assoc->n_data_bytes_ep1;
        listTSN = g_list_last(selected_assoc->tsn1);
    } else {
        maxBytes = selected_assoc->n_data_bytes_ep2;
        listTSN = g_list_last(selected_assoc->tsn2);
}
void Singleton::f2();{
        listTSN = g_list_last(selected_assoc->tsn2);
    }
    while (listTSN) {
        tsn = gxx_list_data(tsn_t*, listTSN);
        tlist = g_list_first(tsn->tsns);
}
void Singleton::f3();{
    ui->sctpPlot->xAxis->setRange(myXByteRange);
    ui->sctpPlot->yAxis->setRange(myYByteRange);
void SCTPGraphByteDialog::drawGraph()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
    if (!selected_assoc) return;
}
void Singleton::f4();{
    frame_num(0),
    direction(dir)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
}
void Singleton::f5();{
    QDialog(parent),
    ui(new Ui::SCTPGraphByteDialog),
    cap_file_(cf),
    frame_num(0),
    direction(dir)
}
void Singleton::f6();{
    this->setWindowTitle(QString(tr("SCTP Data and Adv. Rec. Window over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    if ((direction == 1 && assoc->n_array_tsn1 == 0) || (direction == 2 && assoc->n_array_tsn2 == 0)) {
        QMessageBox msgBox;
        msgBox.setText(tr("No Data Chunks sent"));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        maxBytes = selected_assoc->n_data_bytes_ep1;
        listTSN = g_list_last(selected_assoc->tsn1);
    } else {
        maxBytes = selected_assoc->n_data_bytes_ep2;
        listTSN = g_list_last(selected_assoc->tsn2);
}
void Singleton::f2();{
        listTSN = g_list_last(selected_assoc->tsn2);
    }
    while (listTSN) {
        tsn = gxx_list_data(tsn_t*, listTSN);
        tlist = g_list_first(tsn->tsns);
}
void Singleton::f3();{
    ui->sctpPlot->xAxis->setRange(myXByteRange);
    ui->sctpPlot->yAxis->setRange(myYByteRange);
void SCTPGraphByteDialog::drawGraph()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
    if (!selected_assoc) return;
}
void Singleton::f4();{
    frame_num(0),
    direction(dir)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
}
void Singleton::f5();{
    QDialog(parent),
    ui(new Ui::SCTPGraphByteDialog),
    cap_file_(cf),
    frame_num(0),
    direction(dir)
}
void Singleton::f6();{
    this->setWindowTitle(QString(tr("SCTP Data and Adv. Rec. Window over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    if ((direction == 1 && assoc->n_array_tsn1 == 0) || (direction == 2 && assoc->n_array_tsn2 == 0)) {
        QMessageBox msgBox;
        msgBox.setText(tr("No Data Chunks sent"));
}
void Singleton::f7();{
    direction(dir)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        maxBytes = selected_assoc->n_data_bytes_ep1;
        listTSN = g_list_last(selected_assoc->tsn1);
    } else {
        maxBytes = selected_assoc->n_data_bytes_ep2;
        listTSN = g_list_last(selected_assoc->tsn2);
}
void Singleton::f2();{
        listTSN = g_list_last(selected_assoc->tsn2);
    }
    while (listTSN) {
        tsn = gxx_list_data(tsn_t*, listTSN);
        tlist = g_list_first(tsn->tsns);
}
void Singleton::f3();{
    ui->sctpPlot->xAxis->setRange(myXByteRange);
    ui->sctpPlot->yAxis->setRange(myYByteRange);
void SCTPGraphByteDialog::drawGraph()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
    if (!selected_assoc) return;
}
void Singleton::f4();{
    frame_num(0),
    direction(dir)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
}
void Singleton::f5();{
    QDialog(parent),
    ui(new Ui::SCTPGraphByteDialog),
    cap_file_(cf),
    frame_num(0),
    direction(dir)
}
void Singleton::f6();{
    this->setWindowTitle(QString(tr("SCTP Data and Adv. Rec. Window over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    if ((direction == 1 && assoc->n_array_tsn1 == 0) || (direction == 2 && assoc->n_array_tsn2 == 0)) {
        QMessageBox msgBox;
        msgBox.setText(tr("No Data Chunks sent"));
}
void Singleton::f7();{
    direction(dir)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
}
void Singleton::f8();{
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
    myScatter.setSize(3);
    // create graph and assign data to it:
    // Add Bytes graph
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        maxBytes = selected_assoc->n_data_bytes_ep1;
        listTSN = g_list_last(selected_assoc->tsn1);
    } else {
        maxBytes = selected_assoc->n_data_bytes_ep2;
        listTSN = g_list_last(selected_assoc->tsn2);
}
void Singleton::f2();{
        listTSN = g_list_last(selected_assoc->tsn2);
    }
    while (listTSN) {
        tsn = gxx_list_data(tsn_t*, listTSN);
        tlist = g_list_first(tsn->tsns);
}
void Singleton::f3();{
    ui->sctpPlot->xAxis->setRange(myXByteRange);
    ui->sctpPlot->yAxis->setRange(myYByteRange);
void SCTPGraphByteDialog::drawGraph()
    const sctp_assoc_info_t* selected_assoc = SCTPAssocAnalyseDialog::findAssoc(this, selected_assoc_id);
    if (!selected_assoc) return;
}
void Singleton::f4();{
    frame_num(0),
    direction(dir)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
}
void Singleton::f5();{
    QDialog(parent),
    ui(new Ui::SCTPGraphByteDialog),
    cap_file_(cf),
    frame_num(0),
    direction(dir)
}
void Singleton::f6();{
    this->setWindowTitle(QString(tr("SCTP Data and Adv. Rec. Window over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    if ((direction == 1 && assoc->n_array_tsn1 == 0) || (direction == 2 && assoc->n_array_tsn2 == 0)) {
        QMessageBox msgBox;
        msgBox.setText(tr("No Data Chunks sent"));
}
void Singleton::f7();{
    direction(dir)
    Q_ASSERT(assoc);
    selected_assoc_id = assoc->assoc_id;
    ui->setupUi(this);
    Qt::WindowFlags flags = Qt::Window | Qt::WindowSystemMenuHint
}
void Singleton::f8();{
    QCPScatterStyle myScatter;
    myScatter.setShape(QCPScatterStyle::ssCircle);
    myScatter.setSize(3);
    // create graph and assign data to it:
    // Add Bytes graph
}
void Singleton::f9();{
                length = g_ntohs(gxx_list_data(struct data_chunk_header *, tlist)->length);
                if (type == SCTP_DATA_CHUNK_ID)
                    length -= DATA_CHUNK_HEADER_LENGTH;
                else
                    length -= I_DATA_CHUNK_HEADER_LENGTH;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    yt.clear();
    xs.clear();
    ys.clear();
    xg.clear();
    yg.clear();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    yt.clear();
    xs.clear();
    ys.clear();
    xg.clear();
    yg.clear();
}
void Singleton::f2();{
        QCPGraph *gr = ui->sctpPlot->addGraph();
        gr->setName(QString("TSN"));
        myScatter.setPen(QPen(Qt::black));
        myScatter.setBrush(Qt::black);
        ui->sctpPlot->graph(graphcount)->setScatterStyle(myScatter);
}
void Singleton::f3();{
         minTSN = selected_assoc->min_tsn2;
    }
    if (relative) {
        rel = minTSN;
     }
}
void Singleton::f4();{
    struct gaps *nr_gap = Q_NULLPTR;
    /* This holds the sum of gap acks and nr gap acks */
    guint16 total_gaps = 0;
    if (direction == 1) {
        list = g_list_last(selected_assoc->sack1);
}
void Singleton::f5();{
        drawSACKGraph(selected_assoc);
        drawNRSACKGraph(selected_assoc);
        break;
    }
    // give the axes some labels:
}
void Singleton::f6();{
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    this->setWindowTitle(QString(tr("SCTP TSNs and SACKs over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    if ((direction == 1 && assoc->n_array_tsn1 == 0) || (direction == 2 && assoc->n_array_tsn2 == 0)) {
}
void Singleton::f7();{
         minTSN = selected_assoc->min_tsn1;
    } else {
        listTSN = g_list_last(selected_assoc->tsn2);
         minTSN = selected_assoc->min_tsn2;
    }
}
void Singleton::f8();{
            }
        }
    } else if (plottable->name().contains("NR_GAP", Qt::CaseInsensitive)) {
        for (i = 0; i < xn.size(); i++) {
            if (times <= xn.value(i)) {
}
void Singleton::f9();{
    int graphcount = ui->sctpPlot->graphCount();
    // create graph and assign data to it:
    // Add SACK graph
    if (xs.size() > 0) {
        QCPGraph *gr = ui->sctpPlot->addGraph();
}
void Singleton::f10();{
    }
    // give the axes some labels:
    ui->sctpPlot->xAxis->setLabel(tr("time [secs]"));
    ui->sctpPlot->yAxis->setLabel(tr("TSNs"));
    ui->sctpPlot->setInteractions(QCP::iRangeZoom | QCP::iRangeDrag | QCP::iSelectPlottables);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    yt.clear();
    xs.clear();
    ys.clear();
    xg.clear();
    yg.clear();
}
void Singleton::f2();{
        QCPGraph *gr = ui->sctpPlot->addGraph();
        gr->setName(QString("TSN"));
        myScatter.setPen(QPen(Qt::black));
        myScatter.setBrush(Qt::black);
        ui->sctpPlot->graph(graphcount)->setScatterStyle(myScatter);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    yt.clear();
    xs.clear();
    ys.clear();
    xg.clear();
    yg.clear();
}
void Singleton::f2();{
        QCPGraph *gr = ui->sctpPlot->addGraph();
        gr->setName(QString("TSN"));
        myScatter.setPen(QPen(Qt::black));
        myScatter.setBrush(Qt::black);
        ui->sctpPlot->graph(graphcount)->setScatterStyle(myScatter);
}
void Singleton::f3();{
         minTSN = selected_assoc->min_tsn2;
    }
    if (relative) {
        rel = minTSN;
     }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    yt.clear();
    xs.clear();
    ys.clear();
    xg.clear();
    yg.clear();
}
void Singleton::f2();{
        QCPGraph *gr = ui->sctpPlot->addGraph();
        gr->setName(QString("TSN"));
        myScatter.setPen(QPen(Qt::black));
        myScatter.setBrush(Qt::black);
        ui->sctpPlot->graph(graphcount)->setScatterStyle(myScatter);
}
void Singleton::f3();{
         minTSN = selected_assoc->min_tsn2;
    }
    if (relative) {
        rel = minTSN;
     }
}
void Singleton::f4();{
    struct gaps *nr_gap = Q_NULLPTR;
    /* This holds the sum of gap acks and nr gap acks */
    guint16 total_gaps = 0;
    if (direction == 1) {
        list = g_list_last(selected_assoc->sack1);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    yt.clear();
    xs.clear();
    ys.clear();
    xg.clear();
    yg.clear();
}
void Singleton::f2();{
        QCPGraph *gr = ui->sctpPlot->addGraph();
        gr->setName(QString("TSN"));
        myScatter.setPen(QPen(Qt::black));
        myScatter.setBrush(Qt::black);
        ui->sctpPlot->graph(graphcount)->setScatterStyle(myScatter);
}
void Singleton::f3();{
         minTSN = selected_assoc->min_tsn2;
    }
    if (relative) {
        rel = minTSN;
     }
}
void Singleton::f4();{
    struct gaps *nr_gap = Q_NULLPTR;
    /* This holds the sum of gap acks and nr gap acks */
    guint16 total_gaps = 0;
    if (direction == 1) {
        list = g_list_last(selected_assoc->sack1);
}
void Singleton::f5();{
        drawSACKGraph(selected_assoc);
        drawNRSACKGraph(selected_assoc);
        break;
    }
    // give the axes some labels:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    yt.clear();
    xs.clear();
    ys.clear();
    xg.clear();
    yg.clear();
}
void Singleton::f2();{
        QCPGraph *gr = ui->sctpPlot->addGraph();
        gr->setName(QString("TSN"));
        myScatter.setPen(QPen(Qt::black));
        myScatter.setBrush(Qt::black);
        ui->sctpPlot->graph(graphcount)->setScatterStyle(myScatter);
}
void Singleton::f3();{
         minTSN = selected_assoc->min_tsn2;
    }
    if (relative) {
        rel = minTSN;
     }
}
void Singleton::f4();{
    struct gaps *nr_gap = Q_NULLPTR;
    /* This holds the sum of gap acks and nr gap acks */
    guint16 total_gaps = 0;
    if (direction == 1) {
        list = g_list_last(selected_assoc->sack1);
}
void Singleton::f5();{
        drawSACKGraph(selected_assoc);
        drawNRSACKGraph(selected_assoc);
        break;
    }
    // give the axes some labels:
}
void Singleton::f6();{
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    this->setWindowTitle(QString(tr("SCTP TSNs and SACKs over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    if ((direction == 1 && assoc->n_array_tsn1 == 0) || (direction == 2 && assoc->n_array_tsn2 == 0)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    yt.clear();
    xs.clear();
    ys.clear();
    xg.clear();
    yg.clear();
}
void Singleton::f2();{
        QCPGraph *gr = ui->sctpPlot->addGraph();
        gr->setName(QString("TSN"));
        myScatter.setPen(QPen(Qt::black));
        myScatter.setBrush(Qt::black);
        ui->sctpPlot->graph(graphcount)->setScatterStyle(myScatter);
}
void Singleton::f3();{
         minTSN = selected_assoc->min_tsn2;
    }
    if (relative) {
        rel = minTSN;
     }
}
void Singleton::f4();{
    struct gaps *nr_gap = Q_NULLPTR;
    /* This holds the sum of gap acks and nr gap acks */
    guint16 total_gaps = 0;
    if (direction == 1) {
        list = g_list_last(selected_assoc->sack1);
}
void Singleton::f5();{
        drawSACKGraph(selected_assoc);
        drawNRSACKGraph(selected_assoc);
        break;
    }
    // give the axes some labels:
}
void Singleton::f6();{
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    this->setWindowTitle(QString(tr("SCTP TSNs and SACKs over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    if ((direction == 1 && assoc->n_array_tsn1 == 0) || (direction == 2 && assoc->n_array_tsn2 == 0)) {
}
void Singleton::f7();{
         minTSN = selected_assoc->min_tsn1;
    } else {
        listTSN = g_list_last(selected_assoc->tsn2);
         minTSN = selected_assoc->min_tsn2;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    yt.clear();
    xs.clear();
    ys.clear();
    xg.clear();
    yg.clear();
}
void Singleton::f2();{
        QCPGraph *gr = ui->sctpPlot->addGraph();
        gr->setName(QString("TSN"));
        myScatter.setPen(QPen(Qt::black));
        myScatter.setBrush(Qt::black);
        ui->sctpPlot->graph(graphcount)->setScatterStyle(myScatter);
}
void Singleton::f3();{
         minTSN = selected_assoc->min_tsn2;
    }
    if (relative) {
        rel = minTSN;
     }
}
void Singleton::f4();{
    struct gaps *nr_gap = Q_NULLPTR;
    /* This holds the sum of gap acks and nr gap acks */
    guint16 total_gaps = 0;
    if (direction == 1) {
        list = g_list_last(selected_assoc->sack1);
}
void Singleton::f5();{
        drawSACKGraph(selected_assoc);
        drawNRSACKGraph(selected_assoc);
        break;
    }
    // give the axes some labels:
}
void Singleton::f6();{
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    this->setWindowTitle(QString(tr("SCTP TSNs and SACKs over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    if ((direction == 1 && assoc->n_array_tsn1 == 0) || (direction == 2 && assoc->n_array_tsn2 == 0)) {
}
void Singleton::f7();{
         minTSN = selected_assoc->min_tsn1;
    } else {
        listTSN = g_list_last(selected_assoc->tsn2);
         minTSN = selected_assoc->min_tsn2;
    }
}
void Singleton::f8();{
            }
        }
    } else if (plottable->name().contains("NR_GAP", Qt::CaseInsensitive)) {
        for (i = 0; i < xn.size(); i++) {
            if (times <= xn.value(i)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    yt.clear();
    xs.clear();
    ys.clear();
    xg.clear();
    yg.clear();
}
void Singleton::f2();{
        QCPGraph *gr = ui->sctpPlot->addGraph();
        gr->setName(QString("TSN"));
        myScatter.setPen(QPen(Qt::black));
        myScatter.setBrush(Qt::black);
        ui->sctpPlot->graph(graphcount)->setScatterStyle(myScatter);
}
void Singleton::f3();{
         minTSN = selected_assoc->min_tsn2;
    }
    if (relative) {
        rel = minTSN;
     }
}
void Singleton::f4();{
    struct gaps *nr_gap = Q_NULLPTR;
    /* This holds the sum of gap acks and nr gap acks */
    guint16 total_gaps = 0;
    if (direction == 1) {
        list = g_list_last(selected_assoc->sack1);
}
void Singleton::f5();{
        drawSACKGraph(selected_assoc);
        drawNRSACKGraph(selected_assoc);
        break;
    }
    // give the axes some labels:
}
void Singleton::f6();{
            | Qt::WindowCloseButtonHint;
    this->setWindowFlags(flags);
    this->setWindowTitle(QString(tr("SCTP TSNs and SACKs over Time: %1 Port1 %2 Port2 %3"))
            .arg(gchar_free_to_qstring(cf_get_display_name(cap_file_))).arg(assoc->port1).arg(assoc->port2));
    if ((direction == 1 && assoc->n_array_tsn1 == 0) || (direction == 2 && assoc->n_array_tsn2 == 0)) {
}
void Singleton::f7();{
         minTSN = selected_assoc->min_tsn1;
    } else {
        listTSN = g_list_last(selected_assoc->tsn2);
         minTSN = selected_assoc->min_tsn2;
    }
}
void Singleton::f8();{
            }
        }
    } else if (plottable->name().contains("NR_GAP", Qt::CaseInsensitive)) {
        for (i = 0; i < xn.size(); i++) {
            if (times <= xn.value(i)) {
}
void Singleton::f9();{
    int graphcount = ui->sctpPlot->graphCount();
    // create graph and assign data to it:
    // Add SACK graph
    if (xs.size() > 0) {
        QCPGraph *gr = ui->sctpPlot->addGraph();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
    switch (recent.gui_search_type) {
    case SEARCH_TYPE_DISPLAY_FILTER:
        search_type_idx = df_search_;
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
    switch (recent.gui_search_type) {
    case SEARCH_TYPE_DISPLAY_FILTER:
        search_type_idx = df_search_;
        break;
}
void Singleton::f2();{
    regex_search_
enum {
    narrow_and_wide_chars_,
    narrow_chars_,
    wide_chars_
}
void Singleton::f3();{
    if (!cap_file_) return;
    cap_file_->dir = SD_BACKWARD;
    if (isHidden()) {
        animatedShow();
        return;
}
void Singleton::f4();{
    case SEARCH_CHAR_SET_NARROW_AND_WIDE:
        char_encoding_idx = narrow_and_wide_chars_;
        break;
    case SEARCH_CHAR_SET_NARROW:
        char_encoding_idx = narrow_chars_;
}
void Singleton::f5();{
            goto search_done;
        }
    } else if (cap_file_->string) {
        if (search_type == regex_search_ && !cap_file_->regex) {
            err_string = regex_error_;
}
void Singleton::f6();{
            err_string = tr("You didn't specify any text for which to search.");
            goto search_done;
        }
        cap_file_->string = TRUE;
        cap_file_->case_type = sf_ui_->caseCheckBox->isChecked() ? FALSE : TRUE;
}
void Singleton::f7();{
        switch (sf_ui_->charEncodingComboBox->currentIndex()) {
        case narrow_and_wide_chars_:
            cap_file_->scs_type = SCS_NARROW_AND_WIDE;
            break;
        case narrow_chars_:
}
void Singleton::f8();{
    df_search_,
    hex_search_,
    string_search_,
    regex_search_
enum {
}
void Singleton::f9();{
    }
void SearchFrame::on_cancelButton_clicked()
    animatedHide();
void SearchFrame::changeEvent(QEvent* event)
    if (event)
}
void Singleton::f10();{
            err_string = tr("No packet contained those bytes.");
            goto search_done;
        }
    } else if (cap_file_->string) {
        if (search_type == regex_search_ && !cap_file_->regex) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
    switch (recent.gui_search_type) {
    case SEARCH_TYPE_DISPLAY_FILTER:
        search_type_idx = df_search_;
        break;
}
void Singleton::f2();{
    regex_search_
enum {
    narrow_and_wide_chars_,
    narrow_chars_,
    wide_chars_
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
    switch (recent.gui_search_type) {
    case SEARCH_TYPE_DISPLAY_FILTER:
        search_type_idx = df_search_;
        break;
}
void Singleton::f2();{
    regex_search_
enum {
    narrow_and_wide_chars_,
    narrow_chars_,
    wide_chars_
}
void Singleton::f3();{
    if (!cap_file_) return;
    cap_file_->dir = SD_BACKWARD;
    if (isHidden()) {
        animatedShow();
        return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
    switch (recent.gui_search_type) {
    case SEARCH_TYPE_DISPLAY_FILTER:
        search_type_idx = df_search_;
        break;
}
void Singleton::f2();{
    regex_search_
enum {
    narrow_and_wide_chars_,
    narrow_chars_,
    wide_chars_
}
void Singleton::f3();{
    if (!cap_file_) return;
    cap_file_->dir = SD_BACKWARD;
    if (isHidden()) {
        animatedShow();
        return;
}
void Singleton::f4();{
    case SEARCH_CHAR_SET_NARROW_AND_WIDE:
        char_encoding_idx = narrow_and_wide_chars_;
        break;
    case SEARCH_CHAR_SET_NARROW:
        char_encoding_idx = narrow_chars_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
    switch (recent.gui_search_type) {
    case SEARCH_TYPE_DISPLAY_FILTER:
        search_type_idx = df_search_;
        break;
}
void Singleton::f2();{
    regex_search_
enum {
    narrow_and_wide_chars_,
    narrow_chars_,
    wide_chars_
}
void Singleton::f3();{
    if (!cap_file_) return;
    cap_file_->dir = SD_BACKWARD;
    if (isHidden()) {
        animatedShow();
        return;
}
void Singleton::f4();{
    case SEARCH_CHAR_SET_NARROW_AND_WIDE:
        char_encoding_idx = narrow_and_wide_chars_;
        break;
    case SEARCH_CHAR_SET_NARROW:
        char_encoding_idx = narrow_chars_;
}
void Singleton::f5();{
            goto search_done;
        }
    } else if (cap_file_->string) {
        if (search_type == regex_search_ && !cap_file_->regex) {
            err_string = regex_error_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
    switch (recent.gui_search_type) {
    case SEARCH_TYPE_DISPLAY_FILTER:
        search_type_idx = df_search_;
        break;
}
void Singleton::f2();{
    regex_search_
enum {
    narrow_and_wide_chars_,
    narrow_chars_,
    wide_chars_
}
void Singleton::f3();{
    if (!cap_file_) return;
    cap_file_->dir = SD_BACKWARD;
    if (isHidden()) {
        animatedShow();
        return;
}
void Singleton::f4();{
    case SEARCH_CHAR_SET_NARROW_AND_WIDE:
        char_encoding_idx = narrow_and_wide_chars_;
        break;
    case SEARCH_CHAR_SET_NARROW:
        char_encoding_idx = narrow_chars_;
}
void Singleton::f5();{
            goto search_done;
        }
    } else if (cap_file_->string) {
        if (search_type == regex_search_ && !cap_file_->regex) {
            err_string = regex_error_;
}
void Singleton::f6();{
            err_string = tr("You didn't specify any text for which to search.");
            goto search_done;
        }
        cap_file_->string = TRUE;
        cap_file_->case_type = sf_ui_->caseCheckBox->isChecked() ? FALSE : TRUE;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
    switch (recent.gui_search_type) {
    case SEARCH_TYPE_DISPLAY_FILTER:
        search_type_idx = df_search_;
        break;
}
void Singleton::f2();{
    regex_search_
enum {
    narrow_and_wide_chars_,
    narrow_chars_,
    wide_chars_
}
void Singleton::f3();{
    if (!cap_file_) return;
    cap_file_->dir = SD_BACKWARD;
    if (isHidden()) {
        animatedShow();
        return;
}
void Singleton::f4();{
    case SEARCH_CHAR_SET_NARROW_AND_WIDE:
        char_encoding_idx = narrow_and_wide_chars_;
        break;
    case SEARCH_CHAR_SET_NARROW:
        char_encoding_idx = narrow_chars_;
}
void Singleton::f5();{
            goto search_done;
        }
    } else if (cap_file_->string) {
        if (search_type == regex_search_ && !cap_file_->regex) {
            err_string = regex_error_;
}
void Singleton::f6();{
            err_string = tr("You didn't specify any text for which to search.");
            goto search_done;
        }
        cap_file_->string = TRUE;
        cap_file_->case_type = sf_ui_->caseCheckBox->isChecked() ? FALSE : TRUE;
}
void Singleton::f7();{
        switch (sf_ui_->charEncodingComboBox->currentIndex()) {
        case narrow_and_wide_chars_:
            cap_file_->scs_type = SCS_NARROW_AND_WIDE;
            break;
        case narrow_chars_:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
    switch (recent.gui_search_type) {
    case SEARCH_TYPE_DISPLAY_FILTER:
        search_type_idx = df_search_;
        break;
}
void Singleton::f2();{
    regex_search_
enum {
    narrow_and_wide_chars_,
    narrow_chars_,
    wide_chars_
}
void Singleton::f3();{
    if (!cap_file_) return;
    cap_file_->dir = SD_BACKWARD;
    if (isHidden()) {
        animatedShow();
        return;
}
void Singleton::f4();{
    case SEARCH_CHAR_SET_NARROW_AND_WIDE:
        char_encoding_idx = narrow_and_wide_chars_;
        break;
    case SEARCH_CHAR_SET_NARROW:
        char_encoding_idx = narrow_chars_;
}
void Singleton::f5();{
            goto search_done;
        }
    } else if (cap_file_->string) {
        if (search_type == regex_search_ && !cap_file_->regex) {
            err_string = regex_error_;
}
void Singleton::f6();{
            err_string = tr("You didn't specify any text for which to search.");
            goto search_done;
        }
        cap_file_->string = TRUE;
        cap_file_->case_type = sf_ui_->caseCheckBox->isChecked() ? FALSE : TRUE;
}
void Singleton::f7();{
        switch (sf_ui_->charEncodingComboBox->currentIndex()) {
        case narrow_and_wide_chars_:
            cap_file_->scs_type = SCS_NARROW_AND_WIDE;
            break;
        case narrow_chars_:
}
void Singleton::f8();{
    df_search_,
    hex_search_,
    string_search_,
    regex_search_
enum {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
    switch (recent.gui_search_type) {
    case SEARCH_TYPE_DISPLAY_FILTER:
        search_type_idx = df_search_;
        break;
}
void Singleton::f2();{
    regex_search_
enum {
    narrow_and_wide_chars_,
    narrow_chars_,
    wide_chars_
}
void Singleton::f3();{
    if (!cap_file_) return;
    cap_file_->dir = SD_BACKWARD;
    if (isHidden()) {
        animatedShow();
        return;
}
void Singleton::f4();{
    case SEARCH_CHAR_SET_NARROW_AND_WIDE:
        char_encoding_idx = narrow_and_wide_chars_;
        break;
    case SEARCH_CHAR_SET_NARROW:
        char_encoding_idx = narrow_chars_;
}
void Singleton::f5();{
            goto search_done;
        }
    } else if (cap_file_->string) {
        if (search_type == regex_search_ && !cap_file_->regex) {
            err_string = regex_error_;
}
void Singleton::f6();{
            err_string = tr("You didn't specify any text for which to search.");
            goto search_done;
        }
        cap_file_->string = TRUE;
        cap_file_->case_type = sf_ui_->caseCheckBox->isChecked() ? FALSE : TRUE;
}
void Singleton::f7();{
        switch (sf_ui_->charEncodingComboBox->currentIndex()) {
        case narrow_and_wide_chars_:
            cap_file_->scs_type = SCS_NARROW_AND_WIDE;
            break;
        case narrow_chars_:
}
void Singleton::f8();{
    df_search_,
    hex_search_,
    string_search_,
    regex_search_
enum {
}
void Singleton::f9();{
    }
void SearchFrame::on_cancelButton_clicked()
    animatedHide();
void SearchFrame::changeEvent(QEvent* event)
    if (event)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
    mParentPlot->replot();
_seq_analysis_item *SequenceDiagram::itemForPosY(int ypos)
    double key_pos = qRound(key_axis_->pixelToCoord(ypos));
    if (key_pos >= 0 && key_pos < data_->size()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
    mParentPlot->replot();
_seq_analysis_item *SequenceDiagram::itemForPosY(int ypos)
    double key_pos = qRound(key_axis_->pixelToCoord(ypos));
    if (key_pos >= 0 && key_pos < data_->size()) {
}
void Singleton::f2();{
    return range;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f3();{
    sainfo_(NULL),
    selected_packet_(0),
    selected_key_(-1.0)
    data_ = new WSCPSeqDataMap();
    // xaxis (value): Address
}
void Singleton::f4();{
            }
        }
    }
    return adjacent_packet;
void SequenceDiagram::setData(_seq_analysis_info *sainfo)
}
void Singleton::f5();{
            double comment_start = (sai->src_node < sai->dst_node)
                    ? arrow_start.x() : arrow_end.x();
            double arrow_width = (arrow_end.x() - arrow_start.x()) * dir_mul;
            QString arrow_label = cfm.elidedText(sai->frame_label, Qt::ElideRight, arrow_width);
            int arrow_label_width = 0;
}
void Singleton::f6();{
        }
    }
void SequenceDiagram::drawLegendIcon(QCPPainter *, const QRectF &) const
QCPRange SequenceDiagram::getKeyRange(bool &validRange, QCP::SignDomain) const
    QCPRange range;
}
void Singleton::f7();{
            QPoint arrow_start(coordsToPixels(cur_key, sai->src_node).toPoint());
            arrow_start.setY(arrow_start.y() + (en_w / 2));
            QPoint arrow_end(coordsToPixels(cur_key, sai->dst_node).toPoint());
            arrow_end.setY(arrow_start.y());
            QLine arrow_line(arrow_start, arrow_end);
}
void Singleton::f8();{
        return data_->value(key_pos).value;
    }
    return NULL;
double SequenceDiagram::selectTest(const QPointF &pos, bool, QVariant *) const
    double key_pos = qRound(key_axis_->pixelToCoord(pos.y()));
}
void Singleton::f9();{
    return adjacent_packet;
void SequenceDiagram::setData(_seq_analysis_info *sainfo)
    data_->clear();
    sainfo_ = sainfo;
    if (!sainfo) return;
}
void Singleton::f10();{
            double en_w = cfm.height() / 2.0;
            int dir_mul = (sai->src_node < sai->dst_node) ? 1 : -1;
            double ah_size = (cfm.height() / 5) * dir_mul;
            QPoint arrow_start(coordsToPixels(cur_key, sai->src_node).toPoint());
            arrow_start.setY(arrow_start.y() + (en_w / 2));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
    mParentPlot->replot();
_seq_analysis_item *SequenceDiagram::itemForPosY(int ypos)
    double key_pos = qRound(key_axis_->pixelToCoord(ypos));
    if (key_pos >= 0 && key_pos < data_->size()) {
}
void Singleton::f2();{
    return range;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
    mParentPlot->replot();
_seq_analysis_item *SequenceDiagram::itemForPosY(int ypos)
    double key_pos = qRound(key_axis_->pixelToCoord(ypos));
    if (key_pos >= 0 && key_pos < data_->size()) {
}
void Singleton::f2();{
    return range;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f3();{
    sainfo_(NULL),
    selected_packet_(0),
    selected_key_(-1.0)
    data_ = new WSCPSeqDataMap();
    // xaxis (value): Address
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
    mParentPlot->replot();
_seq_analysis_item *SequenceDiagram::itemForPosY(int ypos)
    double key_pos = qRound(key_axis_->pixelToCoord(ypos));
    if (key_pos >= 0 && key_pos < data_->size()) {
}
void Singleton::f2();{
    return range;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f3();{
    sainfo_(NULL),
    selected_packet_(0),
    selected_key_(-1.0)
    data_ = new WSCPSeqDataMap();
    // xaxis (value): Address
}
void Singleton::f4();{
            }
        }
    }
    return adjacent_packet;
void SequenceDiagram::setData(_seq_analysis_info *sainfo)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
    mParentPlot->replot();
_seq_analysis_item *SequenceDiagram::itemForPosY(int ypos)
    double key_pos = qRound(key_axis_->pixelToCoord(ypos));
    if (key_pos >= 0 && key_pos < data_->size()) {
}
void Singleton::f2();{
    return range;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f3();{
    sainfo_(NULL),
    selected_packet_(0),
    selected_key_(-1.0)
    data_ = new WSCPSeqDataMap();
    // xaxis (value): Address
}
void Singleton::f4();{
            }
        }
    }
    return adjacent_packet;
void SequenceDiagram::setData(_seq_analysis_info *sainfo)
}
void Singleton::f5();{
            double comment_start = (sai->src_node < sai->dst_node)
                    ? arrow_start.x() : arrow_end.x();
            double arrow_width = (arrow_end.x() - arrow_start.x()) * dir_mul;
            QString arrow_label = cfm.elidedText(sai->frame_label, Qt::ElideRight, arrow_width);
            int arrow_label_width = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
    mParentPlot->replot();
_seq_analysis_item *SequenceDiagram::itemForPosY(int ypos)
    double key_pos = qRound(key_axis_->pixelToCoord(ypos));
    if (key_pos >= 0 && key_pos < data_->size()) {
}
void Singleton::f2();{
    return range;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f3();{
    sainfo_(NULL),
    selected_packet_(0),
    selected_key_(-1.0)
    data_ = new WSCPSeqDataMap();
    // xaxis (value): Address
}
void Singleton::f4();{
            }
        }
    }
    return adjacent_packet;
void SequenceDiagram::setData(_seq_analysis_info *sainfo)
}
void Singleton::f5();{
            double comment_start = (sai->src_node < sai->dst_node)
                    ? arrow_start.x() : arrow_end.x();
            double arrow_width = (arrow_end.x() - arrow_start.x()) * dir_mul;
            QString arrow_label = cfm.elidedText(sai->frame_label, Qt::ElideRight, arrow_width);
            int arrow_label_width = 0;
}
void Singleton::f6();{
        }
    }
void SequenceDiagram::drawLegendIcon(QCPPainter *, const QRectF &) const
QCPRange SequenceDiagram::getKeyRange(bool &validRange, QCP::SignDomain) const
    QCPRange range;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
    mParentPlot->replot();
_seq_analysis_item *SequenceDiagram::itemForPosY(int ypos)
    double key_pos = qRound(key_axis_->pixelToCoord(ypos));
    if (key_pos >= 0 && key_pos < data_->size()) {
}
void Singleton::f2();{
    return range;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f3();{
    sainfo_(NULL),
    selected_packet_(0),
    selected_key_(-1.0)
    data_ = new WSCPSeqDataMap();
    // xaxis (value): Address
}
void Singleton::f4();{
            }
        }
    }
    return adjacent_packet;
void SequenceDiagram::setData(_seq_analysis_info *sainfo)
}
void Singleton::f5();{
            double comment_start = (sai->src_node < sai->dst_node)
                    ? arrow_start.x() : arrow_end.x();
            double arrow_width = (arrow_end.x() - arrow_start.x()) * dir_mul;
            QString arrow_label = cfm.elidedText(sai->frame_label, Qt::ElideRight, arrow_width);
            int arrow_label_width = 0;
}
void Singleton::f6();{
        }
    }
void SequenceDiagram::drawLegendIcon(QCPPainter *, const QRectF &) const
QCPRange SequenceDiagram::getKeyRange(bool &validRange, QCP::SignDomain) const
    QCPRange range;
}
void Singleton::f7();{
            QPoint arrow_start(coordsToPixels(cur_key, sai->src_node).toPoint());
            arrow_start.setY(arrow_start.y() + (en_w / 2));
            QPoint arrow_end(coordsToPixels(cur_key, sai->dst_node).toPoint());
            arrow_end.setY(arrow_start.y());
            QLine arrow_line(arrow_start, arrow_end);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
    mParentPlot->replot();
_seq_analysis_item *SequenceDiagram::itemForPosY(int ypos)
    double key_pos = qRound(key_axis_->pixelToCoord(ypos));
    if (key_pos >= 0 && key_pos < data_->size()) {
}
void Singleton::f2();{
    return range;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f3();{
    sainfo_(NULL),
    selected_packet_(0),
    selected_key_(-1.0)
    data_ = new WSCPSeqDataMap();
    // xaxis (value): Address
}
void Singleton::f4();{
            }
        }
    }
    return adjacent_packet;
void SequenceDiagram::setData(_seq_analysis_info *sainfo)
}
void Singleton::f5();{
            double comment_start = (sai->src_node < sai->dst_node)
                    ? arrow_start.x() : arrow_end.x();
            double arrow_width = (arrow_end.x() - arrow_start.x()) * dir_mul;
            QString arrow_label = cfm.elidedText(sai->frame_label, Qt::ElideRight, arrow_width);
            int arrow_label_width = 0;
}
void Singleton::f6();{
        }
    }
void SequenceDiagram::drawLegendIcon(QCPPainter *, const QRectF &) const
QCPRange SequenceDiagram::getKeyRange(bool &validRange, QCP::SignDomain) const
    QCPRange range;
}
void Singleton::f7();{
            QPoint arrow_start(coordsToPixels(cur_key, sai->src_node).toPoint());
            arrow_start.setY(arrow_start.y() + (en_w / 2));
            QPoint arrow_end(coordsToPixels(cur_key, sai->dst_node).toPoint());
            arrow_end.setY(arrow_start.y());
            QLine arrow_line(arrow_start, arrow_end);
}
void Singleton::f8();{
        return data_->value(key_pos).value;
    }
    return NULL;
double SequenceDiagram::selectTest(const QPointF &pos, bool, QVariant *) const
    double key_pos = qRound(key_axis_->pixelToCoord(pos.y()));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
    mParentPlot->replot();
_seq_analysis_item *SequenceDiagram::itemForPosY(int ypos)
    double key_pos = qRound(key_axis_->pixelToCoord(ypos));
    if (key_pos >= 0 && key_pos < data_->size()) {
}
void Singleton::f2();{
    return range;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f3();{
    sainfo_(NULL),
    selected_packet_(0),
    selected_key_(-1.0)
    data_ = new WSCPSeqDataMap();
    // xaxis (value): Address
}
void Singleton::f4();{
            }
        }
    }
    return adjacent_packet;
void SequenceDiagram::setData(_seq_analysis_info *sainfo)
}
void Singleton::f5();{
            double comment_start = (sai->src_node < sai->dst_node)
                    ? arrow_start.x() : arrow_end.x();
            double arrow_width = (arrow_end.x() - arrow_start.x()) * dir_mul;
            QString arrow_label = cfm.elidedText(sai->frame_label, Qt::ElideRight, arrow_width);
            int arrow_label_width = 0;
}
void Singleton::f6();{
        }
    }
void SequenceDiagram::drawLegendIcon(QCPPainter *, const QRectF &) const
QCPRange SequenceDiagram::getKeyRange(bool &validRange, QCP::SignDomain) const
    QCPRange range;
}
void Singleton::f7();{
            QPoint arrow_start(coordsToPixels(cur_key, sai->src_node).toPoint());
            arrow_start.setY(arrow_start.y() + (en_w / 2));
            QPoint arrow_end(coordsToPixels(cur_key, sai->dst_node).toPoint());
            arrow_end.setY(arrow_start.y());
            QLine arrow_line(arrow_start, arrow_end);
}
void Singleton::f8();{
        return data_->value(key_pos).value;
    }
    return NULL;
double SequenceDiagram::selectTest(const QPointF &pos, bool, QVariant *) const
    double key_pos = qRound(key_axis_->pixelToCoord(pos.y()));
}
void Singleton::f9();{
    return adjacent_packet;
void SequenceDiagram::setData(_seq_analysis_info *sainfo)
    data_->clear();
    sainfo_ = sainfo;
    if (!sainfo) return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    if (item_data->flow->itemData(item_data->curr_index).toString().compare(item_data->info->sainfo()->name) == 0)
        item_data->flow->setCurrentIndex(item_data->curr_index);
    item_data->curr_index++;
    return FALSE;
SequenceInfo::SequenceInfo(seq_analysis_info_t *sainfo) :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    if (item_data->flow->itemData(item_data->curr_index).toString().compare(item_data->info->sainfo()->name) == 0)
        item_data->flow->setCurrentIndex(item_data->curr_index);
    item_data->curr_index++;
    return FALSE;
SequenceInfo::SequenceInfo(seq_analysis_info_t *sainfo) :
}
void Singleton::f2();{
    ctx_menu_.addAction(ui->actionMoveLeft1);
    ctx_menu_.addAction(ui->actionMoveUp1);
    ctx_menu_.addAction(ui->actionMoveDown1);
    ctx_menu_.addSeparator();
    ctx_menu_.addAction(ui->actionGoToPacket);
}
void Singleton::f3();{
    panAxes(0, -1);
void SequenceDialog::on_actionZoomIn_triggered()
    zoomXAxis(true);
void SequenceDialog::on_actionZoomOut_triggered()
    zoomXAxis(false);
}
void Singleton::f4();{
    }
    if (v_pan && !(sp->yAxis->range().contains(min_top_) && sp->yAxis->range().contains(num_items_))) {
        sp->yAxis->moveRange(v_pan);
        sp->replot();
    }
}
void Singleton::f5();{
            double scroll_margin = 3.0; // Lines
            if (old_key >= 0) {
                range_offset = new_key - old_key;
            }
            if (new_key < sp->yAxis->range().lower) {
}
void Singleton::f6();{
    h_pan = sp->xAxis2->range().size() * x_pixels / sp->xAxis2->axisRect()->width();
    if (h_pan < 0) {
        h_pan = qMax(h_pan, min_left_ - sp->xAxis2->range().lower);
    } else {
        h_pan = qMin(h_pan, info_->sainfo()->num_nodes - sp->xAxis2->range().upper);
}
void Singleton::f7();{
        }
    }
    sequence_w_ = one_em_ * 15; // Arbitrary
    mouseMoved(NULL);
    resetAxes();
}
void Singleton::f8();{
    item_data.flow = ui->flowComboBox;
    item_data.info = info_;
    //Add all registered analysis to combo box
    sequence_analysis_table_iterate_tables(addFlowSequenceItem, &item_data);
    if (strcmp(info_->sainfo()->name, "voip") == 0) {
}
void Singleton::f9();{
        break;
    case Qt::Key_Down:
    case Qt::Key_J:
        panAxes(0, -1 * pan_pixels);
        break;
}
void Singleton::f10();{
    if (!info_->sainfo()) return;
    QCustomPlot *sp = ui->sequencePlot;
    double h_pan = 0.0;
    double v_pan = 0.0;
    h_pan = sp->xAxis2->range().size() * x_pixels / sp->xAxis2->axisRect()->width();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    if (item_data->flow->itemData(item_data->curr_index).toString().compare(item_data->info->sainfo()->name) == 0)
        item_data->flow->setCurrentIndex(item_data->curr_index);
    item_data->curr_index++;
    return FALSE;
SequenceInfo::SequenceInfo(seq_analysis_info_t *sainfo) :
}
void Singleton::f2();{
    ctx_menu_.addAction(ui->actionMoveLeft1);
    ctx_menu_.addAction(ui->actionMoveUp1);
    ctx_menu_.addAction(ui->actionMoveDown1);
    ctx_menu_.addSeparator();
    ctx_menu_.addAction(ui->actionGoToPacket);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    if (item_data->flow->itemData(item_data->curr_index).toString().compare(item_data->info->sainfo()->name) == 0)
        item_data->flow->setCurrentIndex(item_data->curr_index);
    item_data->curr_index++;
    return FALSE;
SequenceInfo::SequenceInfo(seq_analysis_info_t *sainfo) :
}
void Singleton::f2();{
    ctx_menu_.addAction(ui->actionMoveLeft1);
    ctx_menu_.addAction(ui->actionMoveUp1);
    ctx_menu_.addAction(ui->actionMoveDown1);
    ctx_menu_.addSeparator();
    ctx_menu_.addAction(ui->actionGoToPacket);
}
void Singleton::f3();{
    panAxes(0, -1);
void SequenceDialog::on_actionZoomIn_triggered()
    zoomXAxis(true);
void SequenceDialog::on_actionZoomOut_triggered()
    zoomXAxis(false);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    if (item_data->flow->itemData(item_data->curr_index).toString().compare(item_data->info->sainfo()->name) == 0)
        item_data->flow->setCurrentIndex(item_data->curr_index);
    item_data->curr_index++;
    return FALSE;
SequenceInfo::SequenceInfo(seq_analysis_info_t *sainfo) :
}
void Singleton::f2();{
    ctx_menu_.addAction(ui->actionMoveLeft1);
    ctx_menu_.addAction(ui->actionMoveUp1);
    ctx_menu_.addAction(ui->actionMoveDown1);
    ctx_menu_.addSeparator();
    ctx_menu_.addAction(ui->actionGoToPacket);
}
void Singleton::f3();{
    panAxes(0, -1);
void SequenceDialog::on_actionZoomIn_triggered()
    zoomXAxis(true);
void SequenceDialog::on_actionZoomOut_triggered()
    zoomXAxis(false);
}
void Singleton::f4();{
    }
    if (v_pan && !(sp->yAxis->range().contains(min_top_) && sp->yAxis->range().contains(num_items_))) {
        sp->yAxis->moveRange(v_pan);
        sp->replot();
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    if (item_data->flow->itemData(item_data->curr_index).toString().compare(item_data->info->sainfo()->name) == 0)
        item_data->flow->setCurrentIndex(item_data->curr_index);
    item_data->curr_index++;
    return FALSE;
SequenceInfo::SequenceInfo(seq_analysis_info_t *sainfo) :
}
void Singleton::f2();{
    ctx_menu_.addAction(ui->actionMoveLeft1);
    ctx_menu_.addAction(ui->actionMoveUp1);
    ctx_menu_.addAction(ui->actionMoveDown1);
    ctx_menu_.addSeparator();
    ctx_menu_.addAction(ui->actionGoToPacket);
}
void Singleton::f3();{
    panAxes(0, -1);
void SequenceDialog::on_actionZoomIn_triggered()
    zoomXAxis(true);
void SequenceDialog::on_actionZoomOut_triggered()
    zoomXAxis(false);
}
void Singleton::f4();{
    }
    if (v_pan && !(sp->yAxis->range().contains(min_top_) && sp->yAxis->range().contains(num_items_))) {
        sp->yAxis->moveRange(v_pan);
        sp->replot();
    }
}
void Singleton::f5();{
            double scroll_margin = 3.0; // Lines
            if (old_key >= 0) {
                range_offset = new_key - old_key;
            }
            if (new_key < sp->yAxis->range().lower) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    if (item_data->flow->itemData(item_data->curr_index).toString().compare(item_data->info->sainfo()->name) == 0)
        item_data->flow->setCurrentIndex(item_data->curr_index);
    item_data->curr_index++;
    return FALSE;
SequenceInfo::SequenceInfo(seq_analysis_info_t *sainfo) :
}
void Singleton::f2();{
    ctx_menu_.addAction(ui->actionMoveLeft1);
    ctx_menu_.addAction(ui->actionMoveUp1);
    ctx_menu_.addAction(ui->actionMoveDown1);
    ctx_menu_.addSeparator();
    ctx_menu_.addAction(ui->actionGoToPacket);
}
void Singleton::f3();{
    panAxes(0, -1);
void SequenceDialog::on_actionZoomIn_triggered()
    zoomXAxis(true);
void SequenceDialog::on_actionZoomOut_triggered()
    zoomXAxis(false);
}
void Singleton::f4();{
    }
    if (v_pan && !(sp->yAxis->range().contains(min_top_) && sp->yAxis->range().contains(num_items_))) {
        sp->yAxis->moveRange(v_pan);
        sp->replot();
    }
}
void Singleton::f5();{
            double scroll_margin = 3.0; // Lines
            if (old_key >= 0) {
                range_offset = new_key - old_key;
            }
            if (new_key < sp->yAxis->range().lower) {
}
void Singleton::f6();{
    h_pan = sp->xAxis2->range().size() * x_pixels / sp->xAxis2->axisRect()->width();
    if (h_pan < 0) {
        h_pan = qMax(h_pan, min_left_ - sp->xAxis2->range().lower);
    } else {
        h_pan = qMin(h_pan, info_->sainfo()->num_nodes - sp->xAxis2->range().upper);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    if (item_data->flow->itemData(item_data->curr_index).toString().compare(item_data->info->sainfo()->name) == 0)
        item_data->flow->setCurrentIndex(item_data->curr_index);
    item_data->curr_index++;
    return FALSE;
SequenceInfo::SequenceInfo(seq_analysis_info_t *sainfo) :
}
void Singleton::f2();{
    ctx_menu_.addAction(ui->actionMoveLeft1);
    ctx_menu_.addAction(ui->actionMoveUp1);
    ctx_menu_.addAction(ui->actionMoveDown1);
    ctx_menu_.addSeparator();
    ctx_menu_.addAction(ui->actionGoToPacket);
}
void Singleton::f3();{
    panAxes(0, -1);
void SequenceDialog::on_actionZoomIn_triggered()
    zoomXAxis(true);
void SequenceDialog::on_actionZoomOut_triggered()
    zoomXAxis(false);
}
void Singleton::f4();{
    }
    if (v_pan && !(sp->yAxis->range().contains(min_top_) && sp->yAxis->range().contains(num_items_))) {
        sp->yAxis->moveRange(v_pan);
        sp->replot();
    }
}
void Singleton::f5();{
            double scroll_margin = 3.0; // Lines
            if (old_key >= 0) {
                range_offset = new_key - old_key;
            }
            if (new_key < sp->yAxis->range().lower) {
}
void Singleton::f6();{
    h_pan = sp->xAxis2->range().size() * x_pixels / sp->xAxis2->axisRect()->width();
    if (h_pan < 0) {
        h_pan = qMax(h_pan, min_left_ - sp->xAxis2->range().lower);
    } else {
        h_pan = qMin(h_pan, info_->sainfo()->num_nodes - sp->xAxis2->range().upper);
}
void Singleton::f7();{
        }
    }
    sequence_w_ = one_em_ * 15; // Arbitrary
    mouseMoved(NULL);
    resetAxes();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    if (item_data->flow->itemData(item_data->curr_index).toString().compare(item_data->info->sainfo()->name) == 0)
        item_data->flow->setCurrentIndex(item_data->curr_index);
    item_data->curr_index++;
    return FALSE;
SequenceInfo::SequenceInfo(seq_analysis_info_t *sainfo) :
}
void Singleton::f2();{
    ctx_menu_.addAction(ui->actionMoveLeft1);
    ctx_menu_.addAction(ui->actionMoveUp1);
    ctx_menu_.addAction(ui->actionMoveDown1);
    ctx_menu_.addSeparator();
    ctx_menu_.addAction(ui->actionGoToPacket);
}
void Singleton::f3();{
    panAxes(0, -1);
void SequenceDialog::on_actionZoomIn_triggered()
    zoomXAxis(true);
void SequenceDialog::on_actionZoomOut_triggered()
    zoomXAxis(false);
}
void Singleton::f4();{
    }
    if (v_pan && !(sp->yAxis->range().contains(min_top_) && sp->yAxis->range().contains(num_items_))) {
        sp->yAxis->moveRange(v_pan);
        sp->replot();
    }
}
void Singleton::f5();{
            double scroll_margin = 3.0; // Lines
            if (old_key >= 0) {
                range_offset = new_key - old_key;
            }
            if (new_key < sp->yAxis->range().lower) {
}
void Singleton::f6();{
    h_pan = sp->xAxis2->range().size() * x_pixels / sp->xAxis2->axisRect()->width();
    if (h_pan < 0) {
        h_pan = qMax(h_pan, min_left_ - sp->xAxis2->range().lower);
    } else {
        h_pan = qMin(h_pan, info_->sainfo()->num_nodes - sp->xAxis2->range().upper);
}
void Singleton::f7();{
        }
    }
    sequence_w_ = one_em_ * 15; // Arbitrary
    mouseMoved(NULL);
    resetAxes();
}
void Singleton::f8();{
    item_data.flow = ui->flowComboBox;
    item_data.info = info_;
    //Add all registered analysis to combo box
    sequence_analysis_table_iterate_tables(addFlowSequenceItem, &item_data);
    if (strcmp(info_->sainfo()->name, "voip") == 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    if (item_data->flow->itemData(item_data->curr_index).toString().compare(item_data->info->sainfo()->name) == 0)
        item_data->flow->setCurrentIndex(item_data->curr_index);
    item_data->curr_index++;
    return FALSE;
SequenceInfo::SequenceInfo(seq_analysis_info_t *sainfo) :
}
void Singleton::f2();{
    ctx_menu_.addAction(ui->actionMoveLeft1);
    ctx_menu_.addAction(ui->actionMoveUp1);
    ctx_menu_.addAction(ui->actionMoveDown1);
    ctx_menu_.addSeparator();
    ctx_menu_.addAction(ui->actionGoToPacket);
}
void Singleton::f3();{
    panAxes(0, -1);
void SequenceDialog::on_actionZoomIn_triggered()
    zoomXAxis(true);
void SequenceDialog::on_actionZoomOut_triggered()
    zoomXAxis(false);
}
void Singleton::f4();{
    }
    if (v_pan && !(sp->yAxis->range().contains(min_top_) && sp->yAxis->range().contains(num_items_))) {
        sp->yAxis->moveRange(v_pan);
        sp->replot();
    }
}
void Singleton::f5();{
            double scroll_margin = 3.0; // Lines
            if (old_key >= 0) {
                range_offset = new_key - old_key;
            }
            if (new_key < sp->yAxis->range().lower) {
}
void Singleton::f6();{
    h_pan = sp->xAxis2->range().size() * x_pixels / sp->xAxis2->axisRect()->width();
    if (h_pan < 0) {
        h_pan = qMax(h_pan, min_left_ - sp->xAxis2->range().lower);
    } else {
        h_pan = qMin(h_pan, info_->sainfo()->num_nodes - sp->xAxis2->range().upper);
}
void Singleton::f7();{
        }
    }
    sequence_w_ = one_em_ * 15; // Arbitrary
    mouseMoved(NULL);
    resetAxes();
}
void Singleton::f8();{
    item_data.flow = ui->flowComboBox;
    item_data.info = info_;
    //Add all registered analysis to combo box
    sequence_analysis_table_iterate_tables(addFlowSequenceItem, &item_data);
    if (strcmp(info_->sainfo()->name, "voip") == 0) {
}
void Singleton::f9();{
        break;
    case Qt::Key_Down:
    case Qt::Key_J:
        panAxes(0, -1 * pan_pixels);
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    cap_file_.retapPackets();
    // We only have one table. Move its tree items up one level.
    if (statsTreeWidget()->invisibleRootItem()->childCount() == 1) {
        statsTreeWidget()->setRootIndex(statsTreeWidget()->model()->index(0, 0));
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    cap_file_.retapPackets();
    // We only have one table. Move its tree items up one level.
    if (statsTreeWidget()->invisibleRootItem()->childCount() == 1) {
        statsTreeWidget()->setRootIndex(statsTreeWidget()->model()->index(0, 0));
    }
}
void Singleton::f2();{
        if (ti->type() == srt_row_type_) {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti->parent());
        } else {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti);
        }
}
void Singleton::f3();{
            this, SLOT(statsTreeWidgetItemChanged()));
ServiceResponseTimeDialog::~ServiceResponseTimeDialog()
    if (srt_data_.srt_array) {
        free_srt_table(srt_, srt_data_.srt_array);
        g_array_free(srt_data_.srt_array, TRUE);
}
void Singleton::f4();{
                        tapDraw)) {
        reject(); // XXX Stay open instead?
        return;
    }
    statsTreeWidget()->setSortingEnabled(false);
}
void Singleton::f5();{
gboolean register_service_response_tables(const void *, void *value, void*)
    register_srt_t *srt = (register_srt_t*)value;
    const char* short_name = proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(srt)));
    char *cfg_abbr = srt_table_get_tap_string(srt);
    tpdCreator tpd_creator = ServiceResponseTimeDialog::createSrtDialog;
}
void Singleton::f6();{
    return tid;
const QString ServiceResponseTimeDialog::filterExpression()
    QString filter_expr;
    if (statsTreeWidget()->selectedItems().count() > 0) {
        QTreeWidgetItem *ti = statsTreeWidget()->selectedItems()[0];
}
void Singleton::f7();{
    srt_row_type_
class SrtRowTreeWidgetItem : public QTreeWidgetItem
public:
    SrtRowTreeWidgetItem(QTreeWidgetItem *parent, const srt_procedure_t *procedure) :
        QTreeWidgetItem (parent, srt_row_type_),
}
void Singleton::f8();{
    new SrtTableTreeWidgetItem(statsTreeWidget(), srt_table);
void ServiceResponseTimeDialog::tapReset(void *srtd_ptr)
    srt_data_t *srtd = (srt_data_t*) srtd_ptr;
    ServiceResponseTimeDialog *srt_dlg = static_cast<ServiceResponseTimeDialog *>(srtd->user_data);
    if (!srt_dlg) return;
}
void Singleton::f9();{
    srt_data_.srt_array = NULL;
    srt_data_.user_data = NULL;
    // Add number of columns for this stats_tree
    QStringList header_labels;
    for (int col = 0; col < NUM_SRT_COLUMNS; col++) {
}
void Singleton::f10();{
    if (!srt_dlg) return;
    reset_srt_table(srtd->srt_array);
    srt_dlg->statsTreeWidget()->clear();
void ServiceResponseTimeDialog::tapDraw(void *srtd_ptr)
    srt_data_t *srtd = (srt_data_t*) srtd_ptr;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    cap_file_.retapPackets();
    // We only have one table. Move its tree items up one level.
    if (statsTreeWidget()->invisibleRootItem()->childCount() == 1) {
        statsTreeWidget()->setRootIndex(statsTreeWidget()->model()->index(0, 0));
    }
}
void Singleton::f2();{
        if (ti->type() == srt_row_type_) {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti->parent());
        } else {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti);
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    cap_file_.retapPackets();
    // We only have one table. Move its tree items up one level.
    if (statsTreeWidget()->invisibleRootItem()->childCount() == 1) {
        statsTreeWidget()->setRootIndex(statsTreeWidget()->model()->index(0, 0));
    }
}
void Singleton::f2();{
        if (ti->type() == srt_row_type_) {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti->parent());
        } else {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti);
        }
}
void Singleton::f3();{
            this, SLOT(statsTreeWidgetItemChanged()));
ServiceResponseTimeDialog::~ServiceResponseTimeDialog()
    if (srt_data_.srt_array) {
        free_srt_table(srt_, srt_data_.srt_array);
        g_array_free(srt_data_.srt_array, TRUE);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    cap_file_.retapPackets();
    // We only have one table. Move its tree items up one level.
    if (statsTreeWidget()->invisibleRootItem()->childCount() == 1) {
        statsTreeWidget()->setRootIndex(statsTreeWidget()->model()->index(0, 0));
    }
}
void Singleton::f2();{
        if (ti->type() == srt_row_type_) {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti->parent());
        } else {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti);
        }
}
void Singleton::f3();{
            this, SLOT(statsTreeWidgetItemChanged()));
ServiceResponseTimeDialog::~ServiceResponseTimeDialog()
    if (srt_data_.srt_array) {
        free_srt_table(srt_, srt_data_.srt_array);
        g_array_free(srt_data_.srt_array, TRUE);
}
void Singleton::f4();{
                        tapDraw)) {
        reject(); // XXX Stay open instead?
        return;
    }
    statsTreeWidget()->setSortingEnabled(false);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    cap_file_.retapPackets();
    // We only have one table. Move its tree items up one level.
    if (statsTreeWidget()->invisibleRootItem()->childCount() == 1) {
        statsTreeWidget()->setRootIndex(statsTreeWidget()->model()->index(0, 0));
    }
}
void Singleton::f2();{
        if (ti->type() == srt_row_type_) {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti->parent());
        } else {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti);
        }
}
void Singleton::f3();{
            this, SLOT(statsTreeWidgetItemChanged()));
ServiceResponseTimeDialog::~ServiceResponseTimeDialog()
    if (srt_data_.srt_array) {
        free_srt_table(srt_, srt_data_.srt_array);
        g_array_free(srt_data_.srt_array, TRUE);
}
void Singleton::f4();{
                        tapDraw)) {
        reject(); // XXX Stay open instead?
        return;
    }
    statsTreeWidget()->setSortingEnabled(false);
}
void Singleton::f5();{
gboolean register_service_response_tables(const void *, void *value, void*)
    register_srt_t *srt = (register_srt_t*)value;
    const char* short_name = proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(srt)));
    char *cfg_abbr = srt_table_get_tap_string(srt);
    tpdCreator tpd_creator = ServiceResponseTimeDialog::createSrtDialog;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    cap_file_.retapPackets();
    // We only have one table. Move its tree items up one level.
    if (statsTreeWidget()->invisibleRootItem()->childCount() == 1) {
        statsTreeWidget()->setRootIndex(statsTreeWidget()->model()->index(0, 0));
    }
}
void Singleton::f2();{
        if (ti->type() == srt_row_type_) {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti->parent());
        } else {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti);
        }
}
void Singleton::f3();{
            this, SLOT(statsTreeWidgetItemChanged()));
ServiceResponseTimeDialog::~ServiceResponseTimeDialog()
    if (srt_data_.srt_array) {
        free_srt_table(srt_, srt_data_.srt_array);
        g_array_free(srt_data_.srt_array, TRUE);
}
void Singleton::f4();{
                        tapDraw)) {
        reject(); // XXX Stay open instead?
        return;
    }
    statsTreeWidget()->setSortingEnabled(false);
}
void Singleton::f5();{
gboolean register_service_response_tables(const void *, void *value, void*)
    register_srt_t *srt = (register_srt_t*)value;
    const char* short_name = proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(srt)));
    char *cfg_abbr = srt_table_get_tap_string(srt);
    tpdCreator tpd_creator = ServiceResponseTimeDialog::createSrtDialog;
}
void Singleton::f6();{
    return tid;
const QString ServiceResponseTimeDialog::filterExpression()
    QString filter_expr;
    if (statsTreeWidget()->selectedItems().count() > 0) {
        QTreeWidgetItem *ti = statsTreeWidget()->selectedItems()[0];
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    cap_file_.retapPackets();
    // We only have one table. Move its tree items up one level.
    if (statsTreeWidget()->invisibleRootItem()->childCount() == 1) {
        statsTreeWidget()->setRootIndex(statsTreeWidget()->model()->index(0, 0));
    }
}
void Singleton::f2();{
        if (ti->type() == srt_row_type_) {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti->parent());
        } else {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti);
        }
}
void Singleton::f3();{
            this, SLOT(statsTreeWidgetItemChanged()));
ServiceResponseTimeDialog::~ServiceResponseTimeDialog()
    if (srt_data_.srt_array) {
        free_srt_table(srt_, srt_data_.srt_array);
        g_array_free(srt_data_.srt_array, TRUE);
}
void Singleton::f4();{
                        tapDraw)) {
        reject(); // XXX Stay open instead?
        return;
    }
    statsTreeWidget()->setSortingEnabled(false);
}
void Singleton::f5();{
gboolean register_service_response_tables(const void *, void *value, void*)
    register_srt_t *srt = (register_srt_t*)value;
    const char* short_name = proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(srt)));
    char *cfg_abbr = srt_table_get_tap_string(srt);
    tpdCreator tpd_creator = ServiceResponseTimeDialog::createSrtDialog;
}
void Singleton::f6();{
    return tid;
const QString ServiceResponseTimeDialog::filterExpression()
    QString filter_expr;
    if (statsTreeWidget()->selectedItems().count() > 0) {
        QTreeWidgetItem *ti = statsTreeWidget()->selectedItems()[0];
}
void Singleton::f7();{
    srt_row_type_
class SrtRowTreeWidgetItem : public QTreeWidgetItem
public:
    SrtRowTreeWidgetItem(QTreeWidgetItem *parent, const srt_procedure_t *procedure) :
        QTreeWidgetItem (parent, srt_row_type_),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    cap_file_.retapPackets();
    // We only have one table. Move its tree items up one level.
    if (statsTreeWidget()->invisibleRootItem()->childCount() == 1) {
        statsTreeWidget()->setRootIndex(statsTreeWidget()->model()->index(0, 0));
    }
}
void Singleton::f2();{
        if (ti->type() == srt_row_type_) {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti->parent());
        } else {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti);
        }
}
void Singleton::f3();{
            this, SLOT(statsTreeWidgetItemChanged()));
ServiceResponseTimeDialog::~ServiceResponseTimeDialog()
    if (srt_data_.srt_array) {
        free_srt_table(srt_, srt_data_.srt_array);
        g_array_free(srt_data_.srt_array, TRUE);
}
void Singleton::f4();{
                        tapDraw)) {
        reject(); // XXX Stay open instead?
        return;
    }
    statsTreeWidget()->setSortingEnabled(false);
}
void Singleton::f5();{
gboolean register_service_response_tables(const void *, void *value, void*)
    register_srt_t *srt = (register_srt_t*)value;
    const char* short_name = proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(srt)));
    char *cfg_abbr = srt_table_get_tap_string(srt);
    tpdCreator tpd_creator = ServiceResponseTimeDialog::createSrtDialog;
}
void Singleton::f6();{
    return tid;
const QString ServiceResponseTimeDialog::filterExpression()
    QString filter_expr;
    if (statsTreeWidget()->selectedItems().count() > 0) {
        QTreeWidgetItem *ti = statsTreeWidget()->selectedItems()[0];
}
void Singleton::f7();{
    srt_row_type_
class SrtRowTreeWidgetItem : public QTreeWidgetItem
public:
    SrtRowTreeWidgetItem(QTreeWidgetItem *parent, const srt_procedure_t *procedure) :
        QTreeWidgetItem (parent, srt_row_type_),
}
void Singleton::f8();{
    new SrtTableTreeWidgetItem(statsTreeWidget(), srt_table);
void ServiceResponseTimeDialog::tapReset(void *srtd_ptr)
    srt_data_t *srtd = (srt_data_t*) srtd_ptr;
    ServiceResponseTimeDialog *srt_dlg = static_cast<ServiceResponseTimeDialog *>(srtd->user_data);
    if (!srt_dlg) return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    cap_file_.retapPackets();
    // We only have one table. Move its tree items up one level.
    if (statsTreeWidget()->invisibleRootItem()->childCount() == 1) {
        statsTreeWidget()->setRootIndex(statsTreeWidget()->model()->index(0, 0));
    }
}
void Singleton::f2();{
        if (ti->type() == srt_row_type_) {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti->parent());
        } else {
            srtt_ti = static_cast<SrtTableTreeWidgetItem *>(ti);
        }
}
void Singleton::f3();{
            this, SLOT(statsTreeWidgetItemChanged()));
ServiceResponseTimeDialog::~ServiceResponseTimeDialog()
    if (srt_data_.srt_array) {
        free_srt_table(srt_, srt_data_.srt_array);
        g_array_free(srt_data_.srt_array, TRUE);
}
void Singleton::f4();{
                        tapDraw)) {
        reject(); // XXX Stay open instead?
        return;
    }
    statsTreeWidget()->setSortingEnabled(false);
}
void Singleton::f5();{
gboolean register_service_response_tables(const void *, void *value, void*)
    register_srt_t *srt = (register_srt_t*)value;
    const char* short_name = proto_get_protocol_short_name(find_protocol_by_id(get_srt_proto_id(srt)));
    char *cfg_abbr = srt_table_get_tap_string(srt);
    tpdCreator tpd_creator = ServiceResponseTimeDialog::createSrtDialog;
}
void Singleton::f6();{
    return tid;
const QString ServiceResponseTimeDialog::filterExpression()
    QString filter_expr;
    if (statsTreeWidget()->selectedItems().count() > 0) {
        QTreeWidgetItem *ti = statsTreeWidget()->selectedItems()[0];
}
void Singleton::f7();{
    srt_row_type_
class SrtRowTreeWidgetItem : public QTreeWidgetItem
public:
    SrtRowTreeWidgetItem(QTreeWidgetItem *parent, const srt_procedure_t *procedure) :
        QTreeWidgetItem (parent, srt_row_type_),
}
void Singleton::f8();{
    new SrtTableTreeWidgetItem(statsTreeWidget(), srt_table);
void ServiceResponseTimeDialog::tapReset(void *srtd_ptr)
    srt_data_t *srtd = (srt_data_t*) srtd_ptr;
    ServiceResponseTimeDialog *srt_dlg = static_cast<ServiceResponseTimeDialog *>(srtd->user_data);
    if (!srt_dlg) return;
}
void Singleton::f9();{
    srt_data_.srt_array = NULL;
    srt_data_.user_data = NULL;
    // Add number of columns for this stats_tree
    QStringList header_labels;
    for (int col = 0; col < NUM_SRT_COLUMNS; col++) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    ui->tePacketBytes->setShowSelectedEnabled(enableShowSelected());
    updateFieldBytes();
void ShowPacketBytesDialog::on_cbShowAs_currentIndexChanged(int idx)
    if (idx < 0) return;
    show_as_ = static_cast<ShowAsType>(ui->cbShowAs->itemData(idx).toInt());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    ui->tePacketBytes->setShowSelectedEnabled(enableShowSelected());
    updateFieldBytes();
void ShowPacketBytesDialog::on_cbShowAs_currentIndexChanged(int idx)
    if (idx < 0) return;
    show_as_ = static_cast<ShowAsType>(ui->cbShowAs->itemData(idx).toInt());
}
void Singleton::f2();{
        ui->tePacketBytes->setPlainText(ba);
        break;
    }
    case ShowAsCArray:
    {
}
void Singleton::f3();{
        QString utf8 = QString::fromUtf8(field_bytes_.constData(), (int)field_bytes_.length());
        ui->tePacketBytes->setLineWrapMode(QTextEdit::WidgetWidth);
        ui->tePacketBytes->setPlainText(utf8);
        break;
    }
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f5();{
        ui->tePacketBytes->setPlainText(field_bytes_.toHex());
        break;
    }
void ShowPacketBytesDialog::captureFileClosing()
    // We have lost the source backend and must disable all functions
}
void Singleton::f6();{
                if (i == 7)
                    *cur++ = ' ';
            }
            while (cur < hexbuf + offset_chars + 53)
                *cur++ = ' '; // Fill it up with space to ascii column
}
void Singleton::f7();{
            int i;
            *cur++ = ' ';
            for (i = 0; i < 8 && pos + i < len; i++) {
                // Prepend entries with " 0x"
                *cur++ = ' ';
}
void Singleton::f8();{
    connect(save_as_button_, SIGNAL(clicked()), this, SLOT(saveAs()));
    connect(ui->buttonBox, SIGNAL(helpRequested()), this, SLOT(helpButton()));
    setStartAndEnd(0, finfo_->length);
    updateFieldBytes(true);
ShowPacketBytesDialog::~ShowPacketBytesDialog()
}
void Singleton::f9();{
    case ShowAsASCII:
    case ShowAsASCIIandControl:
    case ShowAsCArray:
    case ShowAsHexDump:
    case ShowAsISO8859_1:
}
void Singleton::f10();{
    }
    case ShowAsUTF16:
    {
        // QString::fromUtf16 calls QUtf16::convertToUnicode, casting buffer
        // back to a const char * and doubling nchars.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    ui->tePacketBytes->setShowSelectedEnabled(enableShowSelected());
    updateFieldBytes();
void ShowPacketBytesDialog::on_cbShowAs_currentIndexChanged(int idx)
    if (idx < 0) return;
    show_as_ = static_cast<ShowAsType>(ui->cbShowAs->itemData(idx).toInt());
}
void Singleton::f2();{
        ui->tePacketBytes->setPlainText(ba);
        break;
    }
    case ShowAsCArray:
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    ui->tePacketBytes->setShowSelectedEnabled(enableShowSelected());
    updateFieldBytes();
void ShowPacketBytesDialog::on_cbShowAs_currentIndexChanged(int idx)
    if (idx < 0) return;
    show_as_ = static_cast<ShowAsType>(ui->cbShowAs->itemData(idx).toInt());
}
void Singleton::f2();{
        ui->tePacketBytes->setPlainText(ba);
        break;
    }
    case ShowAsCArray:
    {
}
void Singleton::f3();{
        QString utf8 = QString::fromUtf8(field_bytes_.constData(), (int)field_bytes_.length());
        ui->tePacketBytes->setLineWrapMode(QTextEdit::WidgetWidth);
        ui->tePacketBytes->setPlainText(utf8);
        break;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    ui->tePacketBytes->setShowSelectedEnabled(enableShowSelected());
    updateFieldBytes();
void ShowPacketBytesDialog::on_cbShowAs_currentIndexChanged(int idx)
    if (idx < 0) return;
    show_as_ = static_cast<ShowAsType>(ui->cbShowAs->itemData(idx).toInt());
}
void Singleton::f2();{
        ui->tePacketBytes->setPlainText(ba);
        break;
    }
    case ShowAsCArray:
    {
}
void Singleton::f3();{
        QString utf8 = QString::fromUtf8(field_bytes_.constData(), (int)field_bytes_.length());
        ui->tePacketBytes->setLineWrapMode(QTextEdit::WidgetWidth);
        ui->tePacketBytes->setPlainText(utf8);
        break;
    }
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    ui->tePacketBytes->setShowSelectedEnabled(enableShowSelected());
    updateFieldBytes();
void ShowPacketBytesDialog::on_cbShowAs_currentIndexChanged(int idx)
    if (idx < 0) return;
    show_as_ = static_cast<ShowAsType>(ui->cbShowAs->itemData(idx).toInt());
}
void Singleton::f2();{
        ui->tePacketBytes->setPlainText(ba);
        break;
    }
    case ShowAsCArray:
    {
}
void Singleton::f3();{
        QString utf8 = QString::fromUtf8(field_bytes_.constData(), (int)field_bytes_.length());
        ui->tePacketBytes->setLineWrapMode(QTextEdit::WidgetWidth);
        ui->tePacketBytes->setPlainText(utf8);
        break;
    }
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f5();{
        ui->tePacketBytes->setPlainText(field_bytes_.toHex());
        break;
    }
void ShowPacketBytesDialog::captureFileClosing()
    // We have lost the source backend and must disable all functions
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    ui->tePacketBytes->setShowSelectedEnabled(enableShowSelected());
    updateFieldBytes();
void ShowPacketBytesDialog::on_cbShowAs_currentIndexChanged(int idx)
    if (idx < 0) return;
    show_as_ = static_cast<ShowAsType>(ui->cbShowAs->itemData(idx).toInt());
}
void Singleton::f2();{
        ui->tePacketBytes->setPlainText(ba);
        break;
    }
    case ShowAsCArray:
    {
}
void Singleton::f3();{
        QString utf8 = QString::fromUtf8(field_bytes_.constData(), (int)field_bytes_.length());
        ui->tePacketBytes->setLineWrapMode(QTextEdit::WidgetWidth);
        ui->tePacketBytes->setPlainText(utf8);
        break;
    }
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f5();{
        ui->tePacketBytes->setPlainText(field_bytes_.toHex());
        break;
    }
void ShowPacketBytesDialog::captureFileClosing()
    // We have lost the source backend and must disable all functions
}
void Singleton::f6();{
                if (i == 7)
                    *cur++ = ' ';
            }
            while (cur < hexbuf + offset_chars + 53)
                *cur++ = ' '; // Fill it up with space to ascii column
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    ui->tePacketBytes->setShowSelectedEnabled(enableShowSelected());
    updateFieldBytes();
void ShowPacketBytesDialog::on_cbShowAs_currentIndexChanged(int idx)
    if (idx < 0) return;
    show_as_ = static_cast<ShowAsType>(ui->cbShowAs->itemData(idx).toInt());
}
void Singleton::f2();{
        ui->tePacketBytes->setPlainText(ba);
        break;
    }
    case ShowAsCArray:
    {
}
void Singleton::f3();{
        QString utf8 = QString::fromUtf8(field_bytes_.constData(), (int)field_bytes_.length());
        ui->tePacketBytes->setLineWrapMode(QTextEdit::WidgetWidth);
        ui->tePacketBytes->setPlainText(utf8);
        break;
    }
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f5();{
        ui->tePacketBytes->setPlainText(field_bytes_.toHex());
        break;
    }
void ShowPacketBytesDialog::captureFileClosing()
    // We have lost the source backend and must disable all functions
}
void Singleton::f6();{
                if (i == 7)
                    *cur++ = ' ';
            }
            while (cur < hexbuf + offset_chars + 53)
                *cur++ = ' '; // Fill it up with space to ascii column
}
void Singleton::f7();{
            int i;
            *cur++ = ' ';
            for (i = 0; i < 8 && pos + i < len; i++) {
                // Prepend entries with " 0x"
                *cur++ = ' ';
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    ui->tePacketBytes->setShowSelectedEnabled(enableShowSelected());
    updateFieldBytes();
void ShowPacketBytesDialog::on_cbShowAs_currentIndexChanged(int idx)
    if (idx < 0) return;
    show_as_ = static_cast<ShowAsType>(ui->cbShowAs->itemData(idx).toInt());
}
void Singleton::f2();{
        ui->tePacketBytes->setPlainText(ba);
        break;
    }
    case ShowAsCArray:
    {
}
void Singleton::f3();{
        QString utf8 = QString::fromUtf8(field_bytes_.constData(), (int)field_bytes_.length());
        ui->tePacketBytes->setLineWrapMode(QTextEdit::WidgetWidth);
        ui->tePacketBytes->setPlainText(utf8);
        break;
    }
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f5();{
        ui->tePacketBytes->setPlainText(field_bytes_.toHex());
        break;
    }
void ShowPacketBytesDialog::captureFileClosing()
    // We have lost the source backend and must disable all functions
}
void Singleton::f6();{
                if (i == 7)
                    *cur++ = ' ';
            }
            while (cur < hexbuf + offset_chars + 53)
                *cur++ = ' '; // Fill it up with space to ascii column
}
void Singleton::f7();{
            int i;
            *cur++ = ' ';
            for (i = 0; i < 8 && pos + i < len; i++) {
                // Prepend entries with " 0x"
                *cur++ = ' ';
}
void Singleton::f8();{
    connect(save_as_button_, SIGNAL(clicked()), this, SLOT(saveAs()));
    connect(ui->buttonBox, SIGNAL(helpRequested()), this, SLOT(helpButton()));
    setStartAndEnd(0, finfo_->length);
    updateFieldBytes(true);
ShowPacketBytesDialog::~ShowPacketBytesDialog()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    ui->tePacketBytes->setShowSelectedEnabled(enableShowSelected());
    updateFieldBytes();
void ShowPacketBytesDialog::on_cbShowAs_currentIndexChanged(int idx)
    if (idx < 0) return;
    show_as_ = static_cast<ShowAsType>(ui->cbShowAs->itemData(idx).toInt());
}
void Singleton::f2();{
        ui->tePacketBytes->setPlainText(ba);
        break;
    }
    case ShowAsCArray:
    {
}
void Singleton::f3();{
        QString utf8 = QString::fromUtf8(field_bytes_.constData(), (int)field_bytes_.length());
        ui->tePacketBytes->setLineWrapMode(QTextEdit::WidgetWidth);
        ui->tePacketBytes->setPlainText(utf8);
        break;
    }
}
void Singleton::f4();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f5();{
        ui->tePacketBytes->setPlainText(field_bytes_.toHex());
        break;
    }
void ShowPacketBytesDialog::captureFileClosing()
    // We have lost the source backend and must disable all functions
}
void Singleton::f6();{
                if (i == 7)
                    *cur++ = ' ';
            }
            while (cur < hexbuf + offset_chars + 53)
                *cur++ = ' '; // Fill it up with space to ascii column
}
void Singleton::f7();{
            int i;
            *cur++ = ' ';
            for (i = 0; i < 8 && pos + i < len; i++) {
                // Prepend entries with " 0x"
                *cur++ = ' ';
}
void Singleton::f8();{
    connect(save_as_button_, SIGNAL(clicked()), this, SLOT(saveAs()));
    connect(ui->buttonBox, SIGNAL(helpRequested()), this, SLOT(helpButton()));
    setStartAndEnd(0, finfo_->length);
    updateFieldBytes(true);
ShowPacketBytesDialog::~ShowPacketBytesDialog()
}
void Singleton::f9();{
    case ShowAsASCII:
    case ShowAsASCIIandControl:
    case ShowAsCArray:
    case ShowAsHexDump:
    case ShowAsISO8859_1:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
void SimpleDialog::displayQueuedMessages(QWidget *parent)
    if (message_queue_.isEmpty()) {
        return;
    }
    QMessageBox mb(parent ? parent : wsApp->mainWindow());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
void SimpleDialog::displayQueuedMessages(QWidget *parent)
    if (message_queue_.isEmpty()) {
        return;
    }
    QMessageBox mb(parent ? parent : wsApp->mainWindow());
}
void Singleton::f2();{
        return;
    }
    message_box_->setDetailedText(detailed_text_);
    message_box_->setCheckBox(check_box_);
    visible_messages_mutex.lock();
}
void Singleton::f3();{
QString SimpleDialog::dontShowThisAgain()
    return QObject::tr("Don't show this message again.");
int SimpleDialog::exec()
    if (!message_box_) {
        return 0;
}
void Singleton::f4();{
        if (visible_messages[i].box == box) {
            g_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_WARNING, "%d duplicates of \"%s\" were suppressed",
                visible_messages[i].counter, box->text().toStdString().c_str());
            visible_messages.removeAt(i);
            break;
}
void Singleton::f5();{
    va_list ap;
    va_start(ap, msg_format);
    vsimple_error_message_box(msg_format, ap);
    va_end(ap);
SimpleDialog::SimpleDialog(QWidget *parent, ESD_TYPE_E type, int btn_mask, const char *msg_format, va_list ap) :
}
void Singleton::f6();{
            max_severity_ = type;
        }
        return;
    }
    message_box_ = new QMessageBox(parent);
}
void Singleton::f7();{
        delete message_box_;
    }
    else
    {
        QObject::connect(message_box_, &QMessageBox::finished,
}
void Singleton::f8();{
    va_list ap;
    va_start(ap, msg_format);
    SimpleDialog sd(wsApp->mainWindow(), type, ESD_BTN_OK, msg_format, ap);
    va_end(ap);
    sd.setDetailedText(secondary_msg);
}
void Singleton::f9();{
    case ESD_TYPE_WARN:
        message_box_->setIcon(QMessageBox::Warning);
        break;
    case ESD_TYPE_CONFIRMATION:
        message_box_->setIcon(QMessageBox::Question);
}
void Singleton::f10();{
    max_severity_ = ESD_TYPE_INFO;
    mb.exec();
QString SimpleDialog::dontShowThisAgain()
    return QObject::tr("Don't show this message again.");
int SimpleDialog::exec()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
void SimpleDialog::displayQueuedMessages(QWidget *parent)
    if (message_queue_.isEmpty()) {
        return;
    }
    QMessageBox mb(parent ? parent : wsApp->mainWindow());
}
void Singleton::f2();{
        return;
    }
    message_box_->setDetailedText(detailed_text_);
    message_box_->setCheckBox(check_box_);
    visible_messages_mutex.lock();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
void SimpleDialog::displayQueuedMessages(QWidget *parent)
    if (message_queue_.isEmpty()) {
        return;
    }
    QMessageBox mb(parent ? parent : wsApp->mainWindow());
}
void Singleton::f2();{
        return;
    }
    message_box_->setDetailedText(detailed_text_);
    message_box_->setCheckBox(check_box_);
    visible_messages_mutex.lock();
}
void Singleton::f3();{
QString SimpleDialog::dontShowThisAgain()
    return QObject::tr("Don't show this message again.");
int SimpleDialog::exec()
    if (!message_box_) {
        return 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
void SimpleDialog::displayQueuedMessages(QWidget *parent)
    if (message_queue_.isEmpty()) {
        return;
    }
    QMessageBox mb(parent ? parent : wsApp->mainWindow());
}
void Singleton::f2();{
        return;
    }
    message_box_->setDetailedText(detailed_text_);
    message_box_->setCheckBox(check_box_);
    visible_messages_mutex.lock();
}
void Singleton::f3();{
QString SimpleDialog::dontShowThisAgain()
    return QObject::tr("Don't show this message again.");
int SimpleDialog::exec()
    if (!message_box_) {
        return 0;
}
void Singleton::f4();{
        if (visible_messages[i].box == box) {
            g_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_WARNING, "%d duplicates of \"%s\" were suppressed",
                visible_messages[i].counter, box->text().toStdString().c_str());
            visible_messages.removeAt(i);
            break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
void SimpleDialog::displayQueuedMessages(QWidget *parent)
    if (message_queue_.isEmpty()) {
        return;
    }
    QMessageBox mb(parent ? parent : wsApp->mainWindow());
}
void Singleton::f2();{
        return;
    }
    message_box_->setDetailedText(detailed_text_);
    message_box_->setCheckBox(check_box_);
    visible_messages_mutex.lock();
}
void Singleton::f3();{
QString SimpleDialog::dontShowThisAgain()
    return QObject::tr("Don't show this message again.");
int SimpleDialog::exec()
    if (!message_box_) {
        return 0;
}
void Singleton::f4();{
        if (visible_messages[i].box == box) {
            g_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_WARNING, "%d duplicates of \"%s\" were suppressed",
                visible_messages[i].counter, box->text().toStdString().c_str());
            visible_messages.removeAt(i);
            break;
}
void Singleton::f5();{
    va_list ap;
    va_start(ap, msg_format);
    vsimple_error_message_box(msg_format, ap);
    va_end(ap);
SimpleDialog::SimpleDialog(QWidget *parent, ESD_TYPE_E type, int btn_mask, const char *msg_format, va_list ap) :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
void SimpleDialog::displayQueuedMessages(QWidget *parent)
    if (message_queue_.isEmpty()) {
        return;
    }
    QMessageBox mb(parent ? parent : wsApp->mainWindow());
}
void Singleton::f2();{
        return;
    }
    message_box_->setDetailedText(detailed_text_);
    message_box_->setCheckBox(check_box_);
    visible_messages_mutex.lock();
}
void Singleton::f3();{
QString SimpleDialog::dontShowThisAgain()
    return QObject::tr("Don't show this message again.");
int SimpleDialog::exec()
    if (!message_box_) {
        return 0;
}
void Singleton::f4();{
        if (visible_messages[i].box == box) {
            g_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_WARNING, "%d duplicates of \"%s\" were suppressed",
                visible_messages[i].counter, box->text().toStdString().c_str());
            visible_messages.removeAt(i);
            break;
}
void Singleton::f5();{
    va_list ap;
    va_start(ap, msg_format);
    vsimple_error_message_box(msg_format, ap);
    va_end(ap);
SimpleDialog::SimpleDialog(QWidget *parent, ESD_TYPE_E type, int btn_mask, const char *msg_format, va_list ap) :
}
void Singleton::f6();{
            max_severity_ = type;
        }
        return;
    }
    message_box_ = new QMessageBox(parent);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
void SimpleDialog::displayQueuedMessages(QWidget *parent)
    if (message_queue_.isEmpty()) {
        return;
    }
    QMessageBox mb(parent ? parent : wsApp->mainWindow());
}
void Singleton::f2();{
        return;
    }
    message_box_->setDetailedText(detailed_text_);
    message_box_->setCheckBox(check_box_);
    visible_messages_mutex.lock();
}
void Singleton::f3();{
QString SimpleDialog::dontShowThisAgain()
    return QObject::tr("Don't show this message again.");
int SimpleDialog::exec()
    if (!message_box_) {
        return 0;
}
void Singleton::f4();{
        if (visible_messages[i].box == box) {
            g_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_WARNING, "%d duplicates of \"%s\" were suppressed",
                visible_messages[i].counter, box->text().toStdString().c_str());
            visible_messages.removeAt(i);
            break;
}
void Singleton::f5();{
    va_list ap;
    va_start(ap, msg_format);
    vsimple_error_message_box(msg_format, ap);
    va_end(ap);
SimpleDialog::SimpleDialog(QWidget *parent, ESD_TYPE_E type, int btn_mask, const char *msg_format, va_list ap) :
}
void Singleton::f6();{
            max_severity_ = type;
        }
        return;
    }
    message_box_ = new QMessageBox(parent);
}
void Singleton::f7();{
        delete message_box_;
    }
    else
    {
        QObject::connect(message_box_, &QMessageBox::finished,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
void SimpleDialog::displayQueuedMessages(QWidget *parent)
    if (message_queue_.isEmpty()) {
        return;
    }
    QMessageBox mb(parent ? parent : wsApp->mainWindow());
}
void Singleton::f2();{
        return;
    }
    message_box_->setDetailedText(detailed_text_);
    message_box_->setCheckBox(check_box_);
    visible_messages_mutex.lock();
}
void Singleton::f3();{
QString SimpleDialog::dontShowThisAgain()
    return QObject::tr("Don't show this message again.");
int SimpleDialog::exec()
    if (!message_box_) {
        return 0;
}
void Singleton::f4();{
        if (visible_messages[i].box == box) {
            g_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_WARNING, "%d duplicates of \"%s\" were suppressed",
                visible_messages[i].counter, box->text().toStdString().c_str());
            visible_messages.removeAt(i);
            break;
}
void Singleton::f5();{
    va_list ap;
    va_start(ap, msg_format);
    vsimple_error_message_box(msg_format, ap);
    va_end(ap);
SimpleDialog::SimpleDialog(QWidget *parent, ESD_TYPE_E type, int btn_mask, const char *msg_format, va_list ap) :
}
void Singleton::f6();{
            max_severity_ = type;
        }
        return;
    }
    message_box_ = new QMessageBox(parent);
}
void Singleton::f7();{
        delete message_box_;
    }
    else
    {
        QObject::connect(message_box_, &QMessageBox::finished,
}
void Singleton::f8();{
    va_list ap;
    va_start(ap, msg_format);
    SimpleDialog sd(wsApp->mainWindow(), type, ESD_BTN_OK, msg_format, ap);
    va_end(ap);
    sd.setDetailedText(secondary_msg);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
void SimpleDialog::displayQueuedMessages(QWidget *parent)
    if (message_queue_.isEmpty()) {
        return;
    }
    QMessageBox mb(parent ? parent : wsApp->mainWindow());
}
void Singleton::f2();{
        return;
    }
    message_box_->setDetailedText(detailed_text_);
    message_box_->setCheckBox(check_box_);
    visible_messages_mutex.lock();
}
void Singleton::f3();{
QString SimpleDialog::dontShowThisAgain()
    return QObject::tr("Don't show this message again.");
int SimpleDialog::exec()
    if (!message_box_) {
        return 0;
}
void Singleton::f4();{
        if (visible_messages[i].box == box) {
            g_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_WARNING, "%d duplicates of \"%s\" were suppressed",
                visible_messages[i].counter, box->text().toStdString().c_str());
            visible_messages.removeAt(i);
            break;
}
void Singleton::f5();{
    va_list ap;
    va_start(ap, msg_format);
    vsimple_error_message_box(msg_format, ap);
    va_end(ap);
SimpleDialog::SimpleDialog(QWidget *parent, ESD_TYPE_E type, int btn_mask, const char *msg_format, va_list ap) :
}
void Singleton::f6();{
            max_severity_ = type;
        }
        return;
    }
    message_box_ = new QMessageBox(parent);
}
void Singleton::f7();{
        delete message_box_;
    }
    else
    {
        QObject::connect(message_box_, &QMessageBox::finished,
}
void Singleton::f8();{
    va_list ap;
    va_start(ap, msg_format);
    SimpleDialog sd(wsApp->mainWindow(), type, ESD_BTN_OK, msg_format, ap);
    va_end(ap);
    sd.setDetailedText(secondary_msg);
}
void Singleton::f9();{
    case ESD_TYPE_WARN:
        message_box_->setIcon(QMessageBox::Warning);
        break;
    case ESD_TYPE_CONFIRMATION:
        message_box_->setIcon(QMessageBox::Question);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
SimpleStatisticsDialog::~SimpleStatisticsDialog()
    stu_->refcount--;
    if (stu_->refcount == 0) {
        if (stu_->tables)
            free_stat_tables(stu_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
SimpleStatisticsDialog::~SimpleStatisticsDialog()
    stu_->refcount--;
    if (stu_->refcount == 0) {
        if (stu_->tables)
            free_stat_tables(stu_);
}
void Singleton::f2();{
    if (!ss_dlg) return;
    ss_dlg->addMissingRows(sd);
    QTreeWidgetItemIterator it(ss_dlg->statsTreeWidget());
    while (*it) {
        if ((*it)->type() == simple_row_type_) {
}
void Singleton::f3();{
    statsTreeWidget()->setHeaderLabels(header_labels);
    for (int col = 0; col < (int) stu_->nfields; col++) {
        if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
            statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
        }
}
void Singleton::f4();{
    simple_row_type_ = 1000
class SimpleStatisticsTreeWidgetItem : public QTreeWidgetItem
public:
    SimpleStatisticsTreeWidgetItem(QTreeWidgetItem *parent, int num_fields, const stat_tap_table_item_type *fields) :
        QTreeWidgetItem (parent, simple_row_type_),
}
void Singleton::f5();{
static QHash<const QString, stat_tap_table_ui *> cfg_str_to_stu_;
extern "C" {
static void
simple_stat_init(const char *args, void*) {
    QStringList args_l = QString(args).split(',');
}
void Singleton::f6();{
                for (int col = 0; col < (int) stu_->nfields; col++) {
                    if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
                        ss_ti->setTextAlignment(col, Qt::AlignRight);
                    }
                }
}
void Singleton::f7();{
            ti = statsTreeWidget()->topLevelItem(table_idx);
        }
        for (guint element = ti->childCount(); element < st_table->num_elements; element++) {
            stat_tap_table_item_type* fields = stat_tap_get_field_data(st_table, element, 0);
            if (stu_->nfields > 0) {
}
void Singleton::f8();{
        free_stat_tables(stu_);
        reject(); // XXX Stay open instead?
        return;
    }
    cap_file_.retapPackets();
}
void Singleton::f9();{
        }
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
        int col = treeWidget()->sortColumn();
}
void Singleton::f10();{
    while (*it) {
        if ((*it)->type() == simple_row_type_) {
            SimpleStatisticsTreeWidgetItem *ss_ti = static_cast<SimpleStatisticsTreeWidgetItem *>((*it));
            ss_ti->draw();
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
SimpleStatisticsDialog::~SimpleStatisticsDialog()
    stu_->refcount--;
    if (stu_->refcount == 0) {
        if (stu_->tables)
            free_stat_tables(stu_);
}
void Singleton::f2();{
    if (!ss_dlg) return;
    ss_dlg->addMissingRows(sd);
    QTreeWidgetItemIterator it(ss_dlg->statsTreeWidget());
    while (*it) {
        if ((*it)->type() == simple_row_type_) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
SimpleStatisticsDialog::~SimpleStatisticsDialog()
    stu_->refcount--;
    if (stu_->refcount == 0) {
        if (stu_->tables)
            free_stat_tables(stu_);
}
void Singleton::f2();{
    if (!ss_dlg) return;
    ss_dlg->addMissingRows(sd);
    QTreeWidgetItemIterator it(ss_dlg->statsTreeWidget());
    while (*it) {
        if ((*it)->type() == simple_row_type_) {
}
void Singleton::f3();{
    statsTreeWidget()->setHeaderLabels(header_labels);
    for (int col = 0; col < (int) stu_->nfields; col++) {
        if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
            statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
SimpleStatisticsDialog::~SimpleStatisticsDialog()
    stu_->refcount--;
    if (stu_->refcount == 0) {
        if (stu_->tables)
            free_stat_tables(stu_);
}
void Singleton::f2();{
    if (!ss_dlg) return;
    ss_dlg->addMissingRows(sd);
    QTreeWidgetItemIterator it(ss_dlg->statsTreeWidget());
    while (*it) {
        if ((*it)->type() == simple_row_type_) {
}
void Singleton::f3();{
    statsTreeWidget()->setHeaderLabels(header_labels);
    for (int col = 0; col < (int) stu_->nfields; col++) {
        if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
            statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
        }
}
void Singleton::f4();{
    simple_row_type_ = 1000
class SimpleStatisticsTreeWidgetItem : public QTreeWidgetItem
public:
    SimpleStatisticsTreeWidgetItem(QTreeWidgetItem *parent, int num_fields, const stat_tap_table_item_type *fields) :
        QTreeWidgetItem (parent, simple_row_type_),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
SimpleStatisticsDialog::~SimpleStatisticsDialog()
    stu_->refcount--;
    if (stu_->refcount == 0) {
        if (stu_->tables)
            free_stat_tables(stu_);
}
void Singleton::f2();{
    if (!ss_dlg) return;
    ss_dlg->addMissingRows(sd);
    QTreeWidgetItemIterator it(ss_dlg->statsTreeWidget());
    while (*it) {
        if ((*it)->type() == simple_row_type_) {
}
void Singleton::f3();{
    statsTreeWidget()->setHeaderLabels(header_labels);
    for (int col = 0; col < (int) stu_->nfields; col++) {
        if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
            statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
        }
}
void Singleton::f4();{
    simple_row_type_ = 1000
class SimpleStatisticsTreeWidgetItem : public QTreeWidgetItem
public:
    SimpleStatisticsTreeWidgetItem(QTreeWidgetItem *parent, int num_fields, const stat_tap_table_item_type *fields) :
        QTreeWidgetItem (parent, simple_row_type_),
}
void Singleton::f5();{
static QHash<const QString, stat_tap_table_ui *> cfg_str_to_stu_;
extern "C" {
static void
simple_stat_init(const char *args, void*) {
    QStringList args_l = QString(args).split(',');
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
SimpleStatisticsDialog::~SimpleStatisticsDialog()
    stu_->refcount--;
    if (stu_->refcount == 0) {
        if (stu_->tables)
            free_stat_tables(stu_);
}
void Singleton::f2();{
    if (!ss_dlg) return;
    ss_dlg->addMissingRows(sd);
    QTreeWidgetItemIterator it(ss_dlg->statsTreeWidget());
    while (*it) {
        if ((*it)->type() == simple_row_type_) {
}
void Singleton::f3();{
    statsTreeWidget()->setHeaderLabels(header_labels);
    for (int col = 0; col < (int) stu_->nfields; col++) {
        if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
            statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
        }
}
void Singleton::f4();{
    simple_row_type_ = 1000
class SimpleStatisticsTreeWidgetItem : public QTreeWidgetItem
public:
    SimpleStatisticsTreeWidgetItem(QTreeWidgetItem *parent, int num_fields, const stat_tap_table_item_type *fields) :
        QTreeWidgetItem (parent, simple_row_type_),
}
void Singleton::f5();{
static QHash<const QString, stat_tap_table_ui *> cfg_str_to_stu_;
extern "C" {
static void
simple_stat_init(const char *args, void*) {
    QStringList args_l = QString(args).split(',');
}
void Singleton::f6();{
                for (int col = 0; col < (int) stu_->nfields; col++) {
                    if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
                        ss_ti->setTextAlignment(col, Qt::AlignRight);
                    }
                }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
SimpleStatisticsDialog::~SimpleStatisticsDialog()
    stu_->refcount--;
    if (stu_->refcount == 0) {
        if (stu_->tables)
            free_stat_tables(stu_);
}
void Singleton::f2();{
    if (!ss_dlg) return;
    ss_dlg->addMissingRows(sd);
    QTreeWidgetItemIterator it(ss_dlg->statsTreeWidget());
    while (*it) {
        if ((*it)->type() == simple_row_type_) {
}
void Singleton::f3();{
    statsTreeWidget()->setHeaderLabels(header_labels);
    for (int col = 0; col < (int) stu_->nfields; col++) {
        if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
            statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
        }
}
void Singleton::f4();{
    simple_row_type_ = 1000
class SimpleStatisticsTreeWidgetItem : public QTreeWidgetItem
public:
    SimpleStatisticsTreeWidgetItem(QTreeWidgetItem *parent, int num_fields, const stat_tap_table_item_type *fields) :
        QTreeWidgetItem (parent, simple_row_type_),
}
void Singleton::f5();{
static QHash<const QString, stat_tap_table_ui *> cfg_str_to_stu_;
extern "C" {
static void
simple_stat_init(const char *args, void*) {
    QStringList args_l = QString(args).split(',');
}
void Singleton::f6();{
                for (int col = 0; col < (int) stu_->nfields; col++) {
                    if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
                        ss_ti->setTextAlignment(col, Qt::AlignRight);
                    }
                }
}
void Singleton::f7();{
            ti = statsTreeWidget()->topLevelItem(table_idx);
        }
        for (guint element = ti->childCount(); element < st_table->num_elements; element++) {
            stat_tap_table_item_type* fields = stat_tap_get_field_data(st_table, element, 0);
            if (stu_->nfields > 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
SimpleStatisticsDialog::~SimpleStatisticsDialog()
    stu_->refcount--;
    if (stu_->refcount == 0) {
        if (stu_->tables)
            free_stat_tables(stu_);
}
void Singleton::f2();{
    if (!ss_dlg) return;
    ss_dlg->addMissingRows(sd);
    QTreeWidgetItemIterator it(ss_dlg->statsTreeWidget());
    while (*it) {
        if ((*it)->type() == simple_row_type_) {
}
void Singleton::f3();{
    statsTreeWidget()->setHeaderLabels(header_labels);
    for (int col = 0; col < (int) stu_->nfields; col++) {
        if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
            statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
        }
}
void Singleton::f4();{
    simple_row_type_ = 1000
class SimpleStatisticsTreeWidgetItem : public QTreeWidgetItem
public:
    SimpleStatisticsTreeWidgetItem(QTreeWidgetItem *parent, int num_fields, const stat_tap_table_item_type *fields) :
        QTreeWidgetItem (parent, simple_row_type_),
}
void Singleton::f5();{
static QHash<const QString, stat_tap_table_ui *> cfg_str_to_stu_;
extern "C" {
static void
simple_stat_init(const char *args, void*) {
    QStringList args_l = QString(args).split(',');
}
void Singleton::f6();{
                for (int col = 0; col < (int) stu_->nfields; col++) {
                    if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
                        ss_ti->setTextAlignment(col, Qt::AlignRight);
                    }
                }
}
void Singleton::f7();{
            ti = statsTreeWidget()->topLevelItem(table_idx);
        }
        for (guint element = ti->childCount(); element < st_table->num_elements; element++) {
            stat_tap_table_item_type* fields = stat_tap_get_field_data(st_table, element, 0);
            if (stu_->nfields > 0) {
}
void Singleton::f8();{
        free_stat_tables(stu_);
        reject(); // XXX Stay open instead?
        return;
    }
    cap_file_.retapPackets();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
SimpleStatisticsDialog::~SimpleStatisticsDialog()
    stu_->refcount--;
    if (stu_->refcount == 0) {
        if (stu_->tables)
            free_stat_tables(stu_);
}
void Singleton::f2();{
    if (!ss_dlg) return;
    ss_dlg->addMissingRows(sd);
    QTreeWidgetItemIterator it(ss_dlg->statsTreeWidget());
    while (*it) {
        if ((*it)->type() == simple_row_type_) {
}
void Singleton::f3();{
    statsTreeWidget()->setHeaderLabels(header_labels);
    for (int col = 0; col < (int) stu_->nfields; col++) {
        if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
            statsTreeWidget()->headerItem()->setTextAlignment(col, Qt::AlignRight);
        }
}
void Singleton::f4();{
    simple_row_type_ = 1000
class SimpleStatisticsTreeWidgetItem : public QTreeWidgetItem
public:
    SimpleStatisticsTreeWidgetItem(QTreeWidgetItem *parent, int num_fields, const stat_tap_table_item_type *fields) :
        QTreeWidgetItem (parent, simple_row_type_),
}
void Singleton::f5();{
static QHash<const QString, stat_tap_table_ui *> cfg_str_to_stu_;
extern "C" {
static void
simple_stat_init(const char *args, void*) {
    QStringList args_l = QString(args).split(',');
}
void Singleton::f6();{
                for (int col = 0; col < (int) stu_->nfields; col++) {
                    if (stu_->fields[col].align == TAP_ALIGN_RIGHT) {
                        ss_ti->setTextAlignment(col, Qt::AlignRight);
                    }
                }
}
void Singleton::f7();{
            ti = statsTreeWidget()->topLevelItem(table_idx);
        }
        for (guint element = ti->childCount(); element < st_table->num_elements; element++) {
            stat_tap_table_item_type* fields = stat_tap_get_field_data(st_table, element, 0);
            if (stu_->nfields > 0) {
}
void Singleton::f8();{
        free_stat_tables(stu_);
        reject(); // XXX Stay open instead?
        return;
    }
    cap_file_.retapPackets();
}
void Singleton::f9();{
        }
    }
    bool operator< (const QTreeWidgetItem &other) const
    {
        int col = treeWidget()->sortColumn();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
	int selectChoice()
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
	int selectChoice()
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
}
void Singleton::f2();{
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
}
void Singleton::f3();{
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
}
void Singleton::f4();{
						  else
					{
						Rennaisance->customer[i]->status = 0;
						cout << "Enter Room No\n";
						cin >> rno;
}
void Singleton::f5();{
				return dish[i];
			}
	void displayDish(Dish d)
		cout << " Dish Name :: " << d.dishName << endl;
		cout << " Price :: " << d.price << endl;
}
void Singleton::f6();{
				room[i].status = 1;
	void askFeedback()
		int f;
		string cname;
		ofstream feedback;
}
void Singleton::f7();{
							e->performDuty();
							cout << "Enter Dish Name you want to Order(Make sure you enter the exact same name.)\n";
							cin >> dname;
							Rennaisance->takeOrder(dname);
							d2 = Rennaisance->restuarant.getDish(dname);
}
void Singleton::f8();{
public:
	void addDishes()
		ofstream menu;
		menu.open("Menu.txt", ios::ate);
		int i;
}
void Singleton::f9();{
		return ch;
	virtual void printCustomer()
		cout << "Name :: " << this->custName << endl;
		cout << "Address :: " << this->custAddress << endl;
		cout << "ID :: " << custID << endl;
}
void Singleton::f10();{
public:
	double rbill;
	Room r;
	int bookStatus;
public:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
	int selectChoice()
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
}
void Singleton::f2();{
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
	int selectChoice()
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
}
void Singleton::f2();{
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
}
void Singleton::f3();{
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
	int selectChoice()
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
}
void Singleton::f2();{
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
}
void Singleton::f3();{
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
}
void Singleton::f4();{
						  else
					{
						Rennaisance->customer[i]->status = 0;
						cout << "Enter Room No\n";
						cin >> rno;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
	int selectChoice()
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
}
void Singleton::f2();{
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
}
void Singleton::f3();{
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
}
void Singleton::f4();{
						  else
					{
						Rennaisance->customer[i]->status = 0;
						cout << "Enter Room No\n";
						cin >> rno;
}
void Singleton::f5();{
				return dish[i];
			}
	void displayDish(Dish d)
		cout << " Dish Name :: " << d.dishName << endl;
		cout << " Price :: " << d.price << endl;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
	int selectChoice()
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
}
void Singleton::f2();{
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
}
void Singleton::f3();{
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
}
void Singleton::f4();{
						  else
					{
						Rennaisance->customer[i]->status = 0;
						cout << "Enter Room No\n";
						cin >> rno;
}
void Singleton::f5();{
				return dish[i];
			}
	void displayDish(Dish d)
		cout << " Dish Name :: " << d.dishName << endl;
		cout << " Price :: " << d.price << endl;
}
void Singleton::f6();{
				room[i].status = 1;
	void askFeedback()
		int f;
		string cname;
		ofstream feedback;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
	int selectChoice()
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
}
void Singleton::f2();{
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
}
void Singleton::f3();{
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
}
void Singleton::f4();{
						  else
					{
						Rennaisance->customer[i]->status = 0;
						cout << "Enter Room No\n";
						cin >> rno;
}
void Singleton::f5();{
				return dish[i];
			}
	void displayDish(Dish d)
		cout << " Dish Name :: " << d.dishName << endl;
		cout << " Price :: " << d.price << endl;
}
void Singleton::f6();{
				room[i].status = 1;
	void askFeedback()
		int f;
		string cname;
		ofstream feedback;
}
void Singleton::f7();{
							e->performDuty();
							cout << "Enter Dish Name you want to Order(Make sure you enter the exact same name.)\n";
							cin >> dname;
							Rennaisance->takeOrder(dname);
							d2 = Rennaisance->restuarant.getDish(dname);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
	int selectChoice()
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
}
void Singleton::f2();{
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
}
void Singleton::f3();{
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
}
void Singleton::f4();{
						  else
					{
						Rennaisance->customer[i]->status = 0;
						cout << "Enter Room No\n";
						cin >> rno;
}
void Singleton::f5();{
				return dish[i];
			}
	void displayDish(Dish d)
		cout << " Dish Name :: " << d.dishName << endl;
		cout << " Price :: " << d.price << endl;
}
void Singleton::f6();{
				room[i].status = 1;
	void askFeedback()
		int f;
		string cname;
		ofstream feedback;
}
void Singleton::f7();{
							e->performDuty();
							cout << "Enter Dish Name you want to Order(Make sure you enter the exact same name.)\n";
							cin >> dname;
							Rennaisance->takeOrder(dname);
							d2 = Rennaisance->restuarant.getDish(dname);
}
void Singleton::f8();{
public:
	void addDishes()
		ofstream menu;
		menu.open("Menu.txt", ios::ate);
		int i;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
	int selectChoice()
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
}
void Singleton::f2();{
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
}
void Singleton::f3();{
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
			if (room[i].status == 0)
}
void Singleton::f4();{
						  else
					{
						Rennaisance->customer[i]->status = 0;
						cout << "Enter Room No\n";
						cin >> rno;
}
void Singleton::f5();{
				return dish[i];
			}
	void displayDish(Dish d)
		cout << " Dish Name :: " << d.dishName << endl;
		cout << " Price :: " << d.price << endl;
}
void Singleton::f6();{
				room[i].status = 1;
	void askFeedback()
		int f;
		string cname;
		ofstream feedback;
}
void Singleton::f7();{
							e->performDuty();
							cout << "Enter Dish Name you want to Order(Make sure you enter the exact same name.)\n";
							cin >> dname;
							Rennaisance->takeOrder(dname);
							d2 = Rennaisance->restuarant.getDish(dname);
}
void Singleton::f8();{
public:
	void addDishes()
		ofstream menu;
		menu.open("Menu.txt", ios::ate);
		int i;
}
void Singleton::f9();{
		return ch;
	virtual void printCustomer()
		cout << "Name :: " << this->custName << endl;
		cout << "Address :: " << this->custAddress << endl;
		cout << "ID :: " << custID << endl;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
}
void Singleton::f2();{
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
}
void Singleton::f3();{
	 */
	void startGame();
	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
}
void Singleton::f4();{
	while (!done) {
		string command;
		string move;
		ScoreBoard* scoreboard = ScoreBoard::getInstance();
		Player* pX = Player::getInstance1();
}
void Singleton::f5();{
	else if (((W == C) && (C == E)) && (C != 0)) { over = true; winner = C; }
	else if (((SW == S) && (S == SE)) && (S != 0)) { over = true; winner = S; }
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
}
void Singleton::f6();{
	 * Returns: pointer to the ScoreBoard created or previously created.
	 */
	static ScoreBoard* getInstance();
	/* printScores()
	 * Purpose: to print out the current scores in the scoreboard
}
void Singleton::f7();{
					scoreboard->makeMove(pO, move);
					if (scoreboard->isOver()) break;
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
}
void Singleton::f8();{
	cout << "E.g. game stdin stdin" << endl;
	cout << "Valid Moves are: NW N NE" << endl;
	cout << "                 W  C E" << endl;
	cout << "                 SW S SE" << endl;
	cout << "Type quit to exit the program." << endl;
}
void Singleton::f9();{
	cout << "Score is" << endl;
	cout << "X " << scoreX << endl;
	cout << "O " << scoreO << endl;
void ScoreBoard::cleanup() {
	delete instance;
}
void Singleton::f10();{
	cout << "Type Command: game sX sO" << endl;
	cout << "Where sX denotes the name of the file name for X's move." << endl;
	cout << "sX may be stdin to take input from cin." << endl;
	cout << "Similarly for O." << endl;
	cout << "E.g. game stdin stdin" << endl;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
}
void Singleton::f2();{
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
}
void Singleton::f2();{
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
}
void Singleton::f3();{
	 */
	void startGame();
	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
}
void Singleton::f2();{
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
}
void Singleton::f3();{
	 */
	void startGame();
	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
}
void Singleton::f4();{
	while (!done) {
		string command;
		string move;
		ScoreBoard* scoreboard = ScoreBoard::getInstance();
		Player* pX = Player::getInstance1();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
}
void Singleton::f2();{
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
}
void Singleton::f3();{
	 */
	void startGame();
	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
}
void Singleton::f4();{
	while (!done) {
		string command;
		string move;
		ScoreBoard* scoreboard = ScoreBoard::getInstance();
		Player* pX = Player::getInstance1();
}
void Singleton::f5();{
	else if (((W == C) && (C == E)) && (C != 0)) { over = true; winner = C; }
	else if (((SW == S) && (S == SE)) && (S != 0)) { over = true; winner = S; }
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
}
void Singleton::f2();{
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
}
void Singleton::f3();{
	 */
	void startGame();
	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
}
void Singleton::f4();{
	while (!done) {
		string command;
		string move;
		ScoreBoard* scoreboard = ScoreBoard::getInstance();
		Player* pX = Player::getInstance1();
}
void Singleton::f5();{
	else if (((W == C) && (C == E)) && (C != 0)) { over = true; winner = C; }
	else if (((SW == S) && (S == SE)) && (S != 0)) { over = true; winner = S; }
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
}
void Singleton::f6();{
	 * Returns: pointer to the ScoreBoard created or previously created.
	 */
	static ScoreBoard* getInstance();
	/* printScores()
	 * Purpose: to print out the current scores in the scoreboard
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
}
void Singleton::f2();{
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
}
void Singleton::f3();{
	 */
	void startGame();
	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
}
void Singleton::f4();{
	while (!done) {
		string command;
		string move;
		ScoreBoard* scoreboard = ScoreBoard::getInstance();
		Player* pX = Player::getInstance1();
}
void Singleton::f5();{
	else if (((W == C) && (C == E)) && (C != 0)) { over = true; winner = C; }
	else if (((SW == S) && (S == SE)) && (S != 0)) { over = true; winner = S; }
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
}
void Singleton::f6();{
	 * Returns: pointer to the ScoreBoard created or previously created.
	 */
	static ScoreBoard* getInstance();
	/* printScores()
	 * Purpose: to print out the current scores in the scoreboard
}
void Singleton::f7();{
					scoreboard->makeMove(pO, move);
					if (scoreboard->isOver()) break;
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
}
void Singleton::f2();{
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
}
void Singleton::f3();{
	 */
	void startGame();
	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
}
void Singleton::f4();{
	while (!done) {
		string command;
		string move;
		ScoreBoard* scoreboard = ScoreBoard::getInstance();
		Player* pX = Player::getInstance1();
}
void Singleton::f5();{
	else if (((W == C) && (C == E)) && (C != 0)) { over = true; winner = C; }
	else if (((SW == S) && (S == SE)) && (S != 0)) { over = true; winner = S; }
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
}
void Singleton::f6();{
	 * Returns: pointer to the ScoreBoard created or previously created.
	 */
	static ScoreBoard* getInstance();
	/* printScores()
	 * Purpose: to print out the current scores in the scoreboard
}
void Singleton::f7();{
					scoreboard->makeMove(pO, move);
					if (scoreboard->isOver()) break;
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
}
void Singleton::f8();{
	cout << "E.g. game stdin stdin" << endl;
	cout << "Valid Moves are: NW N NE" << endl;
	cout << "                 W  C E" << endl;
	cout << "                 SW S SE" << endl;
	cout << "Type quit to exit the program." << endl;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
}
void Singleton::f2();{
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
}
void Singleton::f3();{
	 */
	void startGame();
	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
}
void Singleton::f4();{
	while (!done) {
		string command;
		string move;
		ScoreBoard* scoreboard = ScoreBoard::getInstance();
		Player* pX = Player::getInstance1();
}
void Singleton::f5();{
	else if (((W == C) && (C == E)) && (C != 0)) { over = true; winner = C; }
	else if (((SW == S) && (S == SE)) && (S != 0)) { over = true; winner = S; }
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
}
void Singleton::f6();{
	 * Returns: pointer to the ScoreBoard created or previously created.
	 */
	static ScoreBoard* getInstance();
	/* printScores()
	 * Purpose: to print out the current scores in the scoreboard
}
void Singleton::f7();{
					scoreboard->makeMove(pO, move);
					if (scoreboard->isOver()) break;
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
}
void Singleton::f8();{
	cout << "E.g. game stdin stdin" << endl;
	cout << "Valid Moves are: NW N NE" << endl;
	cout << "                 W  C E" << endl;
	cout << "                 SW S SE" << endl;
	cout << "Type quit to exit the program." << endl;
}
void Singleton::f9();{
	cout << "Score is" << endl;
	cout << "X " << scoreX << endl;
	cout << "O " << scoreO << endl;
void ScoreBoard::cleanup() {
	delete instance;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
						}
					}
					return Singleton::InstancePointer;
				}
				static inline void DestroyInstance(void)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
						}
					}
					return Singleton::InstancePointer;
				}
				static inline void DestroyInstance(void)
}
void Singleton::f2();{
					SpinLock(SpinLock const&) = default;
					SpinLock(SpinLock&&) = default;
					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;
					SpinLock& operator=(SpinLock&&) = default;
}
void Singleton::f3();{
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
template <>
void Class<4>::initialize(void) const
}
void Singleton::f4();{
void Class<2>::initialize(void) const
	return;
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
}
void Singleton::f5();{
				static Private::SpinLock Lock;
				// Static Methods
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
}
void Singleton::f6();{
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
					if (Singleton::InstancePointer == nullptr)
					{
}
void Singleton::f7();{
			}
namespace AO
	namespace Singleton
		inline namespace Version_1
			template <class Derived>
}
void Singleton::f8();{
	Class<3>::GetInstance();
	Class<4>::GetInstance();
	Class<5>::GetInstance();
	Class<6>::GetInstance();
	Class<7>::GetInstance();
}
void Singleton::f9();{
			template <class Derived>
			class Singleton
			{
			public:
				// Static Methods
}
void Singleton::f10();{
				static inline void DestroyInstance(void)
				{
					reinterpret_cast<Derived*>(GetData())->~Derived();
				}
				static inline unsigned char* GetData(void)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
						}
					}
					return Singleton::InstancePointer;
				}
				static inline void DestroyInstance(void)
}
void Singleton::f2();{
					SpinLock(SpinLock const&) = default;
					SpinLock(SpinLock&&) = default;
					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;
					SpinLock& operator=(SpinLock&&) = default;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
						}
					}
					return Singleton::InstancePointer;
				}
				static inline void DestroyInstance(void)
}
void Singleton::f2();{
					SpinLock(SpinLock const&) = default;
					SpinLock(SpinLock&&) = default;
					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;
					SpinLock& operator=(SpinLock&&) = default;
}
void Singleton::f3();{
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
template <>
void Class<4>::initialize(void) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
						}
					}
					return Singleton::InstancePointer;
				}
				static inline void DestroyInstance(void)
}
void Singleton::f2();{
					SpinLock(SpinLock const&) = default;
					SpinLock(SpinLock&&) = default;
					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;
					SpinLock& operator=(SpinLock&&) = default;
}
void Singleton::f3();{
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
template <>
void Class<4>::initialize(void) const
}
void Singleton::f4();{
void Class<2>::initialize(void) const
	return;
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
						}
					}
					return Singleton::InstancePointer;
				}
				static inline void DestroyInstance(void)
}
void Singleton::f2();{
					SpinLock(SpinLock const&) = default;
					SpinLock(SpinLock&&) = default;
					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;
					SpinLock& operator=(SpinLock&&) = default;
}
void Singleton::f3();{
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
template <>
void Class<4>::initialize(void) const
}
void Singleton::f4();{
void Class<2>::initialize(void) const
	return;
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
}
void Singleton::f5();{
				static Private::SpinLock Lock;
				// Static Methods
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
						}
					}
					return Singleton::InstancePointer;
				}
				static inline void DestroyInstance(void)
}
void Singleton::f2();{
					SpinLock(SpinLock const&) = default;
					SpinLock(SpinLock&&) = default;
					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;
					SpinLock& operator=(SpinLock&&) = default;
}
void Singleton::f3();{
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
template <>
void Class<4>::initialize(void) const
}
void Singleton::f4();{
void Class<2>::initialize(void) const
	return;
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
}
void Singleton::f5();{
				static Private::SpinLock Lock;
				// Static Methods
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
}
void Singleton::f6();{
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
					if (Singleton::InstancePointer == nullptr)
					{
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
						}
					}
					return Singleton::InstancePointer;
				}
				static inline void DestroyInstance(void)
}
void Singleton::f2();{
					SpinLock(SpinLock const&) = default;
					SpinLock(SpinLock&&) = default;
					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;
					SpinLock& operator=(SpinLock&&) = default;
}
void Singleton::f3();{
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
template <>
void Class<4>::initialize(void) const
}
void Singleton::f4();{
void Class<2>::initialize(void) const
	return;
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
}
void Singleton::f5();{
				static Private::SpinLock Lock;
				// Static Methods
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
}
void Singleton::f6();{
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
					if (Singleton::InstancePointer == nullptr)
					{
}
void Singleton::f7();{
			}
namespace AO
	namespace Singleton
		inline namespace Version_1
			template <class Derived>
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
						}
					}
					return Singleton::InstancePointer;
				}
				static inline void DestroyInstance(void)
}
void Singleton::f2();{
					SpinLock(SpinLock const&) = default;
					SpinLock(SpinLock&&) = default;
					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;
					SpinLock& operator=(SpinLock&&) = default;
}
void Singleton::f3();{
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
template <>
void Class<4>::initialize(void) const
}
void Singleton::f4();{
void Class<2>::initialize(void) const
	return;
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
}
void Singleton::f5();{
				static Private::SpinLock Lock;
				// Static Methods
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
}
void Singleton::f6();{
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
					if (Singleton::InstancePointer == nullptr)
					{
}
void Singleton::f7();{
			}
namespace AO
	namespace Singleton
		inline namespace Version_1
			template <class Derived>
}
void Singleton::f8();{
	Class<3>::GetInstance();
	Class<4>::GetInstance();
	Class<5>::GetInstance();
	Class<6>::GetInstance();
	Class<7>::GetInstance();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
						}
					}
					return Singleton::InstancePointer;
				}
				static inline void DestroyInstance(void)
}
void Singleton::f2();{
					SpinLock(SpinLock const&) = default;
					SpinLock(SpinLock&&) = default;
					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;
					SpinLock& operator=(SpinLock&&) = default;
}
void Singleton::f3();{
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
template <>
void Class<4>::initialize(void) const
}
void Singleton::f4();{
void Class<2>::initialize(void) const
	return;
template <>
void Class<3>::initialize(void) const
	Class<1>::GetInstance();
}
void Singleton::f5();{
				static Private::SpinLock Lock;
				// Static Methods
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
}
void Singleton::f6();{
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
					if (Singleton::InstancePointer == nullptr)
					{
}
void Singleton::f7();{
			}
namespace AO
	namespace Singleton
		inline namespace Version_1
			template <class Derived>
}
void Singleton::f8();{
	Class<3>::GetInstance();
	Class<4>::GetInstance();
	Class<5>::GetInstance();
	Class<6>::GetInstance();
	Class<7>::GetInstance();
}
void Singleton::f9();{
			template <class Derived>
			class Singleton
			{
			public:
				// Static Methods
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
}
void Singleton::f2();{
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *  This program is distributed in the hope that it will be useful,
}
void Singleton::f3();{
    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);
}
void Singleton::f4();{
    static std::string m_prefix;
    static std::string m_postfix;
    static std::string m_separator;
    static bool m_output;
    static bool m_endl;
}
void Singleton::f5();{
     * clears the prefix
     */
    void clearPrefix();
    /**
     * clears the postfix
}
void Singleton::f6();{
Logger* Logger::m_instance = 0;
std::string Logger::m_prefix = "";
std::string Logger::m_postfix = "";
std::string Logger::m_separator = " ";
bool Logger::m_output = true;
}
void Singleton::f7();{
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::instance()->setOutput(false);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
}
void Singleton::f8();{
  * @version 1.0.0
  * @created 3/16/11
  * @file Logger.h
  *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
  *  This program is free software; you can redistribute it and/or modify
}
void Singleton::f9();{
                break;
            }
        }
        if (i != 0)
        {
}
void Singleton::f10();{
    Logger::instance()->newLine();
    Logger::instance()->log("6. log double**");
    double** d;
    d = new double* [5];
    for (int i = 0; i < 5; ++i)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
}
void Singleton::f2();{
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *  This program is distributed in the hope that it will be useful,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
}
void Singleton::f2();{
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *  This program is distributed in the hope that it will be useful,
}
void Singleton::f3();{
    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
}
void Singleton::f2();{
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *  This program is distributed in the hope that it will be useful,
}
void Singleton::f3();{
    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);
}
void Singleton::f4();{
    static std::string m_prefix;
    static std::string m_postfix;
    static std::string m_separator;
    static bool m_output;
    static bool m_endl;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
}
void Singleton::f2();{
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *  This program is distributed in the hope that it will be useful,
}
void Singleton::f3();{
    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);
}
void Singleton::f4();{
    static std::string m_prefix;
    static std::string m_postfix;
    static std::string m_separator;
    static bool m_output;
    static bool m_endl;
}
void Singleton::f5();{
     * clears the prefix
     */
    void clearPrefix();
    /**
     * clears the postfix
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
}
void Singleton::f2();{
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *  This program is distributed in the hope that it will be useful,
}
void Singleton::f3();{
    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);
}
void Singleton::f4();{
    static std::string m_prefix;
    static std::string m_postfix;
    static std::string m_separator;
    static bool m_output;
    static bool m_endl;
}
void Singleton::f5();{
     * clears the prefix
     */
    void clearPrefix();
    /**
     * clears the postfix
}
void Singleton::f6();{
Logger* Logger::m_instance = 0;
std::string Logger::m_prefix = "";
std::string Logger::m_postfix = "";
std::string Logger::m_separator = " ";
bool Logger::m_output = true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
}
void Singleton::f2();{
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *  This program is distributed in the hope that it will be useful,
}
void Singleton::f3();{
    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);
}
void Singleton::f4();{
    static std::string m_prefix;
    static std::string m_postfix;
    static std::string m_separator;
    static bool m_output;
    static bool m_endl;
}
void Singleton::f5();{
     * clears the prefix
     */
    void clearPrefix();
    /**
     * clears the postfix
}
void Singleton::f6();{
Logger* Logger::m_instance = 0;
std::string Logger::m_prefix = "";
std::string Logger::m_postfix = "";
std::string Logger::m_separator = " ";
bool Logger::m_output = true;
}
void Singleton::f7();{
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::instance()->setOutput(false);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
}
void Singleton::f2();{
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *  This program is distributed in the hope that it will be useful,
}
void Singleton::f3();{
    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);
}
void Singleton::f4();{
    static std::string m_prefix;
    static std::string m_postfix;
    static std::string m_separator;
    static bool m_output;
    static bool m_endl;
}
void Singleton::f5();{
     * clears the prefix
     */
    void clearPrefix();
    /**
     * clears the postfix
}
void Singleton::f6();{
Logger* Logger::m_instance = 0;
std::string Logger::m_prefix = "";
std::string Logger::m_postfix = "";
std::string Logger::m_separator = " ";
bool Logger::m_output = true;
}
void Singleton::f7();{
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::instance()->setOutput(false);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
}
void Singleton::f8();{
  * @version 1.0.0
  * @created 3/16/11
  * @file Logger.h
  *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
  *  This program is free software; you can redistribute it and/or modify
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
}
void Singleton::f2();{
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *  This program is distributed in the hope that it will be useful,
}
void Singleton::f3();{
    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);
}
void Singleton::f4();{
    static std::string m_prefix;
    static std::string m_postfix;
    static std::string m_separator;
    static bool m_output;
    static bool m_endl;
}
void Singleton::f5();{
     * clears the prefix
     */
    void clearPrefix();
    /**
     * clears the postfix
}
void Singleton::f6();{
Logger* Logger::m_instance = 0;
std::string Logger::m_prefix = "";
std::string Logger::m_postfix = "";
std::string Logger::m_separator = " ";
bool Logger::m_output = true;
}
void Singleton::f7();{
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::instance()->setOutput(false);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
}
void Singleton::f8();{
  * @version 1.0.0
  * @created 3/16/11
  * @file Logger.h
  *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
  *  This program is free software; you can redistribute it and/or modify
}
void Singleton::f9();{
                break;
            }
        }
        if (i != 0)
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        finished.push_back(id);
    }
void go()
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        finished.push_back(id);
    }
void go()
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
}
void Singleton::f2();{
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Singleton::instance().whoami();
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
}
void Singleton::f3();{
////////////////////////////////////////////////////////////////////////////////
const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;
////////////////////////////////////////////////////////////////////////////////
}
void Singleton::f4();{
////////////////////////////////////////////////////////////////////////////////
//   Copyright 2017 Doulos Inc.
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
}
void Singleton::f5();{
private:
    Singleton(); // Default constructor
    ~Singleton(); // Destructor
    // attributes
    std::atomic<size_t> m_count{ 0U };
}
void Singleton::f6();{
    // Random delay
    std::uniform_int_distribution<size_t> dist{ 1, 10 };
    std::random_device gen;
    volatile double x = 0.0;
    for (size_t i = PER_JOB_RANDOM_DELAY_COUNT * dist(gen); i > 0; --i) {
}
void Singleton::f7();{
int main()
    // Create threads
    std::deque<std::thread> threads;
    for (size_t i = NUMBER_OF_THREADS; i > 0; --i) {
        threads.emplace_back(std::thread(do_work, i));
}
void Singleton::f8();{
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
    return 0;
////////////////////////////////////////////////////////////////////////////////
//   Copyright 2017 Doulos Inc.
}
void Singleton::f9();{
        threads.emplace_back(std::thread(do_work, i));
    }
    std::cout << threads.size() << " threads ready to race" << std::endl;
    // Start threads
    go();
}
void Singleton::f10();{
    for (size_t i = NUMBER_OF_THREADS; i > 0; --i) {
        threads.emplace_back(std::thread(do_work, i));
    }
    std::cout << threads.size() << " threads ready to race" << std::endl;
    // Start threads
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        finished.push_back(id);
    }
void go()
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
}
void Singleton::f2();{
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Singleton::instance().whoami();
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        finished.push_back(id);
    }
void go()
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
}
void Singleton::f2();{
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Singleton::instance().whoami();
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
}
void Singleton::f3();{
////////////////////////////////////////////////////////////////////////////////
const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;
////////////////////////////////////////////////////////////////////////////////
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        finished.push_back(id);
    }
void go()
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
}
void Singleton::f2();{
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Singleton::instance().whoami();
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
}
void Singleton::f3();{
////////////////////////////////////////////////////////////////////////////////
const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;
////////////////////////////////////////////////////////////////////////////////
}
void Singleton::f4();{
////////////////////////////////////////////////////////////////////////////////
//   Copyright 2017 Doulos Inc.
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        finished.push_back(id);
    }
void go()
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
}
void Singleton::f2();{
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Singleton::instance().whoami();
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
}
void Singleton::f3();{
////////////////////////////////////////////////////////////////////////////////
const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;
////////////////////////////////////////////////////////////////////////////////
}
void Singleton::f4();{
////////////////////////////////////////////////////////////////////////////////
//   Copyright 2017 Doulos Inc.
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
}
void Singleton::f5();{
private:
    Singleton(); // Default constructor
    ~Singleton(); // Destructor
    // attributes
    std::atomic<size_t> m_count{ 0U };
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        finished.push_back(id);
    }
void go()
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
}
void Singleton::f2();{
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Singleton::instance().whoami();
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
}
void Singleton::f3();{
////////////////////////////////////////////////////////////////////////////////
const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;
////////////////////////////////////////////////////////////////////////////////
}
void Singleton::f4();{
////////////////////////////////////////////////////////////////////////////////
//   Copyright 2017 Doulos Inc.
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
}
void Singleton::f5();{
private:
    Singleton(); // Default constructor
    ~Singleton(); // Destructor
    // attributes
    std::atomic<size_t> m_count{ 0U };
}
void Singleton::f6();{
    // Random delay
    std::uniform_int_distribution<size_t> dist{ 1, 10 };
    std::random_device gen;
    volatile double x = 0.0;
    for (size_t i = PER_JOB_RANDOM_DELAY_COUNT * dist(gen); i > 0; --i) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        finished.push_back(id);
    }
void go()
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
}
void Singleton::f2();{
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Singleton::instance().whoami();
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
}
void Singleton::f3();{
////////////////////////////////////////////////////////////////////////////////
const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;
////////////////////////////////////////////////////////////////////////////////
}
void Singleton::f4();{
////////////////////////////////////////////////////////////////////////////////
//   Copyright 2017 Doulos Inc.
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
}
void Singleton::f5();{
private:
    Singleton(); // Default constructor
    ~Singleton(); // Destructor
    // attributes
    std::atomic<size_t> m_count{ 0U };
}
void Singleton::f6();{
    // Random delay
    std::uniform_int_distribution<size_t> dist{ 1, 10 };
    std::random_device gen;
    volatile double x = 0.0;
    for (size_t i = PER_JOB_RANDOM_DELAY_COUNT * dist(gen); i > 0; --i) {
}
void Singleton::f7();{
int main()
    // Create threads
    std::deque<std::thread> threads;
    for (size_t i = NUMBER_OF_THREADS; i > 0; --i) {
        threads.emplace_back(std::thread(do_work, i));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        finished.push_back(id);
    }
void go()
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
}
void Singleton::f2();{
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Singleton::instance().whoami();
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
}
void Singleton::f3();{
////////////////////////////////////////////////////////////////////////////////
const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;
////////////////////////////////////////////////////////////////////////////////
}
void Singleton::f4();{
////////////////////////////////////////////////////////////////////////////////
//   Copyright 2017 Doulos Inc.
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
}
void Singleton::f5();{
private:
    Singleton(); // Default constructor
    ~Singleton(); // Destructor
    // attributes
    std::atomic<size_t> m_count{ 0U };
}
void Singleton::f6();{
    // Random delay
    std::uniform_int_distribution<size_t> dist{ 1, 10 };
    std::random_device gen;
    volatile double x = 0.0;
    for (size_t i = PER_JOB_RANDOM_DELAY_COUNT * dist(gen); i > 0; --i) {
}
void Singleton::f7();{
int main()
    // Create threads
    std::deque<std::thread> threads;
    for (size_t i = NUMBER_OF_THREADS; i > 0; --i) {
        threads.emplace_back(std::thread(do_work, i));
}
void Singleton::f8();{
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
    return 0;
////////////////////////////////////////////////////////////////////////////////
//   Copyright 2017 Doulos Inc.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        finished.push_back(id);
    }
void go()
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
}
void Singleton::f2();{
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Singleton::instance().whoami();
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
}
void Singleton::f3();{
////////////////////////////////////////////////////////////////////////////////
const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;
////////////////////////////////////////////////////////////////////////////////
}
void Singleton::f4();{
////////////////////////////////////////////////////////////////////////////////
//   Copyright 2017 Doulos Inc.
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
}
void Singleton::f5();{
private:
    Singleton(); // Default constructor
    ~Singleton(); // Destructor
    // attributes
    std::atomic<size_t> m_count{ 0U };
}
void Singleton::f6();{
    // Random delay
    std::uniform_int_distribution<size_t> dist{ 1, 10 };
    std::random_device gen;
    volatile double x = 0.0;
    for (size_t i = PER_JOB_RANDOM_DELAY_COUNT * dist(gen); i > 0; --i) {
}
void Singleton::f7();{
int main()
    // Create threads
    std::deque<std::thread> threads;
    for (size_t i = NUMBER_OF_THREADS; i > 0; --i) {
        threads.emplace_back(std::thread(do_work, i));
}
void Singleton::f8();{
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
    return 0;
////////////////////////////////////////////////////////////////////////////////
//   Copyright 2017 Doulos Inc.
}
void Singleton::f9();{
        threads.emplace_back(std::thread(do_work, i));
    }
    std::cout << threads.size() << " threads ready to race" << std::endl;
    // Start threads
    go();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}
void Singleton::f2();{
			FileType::FILETYPE_ERL == m_FileType ||
			FileType::FILETYPE_CC == m_FileType ||
            FileType::FILETYPE_CS   == m_FileType ){
            int lineSize = (int)line.size();
            for(int j=0;j<(int)line.size();j++){
}
void Singleton::f3();{
    std::vector<std::string> lines;
    listOfFiles.readLines(lines, false);
	m_lFileSize = listOfFiles.m_lFileSize;
    int openBlockComments = 0;
	for(int i=0;i<(int)lines.size();i++){
}
void Singleton::f4();{
        switch (m_FileType)
        {
            case FileType::FILETYPE_C   :
            case FileType::FILETYPE_CPP :
            case FileType::FILETYPE_CXX :
}
void Singleton::f5();{
    }
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), (int(*)(int)) tolower);
    if(m_ignorePrepStuff){
        switch (m_FileType)
        {
}
void Singleton::f6();{
        return false;
    }
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), (int(*)(int)) tolower);
    if(m_ignorePrepStuff){
        switch (m_FileType)
}
void Singleton::f7();{
            case FileType::FILETYPE_C   :
            case FileType::FILETYPE_CPP :
			case FileType::FILETYPE_CC:
            case FileType::FILETYPE_CXX :
            case FileType::FILETYPE_H   :
}
void Singleton::f8();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}
void Singleton::f9();{
                }
                if(openBlockComments <= 0){
                    tmp.push_back(line[j]);
                }
                if(line[MAX(0, j-1)] == '*' && line[j] == '/'){
}
void Singleton::f10();{
                // look for preprocessor marker in start of string
                  std::string PreProc_CS = "using";
                return std::string::npos == tmp.find(PreProc_CS.c_str(), 0, PreProc_CS.length());
                }
                break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}
void Singleton::f2();{
			FileType::FILETYPE_ERL == m_FileType ||
			FileType::FILETYPE_CC == m_FileType ||
            FileType::FILETYPE_CS   == m_FileType ){
            int lineSize = (int)line.size();
            for(int j=0;j<(int)line.size();j++){
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}
void Singleton::f2();{
			FileType::FILETYPE_ERL == m_FileType ||
			FileType::FILETYPE_CC == m_FileType ||
            FileType::FILETYPE_CS   == m_FileType ){
            int lineSize = (int)line.size();
            for(int j=0;j<(int)line.size();j++){
}
void Singleton::f3();{
    std::vector<std::string> lines;
    listOfFiles.readLines(lines, false);
	m_lFileSize = listOfFiles.m_lFileSize;
    int openBlockComments = 0;
	for(int i=0;i<(int)lines.size();i++){
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}
void Singleton::f2();{
			FileType::FILETYPE_ERL == m_FileType ||
			FileType::FILETYPE_CC == m_FileType ||
            FileType::FILETYPE_CS   == m_FileType ){
            int lineSize = (int)line.size();
            for(int j=0;j<(int)line.size();j++){
}
void Singleton::f3();{
    std::vector<std::string> lines;
    listOfFiles.readLines(lines, false);
	m_lFileSize = listOfFiles.m_lFileSize;
    int openBlockComments = 0;
	for(int i=0;i<(int)lines.size();i++){
}
void Singleton::f4();{
        switch (m_FileType)
        {
            case FileType::FILETYPE_C   :
            case FileType::FILETYPE_CPP :
            case FileType::FILETYPE_CXX :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}
void Singleton::f2();{
			FileType::FILETYPE_ERL == m_FileType ||
			FileType::FILETYPE_CC == m_FileType ||
            FileType::FILETYPE_CS   == m_FileType ){
            int lineSize = (int)line.size();
            for(int j=0;j<(int)line.size();j++){
}
void Singleton::f3();{
    std::vector<std::string> lines;
    listOfFiles.readLines(lines, false);
	m_lFileSize = listOfFiles.m_lFileSize;
    int openBlockComments = 0;
	for(int i=0;i<(int)lines.size();i++){
}
void Singleton::f4();{
        switch (m_FileType)
        {
            case FileType::FILETYPE_C   :
            case FileType::FILETYPE_CPP :
            case FileType::FILETYPE_CXX :
}
void Singleton::f5();{
    }
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), (int(*)(int)) tolower);
    if(m_ignorePrepStuff){
        switch (m_FileType)
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}
void Singleton::f2();{
			FileType::FILETYPE_ERL == m_FileType ||
			FileType::FILETYPE_CC == m_FileType ||
            FileType::FILETYPE_CS   == m_FileType ){
            int lineSize = (int)line.size();
            for(int j=0;j<(int)line.size();j++){
}
void Singleton::f3();{
    std::vector<std::string> lines;
    listOfFiles.readLines(lines, false);
	m_lFileSize = listOfFiles.m_lFileSize;
    int openBlockComments = 0;
	for(int i=0;i<(int)lines.size();i++){
}
void Singleton::f4();{
        switch (m_FileType)
        {
            case FileType::FILETYPE_C   :
            case FileType::FILETYPE_CPP :
            case FileType::FILETYPE_CXX :
}
void Singleton::f5();{
    }
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), (int(*)(int)) tolower);
    if(m_ignorePrepStuff){
        switch (m_FileType)
        {
}
void Singleton::f6();{
        return false;
    }
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), (int(*)(int)) tolower);
    if(m_ignorePrepStuff){
        switch (m_FileType)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}
void Singleton::f2();{
			FileType::FILETYPE_ERL == m_FileType ||
			FileType::FILETYPE_CC == m_FileType ||
            FileType::FILETYPE_CS   == m_FileType ){
            int lineSize = (int)line.size();
            for(int j=0;j<(int)line.size();j++){
}
void Singleton::f3();{
    std::vector<std::string> lines;
    listOfFiles.readLines(lines, false);
	m_lFileSize = listOfFiles.m_lFileSize;
    int openBlockComments = 0;
	for(int i=0;i<(int)lines.size();i++){
}
void Singleton::f4();{
        switch (m_FileType)
        {
            case FileType::FILETYPE_C   :
            case FileType::FILETYPE_CPP :
            case FileType::FILETYPE_CXX :
}
void Singleton::f5();{
    }
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), (int(*)(int)) tolower);
    if(m_ignorePrepStuff){
        switch (m_FileType)
        {
}
void Singleton::f6();{
        return false;
    }
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), (int(*)(int)) tolower);
    if(m_ignorePrepStuff){
        switch (m_FileType)
}
void Singleton::f7();{
            case FileType::FILETYPE_C   :
            case FileType::FILETYPE_CPP :
			case FileType::FILETYPE_CC:
            case FileType::FILETYPE_CXX :
            case FileType::FILETYPE_H   :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}
void Singleton::f2();{
			FileType::FILETYPE_ERL == m_FileType ||
			FileType::FILETYPE_CC == m_FileType ||
            FileType::FILETYPE_CS   == m_FileType ){
            int lineSize = (int)line.size();
            for(int j=0;j<(int)line.size();j++){
}
void Singleton::f3();{
    std::vector<std::string> lines;
    listOfFiles.readLines(lines, false);
	m_lFileSize = listOfFiles.m_lFileSize;
    int openBlockComments = 0;
	for(int i=0;i<(int)lines.size();i++){
}
void Singleton::f4();{
        switch (m_FileType)
        {
            case FileType::FILETYPE_C   :
            case FileType::FILETYPE_CPP :
            case FileType::FILETYPE_CXX :
}
void Singleton::f5();{
    }
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), (int(*)(int)) tolower);
    if(m_ignorePrepStuff){
        switch (m_FileType)
        {
}
void Singleton::f6();{
        return false;
    }
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), (int(*)(int)) tolower);
    if(m_ignorePrepStuff){
        switch (m_FileType)
}
void Singleton::f7();{
            case FileType::FILETYPE_C   :
            case FileType::FILETYPE_CPP :
			case FileType::FILETYPE_CC:
            case FileType::FILETYPE_CXX :
            case FileType::FILETYPE_H   :
}
void Singleton::f8();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}
void Singleton::f2();{
			FileType::FILETYPE_ERL == m_FileType ||
			FileType::FILETYPE_CC == m_FileType ||
            FileType::FILETYPE_CS   == m_FileType ){
            int lineSize = (int)line.size();
            for(int j=0;j<(int)line.size();j++){
}
void Singleton::f3();{
    std::vector<std::string> lines;
    listOfFiles.readLines(lines, false);
	m_lFileSize = listOfFiles.m_lFileSize;
    int openBlockComments = 0;
	for(int i=0;i<(int)lines.size();i++){
}
void Singleton::f4();{
        switch (m_FileType)
        {
            case FileType::FILETYPE_C   :
            case FileType::FILETYPE_CPP :
            case FileType::FILETYPE_CXX :
}
void Singleton::f5();{
    }
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), (int(*)(int)) tolower);
    if(m_ignorePrepStuff){
        switch (m_FileType)
        {
}
void Singleton::f6();{
        return false;
    }
    std::transform(tmp.begin(), tmp.end(), tmp.begin(), (int(*)(int)) tolower);
    if(m_ignorePrepStuff){
        switch (m_FileType)
}
void Singleton::f7();{
            case FileType::FILETYPE_C   :
            case FileType::FILETYPE_CPP :
			case FileType::FILETYPE_CC:
            case FileType::FILETYPE_CXX :
            case FileType::FILETYPE_H   :
}
void Singleton::f8();{
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
SourceFile::SourceFile(  std::string& fileName,   unsigned int minChars,   bool ignorePrepStuff) :
    m_fileName(fileName),
}
void Singleton::f9();{
                }
                if(openBlockComments <= 0){
                    tmp.push_back(line[j]);
                }
                if(line[MAX(0, j-1)] == '*' && line[j] == '/'){
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
}
void Singleton::f2();{
        idx = idx + step_w;
    }
    QStyleOptionViewItem option_vi = option;
    QStyledItemDelegate::initStyleOption(&option_vi, index);
    painter->save();
}
void Singleton::f3();{
    if ((option_vi.state & QStyle::State_Selected) && !(option_vi.state & QStyle::State_MouseOver)) {
        painter->setPen(option_vi.palette.color(cg, QPalette::HighlightedText));
    } else {
        painter->setPen(option_vi.palette.color(cg, QPalette::Text));
    }
}
void Singleton::f4();{
    QVector<QPointF> fpoints;
    QStyledItemDelegate::paint(painter, option, index);
    if (points.isEmpty() || steps < 1.0 || content_h <= 0) {
        return;
    }
}
void Singleton::f5();{
                option.rect.y() + ((option.rect.height() - option.fontMetrics.height()) / 2) + 1 + 0.5);
    painter->drawPolyline(QPolygonF(fpoints));
    // Some sparklines are decorated with dots at the beginning and end.
    // Ours look better without in my (gcc) opinion.
//    painter->setPen(Qt::NoPen);
}
void Singleton::f6();{
    int max = 1;
    // We typically draw a sparkline alongside some text. Size our
    // drawing area based on an Em width. and a bit of eyballing on
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
}
void Singleton::f7();{
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
    int content_w = option.rect.width() - (em_w / 4);
    int content_h = option.fontMetrics.ascent() - 1;
    int val;
}
void Singleton::f8();{
    // drawing area based on an Em width. and a bit of eyballing on
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
    int content_w = option.rect.width() - (em_w / 4);
    int content_h = option.fontMetrics.ascent() - 1;
}
void Singleton::f9();{
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
    int content_w = option.rect.width() - (em_w / 4);
    int content_h = option.fontMetrics.ascent() - 1;
    int val;
}
void Singleton::f10();{
    // Shift our coordinates by 0.5 pixels, otherwise our lines end
    // up blurry.
    painter->setRenderHint(QPainter::Antialiasing, true);
    painter->translate(
                option.rect.x() + (em_w / 8) + 0.5,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
}
void Singleton::f2();{
        idx = idx + step_w;
    }
    QStyleOptionViewItem option_vi = option;
    QStyledItemDelegate::initStyleOption(&option_vi, index);
    painter->save();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
}
void Singleton::f2();{
        idx = idx + step_w;
    }
    QStyleOptionViewItem option_vi = option;
    QStyledItemDelegate::initStyleOption(&option_vi, index);
    painter->save();
}
void Singleton::f3();{
    if ((option_vi.state & QStyle::State_Selected) && !(option_vi.state & QStyle::State_MouseOver)) {
        painter->setPen(option_vi.palette.color(cg, QPalette::HighlightedText));
    } else {
        painter->setPen(option_vi.palette.color(cg, QPalette::Text));
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
}
void Singleton::f2();{
        idx = idx + step_w;
    }
    QStyleOptionViewItem option_vi = option;
    QStyledItemDelegate::initStyleOption(&option_vi, index);
    painter->save();
}
void Singleton::f3();{
    if ((option_vi.state & QStyle::State_Selected) && !(option_vi.state & QStyle::State_MouseOver)) {
        painter->setPen(option_vi.palette.color(cg, QPalette::HighlightedText));
    } else {
        painter->setPen(option_vi.palette.color(cg, QPalette::Text));
    }
}
void Singleton::f4();{
    QVector<QPointF> fpoints;
    QStyledItemDelegate::paint(painter, option, index);
    if (points.isEmpty() || steps < 1.0 || content_h <= 0) {
        return;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
}
void Singleton::f2();{
        idx = idx + step_w;
    }
    QStyleOptionViewItem option_vi = option;
    QStyledItemDelegate::initStyleOption(&option_vi, index);
    painter->save();
}
void Singleton::f3();{
    if ((option_vi.state & QStyle::State_Selected) && !(option_vi.state & QStyle::State_MouseOver)) {
        painter->setPen(option_vi.palette.color(cg, QPalette::HighlightedText));
    } else {
        painter->setPen(option_vi.palette.color(cg, QPalette::Text));
    }
}
void Singleton::f4();{
    QVector<QPointF> fpoints;
    QStyledItemDelegate::paint(painter, option, index);
    if (points.isEmpty() || steps < 1.0 || content_h <= 0) {
        return;
    }
}
void Singleton::f5();{
                option.rect.y() + ((option.rect.height() - option.fontMetrics.height()) / 2) + 1 + 0.5);
    painter->drawPolyline(QPolygonF(fpoints));
    // Some sparklines are decorated with dots at the beginning and end.
    // Ours look better without in my (gcc) opinion.
//    painter->setPen(Qt::NoPen);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
}
void Singleton::f2();{
        idx = idx + step_w;
    }
    QStyleOptionViewItem option_vi = option;
    QStyledItemDelegate::initStyleOption(&option_vi, index);
    painter->save();
}
void Singleton::f3();{
    if ((option_vi.state & QStyle::State_Selected) && !(option_vi.state & QStyle::State_MouseOver)) {
        painter->setPen(option_vi.palette.color(cg, QPalette::HighlightedText));
    } else {
        painter->setPen(option_vi.palette.color(cg, QPalette::Text));
    }
}
void Singleton::f4();{
    QVector<QPointF> fpoints;
    QStyledItemDelegate::paint(painter, option, index);
    if (points.isEmpty() || steps < 1.0 || content_h <= 0) {
        return;
    }
}
void Singleton::f5();{
                option.rect.y() + ((option.rect.height() - option.fontMetrics.height()) / 2) + 1 + 0.5);
    painter->drawPolyline(QPolygonF(fpoints));
    // Some sparklines are decorated with dots at the beginning and end.
    // Ours look better without in my (gcc) opinion.
//    painter->setPen(Qt::NoPen);
}
void Singleton::f6();{
    int max = 1;
    // We typically draw a sparkline alongside some text. Size our
    // drawing area based on an Em width. and a bit of eyballing on
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
}
void Singleton::f2();{
        idx = idx + step_w;
    }
    QStyleOptionViewItem option_vi = option;
    QStyledItemDelegate::initStyleOption(&option_vi, index);
    painter->save();
}
void Singleton::f3();{
    if ((option_vi.state & QStyle::State_Selected) && !(option_vi.state & QStyle::State_MouseOver)) {
        painter->setPen(option_vi.palette.color(cg, QPalette::HighlightedText));
    } else {
        painter->setPen(option_vi.palette.color(cg, QPalette::Text));
    }
}
void Singleton::f4();{
    QVector<QPointF> fpoints;
    QStyledItemDelegate::paint(painter, option, index);
    if (points.isEmpty() || steps < 1.0 || content_h <= 0) {
        return;
    }
}
void Singleton::f5();{
                option.rect.y() + ((option.rect.height() - option.fontMetrics.height()) / 2) + 1 + 0.5);
    painter->drawPolyline(QPolygonF(fpoints));
    // Some sparklines are decorated with dots at the beginning and end.
    // Ours look better without in my (gcc) opinion.
//    painter->setPen(Qt::NoPen);
}
void Singleton::f6();{
    int max = 1;
    // We typically draw a sparkline alongside some text. Size our
    // drawing area based on an Em width. and a bit of eyballing on
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
}
void Singleton::f7();{
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
    int content_w = option.rect.width() - (em_w / 4);
    int content_h = option.fontMetrics.ascent() - 1;
    int val;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
}
void Singleton::f2();{
        idx = idx + step_w;
    }
    QStyleOptionViewItem option_vi = option;
    QStyledItemDelegate::initStyleOption(&option_vi, index);
    painter->save();
}
void Singleton::f3();{
    if ((option_vi.state & QStyle::State_Selected) && !(option_vi.state & QStyle::State_MouseOver)) {
        painter->setPen(option_vi.palette.color(cg, QPalette::HighlightedText));
    } else {
        painter->setPen(option_vi.palette.color(cg, QPalette::Text));
    }
}
void Singleton::f4();{
    QVector<QPointF> fpoints;
    QStyledItemDelegate::paint(painter, option, index);
    if (points.isEmpty() || steps < 1.0 || content_h <= 0) {
        return;
    }
}
void Singleton::f5();{
                option.rect.y() + ((option.rect.height() - option.fontMetrics.height()) / 2) + 1 + 0.5);
    painter->drawPolyline(QPolygonF(fpoints));
    // Some sparklines are decorated with dots at the beginning and end.
    // Ours look better without in my (gcc) opinion.
//    painter->setPen(Qt::NoPen);
}
void Singleton::f6();{
    int max = 1;
    // We typically draw a sparkline alongside some text. Size our
    // drawing area based on an Em width. and a bit of eyballing on
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
}
void Singleton::f7();{
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
    int content_w = option.rect.width() - (em_w / 4);
    int content_h = option.fontMetrics.ascent() - 1;
    int val;
}
void Singleton::f8();{
    // drawing area based on an Em width. and a bit of eyballing on
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
    int content_w = option.rect.width() - (em_w / 4);
    int content_h = option.fontMetrics.ascent() - 1;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        option_vi.palette.setColor(QPalette::All, QPalette::HighlightedText, option_vi.palette.color(QPalette::Active, QPalette::Text));
    }
    QPalette::ColorGroup cg = option_vi.state & QStyle::State_Enabled
                              ? QPalette::Normal : QPalette::Disabled;
    if (cg == QPalette::Normal && !(option_vi.state & QStyle::State_Active))
}
void Singleton::f2();{
        idx = idx + step_w;
    }
    QStyleOptionViewItem option_vi = option;
    QStyledItemDelegate::initStyleOption(&option_vi, index);
    painter->save();
}
void Singleton::f3();{
    if ((option_vi.state & QStyle::State_Selected) && !(option_vi.state & QStyle::State_MouseOver)) {
        painter->setPen(option_vi.palette.color(cg, QPalette::HighlightedText));
    } else {
        painter->setPen(option_vi.palette.color(cg, QPalette::Text));
    }
}
void Singleton::f4();{
    QVector<QPointF> fpoints;
    QStyledItemDelegate::paint(painter, option, index);
    if (points.isEmpty() || steps < 1.0 || content_h <= 0) {
        return;
    }
}
void Singleton::f5();{
                option.rect.y() + ((option.rect.height() - option.fontMetrics.height()) / 2) + 1 + 0.5);
    painter->drawPolyline(QPolygonF(fpoints));
    // Some sparklines are decorated with dots at the beginning and end.
    // Ours look better without in my (gcc) opinion.
//    painter->setPen(Qt::NoPen);
}
void Singleton::f6();{
    int max = 1;
    // We typically draw a sparkline alongside some text. Size our
    // drawing area based on an Em width. and a bit of eyballing on
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
}
void Singleton::f7();{
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
    int content_w = option.rect.width() - (em_w / 4);
    int content_h = option.fontMetrics.ascent() - 1;
    int val;
}
void Singleton::f8();{
    // drawing area based on an Em width. and a bit of eyballing on
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
    int content_w = option.rect.width() - (em_w / 4);
    int content_h = option.fontMetrics.ascent() - 1;
}
void Singleton::f9();{
    // Linux, macOS, and Windows.
    int em_w = option.fontMetrics.height();
    int content_w = option.rect.width() - (em_w / 4);
    int content_h = option.fontMetrics.ascent() - 1;
    int val;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            message += 18;
        action_msg.append(" ").append(message);
    }
    so_ui_->actionLabel->setText(action_msg);
    so_ui_->progressBar->setValue(register_cur_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            message += 18;
        action_msg.append(" ").append(message);
    }
    so_ui_->actionLabel->setText(action_msg);
    so_ui_->progressBar->setValue(register_cur_);
}
void Singleton::f2();{
    case RA_PREFERENCES:
        action_msg = tr("Loading module preferences");
        break;
    case RA_INTERFACES:
        action_msg = tr("Finding local interfaces");
}
void Singleton::f3();{
        break;
    case RA_REGISTER:
        action_msg = tr("Registering dissectors");
        break;
    case RA_PLUGIN_REGISTER:
}
void Singleton::f4();{
    int register_max = RA_BASE_COUNT;
    register_max++;
    register_max++;
    so_ui_->progressBar->setMaximum(register_max);
    elapsed_timer_.start();
}
void Singleton::f5();{
        break;
    case RA_EXTCAP:
        action_msg = tr("Initializing external capture plugins");
        break;
    case RA_REGISTER:
}
void Singleton::f6();{
    connect(wsApp, SIGNAL(splashUpdate(register_action_e,const char*)),
            this, SLOT(splashUpdate(register_action_e,const char*)));
SplashOverlay::~SplashOverlay()
    delete so_ui_;
// Useful for debugging on fast machines.
}
void Singleton::f7();{
    so_ui_->progressBar->setMaximum(register_max);
    elapsed_timer_.start();
    QColor bg = QColor(tango_aluminium_6);
    bg.setAlphaF(0.2);
    QPalette pal;
}
void Singleton::f8();{
    elapsed_timer_.start();
    QColor bg = QColor(tango_aluminium_6);
    bg.setAlphaF(0.2);
    QPalette pal;
    pal.setColor(QPalette::Window, bg);
}
void Singleton::f9();{
    QPalette pal;
    pal.setColor(QPalette::Window, bg);
    setPalette(pal);
    setAutoFillBackground(true);
    setStyleSheet(QString(
}
void Singleton::f10();{
        break;
    }
    if (message) {
        if (!strncmp(message, "proto_register_", 15))
            message += 15;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            message += 18;
        action_msg.append(" ").append(message);
    }
    so_ui_->actionLabel->setText(action_msg);
    so_ui_->progressBar->setValue(register_cur_);
}
void Singleton::f2();{
    case RA_PREFERENCES:
        action_msg = tr("Loading module preferences");
        break;
    case RA_INTERFACES:
        action_msg = tr("Finding local interfaces");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            message += 18;
        action_msg.append(" ").append(message);
    }
    so_ui_->actionLabel->setText(action_msg);
    so_ui_->progressBar->setValue(register_cur_);
}
void Singleton::f2();{
    case RA_PREFERENCES:
        action_msg = tr("Loading module preferences");
        break;
    case RA_INTERFACES:
        action_msg = tr("Finding local interfaces");
}
void Singleton::f3();{
        break;
    case RA_REGISTER:
        action_msg = tr("Registering dissectors");
        break;
    case RA_PLUGIN_REGISTER:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            message += 18;
        action_msg.append(" ").append(message);
    }
    so_ui_->actionLabel->setText(action_msg);
    so_ui_->progressBar->setValue(register_cur_);
}
void Singleton::f2();{
    case RA_PREFERENCES:
        action_msg = tr("Loading module preferences");
        break;
    case RA_INTERFACES:
        action_msg = tr("Finding local interfaces");
}
void Singleton::f3();{
        break;
    case RA_REGISTER:
        action_msg = tr("Registering dissectors");
        break;
    case RA_PLUGIN_REGISTER:
}
void Singleton::f4();{
    int register_max = RA_BASE_COUNT;
    register_max++;
    register_max++;
    so_ui_->progressBar->setMaximum(register_max);
    elapsed_timer_.start();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            message += 18;
        action_msg.append(" ").append(message);
    }
    so_ui_->actionLabel->setText(action_msg);
    so_ui_->progressBar->setValue(register_cur_);
}
void Singleton::f2();{
    case RA_PREFERENCES:
        action_msg = tr("Loading module preferences");
        break;
    case RA_INTERFACES:
        action_msg = tr("Finding local interfaces");
}
void Singleton::f3();{
        break;
    case RA_REGISTER:
        action_msg = tr("Registering dissectors");
        break;
    case RA_PLUGIN_REGISTER:
}
void Singleton::f4();{
    int register_max = RA_BASE_COUNT;
    register_max++;
    register_max++;
    so_ui_->progressBar->setMaximum(register_max);
    elapsed_timer_.start();
}
void Singleton::f5();{
        break;
    case RA_EXTCAP:
        action_msg = tr("Initializing external capture plugins");
        break;
    case RA_REGISTER:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            message += 18;
        action_msg.append(" ").append(message);
    }
    so_ui_->actionLabel->setText(action_msg);
    so_ui_->progressBar->setValue(register_cur_);
}
void Singleton::f2();{
    case RA_PREFERENCES:
        action_msg = tr("Loading module preferences");
        break;
    case RA_INTERFACES:
        action_msg = tr("Finding local interfaces");
}
void Singleton::f3();{
        break;
    case RA_REGISTER:
        action_msg = tr("Registering dissectors");
        break;
    case RA_PLUGIN_REGISTER:
}
void Singleton::f4();{
    int register_max = RA_BASE_COUNT;
    register_max++;
    register_max++;
    so_ui_->progressBar->setMaximum(register_max);
    elapsed_timer_.start();
}
void Singleton::f5();{
        break;
    case RA_EXTCAP:
        action_msg = tr("Initializing external capture plugins");
        break;
    case RA_REGISTER:
}
void Singleton::f6();{
    connect(wsApp, SIGNAL(splashUpdate(register_action_e,const char*)),
            this, SLOT(splashUpdate(register_action_e,const char*)));
SplashOverlay::~SplashOverlay()
    delete so_ui_;
// Useful for debugging on fast machines.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            message += 18;
        action_msg.append(" ").append(message);
    }
    so_ui_->actionLabel->setText(action_msg);
    so_ui_->progressBar->setValue(register_cur_);
}
void Singleton::f2();{
    case RA_PREFERENCES:
        action_msg = tr("Loading module preferences");
        break;
    case RA_INTERFACES:
        action_msg = tr("Finding local interfaces");
}
void Singleton::f3();{
        break;
    case RA_REGISTER:
        action_msg = tr("Registering dissectors");
        break;
    case RA_PLUGIN_REGISTER:
}
void Singleton::f4();{
    int register_max = RA_BASE_COUNT;
    register_max++;
    register_max++;
    so_ui_->progressBar->setMaximum(register_max);
    elapsed_timer_.start();
}
void Singleton::f5();{
        break;
    case RA_EXTCAP:
        action_msg = tr("Initializing external capture plugins");
        break;
    case RA_REGISTER:
}
void Singleton::f6();{
    connect(wsApp, SIGNAL(splashUpdate(register_action_e,const char*)),
            this, SLOT(splashUpdate(register_action_e,const char*)));
SplashOverlay::~SplashOverlay()
    delete so_ui_;
// Useful for debugging on fast machines.
}
void Singleton::f7();{
    so_ui_->progressBar->setMaximum(register_max);
    elapsed_timer_.start();
    QColor bg = QColor(tango_aluminium_6);
    bg.setAlphaF(0.2);
    QPalette pal;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            message += 18;
        action_msg.append(" ").append(message);
    }
    so_ui_->actionLabel->setText(action_msg);
    so_ui_->progressBar->setValue(register_cur_);
}
void Singleton::f2();{
    case RA_PREFERENCES:
        action_msg = tr("Loading module preferences");
        break;
    case RA_INTERFACES:
        action_msg = tr("Finding local interfaces");
}
void Singleton::f3();{
        break;
    case RA_REGISTER:
        action_msg = tr("Registering dissectors");
        break;
    case RA_PLUGIN_REGISTER:
}
void Singleton::f4();{
    int register_max = RA_BASE_COUNT;
    register_max++;
    register_max++;
    so_ui_->progressBar->setMaximum(register_max);
    elapsed_timer_.start();
}
void Singleton::f5();{
        break;
    case RA_EXTCAP:
        action_msg = tr("Initializing external capture plugins");
        break;
    case RA_REGISTER:
}
void Singleton::f6();{
    connect(wsApp, SIGNAL(splashUpdate(register_action_e,const char*)),
            this, SLOT(splashUpdate(register_action_e,const char*)));
SplashOverlay::~SplashOverlay()
    delete so_ui_;
// Useful for debugging on fast machines.
}
void Singleton::f7();{
    so_ui_->progressBar->setMaximum(register_max);
    elapsed_timer_.start();
    QColor bg = QColor(tango_aluminium_6);
    bg.setAlphaF(0.2);
    QPalette pal;
}
void Singleton::f8();{
    elapsed_timer_.start();
    QColor bg = QColor(tango_aluminium_6);
    bg.setAlphaF(0.2);
    QPalette pal;
    pal.setColor(QPalette::Window, bg);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            message += 18;
        action_msg.append(" ").append(message);
    }
    so_ui_->actionLabel->setText(action_msg);
    so_ui_->progressBar->setValue(register_cur_);
}
void Singleton::f2();{
    case RA_PREFERENCES:
        action_msg = tr("Loading module preferences");
        break;
    case RA_INTERFACES:
        action_msg = tr("Finding local interfaces");
}
void Singleton::f3();{
        break;
    case RA_REGISTER:
        action_msg = tr("Registering dissectors");
        break;
    case RA_PLUGIN_REGISTER:
}
void Singleton::f4();{
    int register_max = RA_BASE_COUNT;
    register_max++;
    register_max++;
    so_ui_->progressBar->setMaximum(register_max);
    elapsed_timer_.start();
}
void Singleton::f5();{
        break;
    case RA_EXTCAP:
        action_msg = tr("Initializing external capture plugins");
        break;
    case RA_REGISTER:
}
void Singleton::f6();{
    connect(wsApp, SIGNAL(splashUpdate(register_action_e,const char*)),
            this, SLOT(splashUpdate(register_action_e,const char*)));
SplashOverlay::~SplashOverlay()
    delete so_ui_;
// Useful for debugging on fast machines.
}
void Singleton::f7();{
    so_ui_->progressBar->setMaximum(register_max);
    elapsed_timer_.start();
    QColor bg = QColor(tango_aluminium_6);
    bg.setAlphaF(0.2);
    QPalette pal;
}
void Singleton::f8();{
    elapsed_timer_.start();
    QColor bg = QColor(tango_aluminium_6);
    bg.setAlphaF(0.2);
    QPalette pal;
    pal.setColor(QPalette::Window, bg);
}
void Singleton::f9();{
    QPalette pal;
    pal.setColor(QPalette::Window, bg);
    setPalette(pal);
    setAutoFillBackground(true);
    setStyleSheet(QString(
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
StatsTreeDialog::~StatsTreeDialog()
    if (st_) {
        stats_tree_free(st_);
    }
// Adds a node to the QTreeWidget
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
StatsTreeDialog::~StatsTreeDialog()
    if (st_) {
        stats_tree_free(st_);
    }
// Adds a node to the QTreeWidget
}
void Singleton::f2();{
    for (int count = 0; count<st_->num_columns; count++) {
        header_labels.push_back(stats_tree_get_column_name(count));
    }
    statsTreeWidget()->setColumnCount(header_labels.count());
    statsTreeWidget()->setHeaderLabels(header_labels);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
const int item_col_ = 0;
const int sn_type_ = 1000;
class StatsTreeWidgetItem : public QTreeWidgetItem
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    st->cfg->init(st);
void StatsTreeDialog::drawTreeItems(void *st_ptr)
    stats_tree *st = (stats_tree *) st_ptr;
    if (!st || !st->cfg || !st->cfg->pr || !st->cfg->pr->st_dlg) return;
    TapParameterDialog *st_dlg = st->cfg->pr->st_dlg;
}
void Singleton::f7();{
        if (order==Qt::DescendingOrder) {
            result = -result;
        }
        return result < 0;
    }
}
void Singleton::f8();{
    }
    if (parent) {
        parent->addChild(ti);
    } else {
        st_dlg->statsTreeWidget()->addTopLevelItem(ti);
}
void Singleton::f9();{
    TapParameterDialog(parent, cf),
    st_(NULL),
    st_cfg_(NULL)
    loadGeometry(800, height(), cfg_abbr);
    st_cfg_ = stats_tree_get_cfg_by_abbr(cfg_abbr);
}
void Singleton::f10();{
            }
            (*iter)->setExpanded((node->parent==(&st->root)) &&
                                 (!(node->st_flags&ST_FLG_DEF_NOEXPAND)));
            g_free(valstrs);
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
StatsTreeDialog::~StatsTreeDialog()
    if (st_) {
        stats_tree_free(st_);
    }
// Adds a node to the QTreeWidget
}
void Singleton::f2();{
    for (int count = 0; count<st_->num_columns; count++) {
        header_labels.push_back(stats_tree_get_column_name(count));
    }
    statsTreeWidget()->setColumnCount(header_labels.count());
    statsTreeWidget()->setHeaderLabels(header_labels);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
StatsTreeDialog::~StatsTreeDialog()
    if (st_) {
        stats_tree_free(st_);
    }
// Adds a node to the QTreeWidget
}
void Singleton::f2();{
    for (int count = 0; count<st_->num_columns; count++) {
        header_labels.push_back(stats_tree_get_column_name(count));
    }
    statsTreeWidget()->setColumnCount(header_labels.count());
    statsTreeWidget()->setHeaderLabels(header_labels);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
StatsTreeDialog::~StatsTreeDialog()
    if (st_) {
        stats_tree_free(st_);
    }
// Adds a node to the QTreeWidget
}
void Singleton::f2();{
    for (int count = 0; count<st_->num_columns; count++) {
        header_labels.push_back(stats_tree_get_column_name(count));
    }
    statsTreeWidget()->setColumnCount(header_labels.count());
    statsTreeWidget()->setHeaderLabels(header_labels);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
const int item_col_ = 0;
const int sn_type_ = 1000;
class StatsTreeWidgetItem : public QTreeWidgetItem
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
StatsTreeDialog::~StatsTreeDialog()
    if (st_) {
        stats_tree_free(st_);
    }
// Adds a node to the QTreeWidget
}
void Singleton::f2();{
    for (int count = 0; count<st_->num_columns; count++) {
        header_labels.push_back(stats_tree_get_column_name(count));
    }
    statsTreeWidget()->setColumnCount(header_labels.count());
    statsTreeWidget()->setHeaderLabels(header_labels);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
const int item_col_ = 0;
const int sn_type_ = 1000;
class StatsTreeWidgetItem : public QTreeWidgetItem
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
StatsTreeDialog::~StatsTreeDialog()
    if (st_) {
        stats_tree_free(st_);
    }
// Adds a node to the QTreeWidget
}
void Singleton::f2();{
    for (int count = 0; count<st_->num_columns; count++) {
        header_labels.push_back(stats_tree_get_column_name(count));
    }
    statsTreeWidget()->setColumnCount(header_labels.count());
    statsTreeWidget()->setHeaderLabels(header_labels);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
const int item_col_ = 0;
const int sn_type_ = 1000;
class StatsTreeWidgetItem : public QTreeWidgetItem
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    st->cfg->init(st);
void StatsTreeDialog::drawTreeItems(void *st_ptr)
    stats_tree *st = (stats_tree *) st_ptr;
    if (!st || !st->cfg || !st->cfg->pr || !st->cfg->pr->st_dlg) return;
    TapParameterDialog *st_dlg = st->cfg->pr->st_dlg;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
StatsTreeDialog::~StatsTreeDialog()
    if (st_) {
        stats_tree_free(st_);
    }
// Adds a node to the QTreeWidget
}
void Singleton::f2();{
    for (int count = 0; count<st_->num_columns; count++) {
        header_labels.push_back(stats_tree_get_column_name(count));
    }
    statsTreeWidget()->setColumnCount(header_labels.count());
    statsTreeWidget()->setHeaderLabels(header_labels);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
const int item_col_ = 0;
const int sn_type_ = 1000;
class StatsTreeWidgetItem : public QTreeWidgetItem
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    st->cfg->init(st);
void StatsTreeDialog::drawTreeItems(void *st_ptr)
    stats_tree *st = (stats_tree *) st_ptr;
    if (!st || !st->cfg || !st->cfg->pr || !st->cfg->pr->st_dlg) return;
    TapParameterDialog *st_dlg = st->cfg->pr->st_dlg;
}
void Singleton::f7();{
        if (order==Qt::DescendingOrder) {
            result = -result;
        }
        return result < 0;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
StatsTreeDialog::~StatsTreeDialog()
    if (st_) {
        stats_tree_free(st_);
    }
// Adds a node to the QTreeWidget
}
void Singleton::f2();{
    for (int count = 0; count<st_->num_columns; count++) {
        header_labels.push_back(stats_tree_get_column_name(count));
    }
    statsTreeWidget()->setColumnCount(header_labels.count());
    statsTreeWidget()->setHeaderLabels(header_labels);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
const int item_col_ = 0;
const int sn_type_ = 1000;
class StatsTreeWidgetItem : public QTreeWidgetItem
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    st->cfg->init(st);
void StatsTreeDialog::drawTreeItems(void *st_ptr)
    stats_tree *st = (stats_tree *) st_ptr;
    if (!st || !st->cfg || !st->cfg->pr || !st->cfg->pr->st_dlg) return;
    TapParameterDialog *st_dlg = st->cfg->pr->st_dlg;
}
void Singleton::f7();{
        if (order==Qt::DescendingOrder) {
            result = -result;
        }
        return result < 0;
    }
}
void Singleton::f8();{
    }
    if (parent) {
        parent->addChild(ti);
    } else {
        st_dlg->statsTreeWidget()->addTopLevelItem(ti);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
StatsTreeDialog::~StatsTreeDialog()
    if (st_) {
        stats_tree_free(st_);
    }
// Adds a node to the QTreeWidget
}
void Singleton::f2();{
    for (int count = 0; count<st_->num_columns; count++) {
        header_labels.push_back(stats_tree_get_column_name(count));
    }
    statsTreeWidget()->setColumnCount(header_labels.count());
    statsTreeWidget()->setHeaderLabels(header_labels);
}
void Singleton::f3();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f4();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
const int item_col_ = 0;
const int sn_type_ = 1000;
class StatsTreeWidgetItem : public QTreeWidgetItem
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    st->cfg->init(st);
void StatsTreeDialog::drawTreeItems(void *st_ptr)
    stats_tree *st = (stats_tree *) st_ptr;
    if (!st || !st->cfg || !st->cfg->pr || !st->cfg->pr->st_dlg) return;
    TapParameterDialog *st_dlg = st->cfg->pr->st_dlg;
}
void Singleton::f7();{
        if (order==Qt::DescendingOrder) {
            result = -result;
        }
        return result < 0;
    }
}
void Singleton::f8();{
    }
    if (parent) {
        parent->addChild(ti);
    } else {
        st_dlg->statsTreeWidget()->addTopLevelItem(ti);
}
void Singleton::f9();{
    TapParameterDialog(parent, cf),
    st_(NULL),
    st_cfg_(NULL)
    loadGeometry(800, height(), cfg_abbr);
    st_cfg_ = stats_tree_get_cfg_by_abbr(cfg_abbr);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                painter.drawPixmap(0, 0, mask_pm);
                QPixmap normal_pm = QPixmap::fromImage(normal_img);
                addPixmap(normal_pm, QIcon::Normal, QIcon::On);
                addPixmap(normal_pm, QIcon::Normal, QIcon::Off);
                QStyleOption opt = {};
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                painter.drawPixmap(0, 0, mask_pm);
                QPixmap normal_pm = QPixmap::fromImage(normal_img);
                addPixmap(normal_pm, QIcon::Normal, QIcon::On);
                addPixmap(normal_pm, QIcon::Normal, QIcon::Off);
                QStyleOption opt = {};
}
void Singleton::f2();{
            painter.drawText(bounding, glyph);
        }
        color_icon.addPixmap(pm);
    }
    return color_icon;
}
void Singleton::f3();{
    icon_name_to_standard_pixmap_["media-playback-start"] = QStyle::SP_MediaPlay;
    icon_name_to_standard_pixmap_["media-playback-stop"] = QStyle::SP_MediaStop;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f4();{
                foreach (QIcon::Mode icon_mode, icon_modes) {
                    QPixmap mode_pm = wsApp->style()->generatedIconPixmap(icon_mode, normal_pm, &opt);
                    addPixmap(mode_pm, icon_mode, QIcon::On);
                    addPixmap(mode_pm, icon_mode, QIcon::Off);
                }
}
void Singleton::f5();{
// https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
// https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
// https://mithatkonar.com/wiki/doku.php/qt/icons
// https://web.archive.org/web/20140829010224/https://developer.apple.com/library/mac/documentation/userexperience/conceptual/applehiguidelines/IconsImages/IconsImages.html
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/image-size-and-resolution/
}
void Singleton::f6();{
    foreach (QString type, types) {
        // First, check for a template (mask) icon
        // Templates should be monochrome as described at
        // https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/custom-icons/
        // Transparency is supported.
}
void Singleton::f7();{
            addFile(icon_path_selected, QSize(), QIcon::Selected, QIcon::On);
        }
        QString icon_path_on = path_pfx_ + QString("%1/%2.on.png").arg(type).arg(icon_name);
        if (QFile::exists(icon_path_on)) {
            addFile(icon_path_on, QSize(), QIcon::Normal, QIcon::On);
}
void Singleton::f8();{
// https://web.archive.org/web/20140829010224/https://developer.apple.com/library/mac/documentation/userexperience/conceptual/applehiguidelines/IconsImages/IconsImages.html
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/image-size-and-resolution/
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/app-icon/
// https://docs.microsoft.com/en-us/windows/win32/uxguide/vis-icons
// https://developer.gnome.org/hig/stable/icons-and-artwork.html.en
}
void Singleton::f9();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Stock icons. Based on gtk/stock_icons.h
}
void Singleton::f10();{
    QList<QIcon::Mode> icon_modes = QList<QIcon::Mode>()
            << QIcon::Disabled
            << QIcon::Active
            << QIcon::Selected;
    foreach (QString type, types) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                painter.drawPixmap(0, 0, mask_pm);
                QPixmap normal_pm = QPixmap::fromImage(normal_img);
                addPixmap(normal_pm, QIcon::Normal, QIcon::On);
                addPixmap(normal_pm, QIcon::Normal, QIcon::Off);
                QStyleOption opt = {};
}
void Singleton::f2();{
            painter.drawText(bounding, glyph);
        }
        color_icon.addPixmap(pm);
    }
    return color_icon;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                painter.drawPixmap(0, 0, mask_pm);
                QPixmap normal_pm = QPixmap::fromImage(normal_img);
                addPixmap(normal_pm, QIcon::Normal, QIcon::On);
                addPixmap(normal_pm, QIcon::Normal, QIcon::Off);
                QStyleOption opt = {};
}
void Singleton::f2();{
            painter.drawText(bounding, glyph);
        }
        color_icon.addPixmap(pm);
    }
    return color_icon;
}
void Singleton::f3();{
    icon_name_to_standard_pixmap_["media-playback-start"] = QStyle::SP_MediaPlay;
    icon_name_to_standard_pixmap_["media-playback-stop"] = QStyle::SP_MediaStop;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                painter.drawPixmap(0, 0, mask_pm);
                QPixmap normal_pm = QPixmap::fromImage(normal_img);
                addPixmap(normal_pm, QIcon::Normal, QIcon::On);
                addPixmap(normal_pm, QIcon::Normal, QIcon::Off);
                QStyleOption opt = {};
}
void Singleton::f2();{
            painter.drawText(bounding, glyph);
        }
        color_icon.addPixmap(pm);
    }
    return color_icon;
}
void Singleton::f3();{
    icon_name_to_standard_pixmap_["media-playback-start"] = QStyle::SP_MediaPlay;
    icon_name_to_standard_pixmap_["media-playback-stop"] = QStyle::SP_MediaStop;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f4();{
                foreach (QIcon::Mode icon_mode, icon_modes) {
                    QPixmap mode_pm = wsApp->style()->generatedIconPixmap(icon_mode, normal_pm, &opt);
                    addPixmap(mode_pm, icon_mode, QIcon::On);
                    addPixmap(mode_pm, icon_mode, QIcon::Off);
                }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                painter.drawPixmap(0, 0, mask_pm);
                QPixmap normal_pm = QPixmap::fromImage(normal_img);
                addPixmap(normal_pm, QIcon::Normal, QIcon::On);
                addPixmap(normal_pm, QIcon::Normal, QIcon::Off);
                QStyleOption opt = {};
}
void Singleton::f2();{
            painter.drawText(bounding, glyph);
        }
        color_icon.addPixmap(pm);
    }
    return color_icon;
}
void Singleton::f3();{
    icon_name_to_standard_pixmap_["media-playback-start"] = QStyle::SP_MediaPlay;
    icon_name_to_standard_pixmap_["media-playback-stop"] = QStyle::SP_MediaStop;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f4();{
                foreach (QIcon::Mode icon_mode, icon_modes) {
                    QPixmap mode_pm = wsApp->style()->generatedIconPixmap(icon_mode, normal_pm, &opt);
                    addPixmap(mode_pm, icon_mode, QIcon::On);
                    addPixmap(mode_pm, icon_mode, QIcon::Off);
                }
}
void Singleton::f5();{
// https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
// https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
// https://mithatkonar.com/wiki/doku.php/qt/icons
// https://web.archive.org/web/20140829010224/https://developer.apple.com/library/mac/documentation/userexperience/conceptual/applehiguidelines/IconsImages/IconsImages.html
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/image-size-and-resolution/
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                painter.drawPixmap(0, 0, mask_pm);
                QPixmap normal_pm = QPixmap::fromImage(normal_img);
                addPixmap(normal_pm, QIcon::Normal, QIcon::On);
                addPixmap(normal_pm, QIcon::Normal, QIcon::Off);
                QStyleOption opt = {};
}
void Singleton::f2();{
            painter.drawText(bounding, glyph);
        }
        color_icon.addPixmap(pm);
    }
    return color_icon;
}
void Singleton::f3();{
    icon_name_to_standard_pixmap_["media-playback-start"] = QStyle::SP_MediaPlay;
    icon_name_to_standard_pixmap_["media-playback-stop"] = QStyle::SP_MediaStop;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f4();{
                foreach (QIcon::Mode icon_mode, icon_modes) {
                    QPixmap mode_pm = wsApp->style()->generatedIconPixmap(icon_mode, normal_pm, &opt);
                    addPixmap(mode_pm, icon_mode, QIcon::On);
                    addPixmap(mode_pm, icon_mode, QIcon::Off);
                }
}
void Singleton::f5();{
// https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
// https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
// https://mithatkonar.com/wiki/doku.php/qt/icons
// https://web.archive.org/web/20140829010224/https://developer.apple.com/library/mac/documentation/userexperience/conceptual/applehiguidelines/IconsImages/IconsImages.html
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/image-size-and-resolution/
}
void Singleton::f6();{
    foreach (QString type, types) {
        // First, check for a template (mask) icon
        // Templates should be monochrome as described at
        // https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/custom-icons/
        // Transparency is supported.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                painter.drawPixmap(0, 0, mask_pm);
                QPixmap normal_pm = QPixmap::fromImage(normal_img);
                addPixmap(normal_pm, QIcon::Normal, QIcon::On);
                addPixmap(normal_pm, QIcon::Normal, QIcon::Off);
                QStyleOption opt = {};
}
void Singleton::f2();{
            painter.drawText(bounding, glyph);
        }
        color_icon.addPixmap(pm);
    }
    return color_icon;
}
void Singleton::f3();{
    icon_name_to_standard_pixmap_["media-playback-start"] = QStyle::SP_MediaPlay;
    icon_name_to_standard_pixmap_["media-playback-stop"] = QStyle::SP_MediaStop;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f4();{
                foreach (QIcon::Mode icon_mode, icon_modes) {
                    QPixmap mode_pm = wsApp->style()->generatedIconPixmap(icon_mode, normal_pm, &opt);
                    addPixmap(mode_pm, icon_mode, QIcon::On);
                    addPixmap(mode_pm, icon_mode, QIcon::Off);
                }
}
void Singleton::f5();{
// https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
// https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
// https://mithatkonar.com/wiki/doku.php/qt/icons
// https://web.archive.org/web/20140829010224/https://developer.apple.com/library/mac/documentation/userexperience/conceptual/applehiguidelines/IconsImages/IconsImages.html
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/image-size-and-resolution/
}
void Singleton::f6();{
    foreach (QString type, types) {
        // First, check for a template (mask) icon
        // Templates should be monochrome as described at
        // https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/custom-icons/
        // Transparency is supported.
}
void Singleton::f7();{
            addFile(icon_path_selected, QSize(), QIcon::Selected, QIcon::On);
        }
        QString icon_path_on = path_pfx_ + QString("%1/%2.on.png").arg(type).arg(icon_name);
        if (QFile::exists(icon_path_on)) {
            addFile(icon_path_on, QSize(), QIcon::Normal, QIcon::On);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                painter.drawPixmap(0, 0, mask_pm);
                QPixmap normal_pm = QPixmap::fromImage(normal_img);
                addPixmap(normal_pm, QIcon::Normal, QIcon::On);
                addPixmap(normal_pm, QIcon::Normal, QIcon::Off);
                QStyleOption opt = {};
}
void Singleton::f2();{
            painter.drawText(bounding, glyph);
        }
        color_icon.addPixmap(pm);
    }
    return color_icon;
}
void Singleton::f3();{
    icon_name_to_standard_pixmap_["media-playback-start"] = QStyle::SP_MediaPlay;
    icon_name_to_standard_pixmap_["media-playback-stop"] = QStyle::SP_MediaStop;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f4();{
                foreach (QIcon::Mode icon_mode, icon_modes) {
                    QPixmap mode_pm = wsApp->style()->generatedIconPixmap(icon_mode, normal_pm, &opt);
                    addPixmap(mode_pm, icon_mode, QIcon::On);
                    addPixmap(mode_pm, icon_mode, QIcon::Off);
                }
}
void Singleton::f5();{
// https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
// https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
// https://mithatkonar.com/wiki/doku.php/qt/icons
// https://web.archive.org/web/20140829010224/https://developer.apple.com/library/mac/documentation/userexperience/conceptual/applehiguidelines/IconsImages/IconsImages.html
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/image-size-and-resolution/
}
void Singleton::f6();{
    foreach (QString type, types) {
        // First, check for a template (mask) icon
        // Templates should be monochrome as described at
        // https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/custom-icons/
        // Transparency is supported.
}
void Singleton::f7();{
            addFile(icon_path_selected, QSize(), QIcon::Selected, QIcon::On);
        }
        QString icon_path_on = path_pfx_ + QString("%1/%2.on.png").arg(type).arg(icon_name);
        if (QFile::exists(icon_path_on)) {
            addFile(icon_path_on, QSize(), QIcon::Normal, QIcon::On);
}
void Singleton::f8();{
// https://web.archive.org/web/20140829010224/https://developer.apple.com/library/mac/documentation/userexperience/conceptual/applehiguidelines/IconsImages/IconsImages.html
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/image-size-and-resolution/
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/app-icon/
// https://docs.microsoft.com/en-us/windows/win32/uxguide/vis-icons
// https://developer.gnome.org/hig/stable/icons-and-artwork.html.en
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                painter.drawPixmap(0, 0, mask_pm);
                QPixmap normal_pm = QPixmap::fromImage(normal_img);
                addPixmap(normal_pm, QIcon::Normal, QIcon::On);
                addPixmap(normal_pm, QIcon::Normal, QIcon::Off);
                QStyleOption opt = {};
}
void Singleton::f2();{
            painter.drawText(bounding, glyph);
        }
        color_icon.addPixmap(pm);
    }
    return color_icon;
}
void Singleton::f3();{
    icon_name_to_standard_pixmap_["media-playback-start"] = QStyle::SP_MediaPlay;
    icon_name_to_standard_pixmap_["media-playback-stop"] = QStyle::SP_MediaStop;
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f4();{
                foreach (QIcon::Mode icon_mode, icon_modes) {
                    QPixmap mode_pm = wsApp->style()->generatedIconPixmap(icon_mode, normal_pm, &opt);
                    addPixmap(mode_pm, icon_mode, QIcon::On);
                    addPixmap(mode_pm, icon_mode, QIcon::Off);
                }
}
void Singleton::f5();{
// https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
// https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
// https://mithatkonar.com/wiki/doku.php/qt/icons
// https://web.archive.org/web/20140829010224/https://developer.apple.com/library/mac/documentation/userexperience/conceptual/applehiguidelines/IconsImages/IconsImages.html
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/image-size-and-resolution/
}
void Singleton::f6();{
    foreach (QString type, types) {
        // First, check for a template (mask) icon
        // Templates should be monochrome as described at
        // https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/custom-icons/
        // Transparency is supported.
}
void Singleton::f7();{
            addFile(icon_path_selected, QSize(), QIcon::Selected, QIcon::On);
        }
        QString icon_path_on = path_pfx_ + QString("%1/%2.on.png").arg(type).arg(icon_name);
        if (QFile::exists(icon_path_on)) {
            addFile(icon_path_on, QSize(), QIcon::Normal, QIcon::On);
}
void Singleton::f8();{
// https://web.archive.org/web/20140829010224/https://developer.apple.com/library/mac/documentation/userexperience/conceptual/applehiguidelines/IconsImages/IconsImages.html
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/image-size-and-resolution/
// https://developer.apple.com/design/human-interface-guidelines/macos/icons-and-images/app-icon/
// https://docs.microsoft.com/en-us/windows/win32/uxguide/vis-icons
// https://developer.gnome.org/hig/stable/icons-and-artwork.html.en
}
void Singleton::f9();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// Stock icons. Based on gtk/stock_icons.h
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f2();{
            mode_icon.addPixmap(base_icon_.pixmap(size, mode, state), mode, state);
        }
    }
    setIcon(mode_icon);
void StockIconToolButton::setStockIcon(QString icon_name)
}
void Singleton::f3();{
    {
        // We can lose QEvent::Leave, QEvent::HoverLeave and underMouse()
        // on macOS if a tooltip appears:
        // https://bugreports.qt.io/browse/QTBUG-46379
        // Work around the issue by periodically checking the mouse
}
void Singleton::f4();{
// We want nice icons that render correctly, and that are responsive
// when the user hovers and clicks them.
// Using setIcon renders correctly on normal and retina displays. It is
// not completely responsive, particularly on macOS.
// Calling setStyleSheet is responsive, but does not render correctly on
}
void Singleton::f5();{
    case QEvent::MouseButtonRelease:
        setIconMode();
        break;
    case QEvent::Timer:
    {
}
void Singleton::f6();{
        }
        break;
    case QEvent::Leave:
        if (leave_timer_ > 0) killTimer(leave_timer_);
        leave_timer_ = 0;
}
void Singleton::f7();{
        return;
    }
    base_icon_ = StockIcon(icon_name_);
    setIconMode();
bool StockIconToolButton::event(QEvent *event)
}
void Singleton::f8();{
    {
        // We can lose QEvent::Leave, QEvent::HoverLeave and underMouse()
        // on macOS if a tooltip appears:
        // https://bugreports.qt.io/browse/QTBUG-46379
        // Work around the issue by periodically checking the mouse
}
void Singleton::f9();{
    }
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}
void Singleton::f10();{
        case QEvent::Enter:
        if (isEnabled()) {
            setIconMode(QIcon::Active);
            if (leave_timer_ > 0) killTimer(leave_timer_);
            leave_timer_ = startTimer(leave_interval_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f2();{
            mode_icon.addPixmap(base_icon_.pixmap(size, mode, state), mode, state);
        }
    }
    setIcon(mode_icon);
void StockIconToolButton::setStockIcon(QString icon_name)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f2();{
            mode_icon.addPixmap(base_icon_.pixmap(size, mode, state), mode, state);
        }
    }
    setIcon(mode_icon);
void StockIconToolButton::setStockIcon(QString icon_name)
}
void Singleton::f3();{
    {
        // We can lose QEvent::Leave, QEvent::HoverLeave and underMouse()
        // on macOS if a tooltip appears:
        // https://bugreports.qt.io/browse/QTBUG-46379
        // Work around the issue by periodically checking the mouse
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f2();{
            mode_icon.addPixmap(base_icon_.pixmap(size, mode, state), mode, state);
        }
    }
    setIcon(mode_icon);
void StockIconToolButton::setStockIcon(QString icon_name)
}
void Singleton::f3();{
    {
        // We can lose QEvent::Leave, QEvent::HoverLeave and underMouse()
        // on macOS if a tooltip appears:
        // https://bugreports.qt.io/browse/QTBUG-46379
        // Work around the issue by periodically checking the mouse
}
void Singleton::f4();{
// We want nice icons that render correctly, and that are responsive
// when the user hovers and clicks them.
// Using setIcon renders correctly on normal and retina displays. It is
// not completely responsive, particularly on macOS.
// Calling setStyleSheet is responsive, but does not render correctly on
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f2();{
            mode_icon.addPixmap(base_icon_.pixmap(size, mode, state), mode, state);
        }
    }
    setIcon(mode_icon);
void StockIconToolButton::setStockIcon(QString icon_name)
}
void Singleton::f3();{
    {
        // We can lose QEvent::Leave, QEvent::HoverLeave and underMouse()
        // on macOS if a tooltip appears:
        // https://bugreports.qt.io/browse/QTBUG-46379
        // Work around the issue by periodically checking the mouse
}
void Singleton::f4();{
// We want nice icons that render correctly, and that are responsive
// when the user hovers and clicks them.
// Using setIcon renders correctly on normal and retina displays. It is
// not completely responsive, particularly on macOS.
// Calling setStyleSheet is responsive, but does not render correctly on
}
void Singleton::f5();{
    case QEvent::MouseButtonRelease:
        setIconMode();
        break;
    case QEvent::Timer:
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f2();{
            mode_icon.addPixmap(base_icon_.pixmap(size, mode, state), mode, state);
        }
    }
    setIcon(mode_icon);
void StockIconToolButton::setStockIcon(QString icon_name)
}
void Singleton::f3();{
    {
        // We can lose QEvent::Leave, QEvent::HoverLeave and underMouse()
        // on macOS if a tooltip appears:
        // https://bugreports.qt.io/browse/QTBUG-46379
        // Work around the issue by periodically checking the mouse
}
void Singleton::f4();{
// We want nice icons that render correctly, and that are responsive
// when the user hovers and clicks them.
// Using setIcon renders correctly on normal and retina displays. It is
// not completely responsive, particularly on macOS.
// Calling setStyleSheet is responsive, but does not render correctly on
}
void Singleton::f5();{
    case QEvent::MouseButtonRelease:
        setIconMode();
        break;
    case QEvent::Timer:
    {
}
void Singleton::f6();{
        }
        break;
    case QEvent::Leave:
        if (leave_timer_ > 0) killTimer(leave_timer_);
        leave_timer_ = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f2();{
            mode_icon.addPixmap(base_icon_.pixmap(size, mode, state), mode, state);
        }
    }
    setIcon(mode_icon);
void StockIconToolButton::setStockIcon(QString icon_name)
}
void Singleton::f3();{
    {
        // We can lose QEvent::Leave, QEvent::HoverLeave and underMouse()
        // on macOS if a tooltip appears:
        // https://bugreports.qt.io/browse/QTBUG-46379
        // Work around the issue by periodically checking the mouse
}
void Singleton::f4();{
// We want nice icons that render correctly, and that are responsive
// when the user hovers and clicks them.
// Using setIcon renders correctly on normal and retina displays. It is
// not completely responsive, particularly on macOS.
// Calling setStyleSheet is responsive, but does not render correctly on
}
void Singleton::f5();{
    case QEvent::MouseButtonRelease:
        setIconMode();
        break;
    case QEvent::Timer:
    {
}
void Singleton::f6();{
        }
        break;
    case QEvent::Leave:
        if (leave_timer_ > 0) killTimer(leave_timer_);
        leave_timer_ = 0;
}
void Singleton::f7();{
        return;
    }
    base_icon_ = StockIcon(icon_name_);
    setIconMode();
bool StockIconToolButton::event(QEvent *event)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f2();{
            mode_icon.addPixmap(base_icon_.pixmap(size, mode, state), mode, state);
        }
    }
    setIcon(mode_icon);
void StockIconToolButton::setStockIcon(QString icon_name)
}
void Singleton::f3();{
    {
        // We can lose QEvent::Leave, QEvent::HoverLeave and underMouse()
        // on macOS if a tooltip appears:
        // https://bugreports.qt.io/browse/QTBUG-46379
        // Work around the issue by periodically checking the mouse
}
void Singleton::f4();{
// We want nice icons that render correctly, and that are responsive
// when the user hovers and clicks them.
// Using setIcon renders correctly on normal and retina displays. It is
// not completely responsive, particularly on macOS.
// Calling setStyleSheet is responsive, but does not render correctly on
}
void Singleton::f5();{
    case QEvent::MouseButtonRelease:
        setIconMode();
        break;
    case QEvent::Timer:
    {
}
void Singleton::f6();{
        }
        break;
    case QEvent::Leave:
        if (leave_timer_ > 0) killTimer(leave_timer_);
        leave_timer_ = 0;
}
void Singleton::f7();{
        return;
    }
    base_icon_ = StockIcon(icon_name_);
    setIconMode();
bool StockIconToolButton::event(QEvent *event)
}
void Singleton::f8();{
    {
        // We can lose QEvent::Leave, QEvent::HoverLeave and underMouse()
        // on macOS if a tooltip appears:
        // https://bugreports.qt.io/browse/QTBUG-46379
        // Work around the issue by periodically checking the mouse
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
}
void Singleton::f2();{
            mode_icon.addPixmap(base_icon_.pixmap(size, mode, state), mode, state);
        }
    }
    setIcon(mode_icon);
void StockIconToolButton::setStockIcon(QString icon_name)
}
void Singleton::f3();{
    {
        // We can lose QEvent::Leave, QEvent::HoverLeave and underMouse()
        // on macOS if a tooltip appears:
        // https://bugreports.qt.io/browse/QTBUG-46379
        // Work around the issue by periodically checking the mouse
}
void Singleton::f4();{
// We want nice icons that render correctly, and that are responsive
// when the user hovers and clicks them.
// Using setIcon renders correctly on normal and retina displays. It is
// not completely responsive, particularly on macOS.
// Calling setStyleSheet is responsive, but does not render correctly on
}
void Singleton::f5();{
    case QEvent::MouseButtonRelease:
        setIconMode();
        break;
    case QEvent::Timer:
    {
}
void Singleton::f6();{
        }
        break;
    case QEvent::Leave:
        if (leave_timer_ > 0) killTimer(leave_timer_);
        leave_timer_ = 0;
}
void Singleton::f7();{
        return;
    }
    base_icon_ = StockIcon(icon_name_);
    setIconMode();
bool StockIconToolButton::event(QEvent *event)
}
void Singleton::f8();{
    {
        // We can lose QEvent::Leave, QEvent::HoverLeave and underMouse()
        // on macOS if a tooltip appears:
        // https://bugreports.qt.io/browse/QTBUG-46379
        // Work around the issue by periodically checking the mouse
}
void Singleton::f9();{
    }
    return QToolButton::event(event);
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f2();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f3();{
        return 0;
    }
    int numFound = 0;
    std::vector<int> positions;
    // At the begin is always a marker
}
void Singleton::f4();{
void StringUtil::StrSub(std::string& cp, const std::string& sub_this, const std::string& for_this, const  int& num_times)
    int loc = 0;
    if (cp.empty())
    {
        cp = sub_this;
}
void Singleton::f5();{
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * Trim string
 * @param input  string to trim
 * @return returns trimmed string
}
void Singleton::f6();{
        std::string s;
        int start = positions[i] + sizeDelim;
        int size = positions[i+1] - positions[i] - sizeDelim;
        if(size > 0){
            s = input.substr(start, size);   
}
void Singleton::f7();{
        return "";
    }
    // Set up temporary
    std::string final=input;
    // Remove spaces at beginning
}
void Singleton::f8();{
            positions.push_back(pos);
        }
    }
    // At the end is always a marker
    positions.push_back((int)input.size());
}
void Singleton::f9();{
 * @return returns number of substrings
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
}
void Singleton::f10();{
    if(newPos < 0){
        if(doTrim){
			results.push_back(trim(input));
        } else {
            results.push_back(input);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f2();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f2();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f3();{
        return 0;
    }
    int numFound = 0;
    std::vector<int> positions;
    // At the begin is always a marker
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f2();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f3();{
        return 0;
    }
    int numFound = 0;
    std::vector<int> positions;
    // At the begin is always a marker
}
void Singleton::f4();{
void StringUtil::StrSub(std::string& cp, const std::string& sub_this, const std::string& for_this, const  int& num_times)
    int loc = 0;
    if (cp.empty())
    {
        cp = sub_this;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f2();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f3();{
        return 0;
    }
    int numFound = 0;
    std::vector<int> positions;
    // At the begin is always a marker
}
void Singleton::f4();{
void StringUtil::StrSub(std::string& cp, const std::string& sub_this, const std::string& for_this, const  int& num_times)
    int loc = 0;
    if (cp.empty())
    {
        cp = sub_this;
}
void Singleton::f5();{
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * Trim string
 * @param input  string to trim
 * @return returns trimmed string
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f2();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f3();{
        return 0;
    }
    int numFound = 0;
    std::vector<int> positions;
    // At the begin is always a marker
}
void Singleton::f4();{
void StringUtil::StrSub(std::string& cp, const std::string& sub_this, const std::string& for_this, const  int& num_times)
    int loc = 0;
    if (cp.empty())
    {
        cp = sub_this;
}
void Singleton::f5();{
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * Trim string
 * @param input  string to trim
 * @return returns trimmed string
}
void Singleton::f6();{
        std::string s;
        int start = positions[i] + sizeDelim;
        int size = positions[i+1] - positions[i] - sizeDelim;
        if(size > 0){
            s = input.substr(start, size);   
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f2();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f3();{
        return 0;
    }
    int numFound = 0;
    std::vector<int> positions;
    // At the begin is always a marker
}
void Singleton::f4();{
void StringUtil::StrSub(std::string& cp, const std::string& sub_this, const std::string& for_this, const  int& num_times)
    int loc = 0;
    if (cp.empty())
    {
        cp = sub_this;
}
void Singleton::f5();{
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * Trim string
 * @param input  string to trim
 * @return returns trimmed string
}
void Singleton::f6();{
        std::string s;
        int start = positions[i] + sizeDelim;
        int size = positions[i+1] - positions[i] - sizeDelim;
        if(size > 0){
            s = input.substr(start, size);   
}
void Singleton::f7();{
        return "";
    }
    // Set up temporary
    std::string final=input;
    // Remove spaces at beginning
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f2();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f3();{
        return 0;
    }
    int numFound = 0;
    std::vector<int> positions;
    // At the begin is always a marker
}
void Singleton::f4();{
void StringUtil::StrSub(std::string& cp, const std::string& sub_this, const std::string& for_this, const  int& num_times)
    int loc = 0;
    if (cp.empty())
    {
        cp = sub_this;
}
void Singleton::f5();{
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * Trim string
 * @param input  string to trim
 * @return returns trimmed string
}
void Singleton::f6();{
        std::string s;
        int start = positions[i] + sizeDelim;
        int size = positions[i+1] - positions[i] - sizeDelim;
        if(size > 0){
            s = input.substr(start, size);   
}
void Singleton::f7();{
        return "";
    }
    // Set up temporary
    std::string final=input;
    // Remove spaces at beginning
}
void Singleton::f8();{
            positions.push_back(pos);
        }
    }
    // At the end is always a marker
    positions.push_back((int)input.size());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f2();{
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
        if(doTrim){
}
void Singleton::f3();{
        return 0;
    }
    int numFound = 0;
    std::vector<int> positions;
    // At the begin is always a marker
}
void Singleton::f4();{
void StringUtil::StrSub(std::string& cp, const std::string& sub_this, const std::string& for_this, const  int& num_times)
    int loc = 0;
    if (cp.empty())
    {
        cp = sub_this;
}
void Singleton::f5();{
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * Trim string
 * @param input  string to trim
 * @return returns trimmed string
}
void Singleton::f6();{
        std::string s;
        int start = positions[i] + sizeDelim;
        int size = positions[i+1] - positions[i] - sizeDelim;
        if(size > 0){
            s = input.substr(start, size);   
}
void Singleton::f7();{
        return "";
    }
    // Set up temporary
    std::string final=input;
    // Remove spaces at beginning
}
void Singleton::f8();{
            positions.push_back(pos);
        }
    }
    // At the end is always a marker
    positions.push_back((int)input.size());
}
void Singleton::f9();{
 * @return returns number of substrings
int StringUtil::split(  std::string& input, const  std::string& delimiter, std::vector<std::string>& results, bool doTrim){
    int sizeDelim = (int)delimiter.size();
    int newPos = (int)input.find(delimiter, 0);
    if(newPos < 0){
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        parent_item = root_;
    else
        parent_item = static_cast<SupportedProtocolsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        parent_item = root_;
    else
        parent_item = static_cast<SupportedProtocolsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
}
void Singleton::f2();{
    return QVariant();
void SupportedProtocolsModel::populate()
    void *proto_cookie;
    void *field_cookie;
    emit beginResetModel();
}
void Singleton::f3();{
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum SupportedProtocolsColumn)section) {
        case colName:
            return tr("Name");
        case colFilter:
}
void Singleton::f4();{
    if (item == NULL)
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
}
void Singleton::f5();{
    root_(new SupportedProtocolsItem(NULL, NULL, NULL, FT_NONE, NULL, NULL)),
    field_count_(0)
SupportedProtocolsModel::~SupportedProtocolsModel()
    delete root_;
int SupportedProtocolsModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f6();{
            for (int row = 0; row < item->childCount(); row++)
            {
                child_item = item->child(row);
                if ((child_item != NULL) && (filterAcceptItem(*child_item)))
                    return true;
}
void Singleton::f7();{
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
        if (!nameIdx.parent().isValid())
}
void Singleton::f8();{
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
        if (!nameIdx.parent().isValid())
}
void Singleton::f9();{
    case colFilter:
        return item->filter();
    case colType:
        if (index.parent().isValid())
            return QString(ftype_pretty_name(item->type()));
}
void Singleton::f10();{
    return colLast;
QVariant SupportedProtocolsModel::headerData(int section, Qt::Orientation orientation, int role) const
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum SupportedProtocolsColumn)section) {
        case colName:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        parent_item = root_;
    else
        parent_item = static_cast<SupportedProtocolsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
}
void Singleton::f2();{
    return QVariant();
void SupportedProtocolsModel::populate()
    void *proto_cookie;
    void *field_cookie;
    emit beginResetModel();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        parent_item = root_;
    else
        parent_item = static_cast<SupportedProtocolsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
}
void Singleton::f2();{
    return QVariant();
void SupportedProtocolsModel::populate()
    void *proto_cookie;
    void *field_cookie;
    emit beginResetModel();
}
void Singleton::f3();{
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum SupportedProtocolsColumn)section) {
        case colName:
            return tr("Name");
        case colFilter:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        parent_item = root_;
    else
        parent_item = static_cast<SupportedProtocolsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
}
void Singleton::f2();{
    return QVariant();
void SupportedProtocolsModel::populate()
    void *proto_cookie;
    void *field_cookie;
    emit beginResetModel();
}
void Singleton::f3();{
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum SupportedProtocolsColumn)section) {
        case colName:
            return tr("Name");
        case colFilter:
}
void Singleton::f4();{
    if (item == NULL)
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        parent_item = root_;
    else
        parent_item = static_cast<SupportedProtocolsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
}
void Singleton::f2();{
    return QVariant();
void SupportedProtocolsModel::populate()
    void *proto_cookie;
    void *field_cookie;
    emit beginResetModel();
}
void Singleton::f3();{
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum SupportedProtocolsColumn)section) {
        case colName:
            return tr("Name");
        case colFilter:
}
void Singleton::f4();{
    if (item == NULL)
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
}
void Singleton::f5();{
    root_(new SupportedProtocolsItem(NULL, NULL, NULL, FT_NONE, NULL, NULL)),
    field_count_(0)
SupportedProtocolsModel::~SupportedProtocolsModel()
    delete root_;
int SupportedProtocolsModel::rowCount(const QModelIndex &parent) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        parent_item = root_;
    else
        parent_item = static_cast<SupportedProtocolsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
}
void Singleton::f2();{
    return QVariant();
void SupportedProtocolsModel::populate()
    void *proto_cookie;
    void *field_cookie;
    emit beginResetModel();
}
void Singleton::f3();{
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum SupportedProtocolsColumn)section) {
        case colName:
            return tr("Name");
        case colFilter:
}
void Singleton::f4();{
    if (item == NULL)
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
}
void Singleton::f5();{
    root_(new SupportedProtocolsItem(NULL, NULL, NULL, FT_NONE, NULL, NULL)),
    field_count_(0)
SupportedProtocolsModel::~SupportedProtocolsModel()
    delete root_;
int SupportedProtocolsModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f6();{
            for (int row = 0; row < item->childCount(); row++)
            {
                child_item = item->child(row);
                if ((child_item != NULL) && (filterAcceptItem(*child_item)))
                    return true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        parent_item = root_;
    else
        parent_item = static_cast<SupportedProtocolsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
}
void Singleton::f2();{
    return QVariant();
void SupportedProtocolsModel::populate()
    void *proto_cookie;
    void *field_cookie;
    emit beginResetModel();
}
void Singleton::f3();{
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum SupportedProtocolsColumn)section) {
        case colName:
            return tr("Name");
        case colFilter:
}
void Singleton::f4();{
    if (item == NULL)
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
}
void Singleton::f5();{
    root_(new SupportedProtocolsItem(NULL, NULL, NULL, FT_NONE, NULL, NULL)),
    field_count_(0)
SupportedProtocolsModel::~SupportedProtocolsModel()
    delete root_;
int SupportedProtocolsModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f6();{
            for (int row = 0; row < item->childCount(); row++)
            {
                child_item = item->child(row);
                if ((child_item != NULL) && (filterAcceptItem(*child_item)))
                    return true;
}
void Singleton::f7();{
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
        if (!nameIdx.parent().isValid())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        parent_item = root_;
    else
        parent_item = static_cast<SupportedProtocolsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
}
void Singleton::f2();{
    return QVariant();
void SupportedProtocolsModel::populate()
    void *proto_cookie;
    void *field_cookie;
    emit beginResetModel();
}
void Singleton::f3();{
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum SupportedProtocolsColumn)section) {
        case colName:
            return tr("Name");
        case colFilter:
}
void Singleton::f4();{
    if (item == NULL)
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
}
void Singleton::f5();{
    root_(new SupportedProtocolsItem(NULL, NULL, NULL, FT_NONE, NULL, NULL)),
    field_count_(0)
SupportedProtocolsModel::~SupportedProtocolsModel()
    delete root_;
int SupportedProtocolsModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f6();{
            for (int row = 0; row < item->childCount(); row++)
            {
                child_item = item->child(row);
                if ((child_item != NULL) && (filterAcceptItem(*child_item)))
                    return true;
}
void Singleton::f7();{
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
        if (!nameIdx.parent().isValid())
}
void Singleton::f8();{
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
        if (!nameIdx.parent().isValid())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        parent_item = root_;
    else
        parent_item = static_cast<SupportedProtocolsItem*>(parent.internalPointer());
    if (parent_item == NULL)
        return 0;
}
void Singleton::f2();{
    return QVariant();
void SupportedProtocolsModel::populate()
    void *proto_cookie;
    void *field_cookie;
    emit beginResetModel();
}
void Singleton::f3();{
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        switch ((enum SupportedProtocolsColumn)section) {
        case colName:
            return tr("Name");
        case colFilter:
}
void Singleton::f4();{
    if (item == NULL)
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
}
void Singleton::f5();{
    root_(new SupportedProtocolsItem(NULL, NULL, NULL, FT_NONE, NULL, NULL)),
    field_count_(0)
SupportedProtocolsModel::~SupportedProtocolsModel()
    delete root_;
int SupportedProtocolsModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f6();{
            for (int row = 0; row < item->childCount(); row++)
            {
                child_item = item->child(row);
                if ((child_item != NULL) && (filterAcceptItem(*child_item)))
                    return true;
}
void Singleton::f7();{
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
        if (!nameIdx.parent().isValid())
}
void Singleton::f8();{
        return true;
    if (!filter_.isEmpty()) {
        if (filterAcceptItem(*item))
            return true;
        if (!nameIdx.parent().isValid())
}
void Singleton::f9();{
    case colFilter:
        return item->filter();
    case colType:
        if (index.parent().isValid())
            return QString(ftype_pretty_name(item->type()));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    // Do nothing on bare shift.
    if ((event->modifiers() & Qt::ShiftModifier) && event->text().isEmpty()) return;
    if (event->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier)) {
        completer_->popup()->hide();
        return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    // Do nothing on bare shift.
    if ((event->modifiers() & Qt::ShiftModifier) && event->text().isEmpty()) return;
    if (event->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier)) {
        completer_->popup()->hide();
        return;
}
void Singleton::f2();{
            setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
}
void Singleton::f3();{
    QStyleOptionFrame opt;
    initStyleOption(&opt);
    QRect cr = style()->subElementRect(QStyle::SE_LineEditContents, &opt, this);
    QRect sir = QRect(0, 0, 14, 14); // QIcon::paint scales, which is not what we want.
    int textWidth = fontMetrics().boundingRect(text()).width();
}
void Singleton::f4();{
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
        g_free(err_msg);
    }
    dfilter_free(dfp);
}
void Singleton::f5();{
        setSyntaxState(SyntaxLineEdit::Empty);
        return;
    }
    bool ok;
    text().toInt(&ok);
}
void Singleton::f6();{
        return;
    }
    QRect cr = cursorRect();
    cr.setWidth(completer_->popup()->sizeHintForColumn(0)
                + completer_->popup()->verticalScrollBar()->sizeHint().width());
}
void Singleton::f7();{
        }
        if (depr) {
            // You keep using that word. I do not think it means what you think it means.
            // Possible alternatives: ::Troubled, or ::Problematic maybe?
            setSyntaxState(SyntaxLineEdit::Deprecated);
}
void Singleton::f8();{
        // instead of Qt::Key_AltGr and they tend to match the time display
        // format shortcuts.
        // Uncommenting the qDebug line below prints the following here:
        //
        // US Keyboard:
}
void Singleton::f9();{
    sir.moveRight(cr.right() - si_off);
    QPainter painter(this);
    painter.setOpacity(0.25);
    state_icon.paint(&painter, sir);
void SyntaxLineEdit::insertFieldCompletion(const QString &completion_text)
}
void Singleton::f10();{
    }
    // ...otherwise process the key ourselves.
    SyntaxLineEdit::keyPressEvent(event);
    if (!completer_ || !completion_model_ || !prefs.gui_autocomplete_filter) return;
    // Do nothing on bare shift.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    // Do nothing on bare shift.
    if ((event->modifiers() & Qt::ShiftModifier) && event->text().isEmpty()) return;
    if (event->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier)) {
        completer_->popup()->hide();
        return;
}
void Singleton::f2();{
            setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    // Do nothing on bare shift.
    if ((event->modifiers() & Qt::ShiftModifier) && event->text().isEmpty()) return;
    if (event->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier)) {
        completer_->popup()->hide();
        return;
}
void Singleton::f2();{
            setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
}
void Singleton::f3();{
    QStyleOptionFrame opt;
    initStyleOption(&opt);
    QRect cr = style()->subElementRect(QStyle::SE_LineEditContents, &opt, this);
    QRect sir = QRect(0, 0, 14, 14); // QIcon::paint scales, which is not what we want.
    int textWidth = fontMetrics().boundingRect(text()).width();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    // Do nothing on bare shift.
    if ((event->modifiers() & Qt::ShiftModifier) && event->text().isEmpty()) return;
    if (event->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier)) {
        completer_->popup()->hide();
        return;
}
void Singleton::f2();{
            setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
}
void Singleton::f3();{
    QStyleOptionFrame opt;
    initStyleOption(&opt);
    QRect cr = style()->subElementRect(QStyle::SE_LineEditContents, &opt, this);
    QRect sir = QRect(0, 0, 14, 14); // QIcon::paint scales, which is not what we want.
    int textWidth = fontMetrics().boundingRect(text()).width();
}
void Singleton::f4();{
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
        g_free(err_msg);
    }
    dfilter_free(dfp);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    // Do nothing on bare shift.
    if ((event->modifiers() & Qt::ShiftModifier) && event->text().isEmpty()) return;
    if (event->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier)) {
        completer_->popup()->hide();
        return;
}
void Singleton::f2();{
            setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
}
void Singleton::f3();{
    QStyleOptionFrame opt;
    initStyleOption(&opt);
    QRect cr = style()->subElementRect(QStyle::SE_LineEditContents, &opt, this);
    QRect sir = QRect(0, 0, 14, 14); // QIcon::paint scales, which is not what we want.
    int textWidth = fontMetrics().boundingRect(text()).width();
}
void Singleton::f4();{
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
        g_free(err_msg);
    }
    dfilter_free(dfp);
}
void Singleton::f5();{
        setSyntaxState(SyntaxLineEdit::Empty);
        return;
    }
    bool ok;
    text().toInt(&ok);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    // Do nothing on bare shift.
    if ((event->modifiers() & Qt::ShiftModifier) && event->text().isEmpty()) return;
    if (event->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier)) {
        completer_->popup()->hide();
        return;
}
void Singleton::f2();{
            setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
}
void Singleton::f3();{
    QStyleOptionFrame opt;
    initStyleOption(&opt);
    QRect cr = style()->subElementRect(QStyle::SE_LineEditContents, &opt, this);
    QRect sir = QRect(0, 0, 14, 14); // QIcon::paint scales, which is not what we want.
    int textWidth = fontMetrics().boundingRect(text()).width();
}
void Singleton::f4();{
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
        g_free(err_msg);
    }
    dfilter_free(dfp);
}
void Singleton::f5();{
        setSyntaxState(SyntaxLineEdit::Empty);
        return;
    }
    bool ok;
    text().toInt(&ok);
}
void Singleton::f6();{
        return;
    }
    QRect cr = cursorRect();
    cr.setWidth(completer_->popup()->sizeHintForColumn(0)
                + completer_->popup()->verticalScrollBar()->sizeHint().width());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    // Do nothing on bare shift.
    if ((event->modifiers() & Qt::ShiftModifier) && event->text().isEmpty()) return;
    if (event->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier)) {
        completer_->popup()->hide();
        return;
}
void Singleton::f2();{
            setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
}
void Singleton::f3();{
    QStyleOptionFrame opt;
    initStyleOption(&opt);
    QRect cr = style()->subElementRect(QStyle::SE_LineEditContents, &opt, this);
    QRect sir = QRect(0, 0, 14, 14); // QIcon::paint scales, which is not what we want.
    int textWidth = fontMetrics().boundingRect(text()).width();
}
void Singleton::f4();{
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
        g_free(err_msg);
    }
    dfilter_free(dfp);
}
void Singleton::f5();{
        setSyntaxState(SyntaxLineEdit::Empty);
        return;
    }
    bool ok;
    text().toInt(&ok);
}
void Singleton::f6();{
        return;
    }
    QRect cr = cursorRect();
    cr.setWidth(completer_->popup()->sizeHintForColumn(0)
                + completer_->popup()->verticalScrollBar()->sizeHint().width());
}
void Singleton::f7();{
        }
        if (depr) {
            // You keep using that word. I do not think it means what you think it means.
            // Possible alternatives: ::Troubled, or ::Problematic maybe?
            setSyntaxState(SyntaxLineEdit::Deprecated);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    // Do nothing on bare shift.
    if ((event->modifiers() & Qt::ShiftModifier) && event->text().isEmpty()) return;
    if (event->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier)) {
        completer_->popup()->hide();
        return;
}
void Singleton::f2();{
            setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
}
void Singleton::f3();{
    QStyleOptionFrame opt;
    initStyleOption(&opt);
    QRect cr = style()->subElementRect(QStyle::SE_LineEditContents, &opt, this);
    QRect sir = QRect(0, 0, 14, 14); // QIcon::paint scales, which is not what we want.
    int textWidth = fontMetrics().boundingRect(text()).width();
}
void Singleton::f4();{
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
        g_free(err_msg);
    }
    dfilter_free(dfp);
}
void Singleton::f5();{
        setSyntaxState(SyntaxLineEdit::Empty);
        return;
    }
    bool ok;
    text().toInt(&ok);
}
void Singleton::f6();{
        return;
    }
    QRect cr = cursorRect();
    cr.setWidth(completer_->popup()->sizeHintForColumn(0)
                + completer_->popup()->verticalScrollBar()->sizeHint().width());
}
void Singleton::f7();{
        }
        if (depr) {
            // You keep using that word. I do not think it means what you think it means.
            // Possible alternatives: ::Troubled, or ::Problematic maybe?
            setSyntaxState(SyntaxLineEdit::Deprecated);
}
void Singleton::f8();{
        // instead of Qt::Key_AltGr and they tend to match the time display
        // format shortcuts.
        // Uncommenting the qDebug line below prints the following here:
        //
        // US Keyboard:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    // Do nothing on bare shift.
    if ((event->modifiers() & Qt::ShiftModifier) && event->text().isEmpty()) return;
    if (event->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier)) {
        completer_->popup()->hide();
        return;
}
void Singleton::f2();{
            setSyntaxState(SyntaxLineEdit::Valid);
        }
    } else {
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
}
void Singleton::f3();{
    QStyleOptionFrame opt;
    initStyleOption(&opt);
    QRect cr = style()->subElementRect(QStyle::SE_LineEditContents, &opt, this);
    QRect sir = QRect(0, 0, 14, 14); // QIcon::paint scales, which is not what we want.
    int textWidth = fontMetrics().boundingRect(text()).width();
}
void Singleton::f4();{
        setSyntaxState(SyntaxLineEdit::Invalid);
        syntax_error_message_ = QString::fromUtf8(err_msg);
        g_free(err_msg);
    }
    dfilter_free(dfp);
}
void Singleton::f5();{
        setSyntaxState(SyntaxLineEdit::Empty);
        return;
    }
    bool ok;
    text().toInt(&ok);
}
void Singleton::f6();{
        return;
    }
    QRect cr = cursorRect();
    cr.setWidth(completer_->popup()->sizeHintForColumn(0)
                + completer_->popup()->verticalScrollBar()->sizeHint().width());
}
void Singleton::f7();{
        }
        if (depr) {
            // You keep using that word. I do not think it means what you think it means.
            // Possible alternatives: ::Troubled, or ::Problematic maybe?
            setSyntaxState(SyntaxLineEdit::Deprecated);
}
void Singleton::f8();{
        // instead of Qt::Key_AltGr and they tend to match the time display
        // format shortcuts.
        // Uncommenting the qDebug line below prints the following here:
        //
        // US Keyboard:
}
void Singleton::f9();{
    sir.moveRight(cr.right() - si_off);
    QPainter painter(this);
    painter.setOpacity(0.25);
    state_icon.paint(&painter, sir);
void SyntaxLineEdit::insertFieldCompletion(const QString &completion_text)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    ui_info.title = title.toUtf8().constData();
    ui_info.cli_string = cfg_abbr;
    ui_info.tap_init_cb = tap_init_cb;
    ui_info.nparams = 0; // We'll need this for SCSI SRT
    ui_info.params = NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    ui_info.title = title.toUtf8().constData();
    ui_info.cli_string = cfg_abbr;
    ui_info.tap_init_cb = tap_init_cb;
    ui_info.nparams = 0; // We'll need this for SCSI SRT
    ui_info.params = NULL;
}
void Singleton::f2();{
    ctx_menu_.insertMenu(insert_action, submenu);
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes(cur_action)) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
}
void Singleton::f3();{
        last_errno = errno;
        fclose(f);
    }
    if (!success) {
        QMessageBox::warning(this, tr("Error saving file %1").arg(file_name),
}
void Singleton::f4();{
QTreeWidget *TapParameterDialog::statsTreeWidget()
    return ui->statsTreeWidget;
QLineEdit *TapParameterDialog::displayFilterLineEdit()
    return ui->displayFilterLineEdit;
QPushButton *TapParameterDialog::applyFilterButton()
}
void Singleton::f5();{
            line = "<row>\n";
            foreach (QVariant var, tid) {
                QString entry = html_escape(var.toString());
                line.append(QString("  <entry>%1</entry>\n").arg(entry));
            }
}
void Singleton::f6();{
    bool af_enabled = ui->applyFilterButton->isEnabled();
    ui->displayFilterLineEdit->setEnabled(false);
    ui->applyFilterButton->setEnabled(false);
    fillTree();
    ui->applyFilterButton->setEnabled(af_enabled);
}
void Singleton::f7();{
                    col_widths.append(ui->statsTreeWidget->headerItem()->text(col).length());
                }
                QVariant var = ui->statsTreeWidget->headerItem()->data(col, Qt::DisplayRole);
                if (var.type() == QVariant::String) {
                    col_widths[col] = qMax(col_widths[col], itemDataToPlain(var).length());
}
void Singleton::f8();{
            line.append("</row>\n");
            break;
        }
        case ST_FORMAT_YAML:
        {
}
void Singleton::f9();{
    // If we wanted to be fancy we could add an isRetapping function to
    // either WiresharkDialog or CaptureFile and use it in updateWidgets
    // to enable and disable the apply button as needed.
    // For now we use more simple but less useful logic.
    bool df_enabled = ui->displayFilterLineEdit->isEnabled();
}
void Singleton::f10();{
    switch (format) {
    case ST_FORMAT_PLAIN:
    {
        // Iterating over trees.
        QTreeWidgetItemIterator width_it(it);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    ui_info.title = title.toUtf8().constData();
    ui_info.cli_string = cfg_abbr;
    ui_info.tap_init_cb = tap_init_cb;
    ui_info.nparams = 0; // We'll need this for SCSI SRT
    ui_info.params = NULL;
}
void Singleton::f2();{
    ctx_menu_.insertMenu(insert_action, submenu);
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes(cur_action)) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    ui_info.title = title.toUtf8().constData();
    ui_info.cli_string = cfg_abbr;
    ui_info.tap_init_cb = tap_init_cb;
    ui_info.nparams = 0; // We'll need this for SCSI SRT
    ui_info.params = NULL;
}
void Singleton::f2();{
    ctx_menu_.insertMenu(insert_action, submenu);
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes(cur_action)) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
}
void Singleton::f3();{
        last_errno = errno;
        fclose(f);
    }
    if (!success) {
        QMessageBox::warning(this, tr("Error saving file %1").arg(file_name),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    ui_info.title = title.toUtf8().constData();
    ui_info.cli_string = cfg_abbr;
    ui_info.tap_init_cb = tap_init_cb;
    ui_info.nparams = 0; // We'll need this for SCSI SRT
    ui_info.params = NULL;
}
void Singleton::f2();{
    ctx_menu_.insertMenu(insert_action, submenu);
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes(cur_action)) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
}
void Singleton::f3();{
        last_errno = errno;
        fclose(f);
    }
    if (!success) {
        QMessageBox::warning(this, tr("Error saving file %1").arg(file_name),
}
void Singleton::f4();{
QTreeWidget *TapParameterDialog::statsTreeWidget()
    return ui->statsTreeWidget;
QLineEdit *TapParameterDialog::displayFilterLineEdit()
    return ui->displayFilterLineEdit;
QPushButton *TapParameterDialog::applyFilterButton()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    ui_info.title = title.toUtf8().constData();
    ui_info.cli_string = cfg_abbr;
    ui_info.tap_init_cb = tap_init_cb;
    ui_info.nparams = 0; // We'll need this for SCSI SRT
    ui_info.params = NULL;
}
void Singleton::f2();{
    ctx_menu_.insertMenu(insert_action, submenu);
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes(cur_action)) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
}
void Singleton::f3();{
        last_errno = errno;
        fclose(f);
    }
    if (!success) {
        QMessageBox::warning(this, tr("Error saving file %1").arg(file_name),
}
void Singleton::f4();{
QTreeWidget *TapParameterDialog::statsTreeWidget()
    return ui->statsTreeWidget;
QLineEdit *TapParameterDialog::displayFilterLineEdit()
    return ui->displayFilterLineEdit;
QPushButton *TapParameterDialog::applyFilterButton()
}
void Singleton::f5();{
            line = "<row>\n";
            foreach (QVariant var, tid) {
                QString entry = html_escape(var.toString());
                line.append(QString("  <entry>%1</entry>\n").arg(entry));
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    ui_info.title = title.toUtf8().constData();
    ui_info.cli_string = cfg_abbr;
    ui_info.tap_init_cb = tap_init_cb;
    ui_info.nparams = 0; // We'll need this for SCSI SRT
    ui_info.params = NULL;
}
void Singleton::f2();{
    ctx_menu_.insertMenu(insert_action, submenu);
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes(cur_action)) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
}
void Singleton::f3();{
        last_errno = errno;
        fclose(f);
    }
    if (!success) {
        QMessageBox::warning(this, tr("Error saving file %1").arg(file_name),
}
void Singleton::f4();{
QTreeWidget *TapParameterDialog::statsTreeWidget()
    return ui->statsTreeWidget;
QLineEdit *TapParameterDialog::displayFilterLineEdit()
    return ui->displayFilterLineEdit;
QPushButton *TapParameterDialog::applyFilterButton()
}
void Singleton::f5();{
            line = "<row>\n";
            foreach (QVariant var, tid) {
                QString entry = html_escape(var.toString());
                line.append(QString("  <entry>%1</entry>\n").arg(entry));
            }
}
void Singleton::f6();{
    bool af_enabled = ui->applyFilterButton->isEnabled();
    ui->displayFilterLineEdit->setEnabled(false);
    ui->applyFilterButton->setEnabled(false);
    fillTree();
    ui->applyFilterButton->setEnabled(af_enabled);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    ui_info.title = title.toUtf8().constData();
    ui_info.cli_string = cfg_abbr;
    ui_info.tap_init_cb = tap_init_cb;
    ui_info.nparams = 0; // We'll need this for SCSI SRT
    ui_info.params = NULL;
}
void Singleton::f2();{
    ctx_menu_.insertMenu(insert_action, submenu);
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes(cur_action)) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
}
void Singleton::f3();{
        last_errno = errno;
        fclose(f);
    }
    if (!success) {
        QMessageBox::warning(this, tr("Error saving file %1").arg(file_name),
}
void Singleton::f4();{
QTreeWidget *TapParameterDialog::statsTreeWidget()
    return ui->statsTreeWidget;
QLineEdit *TapParameterDialog::displayFilterLineEdit()
    return ui->displayFilterLineEdit;
QPushButton *TapParameterDialog::applyFilterButton()
}
void Singleton::f5();{
            line = "<row>\n";
            foreach (QVariant var, tid) {
                QString entry = html_escape(var.toString());
                line.append(QString("  <entry>%1</entry>\n").arg(entry));
            }
}
void Singleton::f6();{
    bool af_enabled = ui->applyFilterButton->isEnabled();
    ui->displayFilterLineEdit->setEnabled(false);
    ui->applyFilterButton->setEnabled(false);
    fillTree();
    ui->applyFilterButton->setEnabled(af_enabled);
}
void Singleton::f7();{
                    col_widths.append(ui->statsTreeWidget->headerItem()->text(col).length());
                }
                QVariant var = ui->statsTreeWidget->headerItem()->data(col, Qt::DisplayRole);
                if (var.type() == QVariant::String) {
                    col_widths[col] = qMax(col_widths[col], itemDataToPlain(var).length());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    ui_info.title = title.toUtf8().constData();
    ui_info.cli_string = cfg_abbr;
    ui_info.tap_init_cb = tap_init_cb;
    ui_info.nparams = 0; // We'll need this for SCSI SRT
    ui_info.params = NULL;
}
void Singleton::f2();{
    ctx_menu_.insertMenu(insert_action, submenu);
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes(cur_action)) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
}
void Singleton::f3();{
        last_errno = errno;
        fclose(f);
    }
    if (!success) {
        QMessageBox::warning(this, tr("Error saving file %1").arg(file_name),
}
void Singleton::f4();{
QTreeWidget *TapParameterDialog::statsTreeWidget()
    return ui->statsTreeWidget;
QLineEdit *TapParameterDialog::displayFilterLineEdit()
    return ui->displayFilterLineEdit;
QPushButton *TapParameterDialog::applyFilterButton()
}
void Singleton::f5();{
            line = "<row>\n";
            foreach (QVariant var, tid) {
                QString entry = html_escape(var.toString());
                line.append(QString("  <entry>%1</entry>\n").arg(entry));
            }
}
void Singleton::f6();{
    bool af_enabled = ui->applyFilterButton->isEnabled();
    ui->displayFilterLineEdit->setEnabled(false);
    ui->applyFilterButton->setEnabled(false);
    fillTree();
    ui->applyFilterButton->setEnabled(af_enabled);
}
void Singleton::f7();{
                    col_widths.append(ui->statsTreeWidget->headerItem()->text(col).length());
                }
                QVariant var = ui->statsTreeWidget->headerItem()->data(col, Qt::DisplayRole);
                if (var.type() == QVariant::String) {
                    col_widths[col] = qMax(col_widths[col], itemDataToPlain(var).length());
}
void Singleton::f8();{
            line.append("</row>\n");
            break;
        }
        case ST_FORMAT_YAML:
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    ui_info.title = title.toUtf8().constData();
    ui_info.cli_string = cfg_abbr;
    ui_info.tap_init_cb = tap_init_cb;
    ui_info.nparams = 0; // We'll need this for SCSI SRT
    ui_info.params = NULL;
}
void Singleton::f2();{
    ctx_menu_.insertMenu(insert_action, submenu);
    cur_action = FilterAction::ActionColorize;
    submenu = ctx_menu_.addMenu(FilterAction::actionName(cur_action));
    foreach (FilterAction::ActionType at, FilterAction::actionTypes(cur_action)) {
        FilterAction *fa = new FilterAction(submenu, cur_action, at);
}
void Singleton::f3();{
        last_errno = errno;
        fclose(f);
    }
    if (!success) {
        QMessageBox::warning(this, tr("Error saving file %1").arg(file_name),
}
void Singleton::f4();{
QTreeWidget *TapParameterDialog::statsTreeWidget()
    return ui->statsTreeWidget;
QLineEdit *TapParameterDialog::displayFilterLineEdit()
    return ui->displayFilterLineEdit;
QPushButton *TapParameterDialog::applyFilterButton()
}
void Singleton::f5();{
            line = "<row>\n";
            foreach (QVariant var, tid) {
                QString entry = html_escape(var.toString());
                line.append(QString("  <entry>%1</entry>\n").arg(entry));
            }
}
void Singleton::f6();{
    bool af_enabled = ui->applyFilterButton->isEnabled();
    ui->displayFilterLineEdit->setEnabled(false);
    ui->applyFilterButton->setEnabled(false);
    fillTree();
    ui->applyFilterButton->setEnabled(af_enabled);
}
void Singleton::f7();{
                    col_widths.append(ui->statsTreeWidget->headerItem()->text(col).length());
                }
                QVariant var = ui->statsTreeWidget->headerItem()->data(col, Qt::DisplayRole);
                if (var.type() == QVariant::String) {
                    col_widths[col] = qMax(col_widths[col], itemDataToPlain(var).length());
}
void Singleton::f8();{
            line.append("</row>\n");
            break;
        }
        case ST_FORMAT_YAML:
        {
}
void Singleton::f9();{
    // If we wanted to be fancy we could add an isRetapping function to
    // either WiresharkDialog or CaptureFile and use it in updateWidgets
    // to enable and disable the apply button as needed.
    // For now we use more simple but less useful logic.
    bool df_enabled = ui->displayFilterLineEdit->isEnabled();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        // next_new:
        //                         [-------------)
        // next_old:
        //  2.             [-------)
        //  3.             [----------------)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        // next_new:
        //                         [-------------)
        // next_old:
        //  2.             [-------)
        //  3.             [----------------)
}
void Singleton::f2();{
    reset_axes_ = (reset_axes_ || reset_axes);
    graph_update_timer_->start(timeout);
void TCPStreamDialog::GraphUpdater::clearPendingUpdate()
    if (hasPendingUpdate()) {
        if (graph_update_timer_->isActive())
}
void Singleton::f3();{
    //  [ NOTE - this is because they assume that there's old data that they
    //      don't have access to - but in our case we know that there's NO
    //      data prior to the first packet in the stream - so it's fine to
    //      spit out the MA immediately... ]
    // The Rosetta Code MA examples start spitting out values immediately.
}
void Singleton::f4();{
    // to incorporate SACKED segments into goodput calculation,
    //   need to keep track of all the SACK blocks we haven't yet
    //   fully ACKed.
    sack_list_t old_sacks, new_sacks;
    new_sacks.reserve(MAX_TCP_SACK_RANGES);
}
void Singleton::f5();{
        tracer_->setGraph(base_graph_);
    // XXX QCustomPlot doesn't seem to draw any sort of focus indicator.
    if (set_focus)
        sp->setFocus();
void TCPStreamDialog::showWidgetsForGraphType()
}
void Singleton::f6();{
        sack_t* next_new = &new_sacks[next_new_idx];
        *seglen += (next_new->second - next_new->first);
        old_sacks.push_back(*next_new);
        ++next_new_idx;
    }
}
void Singleton::f7();{
                x_vals.append(cur->seqno);
            } else {
                x_vals.append(cur->time);
            }
            rtt.append((rt_val - cur->time) * 1000.0);
}
void Singleton::f8();{
    case Qt::Key_I:             // GTK+
        zoomAxes(true);
        break;
    case Qt::Key_X:             // Zoom X axis only
        if (event->modifiers() & Qt::ShiftModifier) {
}
void Singleton::f9();{
        //   there are only a few possible relative configurations
        //   of next_old and next_new:
        // next_new:
        //                         [-------------)
        // next_old:
}
void Singleton::f10();{
    if (spin_box_focused)
        ui->streamNumberSpinBox->clearFocus();
    ui->streamNumberSpinBox->setEnabled(false);
    graph_segment_list_free(&graph_);
    graph_segment_list_get(cap_file_, &graph_);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        // next_new:
        //                         [-------------)
        // next_old:
        //  2.             [-------)
        //  3.             [----------------)
}
void Singleton::f2();{
    reset_axes_ = (reset_axes_ || reset_axes);
    graph_update_timer_->start(timeout);
void TCPStreamDialog::GraphUpdater::clearPendingUpdate()
    if (hasPendingUpdate()) {
        if (graph_update_timer_->isActive())
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        // next_new:
        //                         [-------------)
        // next_old:
        //  2.             [-------)
        //  3.             [----------------)
}
void Singleton::f2();{
    reset_axes_ = (reset_axes_ || reset_axes);
    graph_update_timer_->start(timeout);
void TCPStreamDialog::GraphUpdater::clearPendingUpdate()
    if (hasPendingUpdate()) {
        if (graph_update_timer_->isActive())
}
void Singleton::f3();{
    //  [ NOTE - this is because they assume that there's old data that they
    //      don't have access to - but in our case we know that there's NO
    //      data prior to the first packet in the stream - so it's fine to
    //      spit out the MA immediately... ]
    // The Rosetta Code MA examples start spitting out values immediately.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        // next_new:
        //                         [-------------)
        // next_old:
        //  2.             [-------)
        //  3.             [----------------)
}
void Singleton::f2();{
    reset_axes_ = (reset_axes_ || reset_axes);
    graph_update_timer_->start(timeout);
void TCPStreamDialog::GraphUpdater::clearPendingUpdate()
    if (hasPendingUpdate()) {
        if (graph_update_timer_->isActive())
}
void Singleton::f3();{
    //  [ NOTE - this is because they assume that there's old data that they
    //      don't have access to - but in our case we know that there's NO
    //      data prior to the first packet in the stream - so it's fine to
    //      spit out the MA immediately... ]
    // The Rosetta Code MA examples start spitting out values immediately.
}
void Singleton::f4();{
    // to incorporate SACKED segments into goodput calculation,
    //   need to keep track of all the SACK blocks we haven't yet
    //   fully ACKed.
    sack_list_t old_sacks, new_sacks;
    new_sacks.reserve(MAX_TCP_SACK_RANGES);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        // next_new:
        //                         [-------------)
        // next_old:
        //  2.             [-------)
        //  3.             [----------------)
}
void Singleton::f2();{
    reset_axes_ = (reset_axes_ || reset_axes);
    graph_update_timer_->start(timeout);
void TCPStreamDialog::GraphUpdater::clearPendingUpdate()
    if (hasPendingUpdate()) {
        if (graph_update_timer_->isActive())
}
void Singleton::f3();{
    //  [ NOTE - this is because they assume that there's old data that they
    //      don't have access to - but in our case we know that there's NO
    //      data prior to the first packet in the stream - so it's fine to
    //      spit out the MA immediately... ]
    // The Rosetta Code MA examples start spitting out values immediately.
}
void Singleton::f4();{
    // to incorporate SACKED segments into goodput calculation,
    //   need to keep track of all the SACK blocks we haven't yet
    //   fully ACKed.
    sack_list_t old_sacks, new_sacks;
    new_sacks.reserve(MAX_TCP_SACK_RANGES);
}
void Singleton::f5();{
        tracer_->setGraph(base_graph_);
    // XXX QCustomPlot doesn't seem to draw any sort of focus indicator.
    if (set_focus)
        sp->setFocus();
void TCPStreamDialog::showWidgetsForGraphType()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        // next_new:
        //                         [-------------)
        // next_old:
        //  2.             [-------)
        //  3.             [----------------)
}
void Singleton::f2();{
    reset_axes_ = (reset_axes_ || reset_axes);
    graph_update_timer_->start(timeout);
void TCPStreamDialog::GraphUpdater::clearPendingUpdate()
    if (hasPendingUpdate()) {
        if (graph_update_timer_->isActive())
}
void Singleton::f3();{
    //  [ NOTE - this is because they assume that there's old data that they
    //      don't have access to - but in our case we know that there's NO
    //      data prior to the first packet in the stream - so it's fine to
    //      spit out the MA immediately... ]
    // The Rosetta Code MA examples start spitting out values immediately.
}
void Singleton::f4();{
    // to incorporate SACKED segments into goodput calculation,
    //   need to keep track of all the SACK blocks we haven't yet
    //   fully ACKed.
    sack_list_t old_sacks, new_sacks;
    new_sacks.reserve(MAX_TCP_SACK_RANGES);
}
void Singleton::f5();{
        tracer_->setGraph(base_graph_);
    // XXX QCustomPlot doesn't seem to draw any sort of focus indicator.
    if (set_focus)
        sp->setFocus();
void TCPStreamDialog::showWidgetsForGraphType()
}
void Singleton::f6();{
        sack_t* next_new = &new_sacks[next_new_idx];
        *seglen += (next_new->second - next_new->first);
        old_sacks.push_back(*next_new);
        ++next_new_idx;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        // next_new:
        //                         [-------------)
        // next_old:
        //  2.             [-------)
        //  3.             [----------------)
}
void Singleton::f2();{
    reset_axes_ = (reset_axes_ || reset_axes);
    graph_update_timer_->start(timeout);
void TCPStreamDialog::GraphUpdater::clearPendingUpdate()
    if (hasPendingUpdate()) {
        if (graph_update_timer_->isActive())
}
void Singleton::f3();{
    //  [ NOTE - this is because they assume that there's old data that they
    //      don't have access to - but in our case we know that there's NO
    //      data prior to the first packet in the stream - so it's fine to
    //      spit out the MA immediately... ]
    // The Rosetta Code MA examples start spitting out values immediately.
}
void Singleton::f4();{
    // to incorporate SACKED segments into goodput calculation,
    //   need to keep track of all the SACK blocks we haven't yet
    //   fully ACKed.
    sack_list_t old_sacks, new_sacks;
    new_sacks.reserve(MAX_TCP_SACK_RANGES);
}
void Singleton::f5();{
        tracer_->setGraph(base_graph_);
    // XXX QCustomPlot doesn't seem to draw any sort of focus indicator.
    if (set_focus)
        sp->setFocus();
void TCPStreamDialog::showWidgetsForGraphType()
}
void Singleton::f6();{
        sack_t* next_new = &new_sacks[next_new_idx];
        *seglen += (next_new->second - next_new->first);
        old_sacks.push_back(*next_new);
        ++next_new_idx;
    }
}
void Singleton::f7();{
                x_vals.append(cur->seqno);
            } else {
                x_vals.append(cur->time);
            }
            rtt.append((rt_val - cur->time) * 1000.0);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        // next_new:
        //                         [-------------)
        // next_old:
        //  2.             [-------)
        //  3.             [----------------)
}
void Singleton::f2();{
    reset_axes_ = (reset_axes_ || reset_axes);
    graph_update_timer_->start(timeout);
void TCPStreamDialog::GraphUpdater::clearPendingUpdate()
    if (hasPendingUpdate()) {
        if (graph_update_timer_->isActive())
}
void Singleton::f3();{
    //  [ NOTE - this is because they assume that there's old data that they
    //      don't have access to - but in our case we know that there's NO
    //      data prior to the first packet in the stream - so it's fine to
    //      spit out the MA immediately... ]
    // The Rosetta Code MA examples start spitting out values immediately.
}
void Singleton::f4();{
    // to incorporate SACKED segments into goodput calculation,
    //   need to keep track of all the SACK blocks we haven't yet
    //   fully ACKed.
    sack_list_t old_sacks, new_sacks;
    new_sacks.reserve(MAX_TCP_SACK_RANGES);
}
void Singleton::f5();{
        tracer_->setGraph(base_graph_);
    // XXX QCustomPlot doesn't seem to draw any sort of focus indicator.
    if (set_focus)
        sp->setFocus();
void TCPStreamDialog::showWidgetsForGraphType()
}
void Singleton::f6();{
        sack_t* next_new = &new_sacks[next_new_idx];
        *seglen += (next_new->second - next_new->first);
        old_sacks.push_back(*next_new);
        ++next_new_idx;
    }
}
void Singleton::f7();{
                x_vals.append(cur->seqno);
            } else {
                x_vals.append(cur->time);
            }
            rtt.append((rt_val - cur->time) * 1000.0);
}
void Singleton::f8();{
    case Qt::Key_I:             // GTK+
        zoomAxes(true);
        break;
    case Qt::Key_X:             // Zoom X axis only
        if (event->modifiers() & Qt::ShiftModifier) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        // next_new:
        //                         [-------------)
        // next_old:
        //  2.             [-------)
        //  3.             [----------------)
}
void Singleton::f2();{
    reset_axes_ = (reset_axes_ || reset_axes);
    graph_update_timer_->start(timeout);
void TCPStreamDialog::GraphUpdater::clearPendingUpdate()
    if (hasPendingUpdate()) {
        if (graph_update_timer_->isActive())
}
void Singleton::f3();{
    //  [ NOTE - this is because they assume that there's old data that they
    //      don't have access to - but in our case we know that there's NO
    //      data prior to the first packet in the stream - so it's fine to
    //      spit out the MA immediately... ]
    // The Rosetta Code MA examples start spitting out values immediately.
}
void Singleton::f4();{
    // to incorporate SACKED segments into goodput calculation,
    //   need to keep track of all the SACK blocks we haven't yet
    //   fully ACKed.
    sack_list_t old_sacks, new_sacks;
    new_sacks.reserve(MAX_TCP_SACK_RANGES);
}
void Singleton::f5();{
        tracer_->setGraph(base_graph_);
    // XXX QCustomPlot doesn't seem to draw any sort of focus indicator.
    if (set_focus)
        sp->setFocus();
void TCPStreamDialog::showWidgetsForGraphType()
}
void Singleton::f6();{
        sack_t* next_new = &new_sacks[next_new_idx];
        *seglen += (next_new->second - next_new->first);
        old_sacks.push_back(*next_new);
        ++next_new_idx;
    }
}
void Singleton::f7();{
                x_vals.append(cur->seqno);
            } else {
                x_vals.append(cur->time);
            }
            rtt.append((rt_val - cur->time) * 1000.0);
}
void Singleton::f8();{
    case Qt::Key_I:             // GTK+
        zoomAxes(true);
        break;
    case Qt::Key_X:             // Zoom X axis only
        if (event->modifiers() & Qt::ShiftModifier) {
}
void Singleton::f9();{
        //   there are only a few possible relative configurations
        //   of next_old and next_new:
        // next_new:
        //                         [-------------)
        // next_old:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
		// the following line was replaced by the auto_ptr
		// char* buffer = new char[len];
		// read in all the file
        inFile.read(buffer.get(), len);
        
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
		// the following line was replaced by the auto_ptr
		// char* buffer = new char[len];
		// read in all the file
        inFile.read(buffer.get(), len);
        
}
void Singleton::f2();{
		// this is done since the file might have been opened and not closed before
		inFile.seekg(0, std::ios::beg);
        
		// autopointer for the buffer with the characters
		std::auto_ptr<char> buffer (new char[len]);
}
void Singleton::f3();{
		// get the position of the file position pointer
		unsigned int len = (unsigned int) inFile.tellg();
        
		// reset the position to the beginning of the file
		// this is done since the file might have been opened and not closed before
}
void Singleton::f4();{
    m_fileName(fileName)
/** 
 * Reads the whole text file into a std::string.
 * @param all - reference to the string with all lines
 * @return true if successful, false otherwise
}
void Singleton::f5();{
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
}
void Singleton::f6();{
						 std::ios::in|std::ios::binary|std::ios::ate);
    
	// declare the output stream for the string stream reader
	std::ostringstream os;
        
}
void Singleton::f7();{
    return true;
bool TextFile::readLines(std::vector<std::string>& lines, bool doTrim){
	std::string list;
	if(readAll(list)){
		StringUtil::substitute('\r', ' ', list);
}
void Singleton::f8();{
	if(readAll(list)){
		StringUtil::substitute('\r', ' ', list);
		StringUtil::substitute('\t', ' ', list);
		StringUtil::split(list, "\n", lines, doTrim);
	} else {
}
void Singleton::f9();{
		// using auto_ptr, no need to delete the pointer then
		// delete[] buffer;
        
		all = os.str();
		// get the number of lines in the file
}
void Singleton::f10();{
		return false;	
	return true;
/** 
 * Writes a std::string into a text file.
 * @param all - string to wrint out to the file
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
		// the following line was replaced by the auto_ptr
		// char* buffer = new char[len];
		// read in all the file
        inFile.read(buffer.get(), len);
        
}
void Singleton::f2();{
		// this is done since the file might have been opened and not closed before
		inFile.seekg(0, std::ios::beg);
        
		// autopointer for the buffer with the characters
		std::auto_ptr<char> buffer (new char[len]);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
		// the following line was replaced by the auto_ptr
		// char* buffer = new char[len];
		// read in all the file
        inFile.read(buffer.get(), len);
        
}
void Singleton::f2();{
		// this is done since the file might have been opened and not closed before
		inFile.seekg(0, std::ios::beg);
        
		// autopointer for the buffer with the characters
		std::auto_ptr<char> buffer (new char[len]);
}
void Singleton::f3();{
		// get the position of the file position pointer
		unsigned int len = (unsigned int) inFile.tellg();
        
		// reset the position to the beginning of the file
		// this is done since the file might have been opened and not closed before
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
		// the following line was replaced by the auto_ptr
		// char* buffer = new char[len];
		// read in all the file
        inFile.read(buffer.get(), len);
        
}
void Singleton::f2();{
		// this is done since the file might have been opened and not closed before
		inFile.seekg(0, std::ios::beg);
        
		// autopointer for the buffer with the characters
		std::auto_ptr<char> buffer (new char[len]);
}
void Singleton::f3();{
		// get the position of the file position pointer
		unsigned int len = (unsigned int) inFile.tellg();
        
		// reset the position to the beginning of the file
		// this is done since the file might have been opened and not closed before
}
void Singleton::f4();{
    m_fileName(fileName)
/** 
 * Reads the whole text file into a std::string.
 * @param all - reference to the string with all lines
 * @return true if successful, false otherwise
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
		// the following line was replaced by the auto_ptr
		// char* buffer = new char[len];
		// read in all the file
        inFile.read(buffer.get(), len);
        
}
void Singleton::f2();{
		// this is done since the file might have been opened and not closed before
		inFile.seekg(0, std::ios::beg);
        
		// autopointer for the buffer with the characters
		std::auto_ptr<char> buffer (new char[len]);
}
void Singleton::f3();{
		// get the position of the file position pointer
		unsigned int len = (unsigned int) inFile.tellg();
        
		// reset the position to the beginning of the file
		// this is done since the file might have been opened and not closed before
}
void Singleton::f4();{
    m_fileName(fileName)
/** 
 * Reads the whole text file into a std::string.
 * @param all - reference to the string with all lines
 * @return true if successful, false otherwise
}
void Singleton::f5();{
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
		// the following line was replaced by the auto_ptr
		// char* buffer = new char[len];
		// read in all the file
        inFile.read(buffer.get(), len);
        
}
void Singleton::f2();{
		// this is done since the file might have been opened and not closed before
		inFile.seekg(0, std::ios::beg);
        
		// autopointer for the buffer with the characters
		std::auto_ptr<char> buffer (new char[len]);
}
void Singleton::f3();{
		// get the position of the file position pointer
		unsigned int len = (unsigned int) inFile.tellg();
        
		// reset the position to the beginning of the file
		// this is done since the file might have been opened and not closed before
}
void Singleton::f4();{
    m_fileName(fileName)
/** 
 * Reads the whole text file into a std::string.
 * @param all - reference to the string with all lines
 * @return true if successful, false otherwise
}
void Singleton::f5();{
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
}
void Singleton::f6();{
						 std::ios::in|std::ios::binary|std::ios::ate);
    
	// declare the output stream for the string stream reader
	std::ostringstream os;
        
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
		// the following line was replaced by the auto_ptr
		// char* buffer = new char[len];
		// read in all the file
        inFile.read(buffer.get(), len);
        
}
void Singleton::f2();{
		// this is done since the file might have been opened and not closed before
		inFile.seekg(0, std::ios::beg);
        
		// autopointer for the buffer with the characters
		std::auto_ptr<char> buffer (new char[len]);
}
void Singleton::f3();{
		// get the position of the file position pointer
		unsigned int len = (unsigned int) inFile.tellg();
        
		// reset the position to the beginning of the file
		// this is done since the file might have been opened and not closed before
}
void Singleton::f4();{
    m_fileName(fileName)
/** 
 * Reads the whole text file into a std::string.
 * @param all - reference to the string with all lines
 * @return true if successful, false otherwise
}
void Singleton::f5();{
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
}
void Singleton::f6();{
						 std::ios::in|std::ios::binary|std::ios::ate);
    
	// declare the output stream for the string stream reader
	std::ostringstream os;
        
}
void Singleton::f7();{
    return true;
bool TextFile::readLines(std::vector<std::string>& lines, bool doTrim){
	std::string list;
	if(readAll(list)){
		StringUtil::substitute('\r', ' ', list);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
		// the following line was replaced by the auto_ptr
		// char* buffer = new char[len];
		// read in all the file
        inFile.read(buffer.get(), len);
        
}
void Singleton::f2();{
		// this is done since the file might have been opened and not closed before
		inFile.seekg(0, std::ios::beg);
        
		// autopointer for the buffer with the characters
		std::auto_ptr<char> buffer (new char[len]);
}
void Singleton::f3();{
		// get the position of the file position pointer
		unsigned int len = (unsigned int) inFile.tellg();
        
		// reset the position to the beginning of the file
		// this is done since the file might have been opened and not closed before
}
void Singleton::f4();{
    m_fileName(fileName)
/** 
 * Reads the whole text file into a std::string.
 * @param all - reference to the string with all lines
 * @return true if successful, false otherwise
}
void Singleton::f5();{
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
}
void Singleton::f6();{
						 std::ios::in|std::ios::binary|std::ios::ate);
    
	// declare the output stream for the string stream reader
	std::ostringstream os;
        
}
void Singleton::f7();{
    return true;
bool TextFile::readLines(std::vector<std::string>& lines, bool doTrim){
	std::string list;
	if(readAll(list)){
		StringUtil::substitute('\r', ' ', list);
}
void Singleton::f8();{
	if(readAll(list)){
		StringUtil::substitute('\r', ' ', list);
		StringUtil::substitute('\t', ' ', list);
		StringUtil::split(list, "\n", lines, doTrim);
	} else {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
		// the following line was replaced by the auto_ptr
		// char* buffer = new char[len];
		// read in all the file
        inFile.read(buffer.get(), len);
        
}
void Singleton::f2();{
		// this is done since the file might have been opened and not closed before
		inFile.seekg(0, std::ios::beg);
        
		// autopointer for the buffer with the characters
		std::auto_ptr<char> buffer (new char[len]);
}
void Singleton::f3();{
		// get the position of the file position pointer
		unsigned int len = (unsigned int) inFile.tellg();
        
		// reset the position to the beginning of the file
		// this is done since the file might have been opened and not closed before
}
void Singleton::f4();{
    m_fileName(fileName)
/** 
 * Reads the whole text file into a std::string.
 * @param all - reference to the string with all lines
 * @return true if successful, false otherwise
}
void Singleton::f5();{
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
}
void Singleton::f6();{
						 std::ios::in|std::ios::binary|std::ios::ate);
    
	// declare the output stream for the string stream reader
	std::ostringstream os;
        
}
void Singleton::f7();{
    return true;
bool TextFile::readLines(std::vector<std::string>& lines, bool doTrim){
	std::string list;
	if(readAll(list)){
		StringUtil::substitute('\r', ' ', list);
}
void Singleton::f8();{
	if(readAll(list)){
		StringUtil::substitute('\r', ' ', list);
		StringUtil::substitute('\t', ' ', list);
		StringUtil::split(list, "\n", lines, doTrim);
	} else {
}
void Singleton::f9();{
		// using auto_ptr, no need to delete the pointer then
		// delete[] buffer;
        
		all = os.str();
		// get the number of lines in the file
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    checkDateTime(*ts_ui_->setTwoTimeLineEdit);
    if (ts_ui_->setTwoCheckBox->isEnabled())
        ts_ui_->setTwoCheckBox->setChecked(true);
    enableWidgets();
void TimeShiftDialog::applyTimeShift()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    checkDateTime(*ts_ui_->setTwoTimeLineEdit);
    if (ts_ui_->setTwoCheckBox->isEnabled())
        ts_ui_->setTwoCheckBox->setChecked(true);
    enableWidgets();
void TimeShiftDialog::applyTimeShift()
}
void Singleton::f2();{
    } else if ((err_str = time_string_parse(sa_text.toUtf8().constData(),
                                 NULL, NULL, NULL, &neg, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Invalid);
    } else {
}
void Singleton::f3();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f4();{
    }
    ts_ui_->shiftAllButton->setChecked(true);
    ts_ui_->setTwoCheckBox->setChecked(false);
    enableWidgets();
TimeShiftDialog::~TimeShiftDialog()
}
void Singleton::f5();{
    int cb_label_offset =  ts_ui_->shiftAllButton->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    setStyleSheet(QString(
                      "  margin-left: %1px;"
                      "}"
                      "  margin-left: %2px;"
}
void Singleton::f6();{
        ts_ui_->errorLabel->clear();
        ts_ui_->errorLabel->setStyleSheet(" QLabel { margin-top: 0.5em; }");
    } else {
        ts_ui_->errorLabel->setText(syntax_err_);
        ts_ui_->errorLabel->setStyleSheet(QString(
}
void Singleton::f7();{
        time_le.setSyntaxState(SyntaxLineEdit::Empty);
    } else if ((err_str = time_string_parse(time_le.text().toUtf8().constData(),
                                 &Y, &M, &D, NULL, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        time_le.setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f8();{
    syntax_err_.clear();
    if (frame_le.text().isEmpty()) {
        frame_le.setSyntaxState(SyntaxLineEdit::Empty);
    } else if (!frame_valid || !cap_file_ || frame_num < 1 || frame_num > cap_file_->count) {
        frame_le.setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f9();{
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Empty);
    } else if ((err_str = time_string_parse(sa_text.toUtf8().constData(),
                                 NULL, NULL, NULL, &neg, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f10();{
    }
    if (syntax_err_.isEmpty()) {
        ts_ui_->errorLabel->clear();
        ts_ui_->errorLabel->setStyleSheet(" QLabel { margin-top: 0.5em; }");
    } else {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    checkDateTime(*ts_ui_->setTwoTimeLineEdit);
    if (ts_ui_->setTwoCheckBox->isEnabled())
        ts_ui_->setTwoCheckBox->setChecked(true);
    enableWidgets();
void TimeShiftDialog::applyTimeShift()
}
void Singleton::f2();{
    } else if ((err_str = time_string_parse(sa_text.toUtf8().constData(),
                                 NULL, NULL, NULL, &neg, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Invalid);
    } else {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    checkDateTime(*ts_ui_->setTwoTimeLineEdit);
    if (ts_ui_->setTwoCheckBox->isEnabled())
        ts_ui_->setTwoCheckBox->setChecked(true);
    enableWidgets();
void TimeShiftDialog::applyTimeShift()
}
void Singleton::f2();{
    } else if ((err_str = time_string_parse(sa_text.toUtf8().constData(),
                                 NULL, NULL, NULL, &neg, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Invalid);
    } else {
}
void Singleton::f3();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    checkDateTime(*ts_ui_->setTwoTimeLineEdit);
    if (ts_ui_->setTwoCheckBox->isEnabled())
        ts_ui_->setTwoCheckBox->setChecked(true);
    enableWidgets();
void TimeShiftDialog::applyTimeShift()
}
void Singleton::f2();{
    } else if ((err_str = time_string_parse(sa_text.toUtf8().constData(),
                                 NULL, NULL, NULL, &neg, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Invalid);
    } else {
}
void Singleton::f3();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f4();{
    }
    ts_ui_->shiftAllButton->setChecked(true);
    ts_ui_->setTwoCheckBox->setChecked(false);
    enableWidgets();
TimeShiftDialog::~TimeShiftDialog()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    checkDateTime(*ts_ui_->setTwoTimeLineEdit);
    if (ts_ui_->setTwoCheckBox->isEnabled())
        ts_ui_->setTwoCheckBox->setChecked(true);
    enableWidgets();
void TimeShiftDialog::applyTimeShift()
}
void Singleton::f2();{
    } else if ((err_str = time_string_parse(sa_text.toUtf8().constData(),
                                 NULL, NULL, NULL, &neg, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Invalid);
    } else {
}
void Singleton::f3();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f4();{
    }
    ts_ui_->shiftAllButton->setChecked(true);
    ts_ui_->setTwoCheckBox->setChecked(false);
    enableWidgets();
TimeShiftDialog::~TimeShiftDialog()
}
void Singleton::f5();{
    int cb_label_offset =  ts_ui_->shiftAllButton->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    setStyleSheet(QString(
                      "  margin-left: %1px;"
                      "}"
                      "  margin-left: %2px;"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    checkDateTime(*ts_ui_->setTwoTimeLineEdit);
    if (ts_ui_->setTwoCheckBox->isEnabled())
        ts_ui_->setTwoCheckBox->setChecked(true);
    enableWidgets();
void TimeShiftDialog::applyTimeShift()
}
void Singleton::f2();{
    } else if ((err_str = time_string_parse(sa_text.toUtf8().constData(),
                                 NULL, NULL, NULL, &neg, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Invalid);
    } else {
}
void Singleton::f3();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f4();{
    }
    ts_ui_->shiftAllButton->setChecked(true);
    ts_ui_->setTwoCheckBox->setChecked(false);
    enableWidgets();
TimeShiftDialog::~TimeShiftDialog()
}
void Singleton::f5();{
    int cb_label_offset =  ts_ui_->shiftAllButton->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    setStyleSheet(QString(
                      "  margin-left: %1px;"
                      "}"
                      "  margin-left: %2px;"
}
void Singleton::f6();{
        ts_ui_->errorLabel->clear();
        ts_ui_->errorLabel->setStyleSheet(" QLabel { margin-top: 0.5em; }");
    } else {
        ts_ui_->errorLabel->setText(syntax_err_);
        ts_ui_->errorLabel->setStyleSheet(QString(
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    checkDateTime(*ts_ui_->setTwoTimeLineEdit);
    if (ts_ui_->setTwoCheckBox->isEnabled())
        ts_ui_->setTwoCheckBox->setChecked(true);
    enableWidgets();
void TimeShiftDialog::applyTimeShift()
}
void Singleton::f2();{
    } else if ((err_str = time_string_parse(sa_text.toUtf8().constData(),
                                 NULL, NULL, NULL, &neg, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Invalid);
    } else {
}
void Singleton::f3();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f4();{
    }
    ts_ui_->shiftAllButton->setChecked(true);
    ts_ui_->setTwoCheckBox->setChecked(false);
    enableWidgets();
TimeShiftDialog::~TimeShiftDialog()
}
void Singleton::f5();{
    int cb_label_offset =  ts_ui_->shiftAllButton->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    setStyleSheet(QString(
                      "  margin-left: %1px;"
                      "}"
                      "  margin-left: %2px;"
}
void Singleton::f6();{
        ts_ui_->errorLabel->clear();
        ts_ui_->errorLabel->setStyleSheet(" QLabel { margin-top: 0.5em; }");
    } else {
        ts_ui_->errorLabel->setText(syntax_err_);
        ts_ui_->errorLabel->setStyleSheet(QString(
}
void Singleton::f7();{
        time_le.setSyntaxState(SyntaxLineEdit::Empty);
    } else if ((err_str = time_string_parse(time_le.text().toUtf8().constData(),
                                 &Y, &M, &D, NULL, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        time_le.setSyntaxState(SyntaxLineEdit::Invalid);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    checkDateTime(*ts_ui_->setTwoTimeLineEdit);
    if (ts_ui_->setTwoCheckBox->isEnabled())
        ts_ui_->setTwoCheckBox->setChecked(true);
    enableWidgets();
void TimeShiftDialog::applyTimeShift()
}
void Singleton::f2();{
    } else if ((err_str = time_string_parse(sa_text.toUtf8().constData(),
                                 NULL, NULL, NULL, &neg, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Invalid);
    } else {
}
void Singleton::f3();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f4();{
    }
    ts_ui_->shiftAllButton->setChecked(true);
    ts_ui_->setTwoCheckBox->setChecked(false);
    enableWidgets();
TimeShiftDialog::~TimeShiftDialog()
}
void Singleton::f5();{
    int cb_label_offset =  ts_ui_->shiftAllButton->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    setStyleSheet(QString(
                      "  margin-left: %1px;"
                      "}"
                      "  margin-left: %2px;"
}
void Singleton::f6();{
        ts_ui_->errorLabel->clear();
        ts_ui_->errorLabel->setStyleSheet(" QLabel { margin-top: 0.5em; }");
    } else {
        ts_ui_->errorLabel->setText(syntax_err_);
        ts_ui_->errorLabel->setStyleSheet(QString(
}
void Singleton::f7();{
        time_le.setSyntaxState(SyntaxLineEdit::Empty);
    } else if ((err_str = time_string_parse(time_le.text().toUtf8().constData(),
                                 &Y, &M, &D, NULL, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        time_le.setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f8();{
    syntax_err_.clear();
    if (frame_le.text().isEmpty()) {
        frame_le.setSyntaxState(SyntaxLineEdit::Empty);
    } else if (!frame_valid || !cap_file_ || frame_num < 1 || frame_num > cap_file_->count) {
        frame_le.setSyntaxState(SyntaxLineEdit::Invalid);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    checkDateTime(*ts_ui_->setTwoTimeLineEdit);
    if (ts_ui_->setTwoCheckBox->isEnabled())
        ts_ui_->setTwoCheckBox->setChecked(true);
    enableWidgets();
void TimeShiftDialog::applyTimeShift()
}
void Singleton::f2();{
    } else if ((err_str = time_string_parse(sa_text.toUtf8().constData(),
                                 NULL, NULL, NULL, &neg, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Invalid);
    } else {
}
void Singleton::f3();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f4();{
    }
    ts_ui_->shiftAllButton->setChecked(true);
    ts_ui_->setTwoCheckBox->setChecked(false);
    enableWidgets();
TimeShiftDialog::~TimeShiftDialog()
}
void Singleton::f5();{
    int cb_label_offset =  ts_ui_->shiftAllButton->style()->subElementRect(QStyle::SE_CheckBoxContents, &style_opt).left();
    setStyleSheet(QString(
                      "  margin-left: %1px;"
                      "}"
                      "  margin-left: %2px;"
}
void Singleton::f6();{
        ts_ui_->errorLabel->clear();
        ts_ui_->errorLabel->setStyleSheet(" QLabel { margin-top: 0.5em; }");
    } else {
        ts_ui_->errorLabel->setText(syntax_err_);
        ts_ui_->errorLabel->setStyleSheet(QString(
}
void Singleton::f7();{
        time_le.setSyntaxState(SyntaxLineEdit::Empty);
    } else if ((err_str = time_string_parse(time_le.text().toUtf8().constData(),
                                 &Y, &M, &D, NULL, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        time_le.setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f8();{
    syntax_err_.clear();
    if (frame_le.text().isEmpty()) {
        frame_le.setSyntaxState(SyntaxLineEdit::Empty);
    } else if (!frame_valid || !cap_file_ || frame_num < 1 || frame_num > cap_file_->count) {
        frame_le.setSyntaxState(SyntaxLineEdit::Invalid);
}
void Singleton::f9();{
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Empty);
    } else if ((err_str = time_string_parse(sa_text.toUtf8().constData(),
                                 NULL, NULL, NULL, &neg, &h, &m, &s)) != NULL) {
        syntax_err_ = err_str;
        ts_ui_->shiftAllTimeLineEdit->setSyntaxState(SyntaxLineEdit::Invalid);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f2();{
void TrafficTableDialog::toggleTable()
    QAction *ca = qobject_cast<QAction *>(QObject::sender());
    if (!ca) {
        return;
    }
}
void Singleton::f3();{
    updateWidgets();
    if (ca->isChecked()) {
        ui->trafficTableTabWidget->setCurrentWidget(proto_id_to_tree_[proto_id]);
    }
    if (new_table) {
}
void Singleton::f4();{
                                           << "mptcp" << "rsvp" << "sctp"
                                           << "tcp" << "udp";
    QString table_proto = proto_get_protocol_filter_name(get_conversation_proto_id(table_));
    if (mac_protos.contains(table_proto) && gbl_resolv_flags.mac_name) return true;
    if (net_protos.contains(table_proto) && gbl_resolv_flags.network_name) return true;
}
void Singleton::f5();{
    ProgressFrame::addToButtonBox(ui->buttonBox, parent);
QDialogButtonBox *TrafficTableDialog::buttonBox() const
    return ui->buttonBox;
QTabWidget *TrafficTableDialog::trafficTableTabWidget() const
    return ui->trafficTableTabWidget;
}
void Singleton::f6();{
    for (int col = 0; col < columnCount(); col++) {
        if (isColumnHidden(col)) {
            continue;
        }
        if (row < 0) {
}
void Singleton::f7();{
    if (!table_) return false;
    QStringList mac_protos = QStringList() << "eth" << "tr"<< "wlan";
    QStringList net_protos = QStringList() << "ip" << "ipv6" << "jxta"
                                           << "mptcp" << "rsvp" << "sctp"
                                           << "tcp" << "udp";
}
void Singleton::f8();{
        return QList<QVariant>();
    }
    return cur_tree->rowData(row);
void TrafficTableDialog::copyAsCsv()
    QTreeWidget *cur_tree = qobject_cast<QTreeWidget *>(ui->trafficTableTabWidget->currentWidget());
}
void Singleton::f9();{
    ui->trafficTableTabWidget->setCurrentWidget(cur_w);
    ui->trafficTableTabWidget->setUpdatesEnabled(true);
    WiresharkDialog::updateWidgets();
QList<QVariant> TrafficTableDialog::curTreeRowData(int row) const
    TrafficTableTreeWidget *cur_tree = qobject_cast<TrafficTableTreeWidget *>(ui->trafficTableTabWidget->currentWidget());
}
void Singleton::f10();{
            } else {
                rdsl << v.toString();
            }
        }
        stream << rdsl.join(",") << '\n';
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f2();{
void TrafficTableDialog::toggleTable()
    QAction *ca = qobject_cast<QAction *>(QObject::sender());
    if (!ca) {
        return;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f2();{
void TrafficTableDialog::toggleTable()
    QAction *ca = qobject_cast<QAction *>(QObject::sender());
    if (!ca) {
        return;
    }
}
void Singleton::f3();{
    updateWidgets();
    if (ca->isChecked()) {
        ui->trafficTableTabWidget->setCurrentWidget(proto_id_to_tree_[proto_id]);
    }
    if (new_table) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f2();{
void TrafficTableDialog::toggleTable()
    QAction *ca = qobject_cast<QAction *>(QObject::sender());
    if (!ca) {
        return;
    }
}
void Singleton::f3();{
    updateWidgets();
    if (ca->isChecked()) {
        ui->trafficTableTabWidget->setCurrentWidget(proto_id_to_tree_[proto_id]);
    }
    if (new_table) {
}
void Singleton::f4();{
                                           << "mptcp" << "rsvp" << "sctp"
                                           << "tcp" << "udp";
    QString table_proto = proto_get_protocol_filter_name(get_conversation_proto_id(table_));
    if (mac_protos.contains(table_proto) && gbl_resolv_flags.mac_name) return true;
    if (net_protos.contains(table_proto) && gbl_resolv_flags.network_name) return true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f2();{
void TrafficTableDialog::toggleTable()
    QAction *ca = qobject_cast<QAction *>(QObject::sender());
    if (!ca) {
        return;
    }
}
void Singleton::f3();{
    updateWidgets();
    if (ca->isChecked()) {
        ui->trafficTableTabWidget->setCurrentWidget(proto_id_to_tree_[proto_id]);
    }
    if (new_table) {
}
void Singleton::f4();{
                                           << "mptcp" << "rsvp" << "sctp"
                                           << "tcp" << "udp";
    QString table_proto = proto_get_protocol_filter_name(get_conversation_proto_id(table_));
    if (mac_protos.contains(table_proto) && gbl_resolv_flags.mac_name) return true;
    if (net_protos.contains(table_proto) && gbl_resolv_flags.network_name) return true;
}
void Singleton::f5();{
    ProgressFrame::addToButtonBox(ui->buttonBox, parent);
QDialogButtonBox *TrafficTableDialog::buttonBox() const
    return ui->buttonBox;
QTabWidget *TrafficTableDialog::trafficTableTabWidget() const
    return ui->trafficTableTabWidget;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f2();{
void TrafficTableDialog::toggleTable()
    QAction *ca = qobject_cast<QAction *>(QObject::sender());
    if (!ca) {
        return;
    }
}
void Singleton::f3();{
    updateWidgets();
    if (ca->isChecked()) {
        ui->trafficTableTabWidget->setCurrentWidget(proto_id_to_tree_[proto_id]);
    }
    if (new_table) {
}
void Singleton::f4();{
                                           << "mptcp" << "rsvp" << "sctp"
                                           << "tcp" << "udp";
    QString table_proto = proto_get_protocol_filter_name(get_conversation_proto_id(table_));
    if (mac_protos.contains(table_proto) && gbl_resolv_flags.mac_name) return true;
    if (net_protos.contains(table_proto) && gbl_resolv_flags.network_name) return true;
}
void Singleton::f5();{
    ProgressFrame::addToButtonBox(ui->buttonBox, parent);
QDialogButtonBox *TrafficTableDialog::buttonBox() const
    return ui->buttonBox;
QTabWidget *TrafficTableDialog::trafficTableTabWidget() const
    return ui->trafficTableTabWidget;
}
void Singleton::f6();{
    for (int col = 0; col < columnCount(); col++) {
        if (isColumnHidden(col)) {
            continue;
        }
        if (row < 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f2();{
void TrafficTableDialog::toggleTable()
    QAction *ca = qobject_cast<QAction *>(QObject::sender());
    if (!ca) {
        return;
    }
}
void Singleton::f3();{
    updateWidgets();
    if (ca->isChecked()) {
        ui->trafficTableTabWidget->setCurrentWidget(proto_id_to_tree_[proto_id]);
    }
    if (new_table) {
}
void Singleton::f4();{
                                           << "mptcp" << "rsvp" << "sctp"
                                           << "tcp" << "udp";
    QString table_proto = proto_get_protocol_filter_name(get_conversation_proto_id(table_));
    if (mac_protos.contains(table_proto) && gbl_resolv_flags.mac_name) return true;
    if (net_protos.contains(table_proto) && gbl_resolv_flags.network_name) return true;
}
void Singleton::f5();{
    ProgressFrame::addToButtonBox(ui->buttonBox, parent);
QDialogButtonBox *TrafficTableDialog::buttonBox() const
    return ui->buttonBox;
QTabWidget *TrafficTableDialog::trafficTableTabWidget() const
    return ui->trafficTableTabWidget;
}
void Singleton::f6();{
    for (int col = 0; col < columnCount(); col++) {
        if (isColumnHidden(col)) {
            continue;
        }
        if (row < 0) {
}
void Singleton::f7();{
    if (!table_) return false;
    QStringList mac_protos = QStringList() << "eth" << "tr"<< "wlan";
    QStringList net_protos = QStringList() << "ip" << "ipv6" << "jxta"
                                           << "mptcp" << "rsvp" << "sctp"
                                           << "tcp" << "udp";
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f2();{
void TrafficTableDialog::toggleTable()
    QAction *ca = qobject_cast<QAction *>(QObject::sender());
    if (!ca) {
        return;
    }
}
void Singleton::f3();{
    updateWidgets();
    if (ca->isChecked()) {
        ui->trafficTableTabWidget->setCurrentWidget(proto_id_to_tree_[proto_id]);
    }
    if (new_table) {
}
void Singleton::f4();{
                                           << "mptcp" << "rsvp" << "sctp"
                                           << "tcp" << "udp";
    QString table_proto = proto_get_protocol_filter_name(get_conversation_proto_id(table_));
    if (mac_protos.contains(table_proto) && gbl_resolv_flags.mac_name) return true;
    if (net_protos.contains(table_proto) && gbl_resolv_flags.network_name) return true;
}
void Singleton::f5();{
    ProgressFrame::addToButtonBox(ui->buttonBox, parent);
QDialogButtonBox *TrafficTableDialog::buttonBox() const
    return ui->buttonBox;
QTabWidget *TrafficTableDialog::trafficTableTabWidget() const
    return ui->trafficTableTabWidget;
}
void Singleton::f6();{
    for (int col = 0; col < columnCount(); col++) {
        if (isColumnHidden(col)) {
            continue;
        }
        if (row < 0) {
}
void Singleton::f7();{
    if (!table_) return false;
    QStringList mac_protos = QStringList() << "eth" << "tr"<< "wlan";
    QStringList net_protos = QStringList() << "ip" << "ipv6" << "jxta"
                                           << "mptcp" << "rsvp" << "sctp"
                                           << "tcp" << "udp";
}
void Singleton::f8();{
        return QList<QVariant>();
    }
    return cur_tree->rowData(row);
void TrafficTableDialog::copyAsCsv()
    QTreeWidget *cur_tree = qobject_cast<QTreeWidget *>(ui->trafficTableTabWidget->currentWidget());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
}
void Singleton::f2();{
void TrafficTableDialog::toggleTable()
    QAction *ca = qobject_cast<QAction *>(QObject::sender());
    if (!ca) {
        return;
    }
}
void Singleton::f3();{
    updateWidgets();
    if (ca->isChecked()) {
        ui->trafficTableTabWidget->setCurrentWidget(proto_id_to_tree_[proto_id]);
    }
    if (new_table) {
}
void Singleton::f4();{
                                           << "mptcp" << "rsvp" << "sctp"
                                           << "tcp" << "udp";
    QString table_proto = proto_get_protocol_filter_name(get_conversation_proto_id(table_));
    if (mac_protos.contains(table_proto) && gbl_resolv_flags.mac_name) return true;
    if (net_protos.contains(table_proto) && gbl_resolv_flags.network_name) return true;
}
void Singleton::f5();{
    ProgressFrame::addToButtonBox(ui->buttonBox, parent);
QDialogButtonBox *TrafficTableDialog::buttonBox() const
    return ui->buttonBox;
QTabWidget *TrafficTableDialog::trafficTableTabWidget() const
    return ui->trafficTableTabWidget;
}
void Singleton::f6();{
    for (int col = 0; col < columnCount(); col++) {
        if (isColumnHidden(col)) {
            continue;
        }
        if (row < 0) {
}
void Singleton::f7();{
    if (!table_) return false;
    QStringList mac_protos = QStringList() << "eth" << "tr"<< "wlan";
    QStringList net_protos = QStringList() << "ip" << "ipv6" << "jxta"
                                           << "mptcp" << "rsvp" << "sctp"
                                           << "tcp" << "udp";
}
void Singleton::f8();{
        return QList<QVariant>();
    }
    return cur_tree->rowData(row);
void TrafficTableDialog::copyAsCsv()
    QTreeWidget *cur_tree = qobject_cast<QTreeWidget *>(ui->trafficTableTabWidget->currentWidget());
}
void Singleton::f9();{
    ui->trafficTableTabWidget->setCurrentWidget(cur_w);
    ui->trafficTableTabWidget->setUpdatesEnabled(true);
    WiresharkDialog::updateWidgets();
QList<QVariant> TrafficTableDialog::curTreeRowData(int row) const
    TrafficTableTreeWidget *cur_tree = qobject_cast<TrafficTableTreeWidget *>(ui->trafficTableTabWidget->currentWidget());
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
objectdc.methoddc()
objectdd.methoddd()
objectde.methodde()
if (objectdef.methoddea() && objectded.methoddez())
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
objectdc.methoddc()
objectdd.methoddd()
objectde.methodde()
if (objectdef.methoddea() && objectded.methoddez())
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
}
void Singleton::f2();{
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
	lb(0),
}
void Singleton::f3();{
	lb = ListBox::Allocate();
void AutoComplete::Start(Window &parent, int ctrlID,
	int position, Point location, int startLen_,
	int lineHeight, bool unicodeMode, int technology) {
	if (active) {
}
void Singleton::f4();{
using namespace Scintilla;
AutoComplete::AutoComplete() :
	active(false),
	separator(' '),
	typesep('?'),
}
void Singleton::f5();{
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
		::RemoveMenu(_hMenu, _lrfl.at(i)._id, MF_BYCOMMAND);
}
void Singleton::f6();{
	active(false),
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
}
void Singleton::f7();{
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
@objectf.methodf().invocationp().invocationqq().invocationaa().x
@pNppParams->writeHistory(_lrfl.at(i)._name.c_str());
@if (!lstrcmpi(_lrfl.at(i)._name.c_str(), fn))
@pNppParam->getFindDlgTabTitiles()._replace = nameW;
}
void Singleton::f8();{
using namespace Scintilla;
AutoComplete::AutoComplete() :
	active(false),
	separator(' '),
	typesep('?'),
}
void Singleton::f9();{
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
// Copyright (C)2003 Don HO <don.h@free.fr>
}
void Singleton::f10();{
objectd.methodd().invocationc().invocationa().invocationg().invocationz()
objectda.methodda()
objectdb.methoddb()
objectdc.methoddc()
objectdd.methoddd()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
objectdc.methoddc()
objectdd.methoddd()
objectde.methodde()
if (objectdef.methoddea() && objectded.methoddez())
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
}
void Singleton::f2();{
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
	lb(0),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
objectdc.methoddc()
objectdd.methoddd()
objectde.methodde()
if (objectdef.methoddea() && objectded.methoddez())
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
}
void Singleton::f2();{
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
	lb(0),
}
void Singleton::f3();{
	lb = ListBox::Allocate();
void AutoComplete::Start(Window &parent, int ctrlID,
	int position, Point location, int startLen_,
	int lineHeight, bool unicodeMode, int technology) {
	if (active) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
objectdc.methoddc()
objectdd.methoddd()
objectde.methodde()
if (objectdef.methoddea() && objectded.methoddez())
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
}
void Singleton::f2();{
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
	lb(0),
}
void Singleton::f3();{
	lb = ListBox::Allocate();
void AutoComplete::Start(Window &parent, int ctrlID,
	int position, Point location, int startLen_,
	int lineHeight, bool unicodeMode, int technology) {
	if (active) {
}
void Singleton::f4();{
using namespace Scintilla;
AutoComplete::AutoComplete() :
	active(false),
	separator(' '),
	typesep('?'),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
objectdc.methoddc()
objectdd.methoddd()
objectde.methodde()
if (objectdef.methoddea() && objectded.methoddez())
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
}
void Singleton::f2();{
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
	lb(0),
}
void Singleton::f3();{
	lb = ListBox::Allocate();
void AutoComplete::Start(Window &parent, int ctrlID,
	int position, Point location, int startLen_,
	int lineHeight, bool unicodeMode, int technology) {
	if (active) {
}
void Singleton::f4();{
using namespace Scintilla;
AutoComplete::AutoComplete() :
	active(false),
	separator(' '),
	typesep('?'),
}
void Singleton::f5();{
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
		::RemoveMenu(_hMenu, _lrfl.at(i)._id, MF_BYCOMMAND);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
objectdc.methoddc()
objectdd.methoddd()
objectde.methodde()
if (objectdef.methoddea() && objectded.methoddez())
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
}
void Singleton::f2();{
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
	lb(0),
}
void Singleton::f3();{
	lb = ListBox::Allocate();
void AutoComplete::Start(Window &parent, int ctrlID,
	int position, Point location, int startLen_,
	int lineHeight, bool unicodeMode, int technology) {
	if (active) {
}
void Singleton::f4();{
using namespace Scintilla;
AutoComplete::AutoComplete() :
	active(false),
	separator(' '),
	typesep('?'),
}
void Singleton::f5();{
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
		::RemoveMenu(_hMenu, _lrfl.at(i)._id, MF_BYCOMMAND);
}
void Singleton::f6();{
	active(false),
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
objectdc.methoddc()
objectdd.methoddd()
objectde.methodde()
if (objectdef.methoddea() && objectded.methoddez())
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
}
void Singleton::f2();{
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
	lb(0),
}
void Singleton::f3();{
	lb = ListBox::Allocate();
void AutoComplete::Start(Window &parent, int ctrlID,
	int position, Point location, int startLen_,
	int lineHeight, bool unicodeMode, int technology) {
	if (active) {
}
void Singleton::f4();{
using namespace Scintilla;
AutoComplete::AutoComplete() :
	active(false),
	separator(' '),
	typesep('?'),
}
void Singleton::f5();{
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
		::RemoveMenu(_hMenu, _lrfl.at(i)._id, MF_BYCOMMAND);
}
void Singleton::f6();{
	active(false),
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
}
void Singleton::f7();{
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
@objectf.methodf().invocationp().invocationqq().invocationaa().x
@pNppParams->writeHistory(_lrfl.at(i)._name.c_str());
@if (!lstrcmpi(_lrfl.at(i)._name.c_str(), fn))
@pNppParam->getFindDlgTabTitiles()._replace = nameW;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
objectdc.methoddc()
objectdd.methoddd()
objectde.methodde()
if (objectdef.methoddea() && objectded.methoddez())
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
}
void Singleton::f2();{
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
	lb(0),
}
void Singleton::f3();{
	lb = ListBox::Allocate();
void AutoComplete::Start(Window &parent, int ctrlID,
	int position, Point location, int startLen_,
	int lineHeight, bool unicodeMode, int technology) {
	if (active) {
}
void Singleton::f4();{
using namespace Scintilla;
AutoComplete::AutoComplete() :
	active(false),
	separator(' '),
	typesep('?'),
}
void Singleton::f5();{
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
		::RemoveMenu(_hMenu, _lrfl.at(i)._id, MF_BYCOMMAND);
}
void Singleton::f6();{
	active(false),
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
}
void Singleton::f7();{
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
@objectf.methodf().invocationp().invocationqq().invocationaa().x
@pNppParams->writeHistory(_lrfl.at(i)._name.c_str());
@if (!lstrcmpi(_lrfl.at(i)._name.c_str(), fn))
@pNppParam->getFindDlgTabTitiles()._replace = nameW;
}
void Singleton::f8();{
using namespace Scintilla;
AutoComplete::AutoComplete() :
	active(false),
	separator(' '),
	typesep('?'),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
objectdc.methoddc()
objectdd.methoddd()
objectde.methodde()
if (objectdef.methoddea() && objectded.methoddez())
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
}
void Singleton::f2();{
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
	lb(0),
}
void Singleton::f3();{
	lb = ListBox::Allocate();
void AutoComplete::Start(Window &parent, int ctrlID,
	int position, Point location, int startLen_,
	int lineHeight, bool unicodeMode, int technology) {
	if (active) {
}
void Singleton::f4();{
using namespace Scintilla;
AutoComplete::AutoComplete() :
	active(false),
	separator(' '),
	typesep('?'),
}
void Singleton::f5();{
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
		::RemoveMenu(_hMenu, _lrfl.at(i)._id, MF_BYCOMMAND);
}
void Singleton::f6();{
	active(false),
	separator(' '),
	typesep('?'),
	ignoreCase(false),
	chooseSingle(false),
}
void Singleton::f7();{
@objecte.methode().invocationk().invocationw().invocationl().invocationd().invocatione()
@objectf.methodf().invocationp().invocationqq().invocationaa().x
@pNppParams->writeHistory(_lrfl.at(i)._name.c_str());
@if (!lstrcmpi(_lrfl.at(i)._name.c_str(), fn))
@pNppParam->getFindDlgTabTitiles()._replace = nameW;
}
void Singleton::f8();{
using namespace Scintilla;
AutoComplete::AutoComplete() :
	active(false),
	separator(' '),
	typesep('?'),
}
void Singleton::f9();{
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
// Copyright (C)2003 Don HO <don.h@free.fr>
// version 2 of the License, or (at your option) any later version.
// Copyright (C)2003 Don HO <don.h@free.fr>
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
namespace py {
PyObject* ThriftModule = NULL;
bool parse_struct_item_spec(StructItemSpec* dest, PyObject* spec_tuple) {
  // i'd like to use ParseArgs here, but it seems to be a bottleneck.
  if (PyTuple_Size(spec_tuple) != 5) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
namespace py {
PyObject* ThriftModule = NULL;
bool parse_struct_item_spec(StructItemSpec* dest, PyObject* spec_tuple) {
  // i'd like to use ParseArgs here, but it seems to be a bottleneck.
  if (PyTuple_Size(spec_tuple) != 5) {
}
void Singleton::f2();{
  dest->vtag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 2)));
  if (INT_CONV_ERROR_OCCURRED(dest->vtag)) {
    return false;
  dest->ktypeargs = PyTuple_GET_ITEM(typeargs, 1);
  dest->vtypeargs = PyTuple_GET_ITEM(typeargs, 3);
}
void Singleton::f3();{
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
}
void Singleton::f4();{
    PyErr_SetString(PyExc_TypeError, "expecting 5 arguments for typeargs to map");
    return false;
  dest->ktag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
  if (INT_CONV_ERROR_OCCURRED(dest->ktag)) {
    return false;
}
void Singleton::f5();{
    return false;
  dest->attrname = PyTuple_GET_ITEM(spec_tuple, 2);
  dest->typeargs = PyTuple_GET_ITEM(spec_tuple, 3);
  dest->defval = PyTuple_GET_ITEM(spec_tuple, 4);
  return true;
}
void Singleton::f6();{
bool parse_set_list_args(SetListTypeArgs* dest, PyObject* typeargs) {
  if (PyTuple_Size(typeargs) != 3) {
    PyErr_SetString(PyExc_TypeError, "expecting tuple of size 3 for list/set type args");
    return false;
  dest->element_type = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
}
void Singleton::f7();{
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
}
void Singleton::f8();{
  if (PyList_Size(typeargs) != 2) {
    PyErr_SetString(PyExc_TypeError, "expecting list of size 2 for struct args");
    return false;
  dest->klass = PyList_GET_ITEM(typeargs, 0);
  dest->spec = PyList_GET_ITEM(typeargs, 1);
}
void Singleton::f9();{
  dest->tag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(spec_tuple, 0)));
  if (INT_CONV_ERROR_OCCURRED(dest->tag)) {
    return false;
  dest->type = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(spec_tuple, 1)));
  if (INT_CONV_ERROR_OCCURRED(dest->type)) {
}
void Singleton::f10();{
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
namespace py {
PyObject* ThriftModule = NULL;
bool parse_struct_item_spec(StructItemSpec* dest, PyObject* spec_tuple) {
  // i'd like to use ParseArgs here, but it seems to be a bottleneck.
  if (PyTuple_Size(spec_tuple) != 5) {
}
void Singleton::f2();{
  dest->vtag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 2)));
  if (INT_CONV_ERROR_OCCURRED(dest->vtag)) {
    return false;
  dest->ktypeargs = PyTuple_GET_ITEM(typeargs, 1);
  dest->vtypeargs = PyTuple_GET_ITEM(typeargs, 3);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
namespace py {
PyObject* ThriftModule = NULL;
bool parse_struct_item_spec(StructItemSpec* dest, PyObject* spec_tuple) {
  // i'd like to use ParseArgs here, but it seems to be a bottleneck.
  if (PyTuple_Size(spec_tuple) != 5) {
}
void Singleton::f2();{
  dest->vtag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 2)));
  if (INT_CONV_ERROR_OCCURRED(dest->vtag)) {
    return false;
  dest->ktypeargs = PyTuple_GET_ITEM(typeargs, 1);
  dest->vtypeargs = PyTuple_GET_ITEM(typeargs, 3);
}
void Singleton::f3();{
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
namespace py {
PyObject* ThriftModule = NULL;
bool parse_struct_item_spec(StructItemSpec* dest, PyObject* spec_tuple) {
  // i'd like to use ParseArgs here, but it seems to be a bottleneck.
  if (PyTuple_Size(spec_tuple) != 5) {
}
void Singleton::f2();{
  dest->vtag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 2)));
  if (INT_CONV_ERROR_OCCURRED(dest->vtag)) {
    return false;
  dest->ktypeargs = PyTuple_GET_ITEM(typeargs, 1);
  dest->vtypeargs = PyTuple_GET_ITEM(typeargs, 3);
}
void Singleton::f3();{
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
}
void Singleton::f4();{
    PyErr_SetString(PyExc_TypeError, "expecting 5 arguments for typeargs to map");
    return false;
  dest->ktag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
  if (INT_CONV_ERROR_OCCURRED(dest->ktag)) {
    return false;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
namespace py {
PyObject* ThriftModule = NULL;
bool parse_struct_item_spec(StructItemSpec* dest, PyObject* spec_tuple) {
  // i'd like to use ParseArgs here, but it seems to be a bottleneck.
  if (PyTuple_Size(spec_tuple) != 5) {
}
void Singleton::f2();{
  dest->vtag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 2)));
  if (INT_CONV_ERROR_OCCURRED(dest->vtag)) {
    return false;
  dest->ktypeargs = PyTuple_GET_ITEM(typeargs, 1);
  dest->vtypeargs = PyTuple_GET_ITEM(typeargs, 3);
}
void Singleton::f3();{
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
}
void Singleton::f4();{
    PyErr_SetString(PyExc_TypeError, "expecting 5 arguments for typeargs to map");
    return false;
  dest->ktag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
  if (INT_CONV_ERROR_OCCURRED(dest->ktag)) {
    return false;
}
void Singleton::f5();{
    return false;
  dest->attrname = PyTuple_GET_ITEM(spec_tuple, 2);
  dest->typeargs = PyTuple_GET_ITEM(spec_tuple, 3);
  dest->defval = PyTuple_GET_ITEM(spec_tuple, 4);
  return true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
namespace py {
PyObject* ThriftModule = NULL;
bool parse_struct_item_spec(StructItemSpec* dest, PyObject* spec_tuple) {
  // i'd like to use ParseArgs here, but it seems to be a bottleneck.
  if (PyTuple_Size(spec_tuple) != 5) {
}
void Singleton::f2();{
  dest->vtag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 2)));
  if (INT_CONV_ERROR_OCCURRED(dest->vtag)) {
    return false;
  dest->ktypeargs = PyTuple_GET_ITEM(typeargs, 1);
  dest->vtypeargs = PyTuple_GET_ITEM(typeargs, 3);
}
void Singleton::f3();{
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
}
void Singleton::f4();{
    PyErr_SetString(PyExc_TypeError, "expecting 5 arguments for typeargs to map");
    return false;
  dest->ktag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
  if (INT_CONV_ERROR_OCCURRED(dest->ktag)) {
    return false;
}
void Singleton::f5();{
    return false;
  dest->attrname = PyTuple_GET_ITEM(spec_tuple, 2);
  dest->typeargs = PyTuple_GET_ITEM(spec_tuple, 3);
  dest->defval = PyTuple_GET_ITEM(spec_tuple, 4);
  return true;
}
void Singleton::f6();{
bool parse_set_list_args(SetListTypeArgs* dest, PyObject* typeargs) {
  if (PyTuple_Size(typeargs) != 3) {
    PyErr_SetString(PyExc_TypeError, "expecting tuple of size 3 for list/set type args");
    return false;
  dest->element_type = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
namespace py {
PyObject* ThriftModule = NULL;
bool parse_struct_item_spec(StructItemSpec* dest, PyObject* spec_tuple) {
  // i'd like to use ParseArgs here, but it seems to be a bottleneck.
  if (PyTuple_Size(spec_tuple) != 5) {
}
void Singleton::f2();{
  dest->vtag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 2)));
  if (INT_CONV_ERROR_OCCURRED(dest->vtag)) {
    return false;
  dest->ktypeargs = PyTuple_GET_ITEM(typeargs, 1);
  dest->vtypeargs = PyTuple_GET_ITEM(typeargs, 3);
}
void Singleton::f3();{
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
}
void Singleton::f4();{
    PyErr_SetString(PyExc_TypeError, "expecting 5 arguments for typeargs to map");
    return false;
  dest->ktag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
  if (INT_CONV_ERROR_OCCURRED(dest->ktag)) {
    return false;
}
void Singleton::f5();{
    return false;
  dest->attrname = PyTuple_GET_ITEM(spec_tuple, 2);
  dest->typeargs = PyTuple_GET_ITEM(spec_tuple, 3);
  dest->defval = PyTuple_GET_ITEM(spec_tuple, 4);
  return true;
}
void Singleton::f6();{
bool parse_set_list_args(SetListTypeArgs* dest, PyObject* typeargs) {
  if (PyTuple_Size(typeargs) != 3) {
    PyErr_SetString(PyExc_TypeError, "expecting tuple of size 3 for list/set type args");
    return false;
  dest->element_type = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
}
void Singleton::f7();{
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
namespace py {
PyObject* ThriftModule = NULL;
bool parse_struct_item_spec(StructItemSpec* dest, PyObject* spec_tuple) {
  // i'd like to use ParseArgs here, but it seems to be a bottleneck.
  if (PyTuple_Size(spec_tuple) != 5) {
}
void Singleton::f2();{
  dest->vtag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 2)));
  if (INT_CONV_ERROR_OCCURRED(dest->vtag)) {
    return false;
  dest->ktypeargs = PyTuple_GET_ITEM(typeargs, 1);
  dest->vtypeargs = PyTuple_GET_ITEM(typeargs, 3);
}
void Singleton::f3();{
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
}
void Singleton::f4();{
    PyErr_SetString(PyExc_TypeError, "expecting 5 arguments for typeargs to map");
    return false;
  dest->ktag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
  if (INT_CONV_ERROR_OCCURRED(dest->ktag)) {
    return false;
}
void Singleton::f5();{
    return false;
  dest->attrname = PyTuple_GET_ITEM(spec_tuple, 2);
  dest->typeargs = PyTuple_GET_ITEM(spec_tuple, 3);
  dest->defval = PyTuple_GET_ITEM(spec_tuple, 4);
  return true;
}
void Singleton::f6();{
bool parse_set_list_args(SetListTypeArgs* dest, PyObject* typeargs) {
  if (PyTuple_Size(typeargs) != 3) {
    PyErr_SetString(PyExc_TypeError, "expecting tuple of size 3 for list/set type args");
    return false;
  dest->element_type = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
}
void Singleton::f7();{
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
}
void Singleton::f8();{
  if (PyList_Size(typeargs) != 2) {
    PyErr_SetString(PyExc_TypeError, "expecting list of size 2 for struct args");
    return false;
  dest->klass = PyList_GET_ITEM(typeargs, 0);
  dest->spec = PyList_GET_ITEM(typeargs, 1);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
namespace py {
PyObject* ThriftModule = NULL;
bool parse_struct_item_spec(StructItemSpec* dest, PyObject* spec_tuple) {
  // i'd like to use ParseArgs here, but it seems to be a bottleneck.
  if (PyTuple_Size(spec_tuple) != 5) {
}
void Singleton::f2();{
  dest->vtag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 2)));
  if (INT_CONV_ERROR_OCCURRED(dest->vtag)) {
    return false;
  dest->ktypeargs = PyTuple_GET_ITEM(typeargs, 1);
  dest->vtypeargs = PyTuple_GET_ITEM(typeargs, 3);
}
void Singleton::f3();{
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
}
void Singleton::f4();{
    PyErr_SetString(PyExc_TypeError, "expecting 5 arguments for typeargs to map");
    return false;
  dest->ktag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
  if (INT_CONV_ERROR_OCCURRED(dest->ktag)) {
    return false;
}
void Singleton::f5();{
    return false;
  dest->attrname = PyTuple_GET_ITEM(spec_tuple, 2);
  dest->typeargs = PyTuple_GET_ITEM(spec_tuple, 3);
  dest->defval = PyTuple_GET_ITEM(spec_tuple, 4);
  return true;
}
void Singleton::f6();{
bool parse_set_list_args(SetListTypeArgs* dest, PyObject* typeargs) {
  if (PyTuple_Size(typeargs) != 3) {
    PyErr_SetString(PyExc_TypeError, "expecting tuple of size 3 for list/set type args");
    return false;
  dest->element_type = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(typeargs, 0)));
}
void Singleton::f7();{
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
}
void Singleton::f8();{
  if (PyList_Size(typeargs) != 2) {
    PyErr_SetString(PyExc_TypeError, "expecting list of size 2 for struct args");
    return false;
  dest->klass = PyList_GET_ITEM(typeargs, 0);
  dest->spec = PyList_GET_ITEM(typeargs, 1);
}
void Singleton::f9();{
  dest->tag = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(spec_tuple, 0)));
  if (INT_CONV_ERROR_OCCURRED(dest->tag)) {
    return false;
  dest->type = static_cast<TType>(PyInt_AsLong(PyTuple_GET_ITEM(spec_tuple, 1)));
  if (INT_CONV_ERROR_OCCURRED(dest->type)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    }
    case PT_TXTMOD_COLOR:
    {
        if (qobject_cast<QColorDialog *>(editor))
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    }
    case PT_TXTMOD_COLOR:
    {
        if (qobject_cast<QColorDialog *>(editor))
        {
}
void Singleton::f2();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}
void Singleton::f3();{
        if (qobject_cast<QColorDialog *>(editor))
        {
            QColor color(index.model()->data(index, Qt::DecorationRole).toString());
            qobject_cast<QColorDialog *>(editor)->setCurrentColor(color);
        }
}
void Singleton::f4();{
QWidget *UatDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option,
                                  const QModelIndex &index) const
    uat_field_t *field = indexToField(index);
    QWidget *editor = nullptr;
    switch (field->mode) {
}
void Singleton::f5();{
        hexbytes_regex.setCaseSensitivity(Qt::CaseInsensitive);
        // QString types from QStyledItemDelegate are documented to return a
        // QLineEdit. Note that Qt returns a subclass from QLineEdit which
        // automatically adapts the width to the typed contents.
        QLineEdit *le_editor = static_cast<QLineEdit *>(
}
void Singleton::f6();{
        le_editor->setValidator(new QRegExpValidator(hexbytes_regex, le_editor));
        editor = le_editor;
        break;
    }
    case PT_TXTMOD_BOOL:
}
void Singleton::f7();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}
void Singleton::f8();{
        }
        break;
    case PT_TXTMOD_FILENAME:
        if (index.isValid()) {
            QString filename_old = index.model()->data(index, Qt::EditRole).toString();
}
void Singleton::f9();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f10();{
    case PT_TXTMOD_COLOR:
        //do nothing, dialog signals will update table
        if (qobject_cast<QColorDialog *>(editor))
        {
            QColor newColor = qobject_cast<QColorDialog *>(editor)->currentColor();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    }
    case PT_TXTMOD_COLOR:
    {
        if (qobject_cast<QColorDialog *>(editor))
        {
}
void Singleton::f2();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    }
    case PT_TXTMOD_COLOR:
    {
        if (qobject_cast<QColorDialog *>(editor))
        {
}
void Singleton::f2();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}
void Singleton::f3();{
        if (qobject_cast<QColorDialog *>(editor))
        {
            QColor color(index.model()->data(index, Qt::DecorationRole).toString());
            qobject_cast<QColorDialog *>(editor)->setCurrentColor(color);
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    }
    case PT_TXTMOD_COLOR:
    {
        if (qobject_cast<QColorDialog *>(editor))
        {
}
void Singleton::f2();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}
void Singleton::f3();{
        if (qobject_cast<QColorDialog *>(editor))
        {
            QColor color(index.model()->data(index, Qt::DecorationRole).toString());
            qobject_cast<QColorDialog *>(editor)->setCurrentColor(color);
        }
}
void Singleton::f4();{
QWidget *UatDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option,
                                  const QModelIndex &index) const
    uat_field_t *field = indexToField(index);
    QWidget *editor = nullptr;
    switch (field->mode) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    }
    case PT_TXTMOD_COLOR:
    {
        if (qobject_cast<QColorDialog *>(editor))
        {
}
void Singleton::f2();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}
void Singleton::f3();{
        if (qobject_cast<QColorDialog *>(editor))
        {
            QColor color(index.model()->data(index, Qt::DecorationRole).toString());
            qobject_cast<QColorDialog *>(editor)->setCurrentColor(color);
        }
}
void Singleton::f4();{
QWidget *UatDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option,
                                  const QModelIndex &index) const
    uat_field_t *field = indexToField(index);
    QWidget *editor = nullptr;
    switch (field->mode) {
}
void Singleton::f5();{
        hexbytes_regex.setCaseSensitivity(Qt::CaseInsensitive);
        // QString types from QStyledItemDelegate are documented to return a
        // QLineEdit. Note that Qt returns a subclass from QLineEdit which
        // automatically adapts the width to the typed contents.
        QLineEdit *le_editor = static_cast<QLineEdit *>(
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    }
    case PT_TXTMOD_COLOR:
    {
        if (qobject_cast<QColorDialog *>(editor))
        {
}
void Singleton::f2();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}
void Singleton::f3();{
        if (qobject_cast<QColorDialog *>(editor))
        {
            QColor color(index.model()->data(index, Qt::DecorationRole).toString());
            qobject_cast<QColorDialog *>(editor)->setCurrentColor(color);
        }
}
void Singleton::f4();{
QWidget *UatDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option,
                                  const QModelIndex &index) const
    uat_field_t *field = indexToField(index);
    QWidget *editor = nullptr;
    switch (field->mode) {
}
void Singleton::f5();{
        hexbytes_regex.setCaseSensitivity(Qt::CaseInsensitive);
        // QString types from QStyledItemDelegate are documented to return a
        // QLineEdit. Note that Qt returns a subclass from QLineEdit which
        // automatically adapts the width to the typed contents.
        QLineEdit *le_editor = static_cast<QLineEdit *>(
}
void Singleton::f6();{
        le_editor->setValidator(new QRegExpValidator(hexbytes_regex, le_editor));
        editor = le_editor;
        break;
    }
    case PT_TXTMOD_BOOL:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    }
    case PT_TXTMOD_COLOR:
    {
        if (qobject_cast<QColorDialog *>(editor))
        {
}
void Singleton::f2();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}
void Singleton::f3();{
        if (qobject_cast<QColorDialog *>(editor))
        {
            QColor color(index.model()->data(index, Qt::DecorationRole).toString());
            qobject_cast<QColorDialog *>(editor)->setCurrentColor(color);
        }
}
void Singleton::f4();{
QWidget *UatDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option,
                                  const QModelIndex &index) const
    uat_field_t *field = indexToField(index);
    QWidget *editor = nullptr;
    switch (field->mode) {
}
void Singleton::f5();{
        hexbytes_regex.setCaseSensitivity(Qt::CaseInsensitive);
        // QString types from QStyledItemDelegate are documented to return a
        // QLineEdit. Note that Qt returns a subclass from QLineEdit which
        // automatically adapts the width to the typed contents.
        QLineEdit *le_editor = static_cast<QLineEdit *>(
}
void Singleton::f6();{
        le_editor->setValidator(new QRegExpValidator(hexbytes_regex, le_editor));
        editor = le_editor;
        break;
    }
    case PT_TXTMOD_BOOL:
}
void Singleton::f7();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    }
    case PT_TXTMOD_COLOR:
    {
        if (qobject_cast<QColorDialog *>(editor))
        {
}
void Singleton::f2();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}
void Singleton::f3();{
        if (qobject_cast<QColorDialog *>(editor))
        {
            QColor color(index.model()->data(index, Qt::DecorationRole).toString());
            qobject_cast<QColorDialog *>(editor)->setCurrentColor(color);
        }
}
void Singleton::f4();{
QWidget *UatDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option,
                                  const QModelIndex &index) const
    uat_field_t *field = indexToField(index);
    QWidget *editor = nullptr;
    switch (field->mode) {
}
void Singleton::f5();{
        hexbytes_regex.setCaseSensitivity(Qt::CaseInsensitive);
        // QString types from QStyledItemDelegate are documented to return a
        // QLineEdit. Note that Qt returns a subclass from QLineEdit which
        // automatically adapts the width to the typed contents.
        QLineEdit *le_editor = static_cast<QLineEdit *>(
}
void Singleton::f6();{
        le_editor->setValidator(new QRegExpValidator(hexbytes_regex, le_editor));
        editor = le_editor;
        break;
    }
    case PT_TXTMOD_BOOL:
}
void Singleton::f7();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}
void Singleton::f8();{
        }
        break;
    case PT_TXTMOD_FILENAME:
        if (index.isValid()) {
            QString filename_old = index.model()->data(index, Qt::EditRole).toString();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    }
    case PT_TXTMOD_COLOR:
    {
        if (qobject_cast<QColorDialog *>(editor))
        {
}
void Singleton::f2();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}
void Singleton::f3();{
        if (qobject_cast<QColorDialog *>(editor))
        {
            QColor color(index.model()->data(index, Qt::DecorationRole).toString());
            qobject_cast<QColorDialog *>(editor)->setCurrentColor(color);
        }
}
void Singleton::f4();{
QWidget *UatDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option,
                                  const QModelIndex &index) const
    uat_field_t *field = indexToField(index);
    QWidget *editor = nullptr;
    switch (field->mode) {
}
void Singleton::f5();{
        hexbytes_regex.setCaseSensitivity(Qt::CaseInsensitive);
        // QString types from QStyledItemDelegate are documented to return a
        // QLineEdit. Note that Qt returns a subclass from QLineEdit which
        // automatically adapts the width to the typed contents.
        QLineEdit *le_editor = static_cast<QLineEdit *>(
}
void Singleton::f6();{
        le_editor->setValidator(new QRegExpValidator(hexbytes_regex, le_editor));
        editor = le_editor;
        break;
    }
    case PT_TXTMOD_BOOL:
}
void Singleton::f7();{
        break;
    }
    if (editor) {
        editor->setAutoFillBackground(true);
    }
}
void Singleton::f8();{
        }
        break;
    case PT_TXTMOD_FILENAME:
        if (index.isValid()) {
            QString filename_old = index.model()->data(index, Qt::EditRole).toString();
}
void Singleton::f9();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        /* Just redissect packets if we have any */
        wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
    }
void UatDialog::acceptChanges()
    if (!uat_model_) return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        /* Just redissect packets if we have any */
        wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
    }
void UatDialog::acceptChanges()
    if (!uat_model_) return;
}
void Singleton::f2();{
    if (!data.isNull()) {
        // use HTML instead of PlainText because that handles wordwrap properly
        ui->hintLabel->setText("<small><i>" + html_escape(data.toString()) + "</i></small>");
        return true;
    }
}
void Singleton::f3();{
void UatDialog::modelDataChanged(const QModelIndex &topLeft)
    checkForErrorHint(topLeft, QModelIndex());
    ok_button_->setEnabled(!uat_model_->hasErrors());
// Invoked after a row has been removed from the model.
void UatDialog::modelRowsRemoved()
}
void Singleton::f4();{
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
        ui->clearToolButton->setEnabled(true);
        ui->copyToolButton->setEnabled(true);
        ui->moveUpToolButton->setEnabled(current.row() != 0);
}
void Singleton::f5();{
void UatDialog::on_copyToolButton_clicked()
    addRecord(true);
void UatDialog::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
}
void Singleton::f6();{
// Invoked when a different field is selected. Note: when selecting a different
// field after editing, this event is triggered after modelDataChanged.
void UatDialog::on_uatTreeView_currentItemChanged(const QModelIndex &current, const QModelIndex &previous)
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
}
void Singleton::f7();{
void UatDialog::on_moveDownToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row < (uat_model_->rowCount() - 1)) {
        if (!uat_model_->moveRow(current_row, current_row + 1)) {
}
void Singleton::f8();{
    ui->newToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->copyToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->moveUpToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->moveDownToolButton->setAttribute(Qt::WA_MacSmallSize, true);
}
void Singleton::f9();{
bool UatDialog::trySetErrorHintFromField(const QModelIndex &index)
    const QVariant &data = uat_model_->data(index, Qt::UserRole + 1);
    if (!data.isNull()) {
        // use HTML instead of PlainText because that handles wordwrap properly
        ui->hintLabel->setText("<small><i>" + html_escape(data.toString()) + "</i></small>");
}
void Singleton::f10();{
        }
        applyChanges();
    }
void UatDialog::rejectChanges()
    if (!uat_model_) return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        /* Just redissect packets if we have any */
        wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
    }
void UatDialog::acceptChanges()
    if (!uat_model_) return;
}
void Singleton::f2();{
    if (!data.isNull()) {
        // use HTML instead of PlainText because that handles wordwrap properly
        ui->hintLabel->setText("<small><i>" + html_escape(data.toString()) + "</i></small>");
        return true;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        /* Just redissect packets if we have any */
        wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
    }
void UatDialog::acceptChanges()
    if (!uat_model_) return;
}
void Singleton::f2();{
    if (!data.isNull()) {
        // use HTML instead of PlainText because that handles wordwrap properly
        ui->hintLabel->setText("<small><i>" + html_escape(data.toString()) + "</i></small>");
        return true;
    }
}
void Singleton::f3();{
void UatDialog::modelDataChanged(const QModelIndex &topLeft)
    checkForErrorHint(topLeft, QModelIndex());
    ok_button_->setEnabled(!uat_model_->hasErrors());
// Invoked after a row has been removed from the model.
void UatDialog::modelRowsRemoved()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        /* Just redissect packets if we have any */
        wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
    }
void UatDialog::acceptChanges()
    if (!uat_model_) return;
}
void Singleton::f2();{
    if (!data.isNull()) {
        // use HTML instead of PlainText because that handles wordwrap properly
        ui->hintLabel->setText("<small><i>" + html_escape(data.toString()) + "</i></small>");
        return true;
    }
}
void Singleton::f3();{
void UatDialog::modelDataChanged(const QModelIndex &topLeft)
    checkForErrorHint(topLeft, QModelIndex());
    ok_button_->setEnabled(!uat_model_->hasErrors());
// Invoked after a row has been removed from the model.
void UatDialog::modelRowsRemoved()
}
void Singleton::f4();{
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
        ui->clearToolButton->setEnabled(true);
        ui->copyToolButton->setEnabled(true);
        ui->moveUpToolButton->setEnabled(current.row() != 0);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        /* Just redissect packets if we have any */
        wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
    }
void UatDialog::acceptChanges()
    if (!uat_model_) return;
}
void Singleton::f2();{
    if (!data.isNull()) {
        // use HTML instead of PlainText because that handles wordwrap properly
        ui->hintLabel->setText("<small><i>" + html_escape(data.toString()) + "</i></small>");
        return true;
    }
}
void Singleton::f3();{
void UatDialog::modelDataChanged(const QModelIndex &topLeft)
    checkForErrorHint(topLeft, QModelIndex());
    ok_button_->setEnabled(!uat_model_->hasErrors());
// Invoked after a row has been removed from the model.
void UatDialog::modelRowsRemoved()
}
void Singleton::f4();{
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
        ui->clearToolButton->setEnabled(true);
        ui->copyToolButton->setEnabled(true);
        ui->moveUpToolButton->setEnabled(current.row() != 0);
}
void Singleton::f5();{
void UatDialog::on_copyToolButton_clicked()
    addRecord(true);
void UatDialog::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        /* Just redissect packets if we have any */
        wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
    }
void UatDialog::acceptChanges()
    if (!uat_model_) return;
}
void Singleton::f2();{
    if (!data.isNull()) {
        // use HTML instead of PlainText because that handles wordwrap properly
        ui->hintLabel->setText("<small><i>" + html_escape(data.toString()) + "</i></small>");
        return true;
    }
}
void Singleton::f3();{
void UatDialog::modelDataChanged(const QModelIndex &topLeft)
    checkForErrorHint(topLeft, QModelIndex());
    ok_button_->setEnabled(!uat_model_->hasErrors());
// Invoked after a row has been removed from the model.
void UatDialog::modelRowsRemoved()
}
void Singleton::f4();{
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
        ui->clearToolButton->setEnabled(true);
        ui->copyToolButton->setEnabled(true);
        ui->moveUpToolButton->setEnabled(current.row() != 0);
}
void Singleton::f5();{
void UatDialog::on_copyToolButton_clicked()
    addRecord(true);
void UatDialog::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
}
void Singleton::f6();{
// Invoked when a different field is selected. Note: when selecting a different
// field after editing, this event is triggered after modelDataChanged.
void UatDialog::on_uatTreeView_currentItemChanged(const QModelIndex &current, const QModelIndex &previous)
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        /* Just redissect packets if we have any */
        wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
    }
void UatDialog::acceptChanges()
    if (!uat_model_) return;
}
void Singleton::f2();{
    if (!data.isNull()) {
        // use HTML instead of PlainText because that handles wordwrap properly
        ui->hintLabel->setText("<small><i>" + html_escape(data.toString()) + "</i></small>");
        return true;
    }
}
void Singleton::f3();{
void UatDialog::modelDataChanged(const QModelIndex &topLeft)
    checkForErrorHint(topLeft, QModelIndex());
    ok_button_->setEnabled(!uat_model_->hasErrors());
// Invoked after a row has been removed from the model.
void UatDialog::modelRowsRemoved()
}
void Singleton::f4();{
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
        ui->clearToolButton->setEnabled(true);
        ui->copyToolButton->setEnabled(true);
        ui->moveUpToolButton->setEnabled(current.row() != 0);
}
void Singleton::f5();{
void UatDialog::on_copyToolButton_clicked()
    addRecord(true);
void UatDialog::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
}
void Singleton::f6();{
// Invoked when a different field is selected. Note: when selecting a different
// field after editing, this event is triggered after modelDataChanged.
void UatDialog::on_uatTreeView_currentItemChanged(const QModelIndex &current, const QModelIndex &previous)
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
}
void Singleton::f7();{
void UatDialog::on_moveDownToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row < (uat_model_->rowCount() - 1)) {
        if (!uat_model_->moveRow(current_row, current_row + 1)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        /* Just redissect packets if we have any */
        wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
    }
void UatDialog::acceptChanges()
    if (!uat_model_) return;
}
void Singleton::f2();{
    if (!data.isNull()) {
        // use HTML instead of PlainText because that handles wordwrap properly
        ui->hintLabel->setText("<small><i>" + html_escape(data.toString()) + "</i></small>");
        return true;
    }
}
void Singleton::f3();{
void UatDialog::modelDataChanged(const QModelIndex &topLeft)
    checkForErrorHint(topLeft, QModelIndex());
    ok_button_->setEnabled(!uat_model_->hasErrors());
// Invoked after a row has been removed from the model.
void UatDialog::modelRowsRemoved()
}
void Singleton::f4();{
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
        ui->clearToolButton->setEnabled(true);
        ui->copyToolButton->setEnabled(true);
        ui->moveUpToolButton->setEnabled(current.row() != 0);
}
void Singleton::f5();{
void UatDialog::on_copyToolButton_clicked()
    addRecord(true);
void UatDialog::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
}
void Singleton::f6();{
// Invoked when a different field is selected. Note: when selecting a different
// field after editing, this event is triggered after modelDataChanged.
void UatDialog::on_uatTreeView_currentItemChanged(const QModelIndex &current, const QModelIndex &previous)
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
}
void Singleton::f7();{
void UatDialog::on_moveDownToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row < (uat_model_->rowCount() - 1)) {
        if (!uat_model_->moveRow(current_row, current_row + 1)) {
}
void Singleton::f8();{
    ui->newToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->copyToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->moveUpToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->moveDownToolButton->setAttribute(Qt::WA_MacSmallSize, true);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        /* Just redissect packets if we have any */
        wsApp->queueAppSignal(WiresharkApplication::PacketDissectionChanged);
    }
void UatDialog::acceptChanges()
    if (!uat_model_) return;
}
void Singleton::f2();{
    if (!data.isNull()) {
        // use HTML instead of PlainText because that handles wordwrap properly
        ui->hintLabel->setText("<small><i>" + html_escape(data.toString()) + "</i></small>");
        return true;
    }
}
void Singleton::f3();{
void UatDialog::modelDataChanged(const QModelIndex &topLeft)
    checkForErrorHint(topLeft, QModelIndex());
    ok_button_->setEnabled(!uat_model_->hasErrors());
// Invoked after a row has been removed from the model.
void UatDialog::modelRowsRemoved()
}
void Singleton::f4();{
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
        ui->clearToolButton->setEnabled(true);
        ui->copyToolButton->setEnabled(true);
        ui->moveUpToolButton->setEnabled(current.row() != 0);
}
void Singleton::f5();{
void UatDialog::on_copyToolButton_clicked()
    addRecord(true);
void UatDialog::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
}
void Singleton::f6();{
// Invoked when a different field is selected. Note: when selecting a different
// field after editing, this event is triggered after modelDataChanged.
void UatDialog::on_uatTreeView_currentItemChanged(const QModelIndex &current, const QModelIndex &previous)
    if (current.isValid()) {
        ui->deleteToolButton->setEnabled(true);
}
void Singleton::f7();{
void UatDialog::on_moveDownToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row < (uat_model_->rowCount() - 1)) {
        if (!uat_model_->moveRow(current_row, current_row + 1)) {
}
void Singleton::f8();{
    ui->newToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->deleteToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->copyToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->moveUpToolButton->setAttribute(Qt::WA_MacSmallSize, true);
    ui->moveDownToolButton->setAttribute(Qt::WA_MacSmallSize, true);
}
void Singleton::f9();{
bool UatDialog::trySetErrorHintFromField(const QModelIndex &index)
    const QVariant &data = uat_model_->data(index, Qt::UserRole + 1);
    if (!data.isNull()) {
        // use HTML instead of PlainText because that handles wordwrap properly
        ui->hintLabel->setText("<small><i>" + html_escape(data.toString()) + "</i></small>");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            }
        }
    }
    if (previous.isValid()) {
        if (trySetErrorHintFromField(previous)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            }
        }
    }
    if (previous.isValid()) {
        if (trySetErrorHintFromField(previous)) {
}
void Singleton::f2();{
    if (uat_model_) {
        uat_model_->clearAll();
    }
 * Editor modelines
 * Local Variables:
}
void Singleton::f3();{
    addRecord(true);
void UatFrame::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row > 0) {
}
void Singleton::f4();{
        applyChanges();
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
}
void Singleton::f5();{
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
    if (uat_model_->revertChanges(error)) {
}
void Singleton::f6();{
    if (current.isValid()) {
        if (trySetErrorHintFromField(current)) {
            return;
        }
        const int row = current.row();
}
void Singleton::f7();{
        if (!uat_model_->removeRows(current.row(), 1)) {
            qDebug() << "Failed to remove row";
        }
    }
void UatFrame::on_copyToolButton_clicked()
}
void Singleton::f8();{
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row > 0) {
        if (!uat_model_->moveRow(current_row, current_row - 1)) {
            qDebug() << "Failed to move row up";
            return;
}
void Singleton::f9();{
// Otherwise show the error from the previous field (if any).
// Otherwise clear the error hint.
void UatFrame::checkForErrorHint(const QModelIndex &current, const QModelIndex &previous)
    if (current.isValid()) {
        if (trySetErrorHintFromField(current)) {
}
void Singleton::f10();{
    delete uat_model_;
void UatFrame::setUat(epan_uat *uat)
    QString title(tr("Unknown User Accessible Table"));
    uat_ = uat;
    ui->pathLabel->clear();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            }
        }
    }
    if (previous.isValid()) {
        if (trySetErrorHintFromField(previous)) {
}
void Singleton::f2();{
    if (uat_model_) {
        uat_model_->clearAll();
    }
 * Editor modelines
 * Local Variables:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            }
        }
    }
    if (previous.isValid()) {
        if (trySetErrorHintFromField(previous)) {
}
void Singleton::f2();{
    if (uat_model_) {
        uat_model_->clearAll();
    }
 * Editor modelines
 * Local Variables:
}
void Singleton::f3();{
    addRecord(true);
void UatFrame::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row > 0) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            }
        }
    }
    if (previous.isValid()) {
        if (trySetErrorHintFromField(previous)) {
}
void Singleton::f2();{
    if (uat_model_) {
        uat_model_->clearAll();
    }
 * Editor modelines
 * Local Variables:
}
void Singleton::f3();{
    addRecord(true);
void UatFrame::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row > 0) {
}
void Singleton::f4();{
        applyChanges();
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            }
        }
    }
    if (previous.isValid()) {
        if (trySetErrorHintFromField(previous)) {
}
void Singleton::f2();{
    if (uat_model_) {
        uat_model_->clearAll();
    }
 * Editor modelines
 * Local Variables:
}
void Singleton::f3();{
    addRecord(true);
void UatFrame::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row > 0) {
}
void Singleton::f4();{
        applyChanges();
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
}
void Singleton::f5();{
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
    if (uat_model_->revertChanges(error)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            }
        }
    }
    if (previous.isValid()) {
        if (trySetErrorHintFromField(previous)) {
}
void Singleton::f2();{
    if (uat_model_) {
        uat_model_->clearAll();
    }
 * Editor modelines
 * Local Variables:
}
void Singleton::f3();{
    addRecord(true);
void UatFrame::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row > 0) {
}
void Singleton::f4();{
        applyChanges();
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
}
void Singleton::f5();{
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
    if (uat_model_->revertChanges(error)) {
}
void Singleton::f6();{
    if (current.isValid()) {
        if (trySetErrorHintFromField(current)) {
            return;
        }
        const int row = current.row();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            }
        }
    }
    if (previous.isValid()) {
        if (trySetErrorHintFromField(previous)) {
}
void Singleton::f2();{
    if (uat_model_) {
        uat_model_->clearAll();
    }
 * Editor modelines
 * Local Variables:
}
void Singleton::f3();{
    addRecord(true);
void UatFrame::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row > 0) {
}
void Singleton::f4();{
        applyChanges();
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
}
void Singleton::f5();{
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
    if (uat_model_->revertChanges(error)) {
}
void Singleton::f6();{
    if (current.isValid()) {
        if (trySetErrorHintFromField(current)) {
            return;
        }
        const int row = current.row();
}
void Singleton::f7();{
        if (!uat_model_->removeRows(current.row(), 1)) {
            qDebug() << "Failed to remove row";
        }
    }
void UatFrame::on_copyToolButton_clicked()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            }
        }
    }
    if (previous.isValid()) {
        if (trySetErrorHintFromField(previous)) {
}
void Singleton::f2();{
    if (uat_model_) {
        uat_model_->clearAll();
    }
 * Editor modelines
 * Local Variables:
}
void Singleton::f3();{
    addRecord(true);
void UatFrame::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row > 0) {
}
void Singleton::f4();{
        applyChanges();
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
}
void Singleton::f5();{
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
    if (uat_model_->revertChanges(error)) {
}
void Singleton::f6();{
    if (current.isValid()) {
        if (trySetErrorHintFromField(current)) {
            return;
        }
        const int row = current.row();
}
void Singleton::f7();{
        if (!uat_model_->removeRows(current.row(), 1)) {
            qDebug() << "Failed to remove row";
        }
    }
void UatFrame::on_copyToolButton_clicked()
}
void Singleton::f8();{
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row > 0) {
        if (!uat_model_->moveRow(current_row, current_row - 1)) {
            qDebug() << "Failed to move row up";
            return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            }
        }
    }
    if (previous.isValid()) {
        if (trySetErrorHintFromField(previous)) {
}
void Singleton::f2();{
    if (uat_model_) {
        uat_model_->clearAll();
    }
 * Editor modelines
 * Local Variables:
}
void Singleton::f3();{
    addRecord(true);
void UatFrame::on_moveUpToolButton_clicked()
    const QModelIndex &current = ui->uatTreeView->currentIndex();
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row > 0) {
}
void Singleton::f4();{
        applyChanges();
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
}
void Singleton::f5();{
    }
void UatFrame::rejectChanges()
    if (!uat_model_) return;
    QString error;
    if (uat_model_->revertChanges(error)) {
}
void Singleton::f6();{
    if (current.isValid()) {
        if (trySetErrorHintFromField(current)) {
            return;
        }
        const int row = current.row();
}
void Singleton::f7();{
        if (!uat_model_->removeRows(current.row(), 1)) {
            qDebug() << "Failed to remove row";
        }
    }
void UatFrame::on_copyToolButton_clicked()
}
void Singleton::f8();{
    int current_row = current.row();
    if (uat_model_ && current.isValid() && current_row > 0) {
        if (!uat_model_->moveRow(current_row, current_row - 1)) {
            qDebug() << "Failed to move row up";
            return;
}
void Singleton::f9();{
// Otherwise show the error from the previous field (if any).
// Otherwise clear the error hint.
void UatFrame::checkForErrorHint(const QModelIndex &current, const QModelIndex &previous)
    if (current.isValid()) {
        if (trySetErrorHintFromField(current)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        return state;
    }
    if (role == Qt::UserRole) {
        return QVariant::fromValue(static_cast<void *>(field));
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        return state;
    }
    if (role == Qt::UserRole) {
        return QVariant::fromValue(static_cast<void *>(field));
    }
}
void Singleton::f2();{
        case PT_TXTMOD_HEXBYTES:
            {
            char* temp_str = bytes_to_str(NULL, (const guint8 *) str, length);
            g_free(str);
            QString qstr(temp_str);
}
void Singleton::f3();{
        char *err;
        bool error_changed = errors.remove(col) > 0;
        if (!checkField(row, col, &err)) {
            errors.insert(col, err);
            g_free(err);
}
void Singleton::f4();{
    // will likely mark everything as invalid. Ideally validation should be
    // postponed until the row (in the view) is not selected anymore
    checkRow(row);
    dirty_records.insert(row, true);
    uat_->changed = TRUE;
}
void Singleton::f5();{
    // mark fields that fail the validation.
    if (role == Qt::BackgroundRole) {
        if (errors.contains(index.column())) {
            // TODO is it OK to color cells like this? Maybe some other marker is better?
            return QBrush("pink");
}
void Singleton::f6();{
    }
    return false;
Qt::ItemFlags UatModel::flags(const QModelIndex &index) const
    if (!index.isValid())
        return Qt::ItemFlags();
}
void Singleton::f7();{
    }
    const int row = index.row();
    void *rec = UAT_INDEX_PTR(uat_, row);
    //qDebug() << "Changing (" << row << "," << index.column() << ") from " << data(index, Qt::EditRole) << " to " << value;
    if (field->mode != PT_TXTMOD_BOOL) {
}
void Singleton::f8();{
      uat_->copy_cb(dst_record, src_record, uat_->record_size);
    } else {
      /* According to documentation of uat_copy_cb_t memcpy should be used if uat_->copy_cb is NULL */
      memcpy(dst_record, src_record, uat_->record_size);
    }
}
void Singleton::f9();{
        if (value == Qt::Checked) {
            field->cb.set(rec, "TRUE", 4, field->cbdata.set, field->fld_data);
        } else {
            field->cb.set(rec, "FALSE", 5, field->cbdata.set, field->fld_data);
        }
}
void Singleton::f10();{
    if (!index.isValid())
        return Qt::ItemFlags();
    uat_field_t *field = &uat_->fields[index.column()];
    Qt::ItemFlags flags = QAbstractTableModel::flags(index);
    if (field->mode == PT_TXTMOD_BOOL)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        return state;
    }
    if (role == Qt::UserRole) {
        return QVariant::fromValue(static_cast<void *>(field));
    }
}
void Singleton::f2();{
        case PT_TXTMOD_HEXBYTES:
            {
            char* temp_str = bytes_to_str(NULL, (const guint8 *) str, length);
            g_free(str);
            QString qstr(temp_str);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        return state;
    }
    if (role == Qt::UserRole) {
        return QVariant::fromValue(static_cast<void *>(field));
    }
}
void Singleton::f2();{
        case PT_TXTMOD_HEXBYTES:
            {
            char* temp_str = bytes_to_str(NULL, (const guint8 *) str, length);
            g_free(str);
            QString qstr(temp_str);
}
void Singleton::f3();{
        char *err;
        bool error_changed = errors.remove(col) > 0;
        if (!checkField(row, col, &err)) {
            errors.insert(col, err);
            g_free(err);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        return state;
    }
    if (role == Qt::UserRole) {
        return QVariant::fromValue(static_cast<void *>(field));
    }
}
void Singleton::f2();{
        case PT_TXTMOD_HEXBYTES:
            {
            char* temp_str = bytes_to_str(NULL, (const guint8 *) str, length);
            g_free(str);
            QString qstr(temp_str);
}
void Singleton::f3();{
        char *err;
        bool error_changed = errors.remove(col) > 0;
        if (!checkField(row, col, &err)) {
            errors.insert(col, err);
            g_free(err);
}
void Singleton::f4();{
    // will likely mark everything as invalid. Ideally validation should be
    // postponed until the row (in the view) is not selected anymore
    checkRow(row);
    dirty_records.insert(row, true);
    uat_->changed = TRUE;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        return state;
    }
    if (role == Qt::UserRole) {
        return QVariant::fromValue(static_cast<void *>(field));
    }
}
void Singleton::f2();{
        case PT_TXTMOD_HEXBYTES:
            {
            char* temp_str = bytes_to_str(NULL, (const guint8 *) str, length);
            g_free(str);
            QString qstr(temp_str);
}
void Singleton::f3();{
        char *err;
        bool error_changed = errors.remove(col) > 0;
        if (!checkField(row, col, &err)) {
            errors.insert(col, err);
            g_free(err);
}
void Singleton::f4();{
    // will likely mark everything as invalid. Ideally validation should be
    // postponed until the row (in the view) is not selected anymore
    checkRow(row);
    dirty_records.insert(row, true);
    uat_->changed = TRUE;
}
void Singleton::f5();{
    // mark fields that fail the validation.
    if (role == Qt::BackgroundRole) {
        if (errors.contains(index.column())) {
            // TODO is it OK to color cells like this? Maybe some other marker is better?
            return QBrush("pink");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        return state;
    }
    if (role == Qt::UserRole) {
        return QVariant::fromValue(static_cast<void *>(field));
    }
}
void Singleton::f2();{
        case PT_TXTMOD_HEXBYTES:
            {
            char* temp_str = bytes_to_str(NULL, (const guint8 *) str, length);
            g_free(str);
            QString qstr(temp_str);
}
void Singleton::f3();{
        char *err;
        bool error_changed = errors.remove(col) > 0;
        if (!checkField(row, col, &err)) {
            errors.insert(col, err);
            g_free(err);
}
void Singleton::f4();{
    // will likely mark everything as invalid. Ideally validation should be
    // postponed until the row (in the view) is not selected anymore
    checkRow(row);
    dirty_records.insert(row, true);
    uat_->changed = TRUE;
}
void Singleton::f5();{
    // mark fields that fail the validation.
    if (role == Qt::BackgroundRole) {
        if (errors.contains(index.column())) {
            // TODO is it OK to color cells like this? Maybe some other marker is better?
            return QBrush("pink");
}
void Singleton::f6();{
    }
    return false;
Qt::ItemFlags UatModel::flags(const QModelIndex &index) const
    if (!index.isValid())
        return Qt::ItemFlags();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        return state;
    }
    if (role == Qt::UserRole) {
        return QVariant::fromValue(static_cast<void *>(field));
    }
}
void Singleton::f2();{
        case PT_TXTMOD_HEXBYTES:
            {
            char* temp_str = bytes_to_str(NULL, (const guint8 *) str, length);
            g_free(str);
            QString qstr(temp_str);
}
void Singleton::f3();{
        char *err;
        bool error_changed = errors.remove(col) > 0;
        if (!checkField(row, col, &err)) {
            errors.insert(col, err);
            g_free(err);
}
void Singleton::f4();{
    // will likely mark everything as invalid. Ideally validation should be
    // postponed until the row (in the view) is not selected anymore
    checkRow(row);
    dirty_records.insert(row, true);
    uat_->changed = TRUE;
}
void Singleton::f5();{
    // mark fields that fail the validation.
    if (role == Qt::BackgroundRole) {
        if (errors.contains(index.column())) {
            // TODO is it OK to color cells like this? Maybe some other marker is better?
            return QBrush("pink");
}
void Singleton::f6();{
    }
    return false;
Qt::ItemFlags UatModel::flags(const QModelIndex &index) const
    if (!index.isValid())
        return Qt::ItemFlags();
}
void Singleton::f7();{
    }
    const int row = index.row();
    void *rec = UAT_INDEX_PTR(uat_, row);
    //qDebug() << "Changing (" << row << "," << index.column() << ") from " << data(index, Qt::EditRole) << " to " << value;
    if (field->mode != PT_TXTMOD_BOOL) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        return state;
    }
    if (role == Qt::UserRole) {
        return QVariant::fromValue(static_cast<void *>(field));
    }
}
void Singleton::f2();{
        case PT_TXTMOD_HEXBYTES:
            {
            char* temp_str = bytes_to_str(NULL, (const guint8 *) str, length);
            g_free(str);
            QString qstr(temp_str);
}
void Singleton::f3();{
        char *err;
        bool error_changed = errors.remove(col) > 0;
        if (!checkField(row, col, &err)) {
            errors.insert(col, err);
            g_free(err);
}
void Singleton::f4();{
    // will likely mark everything as invalid. Ideally validation should be
    // postponed until the row (in the view) is not selected anymore
    checkRow(row);
    dirty_records.insert(row, true);
    uat_->changed = TRUE;
}
void Singleton::f5();{
    // mark fields that fail the validation.
    if (role == Qt::BackgroundRole) {
        if (errors.contains(index.column())) {
            // TODO is it OK to color cells like this? Maybe some other marker is better?
            return QBrush("pink");
}
void Singleton::f6();{
    }
    return false;
Qt::ItemFlags UatModel::flags(const QModelIndex &index) const
    if (!index.isValid())
        return Qt::ItemFlags();
}
void Singleton::f7();{
    }
    const int row = index.row();
    void *rec = UAT_INDEX_PTR(uat_, row);
    //qDebug() << "Changing (" << row << "," << index.column() << ") from " << data(index, Qt::EditRole) << " to " << value;
    if (field->mode != PT_TXTMOD_BOOL) {
}
void Singleton::f8();{
      uat_->copy_cb(dst_record, src_record, uat_->record_size);
    } else {
      /* According to documentation of uat_copy_cb_t memcpy should be used if uat_->copy_cb is NULL */
      memcpy(dst_record, src_record, uat_->record_size);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        return state;
    }
    if (role == Qt::UserRole) {
        return QVariant::fromValue(static_cast<void *>(field));
    }
}
void Singleton::f2();{
        case PT_TXTMOD_HEXBYTES:
            {
            char* temp_str = bytes_to_str(NULL, (const guint8 *) str, length);
            g_free(str);
            QString qstr(temp_str);
}
void Singleton::f3();{
        char *err;
        bool error_changed = errors.remove(col) > 0;
        if (!checkField(row, col, &err)) {
            errors.insert(col, err);
            g_free(err);
}
void Singleton::f4();{
    // will likely mark everything as invalid. Ideally validation should be
    // postponed until the row (in the view) is not selected anymore
    checkRow(row);
    dirty_records.insert(row, true);
    uat_->changed = TRUE;
}
void Singleton::f5();{
    // mark fields that fail the validation.
    if (role == Qt::BackgroundRole) {
        if (errors.contains(index.column())) {
            // TODO is it OK to color cells like this? Maybe some other marker is better?
            return QBrush("pink");
}
void Singleton::f6();{
    }
    return false;
Qt::ItemFlags UatModel::flags(const QModelIndex &index) const
    if (!index.isValid())
        return Qt::ItemFlags();
}
void Singleton::f7();{
    }
    const int row = index.row();
    void *rec = UAT_INDEX_PTR(uat_, row);
    //qDebug() << "Changing (" << row << "," << index.column() << ") from " << data(index, Qt::EditRole) << " to " << value;
    if (field->mode != PT_TXTMOD_BOOL) {
}
void Singleton::f8();{
      uat_->copy_cb(dst_record, src_record, uat_->record_size);
    } else {
      /* According to documentation of uat_copy_cb_t memcpy should be used if uat_->copy_cb is NULL */
      memcpy(dst_record, src_record, uat_->record_size);
    }
}
void Singleton::f9();{
        if (value == Qt::Checked) {
            field->cb.set(rec, "TRUE", 4, field->cbdata.set, field->fld_data);
        } else {
            field->cb.set(rec, "FALSE", 5, field->cbdata.set, field->fld_data);
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
}
void Singleton::f3();{
    emit reset();
void GuiHandler::addLogMessage(QString message)
    emit logChanged(message);
void GuiHandler::setToolbar(ext_toolbar_t * toolbar)
    _toolbar = toolbar;
}
void Singleton::f4();{
    }
    return instance;
void GuiHandler::showAboutDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_About * mainwindow = new PluginIFDemo_About();
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    executeDialog((QDialog*)mainwindow);
void GuiHandler::showMainDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_Main * mainwindow = new PluginIFDemo_Main();
    mainwindow->setToolbar(_toolbar);
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f7();{
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
    static GuiHandler * instance = 0;
}
void Singleton::f8();{
    }
    return instance;
void GuiHandler::showAboutDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_About * mainwindow = new PluginIFDemo_About();
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f9();{
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
    static GuiHandler * instance = 0;
    QMutexLocker locker(singletonMutex);
}
void Singleton::f10();{
    bool hasGuiApp = (qobject_cast<QApplication*>(QCoreApplication::instance())!=0);
    if ( ! hasGuiApp )
    {
        /* Necessity for creating the correct app context */
        int argc = 1;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
}
void Singleton::f3();{
    emit reset();
void GuiHandler::addLogMessage(QString message)
    emit logChanged(message);
void GuiHandler::setToolbar(ext_toolbar_t * toolbar)
    _toolbar = toolbar;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
}
void Singleton::f3();{
    emit reset();
void GuiHandler::addLogMessage(QString message)
    emit logChanged(message);
void GuiHandler::setToolbar(ext_toolbar_t * toolbar)
    _toolbar = toolbar;
}
void Singleton::f4();{
    }
    return instance;
void GuiHandler::showAboutDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_About * mainwindow = new PluginIFDemo_About();
    executeDialog((QDialog*)mainwindow);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
}
void Singleton::f3();{
    emit reset();
void GuiHandler::addLogMessage(QString message)
    emit logChanged(message);
void GuiHandler::setToolbar(ext_toolbar_t * toolbar)
    _toolbar = toolbar;
}
void Singleton::f4();{
    }
    return instance;
void GuiHandler::showAboutDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_About * mainwindow = new PluginIFDemo_About();
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
}
void Singleton::f3();{
    emit reset();
void GuiHandler::addLogMessage(QString message)
    emit logChanged(message);
void GuiHandler::setToolbar(ext_toolbar_t * toolbar)
    _toolbar = toolbar;
}
void Singleton::f4();{
    }
    return instance;
void GuiHandler::showAboutDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_About * mainwindow = new PluginIFDemo_About();
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    executeDialog((QDialog*)mainwindow);
void GuiHandler::showMainDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_Main * mainwindow = new PluginIFDemo_Main();
    mainwindow->setToolbar(_toolbar);
    executeDialog((QDialog*)mainwindow);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
}
void Singleton::f3();{
    emit reset();
void GuiHandler::addLogMessage(QString message)
    emit logChanged(message);
void GuiHandler::setToolbar(ext_toolbar_t * toolbar)
    _toolbar = toolbar;
}
void Singleton::f4();{
    }
    return instance;
void GuiHandler::showAboutDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_About * mainwindow = new PluginIFDemo_About();
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    executeDialog((QDialog*)mainwindow);
void GuiHandler::showMainDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_Main * mainwindow = new PluginIFDemo_Main();
    mainwindow->setToolbar(_toolbar);
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f7();{
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
    static GuiHandler * instance = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
}
void Singleton::f3();{
    emit reset();
void GuiHandler::addLogMessage(QString message)
    emit logChanged(message);
void GuiHandler::setToolbar(ext_toolbar_t * toolbar)
    _toolbar = toolbar;
}
void Singleton::f4();{
    }
    return instance;
void GuiHandler::showAboutDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_About * mainwindow = new PluginIFDemo_About();
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    executeDialog((QDialog*)mainwindow);
void GuiHandler::showMainDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_Main * mainwindow = new PluginIFDemo_Main();
    mainwindow->setToolbar(_toolbar);
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f7();{
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
    static GuiHandler * instance = 0;
}
void Singleton::f8();{
    }
    return instance;
void GuiHandler::showAboutDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_About * mainwindow = new PluginIFDemo_About();
    executeDialog((QDialog*)mainwindow);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
}
void Singleton::f2();{
 * Wireshark - Network traffic analyzer
 * By Gerald Combs <gerald@wireshark.org>
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
}
void Singleton::f3();{
    emit reset();
void GuiHandler::addLogMessage(QString message)
    emit logChanged(message);
void GuiHandler::setToolbar(ext_toolbar_t * toolbar)
    _toolbar = toolbar;
}
void Singleton::f4();{
    }
    return instance;
void GuiHandler::showAboutDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_About * mainwindow = new PluginIFDemo_About();
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f5();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f6();{
    executeDialog((QDialog*)mainwindow);
void GuiHandler::showMainDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_Main * mainwindow = new PluginIFDemo_Main();
    mainwindow->setToolbar(_toolbar);
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f7();{
 * SPDX-License-Identifier: GPL-2.0-or-later
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
    static GuiHandler * instance = 0;
}
void Singleton::f8();{
    }
    return instance;
void GuiHandler::showAboutDialog(ext_menubar_gui_type gui_type _U_, gpointer gui_data _U_)
    PluginIFDemo_About * mainwindow = new PluginIFDemo_About();
    executeDialog((QDialog*)mainwindow);
}
void Singleton::f9();{
QMutex * GuiHandler::singletonMutex = new QMutex();
GuiHandler::GuiHandler()
GuiHandler * GuiHandler::getInstance()
    static GuiHandler * instance = 0;
    QMutexLocker locker(singletonMutex);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                        h245_add = gxx_list_data(h245_address_t *, listb);
                        g_string_append_printf(filter_string_fwd,
                            " || (ip.addr == %s && tcp.port == %d && h245)",
                            address_to_qstring(&h245_add->h245_address), h245_add->h245_port);
                        listb = gxx_list_next(listb);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                        h245_add = gxx_list_data(h245_address_t *, listb);
                        g_string_append_printf(filter_string_fwd,
                            " || (ip.addr == %s && tcp.port == %d && h245)",
                            address_to_qstring(&h245_add->h245_address), h245_add->h245_port);
                        listb = gxx_list_next(listb);
}
void Singleton::f2();{
    parent_(parent),
    voip_calls_tap_listeners_removed_(false)
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 2 / 3);
    // Create the model that stores the actual data and the proxy model that is
}
void Singleton::f3();{
    voip_calls_reset_all_taps(&tapinfo_);
    if (!voip_calls_tap_listeners_removed_) {
        voip_calls_remove_all_tap_listeners(&tapinfo_);
        voip_calls_tap_listeners_removed_ = true;
    }
}
void Singleton::f4();{
                        listb = gxx_list_next(listb);
                    }
                    g_string_append_printf(filter_string_fwd, ")");
                }
                    break;
}
void Singleton::f5();{
    RtpPlayerDialog *rtp_player_dialog = new RtpPlayerDialog(*this, cap_file_);
    foreach (QModelIndex index, ui->callTreeView->selectionModel()->selectedIndexes()) {
        voip_calls_info_t *vci = VoipCallsInfoModel::indexToCallInfo(index);
        if (!vci) continue;
        for (GList *rsi_entry = g_list_first(tapinfo_.rtpstream_list); rsi_entry; rsi_entry = gxx_list_next(rsi_entry)) {
}
void Singleton::f6();{
    }
    QString filter_str;
    QSet<guint16> selected_calls;
    QString frame_numbers;
    QList<int> rows;
}
void Singleton::f7();{
    tapinfo_.h225_cstype = H225_OTHER;
    tapinfo_.fs_option = all_flows ? FLOW_ALL : FLOW_ONLY_INVITES; /* flow show option */
    tapinfo_.graph_analysis = sequence_analysis_info_new();
    tapinfo_.graph_analysis->name = "voip";
    sequence_info_ = new SequenceInfo(tapinfo_.graph_analysis);
}
void Singleton::f8();{
                        "(sip.Call-ID == \"%s\")",
                        sipinfo->call_identifier
                    );
                    break;
                case VOIP_ISUP:
}
void Singleton::f9();{
    tapinfo_.h225_cstype = H225_OTHER;
    tapinfo_.fs_option = all_flows ? FLOW_ALL : FLOW_ONLY_INVITES; /* flow show option */
    tapinfo_.graph_analysis = sequence_analysis_info_new();
    tapinfo_.graph_analysis->name = "voip";
    sequence_info_ = new SequenceInfo(tapinfo_.graph_analysis);
}
void Singleton::f10();{
                    g_string_append_printf(filter_string_fwd,
                        "(frame)");
                    break;
                }
                is_first = FALSE;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                        h245_add = gxx_list_data(h245_address_t *, listb);
                        g_string_append_printf(filter_string_fwd,
                            " || (ip.addr == %s && tcp.port == %d && h245)",
                            address_to_qstring(&h245_add->h245_address), h245_add->h245_port);
                        listb = gxx_list_next(listb);
}
void Singleton::f2();{
    parent_(parent),
    voip_calls_tap_listeners_removed_(false)
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 2 / 3);
    // Create the model that stores the actual data and the proxy model that is
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                        h245_add = gxx_list_data(h245_address_t *, listb);
                        g_string_append_printf(filter_string_fwd,
                            " || (ip.addr == %s && tcp.port == %d && h245)",
                            address_to_qstring(&h245_add->h245_address), h245_add->h245_port);
                        listb = gxx_list_next(listb);
}
void Singleton::f2();{
    parent_(parent),
    voip_calls_tap_listeners_removed_(false)
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 2 / 3);
    // Create the model that stores the actual data and the proxy model that is
}
void Singleton::f3();{
    voip_calls_reset_all_taps(&tapinfo_);
    if (!voip_calls_tap_listeners_removed_) {
        voip_calls_remove_all_tap_listeners(&tapinfo_);
        voip_calls_tap_listeners_removed_ = true;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                        h245_add = gxx_list_data(h245_address_t *, listb);
                        g_string_append_printf(filter_string_fwd,
                            " || (ip.addr == %s && tcp.port == %d && h245)",
                            address_to_qstring(&h245_add->h245_address), h245_add->h245_port);
                        listb = gxx_list_next(listb);
}
void Singleton::f2();{
    parent_(parent),
    voip_calls_tap_listeners_removed_(false)
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 2 / 3);
    // Create the model that stores the actual data and the proxy model that is
}
void Singleton::f3();{
    voip_calls_reset_all_taps(&tapinfo_);
    if (!voip_calls_tap_listeners_removed_) {
        voip_calls_remove_all_tap_listeners(&tapinfo_);
        voip_calls_tap_listeners_removed_ = true;
    }
}
void Singleton::f4();{
                        listb = gxx_list_next(listb);
                    }
                    g_string_append_printf(filter_string_fwd, ")");
                }
                    break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                        h245_add = gxx_list_data(h245_address_t *, listb);
                        g_string_append_printf(filter_string_fwd,
                            " || (ip.addr == %s && tcp.port == %d && h245)",
                            address_to_qstring(&h245_add->h245_address), h245_add->h245_port);
                        listb = gxx_list_next(listb);
}
void Singleton::f2();{
    parent_(parent),
    voip_calls_tap_listeners_removed_(false)
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 2 / 3);
    // Create the model that stores the actual data and the proxy model that is
}
void Singleton::f3();{
    voip_calls_reset_all_taps(&tapinfo_);
    if (!voip_calls_tap_listeners_removed_) {
        voip_calls_remove_all_tap_listeners(&tapinfo_);
        voip_calls_tap_listeners_removed_ = true;
    }
}
void Singleton::f4();{
                        listb = gxx_list_next(listb);
                    }
                    g_string_append_printf(filter_string_fwd, ")");
                }
                    break;
}
void Singleton::f5();{
    RtpPlayerDialog *rtp_player_dialog = new RtpPlayerDialog(*this, cap_file_);
    foreach (QModelIndex index, ui->callTreeView->selectionModel()->selectedIndexes()) {
        voip_calls_info_t *vci = VoipCallsInfoModel::indexToCallInfo(index);
        if (!vci) continue;
        for (GList *rsi_entry = g_list_first(tapinfo_.rtpstream_list); rsi_entry; rsi_entry = gxx_list_next(rsi_entry)) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                        h245_add = gxx_list_data(h245_address_t *, listb);
                        g_string_append_printf(filter_string_fwd,
                            " || (ip.addr == %s && tcp.port == %d && h245)",
                            address_to_qstring(&h245_add->h245_address), h245_add->h245_port);
                        listb = gxx_list_next(listb);
}
void Singleton::f2();{
    parent_(parent),
    voip_calls_tap_listeners_removed_(false)
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 2 / 3);
    // Create the model that stores the actual data and the proxy model that is
}
void Singleton::f3();{
    voip_calls_reset_all_taps(&tapinfo_);
    if (!voip_calls_tap_listeners_removed_) {
        voip_calls_remove_all_tap_listeners(&tapinfo_);
        voip_calls_tap_listeners_removed_ = true;
    }
}
void Singleton::f4();{
                        listb = gxx_list_next(listb);
                    }
                    g_string_append_printf(filter_string_fwd, ")");
                }
                    break;
}
void Singleton::f5();{
    RtpPlayerDialog *rtp_player_dialog = new RtpPlayerDialog(*this, cap_file_);
    foreach (QModelIndex index, ui->callTreeView->selectionModel()->selectedIndexes()) {
        voip_calls_info_t *vci = VoipCallsInfoModel::indexToCallInfo(index);
        if (!vci) continue;
        for (GList *rsi_entry = g_list_first(tapinfo_.rtpstream_list); rsi_entry; rsi_entry = gxx_list_next(rsi_entry)) {
}
void Singleton::f6();{
    }
    QString filter_str;
    QSet<guint16> selected_calls;
    QString frame_numbers;
    QList<int> rows;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                        h245_add = gxx_list_data(h245_address_t *, listb);
                        g_string_append_printf(filter_string_fwd,
                            " || (ip.addr == %s && tcp.port == %d && h245)",
                            address_to_qstring(&h245_add->h245_address), h245_add->h245_port);
                        listb = gxx_list_next(listb);
}
void Singleton::f2();{
    parent_(parent),
    voip_calls_tap_listeners_removed_(false)
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 2 / 3);
    // Create the model that stores the actual data and the proxy model that is
}
void Singleton::f3();{
    voip_calls_reset_all_taps(&tapinfo_);
    if (!voip_calls_tap_listeners_removed_) {
        voip_calls_remove_all_tap_listeners(&tapinfo_);
        voip_calls_tap_listeners_removed_ = true;
    }
}
void Singleton::f4();{
                        listb = gxx_list_next(listb);
                    }
                    g_string_append_printf(filter_string_fwd, ")");
                }
                    break;
}
void Singleton::f5();{
    RtpPlayerDialog *rtp_player_dialog = new RtpPlayerDialog(*this, cap_file_);
    foreach (QModelIndex index, ui->callTreeView->selectionModel()->selectedIndexes()) {
        voip_calls_info_t *vci = VoipCallsInfoModel::indexToCallInfo(index);
        if (!vci) continue;
        for (GList *rsi_entry = g_list_first(tapinfo_.rtpstream_list); rsi_entry; rsi_entry = gxx_list_next(rsi_entry)) {
}
void Singleton::f6();{
    }
    QString filter_str;
    QSet<guint16> selected_calls;
    QString frame_numbers;
    QList<int> rows;
}
void Singleton::f7();{
    tapinfo_.h225_cstype = H225_OTHER;
    tapinfo_.fs_option = all_flows ? FLOW_ALL : FLOW_ONLY_INVITES; /* flow show option */
    tapinfo_.graph_analysis = sequence_analysis_info_new();
    tapinfo_.graph_analysis->name = "voip";
    sequence_info_ = new SequenceInfo(tapinfo_.graph_analysis);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                        h245_add = gxx_list_data(h245_address_t *, listb);
                        g_string_append_printf(filter_string_fwd,
                            " || (ip.addr == %s && tcp.port == %d && h245)",
                            address_to_qstring(&h245_add->h245_address), h245_add->h245_port);
                        listb = gxx_list_next(listb);
}
void Singleton::f2();{
    parent_(parent),
    voip_calls_tap_listeners_removed_(false)
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 2 / 3);
    // Create the model that stores the actual data and the proxy model that is
}
void Singleton::f3();{
    voip_calls_reset_all_taps(&tapinfo_);
    if (!voip_calls_tap_listeners_removed_) {
        voip_calls_remove_all_tap_listeners(&tapinfo_);
        voip_calls_tap_listeners_removed_ = true;
    }
}
void Singleton::f4();{
                        listb = gxx_list_next(listb);
                    }
                    g_string_append_printf(filter_string_fwd, ")");
                }
                    break;
}
void Singleton::f5();{
    RtpPlayerDialog *rtp_player_dialog = new RtpPlayerDialog(*this, cap_file_);
    foreach (QModelIndex index, ui->callTreeView->selectionModel()->selectedIndexes()) {
        voip_calls_info_t *vci = VoipCallsInfoModel::indexToCallInfo(index);
        if (!vci) continue;
        for (GList *rsi_entry = g_list_first(tapinfo_.rtpstream_list); rsi_entry; rsi_entry = gxx_list_next(rsi_entry)) {
}
void Singleton::f6();{
    }
    QString filter_str;
    QSet<guint16> selected_calls;
    QString frame_numbers;
    QList<int> rows;
}
void Singleton::f7();{
    tapinfo_.h225_cstype = H225_OTHER;
    tapinfo_.fs_option = all_flows ? FLOW_ALL : FLOW_ONLY_INVITES; /* flow show option */
    tapinfo_.graph_analysis = sequence_analysis_info_new();
    tapinfo_.graph_analysis->name = "voip";
    sequence_info_ = new SequenceInfo(tapinfo_.graph_analysis);
}
void Singleton::f8();{
                        "(sip.Call-ID == \"%s\")",
                        sipinfo->call_identifier
                    );
                    break;
                case VOIP_ISUP:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                        h245_add = gxx_list_data(h245_address_t *, listb);
                        g_string_append_printf(filter_string_fwd,
                            " || (ip.addr == %s && tcp.port == %d && h245)",
                            address_to_qstring(&h245_add->h245_address), h245_add->h245_port);
                        listb = gxx_list_next(listb);
}
void Singleton::f2();{
    parent_(parent),
    voip_calls_tap_listeners_removed_(false)
    ui->setupUi(this);
    loadGeometry(parent.width() * 4 / 5, parent.height() * 2 / 3);
    // Create the model that stores the actual data and the proxy model that is
}
void Singleton::f3();{
    voip_calls_reset_all_taps(&tapinfo_);
    if (!voip_calls_tap_listeners_removed_) {
        voip_calls_remove_all_tap_listeners(&tapinfo_);
        voip_calls_tap_listeners_removed_ = true;
    }
}
void Singleton::f4();{
                        listb = gxx_list_next(listb);
                    }
                    g_string_append_printf(filter_string_fwd, ")");
                }
                    break;
}
void Singleton::f5();{
    RtpPlayerDialog *rtp_player_dialog = new RtpPlayerDialog(*this, cap_file_);
    foreach (QModelIndex index, ui->callTreeView->selectionModel()->selectedIndexes()) {
        voip_calls_info_t *vci = VoipCallsInfoModel::indexToCallInfo(index);
        if (!vci) continue;
        for (GList *rsi_entry = g_list_first(tapinfo_.rtpstream_list); rsi_entry; rsi_entry = gxx_list_next(rsi_entry)) {
}
void Singleton::f6();{
    }
    QString filter_str;
    QSet<guint16> selected_calls;
    QString frame_numbers;
    QList<int> rows;
}
void Singleton::f7();{
    tapinfo_.h225_cstype = H225_OTHER;
    tapinfo_.fs_option = all_flows ? FLOW_ALL : FLOW_ONLY_INVITES; /* flow show option */
    tapinfo_.graph_analysis = sequence_analysis_info_new();
    tapinfo_.graph_analysis->name = "voip";
    sequence_info_ = new SequenceInfo(tapinfo_.graph_analysis);
}
void Singleton::f8();{
                        "(sip.Call-ID == \"%s\")",
                        sipinfo->call_identifier
                    );
                    break;
                case VOIP_ISUP:
}
void Singleton::f9();{
    tapinfo_.h225_cstype = H225_OTHER;
    tapinfo_.fs_option = all_flows ? FLOW_ALL : FLOW_ONLY_INVITES; /* flow show option */
    tapinfo_.graph_analysis = sequence_analysis_info_new();
    tapinfo_.graph_analysis->name = "voip";
    sequence_info_ = new SequenceInfo(tapinfo_.graph_analysis);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
            }
            return tr("Tunneling: %1  Fast Start: %2")
                    .arg(h323_info->is_h245Tunneling ? on_str : off_str)
                    .arg(flag ? on_str : off_str);
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
            }
            return tr("Tunneling: %1  Fast Start: %2")
                    .arg(h323_info->is_h245Tunneling ? on_str : off_str)
                    .arg(flag ? on_str : off_str);
        }
}
void Singleton::f2();{
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
                callinfos_.push_back(call_info);
                cur_call = gxx_list_next(cur_call);
            }
}
void Singleton::f3();{
        }
            break;
        case VOIP_H323:
        {
            h323_calls_info_t *h323_info = (h323_calls_info_t *)call_info->prot_info;
}
void Singleton::f4();{
            g_assert_not_reached();
        }
    }
    return QVariant();
int VoipCallsInfoModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f5();{
        guint extra = g_list_length(cur_call);
        if (extra > 0) {
            beginInsertRows(QModelIndex(), rowCount(), rowCount() + extra - 1);
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
}
void Singleton::f6();{
    voip_calls_info_t *b = VoipCallsInfoModel::indexToCallInfo(source_right);
    if (a && b) {
        switch (source_left.column()) {
        case VoipCallsInfoModel::StartTime:
            return nstime_cmp(&(a->start_rel_ts), &(b->start_rel_ts)) < 0;
}
void Singleton::f7();{
bool VoipCallsInfoSortedModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    voip_calls_info_t *a = VoipCallsInfoModel::indexToCallInfo(source_left);
    voip_calls_info_t *b = VoipCallsInfoModel::indexToCallInfo(source_right);
    if (a && b) {
        switch (source_left.column()) {
}
void Singleton::f8();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f9();{
        case VoipCallsInfoModel::StopTime:
            return nstime_cmp(&(a->stop_rel_ts), &(b->stop_rel_ts)) < 0;
        case VoipCallsInfoModel::InitialSpeaker:
            return cmp_address(&(a->initial_speaker), &(b->initial_speaker)) < 0;
        }
}
void Singleton::f10();{
        GList *cur_call = g_queue_peek_nth_link(callsinfos, rowCount());
        guint extra = g_list_length(cur_call);
        if (extra > 0) {
            beginInsertRows(QModelIndex(), rowCount(), rowCount() + extra - 1);
            while (cur_call && cur_call->data) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
            }
            return tr("Tunneling: %1  Fast Start: %2")
                    .arg(h323_info->is_h245Tunneling ? on_str : off_str)
                    .arg(flag ? on_str : off_str);
        }
}
void Singleton::f2();{
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
                callinfos_.push_back(call_info);
                cur_call = gxx_list_next(cur_call);
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
            }
            return tr("Tunneling: %1  Fast Start: %2")
                    .arg(h323_info->is_h245Tunneling ? on_str : off_str)
                    .arg(flag ? on_str : off_str);
        }
}
void Singleton::f2();{
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
                callinfos_.push_back(call_info);
                cur_call = gxx_list_next(cur_call);
            }
}
void Singleton::f3();{
        }
            break;
        case VOIP_H323:
        {
            h323_calls_info_t *h323_info = (h323_calls_info_t *)call_info->prot_info;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
            }
            return tr("Tunneling: %1  Fast Start: %2")
                    .arg(h323_info->is_h245Tunneling ? on_str : off_str)
                    .arg(flag ? on_str : off_str);
        }
}
void Singleton::f2();{
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
                callinfos_.push_back(call_info);
                cur_call = gxx_list_next(cur_call);
            }
}
void Singleton::f3();{
        }
            break;
        case VOIP_H323:
        {
            h323_calls_info_t *h323_info = (h323_calls_info_t *)call_info->prot_info;
}
void Singleton::f4();{
            g_assert_not_reached();
        }
    }
    return QVariant();
int VoipCallsInfoModel::rowCount(const QModelIndex &parent) const
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
            }
            return tr("Tunneling: %1  Fast Start: %2")
                    .arg(h323_info->is_h245Tunneling ? on_str : off_str)
                    .arg(flag ? on_str : off_str);
        }
}
void Singleton::f2();{
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
                callinfos_.push_back(call_info);
                cur_call = gxx_list_next(cur_call);
            }
}
void Singleton::f3();{
        }
            break;
        case VOIP_H323:
        {
            h323_calls_info_t *h323_info = (h323_calls_info_t *)call_info->prot_info;
}
void Singleton::f4();{
            g_assert_not_reached();
        }
    }
    return QVariant();
int VoipCallsInfoModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f5();{
        guint extra = g_list_length(cur_call);
        if (extra > 0) {
            beginInsertRows(QModelIndex(), rowCount(), rowCount() + extra - 1);
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
            }
            return tr("Tunneling: %1  Fast Start: %2")
                    .arg(h323_info->is_h245Tunneling ? on_str : off_str)
                    .arg(flag ? on_str : off_str);
        }
}
void Singleton::f2();{
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
                callinfos_.push_back(call_info);
                cur_call = gxx_list_next(cur_call);
            }
}
void Singleton::f3();{
        }
            break;
        case VOIP_H323:
        {
            h323_calls_info_t *h323_info = (h323_calls_info_t *)call_info->prot_info;
}
void Singleton::f4();{
            g_assert_not_reached();
        }
    }
    return QVariant();
int VoipCallsInfoModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f5();{
        guint extra = g_list_length(cur_call);
        if (extra > 0) {
            beginInsertRows(QModelIndex(), rowCount(), rowCount() + extra - 1);
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
}
void Singleton::f6();{
    voip_calls_info_t *b = VoipCallsInfoModel::indexToCallInfo(source_right);
    if (a && b) {
        switch (source_left.column()) {
        case VoipCallsInfoModel::StartTime:
            return nstime_cmp(&(a->start_rel_ts), &(b->start_rel_ts)) < 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
            }
            return tr("Tunneling: %1  Fast Start: %2")
                    .arg(h323_info->is_h245Tunneling ? on_str : off_str)
                    .arg(flag ? on_str : off_str);
        }
}
void Singleton::f2();{
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
                callinfos_.push_back(call_info);
                cur_call = gxx_list_next(cur_call);
            }
}
void Singleton::f3();{
        }
            break;
        case VOIP_H323:
        {
            h323_calls_info_t *h323_info = (h323_calls_info_t *)call_info->prot_info;
}
void Singleton::f4();{
            g_assert_not_reached();
        }
    }
    return QVariant();
int VoipCallsInfoModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f5();{
        guint extra = g_list_length(cur_call);
        if (extra > 0) {
            beginInsertRows(QModelIndex(), rowCount(), rowCount() + extra - 1);
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
}
void Singleton::f6();{
    voip_calls_info_t *b = VoipCallsInfoModel::indexToCallInfo(source_right);
    if (a && b) {
        switch (source_left.column()) {
        case VoipCallsInfoModel::StartTime:
            return nstime_cmp(&(a->start_rel_ts), &(b->start_rel_ts)) < 0;
}
void Singleton::f7();{
bool VoipCallsInfoSortedModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    voip_calls_info_t *a = VoipCallsInfoModel::indexToCallInfo(source_left);
    voip_calls_info_t *b = VoipCallsInfoModel::indexToCallInfo(source_right);
    if (a && b) {
        switch (source_left.column()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
            }
            return tr("Tunneling: %1  Fast Start: %2")
                    .arg(h323_info->is_h245Tunneling ? on_str : off_str)
                    .arg(flag ? on_str : off_str);
        }
}
void Singleton::f2();{
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
                callinfos_.push_back(call_info);
                cur_call = gxx_list_next(cur_call);
            }
}
void Singleton::f3();{
        }
            break;
        case VOIP_H323:
        {
            h323_calls_info_t *h323_info = (h323_calls_info_t *)call_info->prot_info;
}
void Singleton::f4();{
            g_assert_not_reached();
        }
    }
    return QVariant();
int VoipCallsInfoModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f5();{
        guint extra = g_list_length(cur_call);
        if (extra > 0) {
            beginInsertRows(QModelIndex(), rowCount(), rowCount() + extra - 1);
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
}
void Singleton::f6();{
    voip_calls_info_t *b = VoipCallsInfoModel::indexToCallInfo(source_right);
    if (a && b) {
        switch (source_left.column()) {
        case VoipCallsInfoModel::StartTime:
            return nstime_cmp(&(a->start_rel_ts), &(b->start_rel_ts)) < 0;
}
void Singleton::f7();{
bool VoipCallsInfoSortedModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    voip_calls_info_t *a = VoipCallsInfoModel::indexToCallInfo(source_left);
    voip_calls_info_t *b = VoipCallsInfoModel::indexToCallInfo(source_right);
    if (a && b) {
        switch (source_left.column()) {
}
void Singleton::f8();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
            }
            return tr("Tunneling: %1  Fast Start: %2")
                    .arg(h323_info->is_h245Tunneling ? on_str : off_str)
                    .arg(flag ? on_str : off_str);
        }
}
void Singleton::f2();{
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
                callinfos_.push_back(call_info);
                cur_call = gxx_list_next(cur_call);
            }
}
void Singleton::f3();{
        }
            break;
        case VOIP_H323:
        {
            h323_calls_info_t *h323_info = (h323_calls_info_t *)call_info->prot_info;
}
void Singleton::f4();{
            g_assert_not_reached();
        }
    }
    return QVariant();
int VoipCallsInfoModel::rowCount(const QModelIndex &parent) const
}
void Singleton::f5();{
        guint extra = g_list_length(cur_call);
        if (extra > 0) {
            beginInsertRows(QModelIndex(), rowCount(), rowCount() + extra - 1);
            while (cur_call && cur_call->data) {
                voip_calls_info_t *call_info = gxx_list_data(voip_calls_info_t*, cur_call);
}
void Singleton::f6();{
    voip_calls_info_t *b = VoipCallsInfoModel::indexToCallInfo(source_right);
    if (a && b) {
        switch (source_left.column()) {
        case VoipCallsInfoModel::StartTime:
            return nstime_cmp(&(a->start_rel_ts), &(b->start_rel_ts)) < 0;
}
void Singleton::f7();{
bool VoipCallsInfoSortedModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
    voip_calls_info_t *a = VoipCallsInfoModel::indexToCallInfo(source_left);
    voip_calls_info_t *b = VoipCallsInfoModel::indexToCallInfo(source_right);
    if (a && b) {
        switch (source_left.column()) {
}
void Singleton::f8();{
 * Editor modelines
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
}
void Singleton::f9();{
        case VoipCallsInfoModel::StopTime:
            return nstime_cmp(&(a->stop_rel_ts), &(b->stop_rel_ts)) < 0;
        case VoipCallsInfoModel::InitialSpeaker:
            return cmp_address(&(a->initial_speaker), &(b->initial_speaker)) < 0;
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    connect(show_action, SIGNAL(triggered(bool)), this, SLOT(showRecentFolder()));
    QAction *copy_action = recent_ctx_menu.addAction(tr("Copy file path"));
    copy_action->setData(cf_path);
    connect(copy_action, SIGNAL(triggered(bool)), this, SLOT(copyRecentPath()));
    recent_ctx_menu.addSeparator();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    connect(show_action, SIGNAL(triggered(bool)), this, SLOT(showRecentFolder()));
    QAction *copy_action = recent_ctx_menu.addAction(tr("Copy file path"));
    copy_action->setData(cf_path);
    connect(copy_action, SIGNAL(triggered(bool)), this, SLOT(copyRecentPath()));
    recent_ctx_menu.addSeparator();
}
void Singleton::f2();{
    welcome_ui_(new Ui::WelcomePage),
    flavor_(tr(VERSION_FLAVOR)),
    show_in_str_(tr("Show in Finder")),
    show_in_str_(tr("Show in Folder")),
    splash_overlay_(NULL)
}
void Singleton::f3();{
        full_release += tr(" You have disabled automatic updates.");
    }
    // XXX Is there a way to tell if the user installed Wireshark via an
    // external package manager? If so we could say so here. We could
    // also add a link to the download page.
}
void Singleton::f4();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(capture_filter);
    captureFilterTextEdited(capture_filter);
void WelcomePage::changeEvent(QEvent* event)
    if (0 != event)
    {
}
void Singleton::f5();{
            "}"
            "QListWidget::item::first {"
            "  padding-top: 0;"
            "}"
            "QListWidget::item::last {"
}
void Singleton::f6();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(global_capture_opts.default_options.cfilter);
    welcome_ui_->captureFilterComboBox->setEnabled(true);
    interfaceListChanged();
    welcome_ui_->interfaceFrame->ensureSelectedInterface();
    delete splash_overlay_;
}
void Singleton::f7();{
    splash_overlay_ = new SplashOverlay(this);
WelcomePage::~WelcomePage()
    delete welcome_ui_;
InterfaceFrame *WelcomePage::getInterfaceFrame()
    return welcome_ui_->interfaceFrame;
}
void Singleton::f8();{
    connect(remove_action, SIGNAL(triggered(bool)), this, SLOT(removeRecentPath()));
    recent_ctx_menu.exec(recent_files_->mapToGlobal(pos));
void WelcomePage::showRecentFolder()
    QAction *ria = qobject_cast<QAction*>(sender());
    if (!ria) return;
}
void Singleton::f9();{
        break;
    }
    return QFrame::event(event);
void WelcomePage::on_interfaceFrame_showExtcapOptions(QString device_name)
    emit showExtcapOptions(device_name);
}
void Singleton::f10();{
            }
        } else {
            itemLabel.append(tr("not found"));
        }
        itemLabel.append(")");
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    connect(show_action, SIGNAL(triggered(bool)), this, SLOT(showRecentFolder()));
    QAction *copy_action = recent_ctx_menu.addAction(tr("Copy file path"));
    copy_action->setData(cf_path);
    connect(copy_action, SIGNAL(triggered(bool)), this, SLOT(copyRecentPath()));
    recent_ctx_menu.addSeparator();
}
void Singleton::f2();{
    welcome_ui_(new Ui::WelcomePage),
    flavor_(tr(VERSION_FLAVOR)),
    show_in_str_(tr("Show in Finder")),
    show_in_str_(tr("Show in Folder")),
    splash_overlay_(NULL)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    connect(show_action, SIGNAL(triggered(bool)), this, SLOT(showRecentFolder()));
    QAction *copy_action = recent_ctx_menu.addAction(tr("Copy file path"));
    copy_action->setData(cf_path);
    connect(copy_action, SIGNAL(triggered(bool)), this, SLOT(copyRecentPath()));
    recent_ctx_menu.addSeparator();
}
void Singleton::f2();{
    welcome_ui_(new Ui::WelcomePage),
    flavor_(tr(VERSION_FLAVOR)),
    show_in_str_(tr("Show in Finder")),
    show_in_str_(tr("Show in Folder")),
    splash_overlay_(NULL)
}
void Singleton::f3();{
        full_release += tr(" You have disabled automatic updates.");
    }
    // XXX Is there a way to tell if the user installed Wireshark via an
    // external package manager? If so we could say so here. We could
    // also add a link to the download page.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    connect(show_action, SIGNAL(triggered(bool)), this, SLOT(showRecentFolder()));
    QAction *copy_action = recent_ctx_menu.addAction(tr("Copy file path"));
    copy_action->setData(cf_path);
    connect(copy_action, SIGNAL(triggered(bool)), this, SLOT(copyRecentPath()));
    recent_ctx_menu.addSeparator();
}
void Singleton::f2();{
    welcome_ui_(new Ui::WelcomePage),
    flavor_(tr(VERSION_FLAVOR)),
    show_in_str_(tr("Show in Finder")),
    show_in_str_(tr("Show in Folder")),
    splash_overlay_(NULL)
}
void Singleton::f3();{
        full_release += tr(" You have disabled automatic updates.");
    }
    // XXX Is there a way to tell if the user installed Wireshark via an
    // external package manager? If so we could say so here. We could
    // also add a link to the download page.
}
void Singleton::f4();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(capture_filter);
    captureFilterTextEdited(capture_filter);
void WelcomePage::changeEvent(QEvent* event)
    if (0 != event)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    connect(show_action, SIGNAL(triggered(bool)), this, SLOT(showRecentFolder()));
    QAction *copy_action = recent_ctx_menu.addAction(tr("Copy file path"));
    copy_action->setData(cf_path);
    connect(copy_action, SIGNAL(triggered(bool)), this, SLOT(copyRecentPath()));
    recent_ctx_menu.addSeparator();
}
void Singleton::f2();{
    welcome_ui_(new Ui::WelcomePage),
    flavor_(tr(VERSION_FLAVOR)),
    show_in_str_(tr("Show in Finder")),
    show_in_str_(tr("Show in Folder")),
    splash_overlay_(NULL)
}
void Singleton::f3();{
        full_release += tr(" You have disabled automatic updates.");
    }
    // XXX Is there a way to tell if the user installed Wireshark via an
    // external package manager? If so we could say so here. We could
    // also add a link to the download page.
}
void Singleton::f4();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(capture_filter);
    captureFilterTextEdited(capture_filter);
void WelcomePage::changeEvent(QEvent* event)
    if (0 != event)
    {
}
void Singleton::f5();{
            "}"
            "QListWidget::item::first {"
            "  padding-top: 0;"
            "}"
            "QListWidget::item::last {"
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    connect(show_action, SIGNAL(triggered(bool)), this, SLOT(showRecentFolder()));
    QAction *copy_action = recent_ctx_menu.addAction(tr("Copy file path"));
    copy_action->setData(cf_path);
    connect(copy_action, SIGNAL(triggered(bool)), this, SLOT(copyRecentPath()));
    recent_ctx_menu.addSeparator();
}
void Singleton::f2();{
    welcome_ui_(new Ui::WelcomePage),
    flavor_(tr(VERSION_FLAVOR)),
    show_in_str_(tr("Show in Finder")),
    show_in_str_(tr("Show in Folder")),
    splash_overlay_(NULL)
}
void Singleton::f3();{
        full_release += tr(" You have disabled automatic updates.");
    }
    // XXX Is there a way to tell if the user installed Wireshark via an
    // external package manager? If so we could say so here. We could
    // also add a link to the download page.
}
void Singleton::f4();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(capture_filter);
    captureFilterTextEdited(capture_filter);
void WelcomePage::changeEvent(QEvent* event)
    if (0 != event)
    {
}
void Singleton::f5();{
            "}"
            "QListWidget::item::first {"
            "  padding-top: 0;"
            "}"
            "QListWidget::item::last {"
}
void Singleton::f6();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(global_capture_opts.default_options.cfilter);
    welcome_ui_->captureFilterComboBox->setEnabled(true);
    interfaceListChanged();
    welcome_ui_->interfaceFrame->ensureSelectedInterface();
    delete splash_overlay_;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    connect(show_action, SIGNAL(triggered(bool)), this, SLOT(showRecentFolder()));
    QAction *copy_action = recent_ctx_menu.addAction(tr("Copy file path"));
    copy_action->setData(cf_path);
    connect(copy_action, SIGNAL(triggered(bool)), this, SLOT(copyRecentPath()));
    recent_ctx_menu.addSeparator();
}
void Singleton::f2();{
    welcome_ui_(new Ui::WelcomePage),
    flavor_(tr(VERSION_FLAVOR)),
    show_in_str_(tr("Show in Finder")),
    show_in_str_(tr("Show in Folder")),
    splash_overlay_(NULL)
}
void Singleton::f3();{
        full_release += tr(" You have disabled automatic updates.");
    }
    // XXX Is there a way to tell if the user installed Wireshark via an
    // external package manager? If so we could say so here. We could
    // also add a link to the download page.
}
void Singleton::f4();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(capture_filter);
    captureFilterTextEdited(capture_filter);
void WelcomePage::changeEvent(QEvent* event)
    if (0 != event)
    {
}
void Singleton::f5();{
            "}"
            "QListWidget::item::first {"
            "  padding-top: 0;"
            "}"
            "QListWidget::item::last {"
}
void Singleton::f6();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(global_capture_opts.default_options.cfilter);
    welcome_ui_->captureFilterComboBox->setEnabled(true);
    interfaceListChanged();
    welcome_ui_->interfaceFrame->ensureSelectedInterface();
    delete splash_overlay_;
}
void Singleton::f7();{
    splash_overlay_ = new SplashOverlay(this);
WelcomePage::~WelcomePage()
    delete welcome_ui_;
InterfaceFrame *WelcomePage::getInterfaceFrame()
    return welcome_ui_->interfaceFrame;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    connect(show_action, SIGNAL(triggered(bool)), this, SLOT(showRecentFolder()));
    QAction *copy_action = recent_ctx_menu.addAction(tr("Copy file path"));
    copy_action->setData(cf_path);
    connect(copy_action, SIGNAL(triggered(bool)), this, SLOT(copyRecentPath()));
    recent_ctx_menu.addSeparator();
}
void Singleton::f2();{
    welcome_ui_(new Ui::WelcomePage),
    flavor_(tr(VERSION_FLAVOR)),
    show_in_str_(tr("Show in Finder")),
    show_in_str_(tr("Show in Folder")),
    splash_overlay_(NULL)
}
void Singleton::f3();{
        full_release += tr(" You have disabled automatic updates.");
    }
    // XXX Is there a way to tell if the user installed Wireshark via an
    // external package manager? If so we could say so here. We could
    // also add a link to the download page.
}
void Singleton::f4();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(capture_filter);
    captureFilterTextEdited(capture_filter);
void WelcomePage::changeEvent(QEvent* event)
    if (0 != event)
    {
}
void Singleton::f5();{
            "}"
            "QListWidget::item::first {"
            "  padding-top: 0;"
            "}"
            "QListWidget::item::last {"
}
void Singleton::f6();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(global_capture_opts.default_options.cfilter);
    welcome_ui_->captureFilterComboBox->setEnabled(true);
    interfaceListChanged();
    welcome_ui_->interfaceFrame->ensureSelectedInterface();
    delete splash_overlay_;
}
void Singleton::f7();{
    splash_overlay_ = new SplashOverlay(this);
WelcomePage::~WelcomePage()
    delete welcome_ui_;
InterfaceFrame *WelcomePage::getInterfaceFrame()
    return welcome_ui_->interfaceFrame;
}
void Singleton::f8();{
    connect(remove_action, SIGNAL(triggered(bool)), this, SLOT(removeRecentPath()));
    recent_ctx_menu.exec(recent_files_->mapToGlobal(pos));
void WelcomePage::showRecentFolder()
    QAction *ria = qobject_cast<QAction*>(sender());
    if (!ria) return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    connect(show_action, SIGNAL(triggered(bool)), this, SLOT(showRecentFolder()));
    QAction *copy_action = recent_ctx_menu.addAction(tr("Copy file path"));
    copy_action->setData(cf_path);
    connect(copy_action, SIGNAL(triggered(bool)), this, SLOT(copyRecentPath()));
    recent_ctx_menu.addSeparator();
}
void Singleton::f2();{
    welcome_ui_(new Ui::WelcomePage),
    flavor_(tr(VERSION_FLAVOR)),
    show_in_str_(tr("Show in Finder")),
    show_in_str_(tr("Show in Folder")),
    splash_overlay_(NULL)
}
void Singleton::f3();{
        full_release += tr(" You have disabled automatic updates.");
    }
    // XXX Is there a way to tell if the user installed Wireshark via an
    // external package manager? If so we could say so here. We could
    // also add a link to the download page.
}
void Singleton::f4();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(capture_filter);
    captureFilterTextEdited(capture_filter);
void WelcomePage::changeEvent(QEvent* event)
    if (0 != event)
    {
}
void Singleton::f5();{
            "}"
            "QListWidget::item::first {"
            "  padding-top: 0;"
            "}"
            "QListWidget::item::last {"
}
void Singleton::f6();{
    welcome_ui_->captureFilterComboBox->lineEdit()->setText(global_capture_opts.default_options.cfilter);
    welcome_ui_->captureFilterComboBox->setEnabled(true);
    interfaceListChanged();
    welcome_ui_->interfaceFrame->ensureSelectedInterface();
    delete splash_overlay_;
}
void Singleton::f7();{
    splash_overlay_ = new SplashOverlay(this);
WelcomePage::~WelcomePage()
    delete welcome_ui_;
InterfaceFrame *WelcomePage::getInterfaceFrame()
    return welcome_ui_->interfaceFrame;
}
void Singleton::f8();{
    connect(remove_action, SIGNAL(triggered(bool)), this, SLOT(removeRecentPath()));
    recent_ctx_menu.exec(recent_files_->mapToGlobal(pos));
void WelcomePage::showRecentFolder()
    QAction *ria = qobject_cast<QAction*>(sender());
    if (!ria) return;
}
void Singleton::f9();{
        break;
    }
    return QFrame::event(event);
void WelcomePage::on_interfaceFrame_showExtcapOptions(QString device_name)
    emit showExtcapOptions(device_name);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
    updateWidgets();
void WirelessFrame::setInterfaceInfo()
    QString cur_iface = ui->interfaceComboBox->currentText();
    int cur_chan_idx = ui->channelComboBox->currentIndex();
    int cur_type_idx = ui->channelTypeComboBox->currentIndex();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
    updateWidgets();
void WirelessFrame::setInterfaceInfo()
    QString cur_iface = ui->interfaceComboBox->currentText();
    int cur_chan_idx = ui->channelComboBox->currentIndex();
    int cur_type_idx = ui->channelTypeComboBox->currentIndex();
}
void Singleton::f2();{
    delete ui;
void WirelessFrame::setCaptureInProgress(bool capture_in_progress)
    capture_in_progress_ = capture_in_progress;
    updateWidgets();
int WirelessFrame::startTimer(int interval)
}
void Singleton::f3();{
            // and WS80211_CHAN_HT20? E.g. is there a driver that won't capture
            // HT frames if you use WS80211_CHAN_NO_HT?
            ui->channelTypeComboBox->addItem("20 MHz", WS80211_CHAN_NO_HT);
            if (iface_info.current_chan_type == WS80211_CHAN_NO_HT || iface_info.current_chan_type == WS80211_CHAN_HT20) {
                ui->channelTypeComboBox->setCurrentIndex(0);
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
                if (iface_info.current_chan_type == WS80211_CHAN_VHT160) {
                    ui->channelTypeComboBox->setCurrentIndex(ui->channelTypeComboBox->count() - 1);
                }
            }
            if (ws80211_has_fcs_filter()) {
}
void Singleton::f6();{
                if ((int)frequency == iface_info.current_freq) {
                    ui->channelComboBox->setCurrentIndex(ui->channelComboBox->count() - 1);
                }
                units = QString();
            }
}
void Singleton::f7();{
    getInterfaceInfo();
int WirelessFrame::getCenterFrequency(int control_frequency, int bandwidth)
    if (bandwidth < 80 || control_frequency < 5180)
        return -1;
    return ((control_frequency - 5180) / bandwidth) * bandwidth + 5180 + (bandwidth / 2) - 10;
}
void Singleton::f8();{
    capture_in_progress_(false),
    iface_timer_id_(-1)
    ui->setupUi(this);
    ui->helperToolButton->hide();
    if (ws80211_init() == WS80211_INIT_OK) {
}
void Singleton::f9();{
    ui->fcsFilterFrame->setVisible(ws80211_has_fcs_filter());
    updateInterfaceList();
    connect(wsApp, &WiresharkApplication::localInterfaceEvent,
            this, &WirelessFrame::handleInterfaceEvent);
WirelessFrame::~WirelessFrame()
}
void Singleton::f10();{
        enable_show_fcs = true;
    }
    if (enable_interface && ui->channelComboBox->count() > 0) {
        enable_channel = true;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
    updateWidgets();
void WirelessFrame::setInterfaceInfo()
    QString cur_iface = ui->interfaceComboBox->currentText();
    int cur_chan_idx = ui->channelComboBox->currentIndex();
    int cur_type_idx = ui->channelTypeComboBox->currentIndex();
}
void Singleton::f2();{
    delete ui;
void WirelessFrame::setCaptureInProgress(bool capture_in_progress)
    capture_in_progress_ = capture_in_progress;
    updateWidgets();
int WirelessFrame::startTimer(int interval)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
    updateWidgets();
void WirelessFrame::setInterfaceInfo()
    QString cur_iface = ui->interfaceComboBox->currentText();
    int cur_chan_idx = ui->channelComboBox->currentIndex();
    int cur_type_idx = ui->channelTypeComboBox->currentIndex();
}
void Singleton::f2();{
    delete ui;
void WirelessFrame::setCaptureInProgress(bool capture_in_progress)
    capture_in_progress_ = capture_in_progress;
    updateWidgets();
int WirelessFrame::startTimer(int interval)
}
void Singleton::f3();{
            // and WS80211_CHAN_HT20? E.g. is there a driver that won't capture
            // HT frames if you use WS80211_CHAN_NO_HT?
            ui->channelTypeComboBox->addItem("20 MHz", WS80211_CHAN_NO_HT);
            if (iface_info.current_chan_type == WS80211_CHAN_NO_HT || iface_info.current_chan_type == WS80211_CHAN_HT20) {
                ui->channelTypeComboBox->setCurrentIndex(0);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
    updateWidgets();
void WirelessFrame::setInterfaceInfo()
    QString cur_iface = ui->interfaceComboBox->currentText();
    int cur_chan_idx = ui->channelComboBox->currentIndex();
    int cur_type_idx = ui->channelTypeComboBox->currentIndex();
}
void Singleton::f2();{
    delete ui;
void WirelessFrame::setCaptureInProgress(bool capture_in_progress)
    capture_in_progress_ = capture_in_progress;
    updateWidgets();
int WirelessFrame::startTimer(int interval)
}
void Singleton::f3();{
            // and WS80211_CHAN_HT20? E.g. is there a driver that won't capture
            // HT frames if you use WS80211_CHAN_NO_HT?
            ui->channelTypeComboBox->addItem("20 MHz", WS80211_CHAN_NO_HT);
            if (iface_info.current_chan_type == WS80211_CHAN_NO_HT || iface_info.current_chan_type == WS80211_CHAN_HT20) {
                ui->channelTypeComboBox->setCurrentIndex(0);
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
    updateWidgets();
void WirelessFrame::setInterfaceInfo()
    QString cur_iface = ui->interfaceComboBox->currentText();
    int cur_chan_idx = ui->channelComboBox->currentIndex();
    int cur_type_idx = ui->channelTypeComboBox->currentIndex();
}
void Singleton::f2();{
    delete ui;
void WirelessFrame::setCaptureInProgress(bool capture_in_progress)
    capture_in_progress_ = capture_in_progress;
    updateWidgets();
int WirelessFrame::startTimer(int interval)
}
void Singleton::f3();{
            // and WS80211_CHAN_HT20? E.g. is there a driver that won't capture
            // HT frames if you use WS80211_CHAN_NO_HT?
            ui->channelTypeComboBox->addItem("20 MHz", WS80211_CHAN_NO_HT);
            if (iface_info.current_chan_type == WS80211_CHAN_NO_HT || iface_info.current_chan_type == WS80211_CHAN_HT20) {
                ui->channelTypeComboBox->setCurrentIndex(0);
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
                if (iface_info.current_chan_type == WS80211_CHAN_VHT160) {
                    ui->channelTypeComboBox->setCurrentIndex(ui->channelTypeComboBox->count() - 1);
                }
            }
            if (ws80211_has_fcs_filter()) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
    updateWidgets();
void WirelessFrame::setInterfaceInfo()
    QString cur_iface = ui->interfaceComboBox->currentText();
    int cur_chan_idx = ui->channelComboBox->currentIndex();
    int cur_type_idx = ui->channelTypeComboBox->currentIndex();
}
void Singleton::f2();{
    delete ui;
void WirelessFrame::setCaptureInProgress(bool capture_in_progress)
    capture_in_progress_ = capture_in_progress;
    updateWidgets();
int WirelessFrame::startTimer(int interval)
}
void Singleton::f3();{
            // and WS80211_CHAN_HT20? E.g. is there a driver that won't capture
            // HT frames if you use WS80211_CHAN_NO_HT?
            ui->channelTypeComboBox->addItem("20 MHz", WS80211_CHAN_NO_HT);
            if (iface_info.current_chan_type == WS80211_CHAN_NO_HT || iface_info.current_chan_type == WS80211_CHAN_HT20) {
                ui->channelTypeComboBox->setCurrentIndex(0);
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
                if (iface_info.current_chan_type == WS80211_CHAN_VHT160) {
                    ui->channelTypeComboBox->setCurrentIndex(ui->channelTypeComboBox->count() - 1);
                }
            }
            if (ws80211_has_fcs_filter()) {
}
void Singleton::f6();{
                if ((int)frequency == iface_info.current_freq) {
                    ui->channelComboBox->setCurrentIndex(ui->channelComboBox->count() - 1);
                }
                units = QString();
            }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
    updateWidgets();
void WirelessFrame::setInterfaceInfo()
    QString cur_iface = ui->interfaceComboBox->currentText();
    int cur_chan_idx = ui->channelComboBox->currentIndex();
    int cur_type_idx = ui->channelTypeComboBox->currentIndex();
}
void Singleton::f2();{
    delete ui;
void WirelessFrame::setCaptureInProgress(bool capture_in_progress)
    capture_in_progress_ = capture_in_progress;
    updateWidgets();
int WirelessFrame::startTimer(int interval)
}
void Singleton::f3();{
            // and WS80211_CHAN_HT20? E.g. is there a driver that won't capture
            // HT frames if you use WS80211_CHAN_NO_HT?
            ui->channelTypeComboBox->addItem("20 MHz", WS80211_CHAN_NO_HT);
            if (iface_info.current_chan_type == WS80211_CHAN_NO_HT || iface_info.current_chan_type == WS80211_CHAN_HT20) {
                ui->channelTypeComboBox->setCurrentIndex(0);
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
                if (iface_info.current_chan_type == WS80211_CHAN_VHT160) {
                    ui->channelTypeComboBox->setCurrentIndex(ui->channelTypeComboBox->count() - 1);
                }
            }
            if (ws80211_has_fcs_filter()) {
}
void Singleton::f6();{
                if ((int)frequency == iface_info.current_freq) {
                    ui->channelComboBox->setCurrentIndex(ui->channelComboBox->count() - 1);
                }
                units = QString();
            }
}
void Singleton::f7();{
    getInterfaceInfo();
int WirelessFrame::getCenterFrequency(int control_frequency, int bandwidth)
    if (bandwidth < 80 || control_frequency < 5180)
        return -1;
    return ((control_frequency - 5180) / bandwidth) * bandwidth + 5180 + (bandwidth / 2) - 10;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
    updateWidgets();
void WirelessFrame::setInterfaceInfo()
    QString cur_iface = ui->interfaceComboBox->currentText();
    int cur_chan_idx = ui->channelComboBox->currentIndex();
    int cur_type_idx = ui->channelTypeComboBox->currentIndex();
}
void Singleton::f2();{
    delete ui;
void WirelessFrame::setCaptureInProgress(bool capture_in_progress)
    capture_in_progress_ = capture_in_progress;
    updateWidgets();
int WirelessFrame::startTimer(int interval)
}
void Singleton::f3();{
            // and WS80211_CHAN_HT20? E.g. is there a driver that won't capture
            // HT frames if you use WS80211_CHAN_NO_HT?
            ui->channelTypeComboBox->addItem("20 MHz", WS80211_CHAN_NO_HT);
            if (iface_info.current_chan_type == WS80211_CHAN_NO_HT || iface_info.current_chan_type == WS80211_CHAN_HT20) {
                ui->channelTypeComboBox->setCurrentIndex(0);
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
                if (iface_info.current_chan_type == WS80211_CHAN_VHT160) {
                    ui->channelTypeComboBox->setCurrentIndex(ui->channelTypeComboBox->count() - 1);
                }
            }
            if (ws80211_has_fcs_filter()) {
}
void Singleton::f6();{
                if ((int)frequency == iface_info.current_freq) {
                    ui->channelComboBox->setCurrentIndex(ui->channelComboBox->count() - 1);
                }
                units = QString();
            }
}
void Singleton::f7();{
    getInterfaceInfo();
int WirelessFrame::getCenterFrequency(int control_frequency, int bandwidth)
    if (bandwidth < 80 || control_frequency < 5180)
        return -1;
    return ((control_frequency - 5180) / bandwidth) * bandwidth + 5180 + (bandwidth / 2) - 10;
}
void Singleton::f8();{
    capture_in_progress_(false),
    iface_timer_id_(-1)
    ui->setupUi(this);
    ui->helperToolButton->hide();
    if (ws80211_init() == WS80211_INIT_OK) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
    updateWidgets();
void WirelessFrame::setInterfaceInfo()
    QString cur_iface = ui->interfaceComboBox->currentText();
    int cur_chan_idx = ui->channelComboBox->currentIndex();
    int cur_type_idx = ui->channelTypeComboBox->currentIndex();
}
void Singleton::f2();{
    delete ui;
void WirelessFrame::setCaptureInProgress(bool capture_in_progress)
    capture_in_progress_ = capture_in_progress;
    updateWidgets();
int WirelessFrame::startTimer(int interval)
}
void Singleton::f3();{
            // and WS80211_CHAN_HT20? E.g. is there a driver that won't capture
            // HT frames if you use WS80211_CHAN_NO_HT?
            ui->channelTypeComboBox->addItem("20 MHz", WS80211_CHAN_NO_HT);
            if (iface_info.current_chan_type == WS80211_CHAN_NO_HT || iface_info.current_chan_type == WS80211_CHAN_HT20) {
                ui->channelTypeComboBox->setCurrentIndex(0);
}
void Singleton::f4();{
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 * ex: set shiftwidth=4 tabstop=8 expandtab:
}
void Singleton::f5();{
                if (iface_info.current_chan_type == WS80211_CHAN_VHT160) {
                    ui->channelTypeComboBox->setCurrentIndex(ui->channelTypeComboBox->count() - 1);
                }
            }
            if (ws80211_has_fcs_filter()) {
}
void Singleton::f6();{
                if ((int)frequency == iface_info.current_freq) {
                    ui->channelComboBox->setCurrentIndex(ui->channelComboBox->count() - 1);
                }
                units = QString();
            }
}
void Singleton::f7();{
    getInterfaceInfo();
int WirelessFrame::getCenterFrequency(int control_frequency, int bandwidth)
    if (bandwidth < 80 || control_frequency < 5180)
        return -1;
    return ((control_frequency - 5180) / bandwidth) * bandwidth + 5180 + (bandwidth / 2) - 10;
}
void Singleton::f8();{
    capture_in_progress_(false),
    iface_timer_id_(-1)
    ui->setupUi(this);
    ui->helperToolButton->hide();
    if (ws80211_init() == WS80211_INIT_OK) {
}
void Singleton::f9();{
    ui->fcsFilterFrame->setVisible(ws80211_has_fcs_filter());
    updateInterfaceList();
    connect(wsApp, &WiresharkApplication::localInterfaceEvent,
            this, &WirelessFrame::handleInterfaceEvent);
WirelessFrame::~WirelessFrame()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        guint packet = find_packet(helpEvent->pos().x());
        if (packet) {
            doToolTip(get_wlan_radio(packet), helpEvent->globalPos(), helpEvent->x());
        } else {
            QToolTip::hideText();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        guint packet = find_packet(helpEvent->pos().x());
        if (packet) {
            doToolTip(get_wlan_radio(packet), helpEvent->globalPos(), helpEvent->x());
        } else {
            QToolTip::hideText();
}
void Singleton::f2();{
             * pixel */
            last_x = x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, width, red, green, blue);
        } else {
            /* it spans more than 1 pixel.
}
void Singleton::f3();{
     * causes frequent IFS values in the range 0 to -30. Some generators emit excessive
     * data when an FCS error happens, and this results in the duration calculation for
     * the error frame being excessively long. This can cause larger negative IFS values
     * (-30 to -1000) for the subsequent frame. Ignore these cases, as they don't seem
     * to impact the GUI too badly. If the TSF reference point is set wrong (TSF at
}
void Singleton::f4();{
             * first accumulate the part that does fit */
            float partial = ((int) x) + 1 - x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, partial, red, green, blue);
            /* and render it */
            render_pixels(p, (int) x, 1, rgb, ratio);
}
void Singleton::f5();{
    setFixedHeight(TIMELINE_HEIGHT);
    first_packet = 1;
    setMouseTracking(true);
    start_x = 0;
    last_x = 0;
}
void Singleton::f6();{
void WirelessTimeline::bgColorizationProgress(int first, int last)
    if (isHidden()) return;
    struct wlan_radio *first_wr = get_wlan_radio(first);
    struct wlan_radio *last_wr = get_wlan_radio(last-1);
    int x = position(first_wr->start_tsf, 1);
}
void Singleton::f7();{
    start_tsf = center - span * x_fraction;
    end_tsf = center + span * (1.0 - x_fraction);
    clip_tsf();
    update();
int WirelessTimeline::find_packet_tsf(guint64 tsf)
}
void Singleton::f8();{
        g_hash_table_destroy(timeline->radio_packet_list);
    }
    timeline->hide();
    timeline->radio_packet_list = g_hash_table_new(g_direct_hash, g_direct_equal);
tap_packet_status WirelessTimeline::tap_timeline_packet(void *tapdata, packet_info* pinfo, epan_dissect_t* edt _U_, const void *data)
}
void Singleton::f9();{
        start_tsf += shift;
        end_tsf += shift;
    }
    if (end_tsf > last->end_tsf) {
        guint64 shift = end_tsf - last->end_tsf;
}
void Singleton::f10();{
    }
    // draw the NAV lines last, so they appear on top of the packets
    qs.render(&p, rect(), rect());
 * Editor modelines
 * Local Variables:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        guint packet = find_packet(helpEvent->pos().x());
        if (packet) {
            doToolTip(get_wlan_radio(packet), helpEvent->globalPos(), helpEvent->x());
        } else {
            QToolTip::hideText();
}
void Singleton::f2();{
             * pixel */
            last_x = x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, width, red, green, blue);
        } else {
            /* it spans more than 1 pixel.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        guint packet = find_packet(helpEvent->pos().x());
        if (packet) {
            doToolTip(get_wlan_radio(packet), helpEvent->globalPos(), helpEvent->x());
        } else {
            QToolTip::hideText();
}
void Singleton::f2();{
             * pixel */
            last_x = x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, width, red, green, blue);
        } else {
            /* it spans more than 1 pixel.
}
void Singleton::f3();{
     * causes frequent IFS values in the range 0 to -30. Some generators emit excessive
     * data when an FCS error happens, and this results in the duration calculation for
     * the error frame being excessively long. This can cause larger negative IFS values
     * (-30 to -1000) for the subsequent frame. Ignore these cases, as they don't seem
     * to impact the GUI too badly. If the TSF reference point is set wrong (TSF at
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        guint packet = find_packet(helpEvent->pos().x());
        if (packet) {
            doToolTip(get_wlan_radio(packet), helpEvent->globalPos(), helpEvent->x());
        } else {
            QToolTip::hideText();
}
void Singleton::f2();{
             * pixel */
            last_x = x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, width, red, green, blue);
        } else {
            /* it spans more than 1 pixel.
}
void Singleton::f3();{
     * causes frequent IFS values in the range 0 to -30. Some generators emit excessive
     * data when an FCS error happens, and this results in the duration calculation for
     * the error frame being excessively long. This can cause larger negative IFS values
     * (-30 to -1000) for the subsequent frame. Ignore these cases, as they don't seem
     * to impact the GUI too badly. If the TSF reference point is set wrong (TSF at
}
void Singleton::f4();{
             * first accumulate the part that does fit */
            float partial = ((int) x) + 1 - x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, partial, red, green, blue);
            /* and render it */
            render_pixels(p, (int) x, 1, rgb, ratio);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        guint packet = find_packet(helpEvent->pos().x());
        if (packet) {
            doToolTip(get_wlan_radio(packet), helpEvent->globalPos(), helpEvent->x());
        } else {
            QToolTip::hideText();
}
void Singleton::f2();{
             * pixel */
            last_x = x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, width, red, green, blue);
        } else {
            /* it spans more than 1 pixel.
}
void Singleton::f3();{
     * causes frequent IFS values in the range 0 to -30. Some generators emit excessive
     * data when an FCS error happens, and this results in the duration calculation for
     * the error frame being excessively long. This can cause larger negative IFS values
     * (-30 to -1000) for the subsequent frame. Ignore these cases, as they don't seem
     * to impact the GUI too badly. If the TSF reference point is set wrong (TSF at
}
void Singleton::f4();{
             * first accumulate the part that does fit */
            float partial = ((int) x) + 1 - x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, partial, red, green, blue);
            /* and render it */
            render_pixels(p, (int) x, 1, rgb, ratio);
}
void Singleton::f5();{
    setFixedHeight(TIMELINE_HEIGHT);
    first_packet = 1;
    setMouseTracking(true);
    start_x = 0;
    last_x = 0;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        guint packet = find_packet(helpEvent->pos().x());
        if (packet) {
            doToolTip(get_wlan_radio(packet), helpEvent->globalPos(), helpEvent->x());
        } else {
            QToolTip::hideText();
}
void Singleton::f2();{
             * pixel */
            last_x = x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, width, red, green, blue);
        } else {
            /* it spans more than 1 pixel.
}
void Singleton::f3();{
     * causes frequent IFS values in the range 0 to -30. Some generators emit excessive
     * data when an FCS error happens, and this results in the duration calculation for
     * the error frame being excessively long. This can cause larger negative IFS values
     * (-30 to -1000) for the subsequent frame. Ignore these cases, as they don't seem
     * to impact the GUI too badly. If the TSF reference point is set wrong (TSF at
}
void Singleton::f4();{
             * first accumulate the part that does fit */
            float partial = ((int) x) + 1 - x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, partial, red, green, blue);
            /* and render it */
            render_pixels(p, (int) x, 1, rgb, ratio);
}
void Singleton::f5();{
    setFixedHeight(TIMELINE_HEIGHT);
    first_packet = 1;
    setMouseTracking(true);
    start_x = 0;
    last_x = 0;
}
void Singleton::f6();{
void WirelessTimeline::bgColorizationProgress(int first, int last)
    if (isHidden()) return;
    struct wlan_radio *first_wr = get_wlan_radio(first);
    struct wlan_radio *last_wr = get_wlan_radio(last-1);
    int x = position(first_wr->start_tsf, 1);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        guint packet = find_packet(helpEvent->pos().x());
        if (packet) {
            doToolTip(get_wlan_radio(packet), helpEvent->globalPos(), helpEvent->x());
        } else {
            QToolTip::hideText();
}
void Singleton::f2();{
             * pixel */
            last_x = x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, width, red, green, blue);
        } else {
            /* it spans more than 1 pixel.
}
void Singleton::f3();{
     * causes frequent IFS values in the range 0 to -30. Some generators emit excessive
     * data when an FCS error happens, and this results in the duration calculation for
     * the error frame being excessively long. This can cause larger negative IFS values
     * (-30 to -1000) for the subsequent frame. Ignore these cases, as they don't seem
     * to impact the GUI too badly. If the TSF reference point is set wrong (TSF at
}
void Singleton::f4();{
             * first accumulate the part that does fit */
            float partial = ((int) x) + 1 - x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, partial, red, green, blue);
            /* and render it */
            render_pixels(p, (int) x, 1, rgb, ratio);
}
void Singleton::f5();{
    setFixedHeight(TIMELINE_HEIGHT);
    first_packet = 1;
    setMouseTracking(true);
    start_x = 0;
    last_x = 0;
}
void Singleton::f6();{
void WirelessTimeline::bgColorizationProgress(int first, int last)
    if (isHidden()) return;
    struct wlan_radio *first_wr = get_wlan_radio(first);
    struct wlan_radio *last_wr = get_wlan_radio(last-1);
    int x = position(first_wr->start_tsf, 1);
}
void Singleton::f7();{
    start_tsf = center - span * x_fraction;
    end_tsf = center + span * (1.0 - x_fraction);
    clip_tsf();
    update();
int WirelessTimeline::find_packet_tsf(guint64 tsf)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        guint packet = find_packet(helpEvent->pos().x());
        if (packet) {
            doToolTip(get_wlan_radio(packet), helpEvent->globalPos(), helpEvent->x());
        } else {
            QToolTip::hideText();
}
void Singleton::f2();{
             * pixel */
            last_x = x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, width, red, green, blue);
        } else {
            /* it spans more than 1 pixel.
}
void Singleton::f3();{
     * causes frequent IFS values in the range 0 to -30. Some generators emit excessive
     * data when an FCS error happens, and this results in the duration calculation for
     * the error frame being excessively long. This can cause larger negative IFS values
     * (-30 to -1000) for the subsequent frame. Ignore these cases, as they don't seem
     * to impact the GUI too badly. If the TSF reference point is set wrong (TSF at
}
void Singleton::f4();{
             * first accumulate the part that does fit */
            float partial = ((int) x) + 1 - x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, partial, red, green, blue);
            /* and render it */
            render_pixels(p, (int) x, 1, rgb, ratio);
}
void Singleton::f5();{
    setFixedHeight(TIMELINE_HEIGHT);
    first_packet = 1;
    setMouseTracking(true);
    start_x = 0;
    last_x = 0;
}
void Singleton::f6();{
void WirelessTimeline::bgColorizationProgress(int first, int last)
    if (isHidden()) return;
    struct wlan_radio *first_wr = get_wlan_radio(first);
    struct wlan_radio *last_wr = get_wlan_radio(last-1);
    int x = position(first_wr->start_tsf, 1);
}
void Singleton::f7();{
    start_tsf = center - span * x_fraction;
    end_tsf = center + span * (1.0 - x_fraction);
    clip_tsf();
    update();
int WirelessTimeline::find_packet_tsf(guint64 tsf)
}
void Singleton::f8();{
        g_hash_table_destroy(timeline->radio_packet_list);
    }
    timeline->hide();
    timeline->radio_packet_list = g_hash_table_new(g_direct_hash, g_direct_equal);
tap_packet_status WirelessTimeline::tap_timeline_packet(void *tapdata, packet_info* pinfo, epan_dissect_t* edt _U_, const void *data)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        guint packet = find_packet(helpEvent->pos().x());
        if (packet) {
            doToolTip(get_wlan_radio(packet), helpEvent->globalPos(), helpEvent->x());
        } else {
            QToolTip::hideText();
}
void Singleton::f2();{
             * pixel */
            last_x = x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, width, red, green, blue);
        } else {
            /* it spans more than 1 pixel.
}
void Singleton::f3();{
     * causes frequent IFS values in the range 0 to -30. Some generators emit excessive
     * data when an FCS error happens, and this results in the duration calculation for
     * the error frame being excessively long. This can cause larger negative IFS values
     * (-30 to -1000) for the subsequent frame. Ignore these cases, as they don't seem
     * to impact the GUI too badly. If the TSF reference point is set wrong (TSF at
}
void Singleton::f4();{
             * first accumulate the part that does fit */
            float partial = ((int) x) + 1 - x;
            accumulate_rgb(rgb, height, fdata->passed_dfilter, partial, red, green, blue);
            /* and render it */
            render_pixels(p, (int) x, 1, rgb, ratio);
}
void Singleton::f5();{
    setFixedHeight(TIMELINE_HEIGHT);
    first_packet = 1;
    setMouseTracking(true);
    start_x = 0;
    last_x = 0;
}
void Singleton::f6();{
void WirelessTimeline::bgColorizationProgress(int first, int last)
    if (isHidden()) return;
    struct wlan_radio *first_wr = get_wlan_radio(first);
    struct wlan_radio *last_wr = get_wlan_radio(last-1);
    int x = position(first_wr->start_tsf, 1);
}
void Singleton::f7();{
    start_tsf = center - span * x_fraction;
    end_tsf = center + span * (1.0 - x_fraction);
    clip_tsf();
    update();
int WirelessTimeline::find_packet_tsf(guint64 tsf)
}
void Singleton::f8();{
        g_hash_table_destroy(timeline->radio_packet_list);
    }
    timeline->hide();
    timeline->radio_packet_list = g_hash_table_new(g_direct_hash, g_direct_equal);
tap_packet_status WirelessTimeline::tap_timeline_packet(void *tapdata, packet_info* pinfo, epan_dissect_t* edt _U_, const void *data)
}
void Singleton::f9();{
        start_tsf += shift;
        end_tsf += shift;
    }
    if (end_tsf > last->end_tsf) {
        guint64 shift = end_tsf - last->end_tsf;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                 * of it from the current list of interfaces selected
                 * for capturing.
                 */
                for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                    interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                 * of it from the current list of interfaces selected
                 * for capturing.
                 */
                for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                    interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
}
void Singleton::f2();{
    err = iface_mon_start(&iface_mon_event_cb);
    if (err == 0) {
        if_notifier_ = new QSocketNotifier(iface_mon_get_sock(),
                                           QSocketNotifier::Read, this);
        connect(if_notifier_, SIGNAL(activated(int)), SLOT(ifChangeEventsAvailable()));
}
void Singleton::f3();{
    }
// Return the first top-level QMainWindow.
QWidget *WiresharkApplication::mainWindow()
    foreach (QWidget *tlw, topLevelWidgets()) {
        QMainWindow *tlmw = qobject_cast<QMainWindow *>(tlw);
}
void Singleton::f4();{
    if (!recent_read_profile_static(&rf_path, &rf_open_errno)) {
        simple_dialog(ESD_TYPE_WARN, ESD_BTN_OK,
            "Could not open common recent file\n\"%s\": %s.",
            rf_path, g_strerror(rf_open_errno));
        g_free(rf_path);
}
void Singleton::f5();{
        localeLanguage = newLanguage;
    }
    locale = QLocale(localeLanguage);
    QLocale::setDefault(locale);
    switchTranslator(wsApp->translator,
}
void Singleton::f6();{
        QString cf_name;
        /* get capture filename from the menu item label */
        cf_name = rii.previous()->filename;
        if (cf_name != NULL) {
            fprintf (rf, RECENT_KEY_CAPTURE_FILE ": %s\n", qUtf8Printable(cf_name));
}
void Singleton::f7();{
    // by virtue of a file system being re-mounted.  The only way to
    // catch *that* would be to watch for mounts and re-check all
    // marked-as-inaccessible files.
    //
    // macOS and FreeBSD also support EVFILT_FS events, which notify you
}
void Singleton::f8();{
 *  current capture).
extern "C" int software_update_can_shutdown_callback(void) {
    return wsApp->softwareUpdateCanShutdown();
/** Shut down Wireshark in preparation for an upgrade.
extern "C" void software_update_shutdown_request_callback(void) {
}
void Singleton::f9();{
    if (QFile::exists(QString("%1/qt_%2.qm")
            .arg(get_datafile_dir()).arg(localeLanguage))) {
        switchTranslator(wsApp->translatorQt,
                QString("qt_%1.qm").arg(localeLanguage), QString(get_datafile_dir()));
    } else if (QFile::exists(QString("%1/qt_%2.qm")
}
void Singleton::f10();{
                 */
                for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                    interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
                    if (strcmp(interface_opts->name, device->name) == 0) {
                        capture_opts_del_iface(&global_capture_opts, j);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                 * of it from the current list of interfaces selected
                 * for capturing.
                 */
                for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                    interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
}
void Singleton::f2();{
    err = iface_mon_start(&iface_mon_event_cb);
    if (err == 0) {
        if_notifier_ = new QSocketNotifier(iface_mon_get_sock(),
                                           QSocketNotifier::Read, this);
        connect(if_notifier_, SIGNAL(activated(int)), SLOT(ifChangeEventsAvailable()));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                 * of it from the current list of interfaces selected
                 * for capturing.
                 */
                for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                    interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
}
void Singleton::f2();{
    err = iface_mon_start(&iface_mon_event_cb);
    if (err == 0) {
        if_notifier_ = new QSocketNotifier(iface_mon_get_sock(),
                                           QSocketNotifier::Read, this);
        connect(if_notifier_, SIGNAL(activated(int)), SLOT(ifChangeEventsAvailable()));
}
void Singleton::f3();{
    }
// Return the first top-level QMainWindow.
QWidget *WiresharkApplication::mainWindow()
    foreach (QWidget *tlw, topLevelWidgets()) {
        QMainWindow *tlmw = qobject_cast<QMainWindow *>(tlw);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                 * of it from the current list of interfaces selected
                 * for capturing.
                 */
                for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                    interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
}
void Singleton::f2();{
    err = iface_mon_start(&iface_mon_event_cb);
    if (err == 0) {
        if_notifier_ = new QSocketNotifier(iface_mon_get_sock(),
                                           QSocketNotifier::Read, this);
        connect(if_notifier_, SIGNAL(activated(int)), SLOT(ifChangeEventsAvailable()));
}
void Singleton::f3();{
    }
// Return the first top-level QMainWindow.
QWidget *WiresharkApplication::mainWindow()
    foreach (QWidget *tlw, topLevelWidgets()) {
        QMainWindow *tlmw = qobject_cast<QMainWindow *>(tlw);
}
void Singleton::f4();{
    if (!recent_read_profile_static(&rf_path, &rf_open_errno)) {
        simple_dialog(ESD_TYPE_WARN, ESD_BTN_OK,
            "Could not open common recent file\n\"%s\": %s.",
            rf_path, g_strerror(rf_open_errno));
        g_free(rf_path);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                 * of it from the current list of interfaces selected
                 * for capturing.
                 */
                for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                    interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
}
void Singleton::f2();{
    err = iface_mon_start(&iface_mon_event_cb);
    if (err == 0) {
        if_notifier_ = new QSocketNotifier(iface_mon_get_sock(),
                                           QSocketNotifier::Read, this);
        connect(if_notifier_, SIGNAL(activated(int)), SLOT(ifChangeEventsAvailable()));
}
void Singleton::f3();{
    }
// Return the first top-level QMainWindow.
QWidget *WiresharkApplication::mainWindow()
    foreach (QWidget *tlw, topLevelWidgets()) {
        QMainWindow *tlmw = qobject_cast<QMainWindow *>(tlw);
}
void Singleton::f4();{
    if (!recent_read_profile_static(&rf_path, &rf_open_errno)) {
        simple_dialog(ESD_TYPE_WARN, ESD_BTN_OK,
            "Could not open common recent file\n\"%s\": %s.",
            rf_path, g_strerror(rf_open_errno));
        g_free(rf_path);
}
void Singleton::f5();{
        localeLanguage = newLanguage;
    }
    locale = QLocale(localeLanguage);
    QLocale::setDefault(locale);
    switchTranslator(wsApp->translator,
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                 * of it from the current list of interfaces selected
                 * for capturing.
                 */
                for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                    interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
}
void Singleton::f2();{
    err = iface_mon_start(&iface_mon_event_cb);
    if (err == 0) {
        if_notifier_ = new QSocketNotifier(iface_mon_get_sock(),
                                           QSocketNotifier::Read, this);
        connect(if_notifier_, SIGNAL(activated(int)), SLOT(ifChangeEventsAvailable()));
}
void Singleton::f3();{
    }
// Return the first top-level QMainWindow.
QWidget *WiresharkApplication::mainWindow()
    foreach (QWidget *tlw, topLevelWidgets()) {
        QMainWindow *tlmw = qobject_cast<QMainWindow *>(tlw);
}
void Singleton::f4();{
    if (!recent_read_profile_static(&rf_path, &rf_open_errno)) {
        simple_dialog(ESD_TYPE_WARN, ESD_BTN_OK,
            "Could not open common recent file\n\"%s\": %s.",
            rf_path, g_strerror(rf_open_errno));
        g_free(rf_path);
}
void Singleton::f5();{
        localeLanguage = newLanguage;
    }
    locale = QLocale(localeLanguage);
    QLocale::setDefault(locale);
    switchTranslator(wsApp->translator,
}
void Singleton::f6();{
        QString cf_name;
        /* get capture filename from the menu item label */
        cf_name = rii.previous()->filename;
        if (cf_name != NULL) {
            fprintf (rf, RECENT_KEY_CAPTURE_FILE ": %s\n", qUtf8Printable(cf_name));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                 * of it from the current list of interfaces selected
                 * for capturing.
                 */
                for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                    interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
}
void Singleton::f2();{
    err = iface_mon_start(&iface_mon_event_cb);
    if (err == 0) {
        if_notifier_ = new QSocketNotifier(iface_mon_get_sock(),
                                           QSocketNotifier::Read, this);
        connect(if_notifier_, SIGNAL(activated(int)), SLOT(ifChangeEventsAvailable()));
}
void Singleton::f3();{
    }
// Return the first top-level QMainWindow.
QWidget *WiresharkApplication::mainWindow()
    foreach (QWidget *tlw, topLevelWidgets()) {
        QMainWindow *tlmw = qobject_cast<QMainWindow *>(tlw);
}
void Singleton::f4();{
    if (!recent_read_profile_static(&rf_path, &rf_open_errno)) {
        simple_dialog(ESD_TYPE_WARN, ESD_BTN_OK,
            "Could not open common recent file\n\"%s\": %s.",
            rf_path, g_strerror(rf_open_errno));
        g_free(rf_path);
}
void Singleton::f5();{
        localeLanguage = newLanguage;
    }
    locale = QLocale(localeLanguage);
    QLocale::setDefault(locale);
    switchTranslator(wsApp->translator,
}
void Singleton::f6();{
        QString cf_name;
        /* get capture filename from the menu item label */
        cf_name = rii.previous()->filename;
        if (cf_name != NULL) {
            fprintf (rf, RECENT_KEY_CAPTURE_FILE ": %s\n", qUtf8Printable(cf_name));
}
void Singleton::f7();{
    // by virtue of a file system being re-mounted.  The only way to
    // catch *that* would be to watch for mounts and re-check all
    // marked-as-inaccessible files.
    //
    // macOS and FreeBSD also support EVFILT_FS events, which notify you
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                 * of it from the current list of interfaces selected
                 * for capturing.
                 */
                for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                    interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
}
void Singleton::f2();{
    err = iface_mon_start(&iface_mon_event_cb);
    if (err == 0) {
        if_notifier_ = new QSocketNotifier(iface_mon_get_sock(),
                                           QSocketNotifier::Read, this);
        connect(if_notifier_, SIGNAL(activated(int)), SLOT(ifChangeEventsAvailable()));
}
void Singleton::f3();{
    }
// Return the first top-level QMainWindow.
QWidget *WiresharkApplication::mainWindow()
    foreach (QWidget *tlw, topLevelWidgets()) {
        QMainWindow *tlmw = qobject_cast<QMainWindow *>(tlw);
}
void Singleton::f4();{
    if (!recent_read_profile_static(&rf_path, &rf_open_errno)) {
        simple_dialog(ESD_TYPE_WARN, ESD_BTN_OK,
            "Could not open common recent file\n\"%s\": %s.",
            rf_path, g_strerror(rf_open_errno));
        g_free(rf_path);
}
void Singleton::f5();{
        localeLanguage = newLanguage;
    }
    locale = QLocale(localeLanguage);
    QLocale::setDefault(locale);
    switchTranslator(wsApp->translator,
}
void Singleton::f6();{
        QString cf_name;
        /* get capture filename from the menu item label */
        cf_name = rii.previous()->filename;
        if (cf_name != NULL) {
            fprintf (rf, RECENT_KEY_CAPTURE_FILE ": %s\n", qUtf8Printable(cf_name));
}
void Singleton::f7();{
    // by virtue of a file system being re-mounted.  The only way to
    // catch *that* would be to watch for mounts and re-check all
    // marked-as-inaccessible files.
    //
    // macOS and FreeBSD also support EVFILT_FS events, which notify you
}
void Singleton::f8();{
 *  current capture).
extern "C" int software_update_can_shutdown_callback(void) {
    return wsApp->softwareUpdateCanShutdown();
/** Shut down Wireshark in preparation for an upgrade.
extern "C" void software_update_shutdown_request_callback(void) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                 * of it from the current list of interfaces selected
                 * for capturing.
                 */
                for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                    interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);
}
void Singleton::f2();{
    err = iface_mon_start(&iface_mon_event_cb);
    if (err == 0) {
        if_notifier_ = new QSocketNotifier(iface_mon_get_sock(),
                                           QSocketNotifier::Read, this);
        connect(if_notifier_, SIGNAL(activated(int)), SLOT(ifChangeEventsAvailable()));
}
void Singleton::f3();{
    }
// Return the first top-level QMainWindow.
QWidget *WiresharkApplication::mainWindow()
    foreach (QWidget *tlw, topLevelWidgets()) {
        QMainWindow *tlmw = qobject_cast<QMainWindow *>(tlw);
}
void Singleton::f4();{
    if (!recent_read_profile_static(&rf_path, &rf_open_errno)) {
        simple_dialog(ESD_TYPE_WARN, ESD_BTN_OK,
            "Could not open common recent file\n\"%s\": %s.",
            rf_path, g_strerror(rf_open_errno));
        g_free(rf_path);
}
void Singleton::f5();{
        localeLanguage = newLanguage;
    }
    locale = QLocale(localeLanguage);
    QLocale::setDefault(locale);
    switchTranslator(wsApp->translator,
}
void Singleton::f6();{
        QString cf_name;
        /* get capture filename from the menu item label */
        cf_name = rii.previous()->filename;
        if (cf_name != NULL) {
            fprintf (rf, RECENT_KEY_CAPTURE_FILE ": %s\n", qUtf8Printable(cf_name));
}
void Singleton::f7();{
    // by virtue of a file system being re-mounted.  The only way to
    // catch *that* would be to watch for mounts and re-check all
    // marked-as-inaccessible files.
    //
    // macOS and FreeBSD also support EVFILT_FS events, which notify you
}
void Singleton::f8();{
 *  current capture).
extern "C" int software_update_can_shutdown_callback(void) {
    return wsApp->softwareUpdateCanShutdown();
/** Shut down Wireshark in preparation for an upgrade.
extern "C" void software_update_shutdown_request_callback(void) {
}
void Singleton::f9();{
    if (QFile::exists(QString("%1/qt_%2.qm")
            .arg(get_datafile_dir()).arg(localeLanguage))) {
        switchTranslator(wsApp->translatorQt,
                QString("qt_%1.qm").arg(localeLanguage), QString(get_datafile_dir()));
    } else if (QFile::exists(QString("%1/qt_%2.qm")
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        break;
    default:
        break;
    }
void WiresharkDialog::beginRetapPackets()
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        break;
    default:
        break;
    }
void WiresharkDialog::beginRetapPackets()
}
void Singleton::f2();{
    retap_depth_(0),
    dialog_closed_(false)
    setWindowIcon(wsApp->normalIcon());
    setWindowSubtitle(QString());
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f3();{
        g_string_free(error_string, TRUE);
        return false;
    }
    tap_listeners_ << tap_data;
    return true;
}
void Singleton::f4();{
// XXX Should we do this in WiresharkDialog?
void WiresharkDialog::reject()
    QDialog::reject();
    dialogCleanup(true);
void WiresharkDialog::setWindowSubtitle(const QString &subtitle)
}
void Singleton::f5();{
            break;
        }
        break;
    default:
        break;
}
void Singleton::f6();{
    {
        // Cancel any taps in progress?
        // cap_file_.setCaptureStopFlag();
        removeTapListeners();
        dialog_closed_ = true;
}
void Singleton::f7();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Use a dynamic property + Q_PROPERTY for the subtitle.
// - Make our nested event loop more robust. See tryDeleteLater for details.
}
void Singleton::f8();{
// To do:
// - Use a dynamic property + Q_PROPERTY for the subtitle.
// - Make our nested event loop more robust. See tryDeleteLater for details.
WiresharkDialog::WiresharkDialog(QWidget &parent, CaptureFile &capture_file) :
    GeometryStateDialog(&parent, Qt::Window),
}
void Singleton::f9();{
        removeTapListeners();
        dialog_closed_ = true;
    }
    if (retap_depth_ < 1 && dialog_closed_) {
        disconnect();
}
void Singleton::f10();{
        remove_tap_listener(tap_listeners_.takeFirst());
    }
void WiresharkDialog::captureFileClosing()
    if (file_closed_)
        return;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        break;
    default:
        break;
    }
void WiresharkDialog::beginRetapPackets()
}
void Singleton::f2();{
    retap_depth_(0),
    dialog_closed_(false)
    setWindowIcon(wsApp->normalIcon());
    setWindowSubtitle(QString());
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        break;
    default:
        break;
    }
void WiresharkDialog::beginRetapPackets()
}
void Singleton::f2();{
    retap_depth_(0),
    dialog_closed_(false)
    setWindowIcon(wsApp->normalIcon());
    setWindowSubtitle(QString());
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f3();{
        g_string_free(error_string, TRUE);
        return false;
    }
    tap_listeners_ << tap_data;
    return true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        break;
    default:
        break;
    }
void WiresharkDialog::beginRetapPackets()
}
void Singleton::f2();{
    retap_depth_(0),
    dialog_closed_(false)
    setWindowIcon(wsApp->normalIcon());
    setWindowSubtitle(QString());
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f3();{
        g_string_free(error_string, TRUE);
        return false;
    }
    tap_listeners_ << tap_data;
    return true;
}
void Singleton::f4();{
// XXX Should we do this in WiresharkDialog?
void WiresharkDialog::reject()
    QDialog::reject();
    dialogCleanup(true);
void WiresharkDialog::setWindowSubtitle(const QString &subtitle)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        break;
    default:
        break;
    }
void WiresharkDialog::beginRetapPackets()
}
void Singleton::f2();{
    retap_depth_(0),
    dialog_closed_(false)
    setWindowIcon(wsApp->normalIcon());
    setWindowSubtitle(QString());
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f3();{
        g_string_free(error_string, TRUE);
        return false;
    }
    tap_listeners_ << tap_data;
    return true;
}
void Singleton::f4();{
// XXX Should we do this in WiresharkDialog?
void WiresharkDialog::reject()
    QDialog::reject();
    dialogCleanup(true);
void WiresharkDialog::setWindowSubtitle(const QString &subtitle)
}
void Singleton::f5();{
            break;
        }
        break;
    default:
        break;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        break;
    default:
        break;
    }
void WiresharkDialog::beginRetapPackets()
}
void Singleton::f2();{
    retap_depth_(0),
    dialog_closed_(false)
    setWindowIcon(wsApp->normalIcon());
    setWindowSubtitle(QString());
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f3();{
        g_string_free(error_string, TRUE);
        return false;
    }
    tap_listeners_ << tap_data;
    return true;
}
void Singleton::f4();{
// XXX Should we do this in WiresharkDialog?
void WiresharkDialog::reject()
    QDialog::reject();
    dialogCleanup(true);
void WiresharkDialog::setWindowSubtitle(const QString &subtitle)
}
void Singleton::f5();{
            break;
        }
        break;
    default:
        break;
}
void Singleton::f6();{
    {
        // Cancel any taps in progress?
        // cap_file_.setCaptureStopFlag();
        removeTapListeners();
        dialog_closed_ = true;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        break;
    default:
        break;
    }
void WiresharkDialog::beginRetapPackets()
}
void Singleton::f2();{
    retap_depth_(0),
    dialog_closed_(false)
    setWindowIcon(wsApp->normalIcon());
    setWindowSubtitle(QString());
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f3();{
        g_string_free(error_string, TRUE);
        return false;
    }
    tap_listeners_ << tap_data;
    return true;
}
void Singleton::f4();{
// XXX Should we do this in WiresharkDialog?
void WiresharkDialog::reject()
    QDialog::reject();
    dialogCleanup(true);
void WiresharkDialog::setWindowSubtitle(const QString &subtitle)
}
void Singleton::f5();{
            break;
        }
        break;
    default:
        break;
}
void Singleton::f6();{
    {
        // Cancel any taps in progress?
        // cap_file_.setCaptureStopFlag();
        removeTapListeners();
        dialog_closed_ = true;
}
void Singleton::f7();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Use a dynamic property + Q_PROPERTY for the subtitle.
// - Make our nested event loop more robust. See tryDeleteLater for details.
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        break;
    default:
        break;
    }
void WiresharkDialog::beginRetapPackets()
}
void Singleton::f2();{
    retap_depth_(0),
    dialog_closed_(false)
    setWindowIcon(wsApp->normalIcon());
    setWindowSubtitle(QString());
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f3();{
        g_string_free(error_string, TRUE);
        return false;
    }
    tap_listeners_ << tap_data;
    return true;
}
void Singleton::f4();{
// XXX Should we do this in WiresharkDialog?
void WiresharkDialog::reject()
    QDialog::reject();
    dialogCleanup(true);
void WiresharkDialog::setWindowSubtitle(const QString &subtitle)
}
void Singleton::f5();{
            break;
        }
        break;
    default:
        break;
}
void Singleton::f6();{
    {
        // Cancel any taps in progress?
        // cap_file_.setCaptureStopFlag();
        removeTapListeners();
        dialog_closed_ = true;
}
void Singleton::f7();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Use a dynamic property + Q_PROPERTY for the subtitle.
// - Make our nested event loop more robust. See tryDeleteLater for details.
}
void Singleton::f8();{
// To do:
// - Use a dynamic property + Q_PROPERTY for the subtitle.
// - Make our nested event loop more robust. See tryDeleteLater for details.
WiresharkDialog::WiresharkDialog(QWidget &parent, CaptureFile &capture_file) :
    GeometryStateDialog(&parent, Qt::Window),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        break;
    default:
        break;
    }
void WiresharkDialog::beginRetapPackets()
}
void Singleton::f2();{
    retap_depth_(0),
    dialog_closed_(false)
    setWindowIcon(wsApp->normalIcon());
    setWindowSubtitle(QString());
    connect(&cap_file_, SIGNAL(captureEvent(CaptureEvent)),
}
void Singleton::f3();{
        g_string_free(error_string, TRUE);
        return false;
    }
    tap_listeners_ << tap_data;
    return true;
}
void Singleton::f4();{
// XXX Should we do this in WiresharkDialog?
void WiresharkDialog::reject()
    QDialog::reject();
    dialogCleanup(true);
void WiresharkDialog::setWindowSubtitle(const QString &subtitle)
}
void Singleton::f5();{
            break;
        }
        break;
    default:
        break;
}
void Singleton::f6();{
    {
        // Cancel any taps in progress?
        // cap_file_.setCaptureStopFlag();
        removeTapListeners();
        dialog_closed_ = true;
}
void Singleton::f7();{
 * Copyright 1998 Gerald Combs
 * SPDX-License-Identifier: GPL-2.0-or-later
// To do:
// - Use a dynamic property + Q_PROPERTY for the subtitle.
// - Make our nested event loop more robust. See tryDeleteLater for details.
}
void Singleton::f8();{
// To do:
// - Use a dynamic property + Q_PROPERTY for the subtitle.
// - Make our nested event loop more robust. See tryDeleteLater for details.
WiresharkDialog::WiresharkDialog(QWidget &parent, CaptureFile &capture_file) :
    GeometryStateDialog(&parent, Qt::Window),
}
void Singleton::f9();{
        removeTapListeners();
        dialog_closed_ = true;
    }
    if (retap_depth_ < 1 && dialog_closed_) {
        disconnect();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
    EnumPreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget *parent, const QStyleOptionViewItem &/*option*/, const QModelIndex &/*index*/)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
    EnumPreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget *parent, const QStyleOptionViewItem &/*option*/, const QModelIndex &/*index*/)
}
void Singleton::f2();{
public:
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
}
void Singleton::f3();{
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
}
void Singleton::f4();{
        return WiresharkPreference::editor(parent, option, index);
    }
REGISTER_PREFERENCE_TYPE(PREF_BOOL, BoolPreference)
class StringPreference : public WiresharkPreference
public:
}
void Singleton::f5();{
    {
        if (prefsItem()->getPrefGUIType() == GUI_ALL || prefsItem()->getPrefGUIType() == GUI_QT) {
            UatDialog uat_dlg(parent, prefs_get_uat_value(prefsItem()->getPref()));
            uat_dlg.exec();
        }
}
void Singleton::f6();{
        color_dlg->show();
        return color_dlg;
    }
    virtual void setData(QWidget *editor, const QModelIndex &index)
    {
}
void Singleton::f7();{
            UatDialog uat_dlg(parent, prefs_get_uat_value(prefsItem()->getPref()));
            uat_dlg.exec();
        }
        return WiresharkPreference::editor(parent, option, index);
    }
}
void Singleton::f8();{
            if (prefs_get_enum_value(pref->getPref(), pref_stashed) == ev->value)
                combo->setCurrentIndex(combo->count() - 1);
        }
    }
    virtual void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index)
}
void Singleton::f9();{
public:
    OpenFilePreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget * parent, const QStyleOptionViewItem &option, const QModelIndex &index)
    {
        QString filename = WiresharkFileDialog::getOpenFileName(parent, wsApp->windowTitleString(prefs_get_title(prefsItem()->getPref())),
}
void Singleton::f10();{
        return WiresharkPreference::editor(parent, option, index);
    }
REGISTER_PREFERENCE_TYPE(PREF_DIRNAME, DirNamePreference)
class UatPreference : public WiresharkPreference
public:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
    EnumPreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget *parent, const QStyleOptionViewItem &/*option*/, const QModelIndex &/*index*/)
}
void Singleton::f2();{
public:
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
    EnumPreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget *parent, const QStyleOptionViewItem &/*option*/, const QModelIndex &/*index*/)
}
void Singleton::f2();{
public:
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
}
void Singleton::f3();{
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
    EnumPreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget *parent, const QStyleOptionViewItem &/*option*/, const QModelIndex &/*index*/)
}
void Singleton::f2();{
public:
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
}
void Singleton::f3();{
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
}
void Singleton::f4();{
        return WiresharkPreference::editor(parent, option, index);
    }
REGISTER_PREFERENCE_TYPE(PREF_BOOL, BoolPreference)
class StringPreference : public WiresharkPreference
public:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
    EnumPreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget *parent, const QStyleOptionViewItem &/*option*/, const QModelIndex &/*index*/)
}
void Singleton::f2();{
public:
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
}
void Singleton::f3();{
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
}
void Singleton::f4();{
        return WiresharkPreference::editor(parent, option, index);
    }
REGISTER_PREFERENCE_TYPE(PREF_BOOL, BoolPreference)
class StringPreference : public WiresharkPreference
public:
}
void Singleton::f5();{
    {
        if (prefsItem()->getPrefGUIType() == GUI_ALL || prefsItem()->getPrefGUIType() == GUI_QT) {
            UatDialog uat_dlg(parent, prefs_get_uat_value(prefsItem()->getPref()));
            uat_dlg.exec();
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
    EnumPreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget *parent, const QStyleOptionViewItem &/*option*/, const QModelIndex &/*index*/)
}
void Singleton::f2();{
public:
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
}
void Singleton::f3();{
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
}
void Singleton::f4();{
        return WiresharkPreference::editor(parent, option, index);
    }
REGISTER_PREFERENCE_TYPE(PREF_BOOL, BoolPreference)
class StringPreference : public WiresharkPreference
public:
}
void Singleton::f5();{
    {
        if (prefsItem()->getPrefGUIType() == GUI_ALL || prefsItem()->getPrefGUIType() == GUI_QT) {
            UatDialog uat_dlg(parent, prefs_get_uat_value(prefsItem()->getPref()));
            uat_dlg.exec();
        }
}
void Singleton::f6();{
        color_dlg->show();
        return color_dlg;
    }
    virtual void setData(QWidget *editor, const QModelIndex &index)
    {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
    EnumPreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget *parent, const QStyleOptionViewItem &/*option*/, const QModelIndex &/*index*/)
}
void Singleton::f2();{
public:
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
}
void Singleton::f3();{
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
}
void Singleton::f4();{
        return WiresharkPreference::editor(parent, option, index);
    }
REGISTER_PREFERENCE_TYPE(PREF_BOOL, BoolPreference)
class StringPreference : public WiresharkPreference
public:
}
void Singleton::f5();{
    {
        if (prefsItem()->getPrefGUIType() == GUI_ALL || prefsItem()->getPrefGUIType() == GUI_QT) {
            UatDialog uat_dlg(parent, prefs_get_uat_value(prefsItem()->getPref()));
            uat_dlg.exec();
        }
}
void Singleton::f6();{
        color_dlg->show();
        return color_dlg;
    }
    virtual void setData(QWidget *editor, const QModelIndex &index)
    {
}
void Singleton::f7();{
            UatDialog uat_dlg(parent, prefs_get_uat_value(prefsItem()->getPref()));
            uat_dlg.exec();
        }
        return WiresharkPreference::editor(parent, option, index);
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
    EnumPreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget *parent, const QStyleOptionViewItem &/*option*/, const QModelIndex &/*index*/)
}
void Singleton::f2();{
public:
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
}
void Singleton::f3();{
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
}
void Singleton::f4();{
        return WiresharkPreference::editor(parent, option, index);
    }
REGISTER_PREFERENCE_TYPE(PREF_BOOL, BoolPreference)
class StringPreference : public WiresharkPreference
public:
}
void Singleton::f5();{
    {
        if (prefsItem()->getPrefGUIType() == GUI_ALL || prefsItem()->getPrefGUIType() == GUI_QT) {
            UatDialog uat_dlg(parent, prefs_get_uat_value(prefsItem()->getPref()));
            uat_dlg.exec();
        }
}
void Singleton::f6();{
        color_dlg->show();
        return color_dlg;
    }
    virtual void setData(QWidget *editor, const QModelIndex &index)
    {
}
void Singleton::f7();{
            UatDialog uat_dlg(parent, prefs_get_uat_value(prefsItem()->getPref()));
            uat_dlg.exec();
        }
        return WiresharkPreference::editor(parent, option, index);
    }
}
void Singleton::f8();{
            if (prefs_get_enum_value(pref->getPref(), pref_stashed) == ev->value)
                combo->setCurrentIndex(combo->count() - 1);
        }
    }
    virtual void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
    EnumPreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget *parent, const QStyleOptionViewItem &/*option*/, const QModelIndex &/*index*/)
}
void Singleton::f2();{
public:
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
}
void Singleton::f3();{
    UIntPreference(QObject * parent = Q_NULLPTR) : StringPreference(parent) {}
REGISTER_PREFERENCE_TYPE(PREF_UINT, UIntPreference)
REGISTER_PREFERENCE_TYPE(PREF_DECODE_AS_UINT, UIntPreference)
class EnumPreference : public WiresharkPreference
public:
}
void Singleton::f4();{
        return WiresharkPreference::editor(parent, option, index);
    }
REGISTER_PREFERENCE_TYPE(PREF_BOOL, BoolPreference)
class StringPreference : public WiresharkPreference
public:
}
void Singleton::f5();{
    {
        if (prefsItem()->getPrefGUIType() == GUI_ALL || prefsItem()->getPrefGUIType() == GUI_QT) {
            UatDialog uat_dlg(parent, prefs_get_uat_value(prefsItem()->getPref()));
            uat_dlg.exec();
        }
}
void Singleton::f6();{
        color_dlg->show();
        return color_dlg;
    }
    virtual void setData(QWidget *editor, const QModelIndex &index)
    {
}
void Singleton::f7();{
            UatDialog uat_dlg(parent, prefs_get_uat_value(prefsItem()->getPref()));
            uat_dlg.exec();
        }
        return WiresharkPreference::editor(parent, option, index);
    }
}
void Singleton::f8();{
            if (prefs_get_enum_value(pref->getPref(), pref_stashed) == ev->value)
                combo->setCurrentIndex(combo->count() - 1);
        }
    }
    virtual void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index)
}
void Singleton::f9();{
public:
    OpenFilePreference(QObject * parent = Q_NULLPTR) : WiresharkPreference(parent) {}
    virtual QWidget * editor(QWidget * parent, const QStyleOptionViewItem &option, const QModelIndex &index)
    {
        QString filename = WiresharkFileDialog::getOpenFileName(parent, wsApp->windowTitleString(prefs_get_title(prefsItem()->getPref())),
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}
void Singleton::f2();{
                                    file.write(buf, err);
                                file.close();
                            }
                            unzCloseCurrentFile(uf);
                            free(buf);
}
void Singleton::f3();{
            if (err!=UNZ_OK)
            {
                break;
            }
        }
}
void Singleton::f4();{
            if (fileInZip.length() == 0 || (fileCheck && ! fileCheck(fileInZip, fileSize)) )
                continue;
            if (di.exists())
            {
                /* This is an additional fix for bug 16608, in which exports did contain the full path they
}
void Singleton::f5();{
                        }
                    }
                }
            }
        }
}
void Singleton::f6();{
    memset(&zi, 0, sizeof(zi));
    QDateTime fTime = fi.lastModified();
    zi.dosDate = qDateToDosDate(fTime);
    QFile fh(filepath);
    /* Checks if a large file block has to be written */
}
void Singleton::f7();{
    if (fh.open(QIODevice::ReadOnly))
    {
        char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
        while (! fh.atEnd() && err == ZIP_OK)
        {
}
void Singleton::f8();{
                                      Q_NULLPTR, 0, Q_NULLPTR, 0);
        if (err == UNZ_OK)
        {
            QString fileInZip(filename_inzip);
            int fileSize = static_cast<int>(file_info.uncompressed_size);
}
void Singleton::f9();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}
void Singleton::f10();{
                        }
                        cleanPaths.insert(dirPath, tempPath);
                    }
                    dirPath = cleanPaths[dirPath];
                    if (dirPath.length() == 0)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}
void Singleton::f2();{
                                    file.write(buf, err);
                                file.close();
                            }
                            unzCloseCurrentFile(uf);
                            free(buf);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}
void Singleton::f2();{
                                    file.write(buf, err);
                                file.close();
                            }
                            unzCloseCurrentFile(uf);
                            free(buf);
}
void Singleton::f3();{
            if (err!=UNZ_OK)
            {
                break;
            }
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}
void Singleton::f2();{
                                    file.write(buf, err);
                                file.close();
                            }
                            unzCloseCurrentFile(uf);
                            free(buf);
}
void Singleton::f3();{
            if (err!=UNZ_OK)
            {
                break;
            }
        }
}
void Singleton::f4();{
            if (fileInZip.length() == 0 || (fileCheck && ! fileCheck(fileInZip, fileSize)) )
                continue;
            if (di.exists())
            {
                /* This is an additional fix for bug 16608, in which exports did contain the full path they
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}
void Singleton::f2();{
                                    file.write(buf, err);
                                file.close();
                            }
                            unzCloseCurrentFile(uf);
                            free(buf);
}
void Singleton::f3();{
            if (err!=UNZ_OK)
            {
                break;
            }
        }
}
void Singleton::f4();{
            if (fileInZip.length() == 0 || (fileCheck && ! fileCheck(fileInZip, fileSize)) )
                continue;
            if (di.exists())
            {
                /* This is an additional fix for bug 16608, in which exports did contain the full path they
}
void Singleton::f5();{
                        }
                    }
                }
            }
        }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}
void Singleton::f2();{
                                    file.write(buf, err);
                                file.close();
                            }
                            unzCloseCurrentFile(uf);
                            free(buf);
}
void Singleton::f3();{
            if (err!=UNZ_OK)
            {
                break;
            }
        }
}
void Singleton::f4();{
            if (fileInZip.length() == 0 || (fileCheck && ! fileCheck(fileInZip, fileSize)) )
                continue;
            if (di.exists())
            {
                /* This is an additional fix for bug 16608, in which exports did contain the full path they
}
void Singleton::f5();{
                        }
                    }
                }
            }
        }
}
void Singleton::f6();{
    memset(&zi, 0, sizeof(zi));
    QDateTime fTime = fi.lastModified();
    zi.dosDate = qDateToDosDate(fTime);
    QFile fh(filepath);
    /* Checks if a large file block has to be written */
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}
void Singleton::f2();{
                                    file.write(buf, err);
                                file.close();
                            }
                            unzCloseCurrentFile(uf);
                            free(buf);
}
void Singleton::f3();{
            if (err!=UNZ_OK)
            {
                break;
            }
        }
}
void Singleton::f4();{
            if (fileInZip.length() == 0 || (fileCheck && ! fileCheck(fileInZip, fileSize)) )
                continue;
            if (di.exists())
            {
                /* This is an additional fix for bug 16608, in which exports did contain the full path they
}
void Singleton::f5();{
                        }
                    }
                }
            }
        }
}
void Singleton::f6();{
    memset(&zi, 0, sizeof(zi));
    QDateTime fTime = fi.lastModified();
    zi.dosDate = qDateToDosDate(fTime);
    QFile fh(filepath);
    /* Checks if a large file block has to be written */
}
void Singleton::f7();{
    if (fh.open(QIODevice::ReadOnly))
    {
        char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
        while (! fh.atEnd() && err == ZIP_OK)
        {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}
void Singleton::f2();{
                                    file.write(buf, err);
                                file.close();
                            }
                            unzCloseCurrentFile(uf);
                            free(buf);
}
void Singleton::f3();{
            if (err!=UNZ_OK)
            {
                break;
            }
        }
}
void Singleton::f4();{
            if (fileInZip.length() == 0 || (fileCheck && ! fileCheck(fileInZip, fileSize)) )
                continue;
            if (di.exists())
            {
                /* This is an additional fix for bug 16608, in which exports did contain the full path they
}
void Singleton::f5();{
                        }
                    }
                }
            }
        }
}
void Singleton::f6();{
    memset(&zi, 0, sizeof(zi));
    QDateTime fTime = fi.lastModified();
    zi.dosDate = qDateToDosDate(fTime);
    QFile fh(filepath);
    /* Checks if a large file block has to be written */
}
void Singleton::f7();{
    if (fh.open(QIODevice::ReadOnly))
    {
        char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
        while (! fh.atEnd() && err == ZIP_OK)
        {
}
void Singleton::f8();{
                                      Q_NULLPTR, 0, Q_NULLPTR, 0);
        if (err == UNZ_OK)
        {
            QString fileInZip(filename_inzip);
            int fileSize = static_cast<int>(file_info.uncompressed_size);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}
void Singleton::f2();{
                                    file.write(buf, err);
                                file.close();
                            }
                            unzCloseCurrentFile(uf);
                            free(buf);
}
void Singleton::f3();{
            if (err!=UNZ_OK)
            {
                break;
            }
        }
}
void Singleton::f4();{
            if (fileInZip.length() == 0 || (fileCheck && ! fileCheck(fileInZip, fileSize)) )
                continue;
            if (di.exists())
            {
                /* This is an additional fix for bug 16608, in which exports did contain the full path they
}
void Singleton::f5();{
                        }
                    }
                }
            }
        }
}
void Singleton::f6();{
    memset(&zi, 0, sizeof(zi));
    QDateTime fTime = fi.lastModified();
    zi.dosDate = qDateToDosDate(fTime);
    QFile fh(filepath);
    /* Checks if a large file block has to be written */
}
void Singleton::f7();{
    if (fh.open(QIODevice::ReadOnly))
    {
        char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
        while (! fh.atEnd() && err == ZIP_OK)
        {
}
void Singleton::f8();{
                                      Q_NULLPTR, 0, Q_NULLPTR, 0);
        if (err == UNZ_OK)
        {
            QString fileInZip(filename_inzip);
            int fileSize = static_cast<int>(file_info.uncompressed_size);
}
void Singleton::f9();{
                        err = unzOpenCurrentFile(uf);
                        if (err == UNZ_OK)
                        {
                            char * buf = static_cast<char *>(malloc(IO_BUF_SIZE));
                            if (file.open(QIODevice::WriteOnly))
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
        case MGT_PROBE_RESP:
            probe_resp_++;
            break;
        case MGT_BEACON:
            // Skip
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
        case MGT_PROBE_RESP:
            probe_resp_++;
            break;
        case MGT_BEACON:
            // Skip
}
void Singleton::f2();{
        WlanStationTreeWidgetItem* sender_ws_ti = NULL;
        WlanStationTreeWidgetItem* receiver_ws_ti = NULL;
        foreach (QTreeWidgetItem *cur_ti, stations_) {
            WlanStationTreeWidgetItem *cur_ws_ti = dynamic_cast<WlanStationTreeWidgetItem *>(cur_ti);
            if (cur_ws_ti && (cur_ws_ti->isMatch(&wlan_hdr->src))) sender_ws_ti = cur_ws_ti;
}
void Singleton::f3();{
            return deauth_ < other_row->deauth_;
        case col_others_:
            return other_ < other_row->other_;
        case col_protection_:
        default:
}
void Singleton::f4();{
                << text(col_protection_);
    }
    const QString filterExpression() {
        QString filter_expr = QString("(wlan.bssid==%1")
                .arg(address_to_qstring(&bssid_));
}
void Singleton::f5();{
    statsTreeWidget()->setItemDelegateForColumn(col_pct_retry_, retry_delegate_);
    statsTreeWidget()->sortByColumn(col_bssid_, Qt::AscendingOrder);
    // resizeColumnToContents doesn't work well here, so set sizes manually.
    int one_em = fontMetrics().height();
    for (int col = 0; col < statsTreeWidget()->columnCount() - 1; col++) {
}
void Singleton::f6();{
        QString filter_expr = QString("wlan.addr==%1")
                .arg(address_to_qstring(&addr_));
        return filter_expr;
    }
private:
}
void Singleton::f7();{
            gchar* str;
            ssid_ = QByteArray::fromRawData((const char *)wlan_hdr->stats.ssid, wlan_hdr->stats.ssid_len);
            str = format_text(NULL, wlan_hdr->stats.ssid, wlan_hdr->stats.ssid_len);
            setText(col_ssid_, str);
            wmem_free(NULL, str);
}
void Singleton::f8();{
                             tapPacket,
                             tapDraw)) {
        reject();
        return;
    }
}
void Singleton::f9();{
static const QString node_col_0_title_ = QObject::tr("Address");
static const QString node_col_4_title_ = QObject::tr("Pkts Sent");
static const QString node_col_5_title_ = QObject::tr("Pkts Received");
static const QString node_col_11_title_ = QObject::tr("Comment");
WlanStatisticsDialog::WlanStatisticsDialog(QWidget &parent, CaptureFile &cf, const char *filter) :
}
void Singleton::f10();{
        statsTreeWidget()->headerItem()->setText(col_protection_, network_col_13_title_);
    }
void WlanStatisticsDialog::captureFileClosing()
    remove_tap_listener(this);
    updateWidgets();
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
        case MGT_PROBE_RESP:
            probe_resp_++;
            break;
        case MGT_BEACON:
            // Skip
}
void Singleton::f2();{
        WlanStationTreeWidgetItem* sender_ws_ti = NULL;
        WlanStationTreeWidgetItem* receiver_ws_ti = NULL;
        foreach (QTreeWidgetItem *cur_ti, stations_) {
            WlanStationTreeWidgetItem *cur_ws_ti = dynamic_cast<WlanStationTreeWidgetItem *>(cur_ti);
            if (cur_ws_ti && (cur_ws_ti->isMatch(&wlan_hdr->src))) sender_ws_ti = cur_ws_ti;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
        case MGT_PROBE_RESP:
            probe_resp_++;
            break;
        case MGT_BEACON:
            // Skip
}
void Singleton::f2();{
        WlanStationTreeWidgetItem* sender_ws_ti = NULL;
        WlanStationTreeWidgetItem* receiver_ws_ti = NULL;
        foreach (QTreeWidgetItem *cur_ti, stations_) {
            WlanStationTreeWidgetItem *cur_ws_ti = dynamic_cast<WlanStationTreeWidgetItem *>(cur_ti);
            if (cur_ws_ti && (cur_ws_ti->isMatch(&wlan_hdr->src))) sender_ws_ti = cur_ws_ti;
}
void Singleton::f3();{
            return deauth_ < other_row->deauth_;
        case col_others_:
            return other_ < other_row->other_;
        case col_protection_:
        default:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
        case MGT_PROBE_RESP:
            probe_resp_++;
            break;
        case MGT_BEACON:
            // Skip
}
void Singleton::f2();{
        WlanStationTreeWidgetItem* sender_ws_ti = NULL;
        WlanStationTreeWidgetItem* receiver_ws_ti = NULL;
        foreach (QTreeWidgetItem *cur_ti, stations_) {
            WlanStationTreeWidgetItem *cur_ws_ti = dynamic_cast<WlanStationTreeWidgetItem *>(cur_ti);
            if (cur_ws_ti && (cur_ws_ti->isMatch(&wlan_hdr->src))) sender_ws_ti = cur_ws_ti;
}
void Singleton::f3();{
            return deauth_ < other_row->deauth_;
        case col_others_:
            return other_ < other_row->other_;
        case col_protection_:
        default:
}
void Singleton::f4();{
                << text(col_protection_);
    }
    const QString filterExpression() {
        QString filter_expr = QString("(wlan.bssid==%1")
                .arg(address_to_qstring(&bssid_));
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
        case MGT_PROBE_RESP:
            probe_resp_++;
            break;
        case MGT_BEACON:
            // Skip
}
void Singleton::f2();{
        WlanStationTreeWidgetItem* sender_ws_ti = NULL;
        WlanStationTreeWidgetItem* receiver_ws_ti = NULL;
        foreach (QTreeWidgetItem *cur_ti, stations_) {
            WlanStationTreeWidgetItem *cur_ws_ti = dynamic_cast<WlanStationTreeWidgetItem *>(cur_ti);
            if (cur_ws_ti && (cur_ws_ti->isMatch(&wlan_hdr->src))) sender_ws_ti = cur_ws_ti;
}
void Singleton::f3();{
            return deauth_ < other_row->deauth_;
        case col_others_:
            return other_ < other_row->other_;
        case col_protection_:
        default:
}
void Singleton::f4();{
                << text(col_protection_);
    }
    const QString filterExpression() {
        QString filter_expr = QString("(wlan.bssid==%1")
                .arg(address_to_qstring(&bssid_));
}
void Singleton::f5();{
    statsTreeWidget()->setItemDelegateForColumn(col_pct_retry_, retry_delegate_);
    statsTreeWidget()->sortByColumn(col_bssid_, Qt::AscendingOrder);
    // resizeColumnToContents doesn't work well here, so set sizes manually.
    int one_em = fontMetrics().height();
    for (int col = 0; col < statsTreeWidget()->columnCount() - 1; col++) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
        case MGT_PROBE_RESP:
            probe_resp_++;
            break;
        case MGT_BEACON:
            // Skip
}
void Singleton::f2();{
        WlanStationTreeWidgetItem* sender_ws_ti = NULL;
        WlanStationTreeWidgetItem* receiver_ws_ti = NULL;
        foreach (QTreeWidgetItem *cur_ti, stations_) {
            WlanStationTreeWidgetItem *cur_ws_ti = dynamic_cast<WlanStationTreeWidgetItem *>(cur_ti);
            if (cur_ws_ti && (cur_ws_ti->isMatch(&wlan_hdr->src))) sender_ws_ti = cur_ws_ti;
}
void Singleton::f3();{
            return deauth_ < other_row->deauth_;
        case col_others_:
            return other_ < other_row->other_;
        case col_protection_:
        default:
}
void Singleton::f4();{
                << text(col_protection_);
    }
    const QString filterExpression() {
        QString filter_expr = QString("(wlan.bssid==%1")
                .arg(address_to_qstring(&bssid_));
}
void Singleton::f5();{
    statsTreeWidget()->setItemDelegateForColumn(col_pct_retry_, retry_delegate_);
    statsTreeWidget()->sortByColumn(col_bssid_, Qt::AscendingOrder);
    // resizeColumnToContents doesn't work well here, so set sizes manually.
    int one_em = fontMetrics().height();
    for (int col = 0; col < statsTreeWidget()->columnCount() - 1; col++) {
}
void Singleton::f6();{
        QString filter_expr = QString("wlan.addr==%1")
                .arg(address_to_qstring(&addr_));
        return filter_expr;
    }
private:
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
        case MGT_PROBE_RESP:
            probe_resp_++;
            break;
        case MGT_BEACON:
            // Skip
}
void Singleton::f2();{
        WlanStationTreeWidgetItem* sender_ws_ti = NULL;
        WlanStationTreeWidgetItem* receiver_ws_ti = NULL;
        foreach (QTreeWidgetItem *cur_ti, stations_) {
            WlanStationTreeWidgetItem *cur_ws_ti = dynamic_cast<WlanStationTreeWidgetItem *>(cur_ti);
            if (cur_ws_ti && (cur_ws_ti->isMatch(&wlan_hdr->src))) sender_ws_ti = cur_ws_ti;
}
void Singleton::f3();{
            return deauth_ < other_row->deauth_;
        case col_others_:
            return other_ < other_row->other_;
        case col_protection_:
        default:
}
void Singleton::f4();{
                << text(col_protection_);
    }
    const QString filterExpression() {
        QString filter_expr = QString("(wlan.bssid==%1")
                .arg(address_to_qstring(&bssid_));
}
void Singleton::f5();{
    statsTreeWidget()->setItemDelegateForColumn(col_pct_retry_, retry_delegate_);
    statsTreeWidget()->sortByColumn(col_bssid_, Qt::AscendingOrder);
    // resizeColumnToContents doesn't work well here, so set sizes manually.
    int one_em = fontMetrics().height();
    for (int col = 0; col < statsTreeWidget()->columnCount() - 1; col++) {
}
void Singleton::f6();{
        QString filter_expr = QString("wlan.addr==%1")
                .arg(address_to_qstring(&addr_));
        return filter_expr;
    }
private:
}
void Singleton::f7();{
            gchar* str;
            ssid_ = QByteArray::fromRawData((const char *)wlan_hdr->stats.ssid, wlan_hdr->stats.ssid_len);
            str = format_text(NULL, wlan_hdr->stats.ssid, wlan_hdr->stats.ssid_len);
            setText(col_ssid_, str);
            wmem_free(NULL, str);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
        case MGT_PROBE_RESP:
            probe_resp_++;
            break;
        case MGT_BEACON:
            // Skip
}
void Singleton::f2();{
        WlanStationTreeWidgetItem* sender_ws_ti = NULL;
        WlanStationTreeWidgetItem* receiver_ws_ti = NULL;
        foreach (QTreeWidgetItem *cur_ti, stations_) {
            WlanStationTreeWidgetItem *cur_ws_ti = dynamic_cast<WlanStationTreeWidgetItem *>(cur_ti);
            if (cur_ws_ti && (cur_ws_ti->isMatch(&wlan_hdr->src))) sender_ws_ti = cur_ws_ti;
}
void Singleton::f3();{
            return deauth_ < other_row->deauth_;
        case col_others_:
            return other_ < other_row->other_;
        case col_protection_:
        default:
}
void Singleton::f4();{
                << text(col_protection_);
    }
    const QString filterExpression() {
        QString filter_expr = QString("(wlan.bssid==%1")
                .arg(address_to_qstring(&bssid_));
}
void Singleton::f5();{
    statsTreeWidget()->setItemDelegateForColumn(col_pct_retry_, retry_delegate_);
    statsTreeWidget()->sortByColumn(col_bssid_, Qt::AscendingOrder);
    // resizeColumnToContents doesn't work well here, so set sizes manually.
    int one_em = fontMetrics().height();
    for (int col = 0; col < statsTreeWidget()->columnCount() - 1; col++) {
}
void Singleton::f6();{
        QString filter_expr = QString("wlan.addr==%1")
                .arg(address_to_qstring(&addr_));
        return filter_expr;
    }
private:
}
void Singleton::f7();{
            gchar* str;
            ssid_ = QByteArray::fromRawData((const char *)wlan_hdr->stats.ssid, wlan_hdr->stats.ssid_len);
            str = format_text(NULL, wlan_hdr->stats.ssid, wlan_hdr->stats.ssid_len);
            setText(col_ssid_, str);
            wmem_free(NULL, str);
}
void Singleton::f8();{
                             tapPacket,
                             tapDraw)) {
        reject();
        return;
    }
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
        case MGT_PROBE_RESP:
            probe_resp_++;
            break;
        case MGT_BEACON:
            // Skip
}
void Singleton::f2();{
        WlanStationTreeWidgetItem* sender_ws_ti = NULL;
        WlanStationTreeWidgetItem* receiver_ws_ti = NULL;
        foreach (QTreeWidgetItem *cur_ti, stations_) {
            WlanStationTreeWidgetItem *cur_ws_ti = dynamic_cast<WlanStationTreeWidgetItem *>(cur_ti);
            if (cur_ws_ti && (cur_ws_ti->isMatch(&wlan_hdr->src))) sender_ws_ti = cur_ws_ti;
}
void Singleton::f3();{
            return deauth_ < other_row->deauth_;
        case col_others_:
            return other_ < other_row->other_;
        case col_protection_:
        default:
}
void Singleton::f4();{
                << text(col_protection_);
    }
    const QString filterExpression() {
        QString filter_expr = QString("(wlan.bssid==%1")
                .arg(address_to_qstring(&bssid_));
}
void Singleton::f5();{
    statsTreeWidget()->setItemDelegateForColumn(col_pct_retry_, retry_delegate_);
    statsTreeWidget()->sortByColumn(col_bssid_, Qt::AscendingOrder);
    // resizeColumnToContents doesn't work well here, so set sizes manually.
    int one_em = fontMetrics().height();
    for (int col = 0; col < statsTreeWidget()->columnCount() - 1; col++) {
}
void Singleton::f6();{
        QString filter_expr = QString("wlan.addr==%1")
                .arg(address_to_qstring(&addr_));
        return filter_expr;
    }
private:
}
void Singleton::f7();{
            gchar* str;
            ssid_ = QByteArray::fromRawData((const char *)wlan_hdr->stats.ssid, wlan_hdr->stats.ssid_len);
            str = format_text(NULL, wlan_hdr->stats.ssid, wlan_hdr->stats.ssid_len);
            setText(col_ssid_, str);
            wmem_free(NULL, str);
}
void Singleton::f8();{
                             tapPacket,
                             tapDraw)) {
        reject();
        return;
    }
}
void Singleton::f9();{
static const QString node_col_0_title_ = QObject::tr("Address");
static const QString node_col_4_title_ = QObject::tr("Pkts Sent");
static const QString node_col_5_title_ = QObject::tr("Pkts Received");
static const QString node_col_11_title_ = QObject::tr("Comment");
WlanStatisticsDialog::WlanStatisticsDialog(QWidget &parent, CaptureFile &cf, const char *filter) :
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();

};

void Singleton::f1();{
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();
	void Singleton::f10();

};

void Singleton::f1();{
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
}
void Singleton::f2();{
	int depth;
	exception_t(int depth) : depth(depth) { }
/* Functions are called via pointers to prevent inlining */
static void (*p_test_exception_throw)(int depth);
static PyObject* (*p_test_exception_switch_recurse)(int depth, int left);
}
void Singleton::f3();{
static PyObject *
test_exception_switch(PyObject *self, PyObject *args)
	int depth;
	if (!PyArg_ParseTuple(args, "i", &depth))
		return NULL;
}
void Singleton::f4();{
 * - recurses depth times
 * - switches to parent inside try/catch block
 * - throws an exception that (expected to be caught in the same function)
 * - verifies depth matches (exceptions shouldn't be caught in other greenlets)
static PyObject *
}
void Singleton::f5();{
	Py_DECREF(self);
	return result;
/* test_exception_switch(int depth)
 * - recurses depth times
 * - switches to parent inside try/catch block
}
void Singleton::f6();{
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
		p_test_exception_throw(depth);
		PyErr_SetString(PyExc_RuntimeError, "throwing C++ exception didn't work");
	} catch(exception_t& e) {
}
void Singleton::f7();{
	PyObject* result = NULL;
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
}
void Singleton::f8();{
	if (left > 0) {
		return p_test_exception_switch_recurse(depth, left - 1);
	PyObject* result = NULL;
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
}
void Singleton::f9();{
PyMODINIT_FUNC
PyInit__test_extension_cpp(void)
PyMODINIT_FUNC
init_test_extension_cpp(void)
	PyObject *module = NULL;
}
void Singleton::f10();{
	exception_t(int depth) : depth(depth) { }
/* Functions are called via pointers to prevent inlining */
static void (*p_test_exception_throw)(int depth);
static PyObject* (*p_test_exception_switch_recurse)(int depth, int left);
static void test_exception_throw(int depth)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();

};

void Singleton::f1();{
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
}
void Singleton::f2();{
	int depth;
	exception_t(int depth) : depth(depth) { }
/* Functions are called via pointers to prevent inlining */
static void (*p_test_exception_throw)(int depth);
static PyObject* (*p_test_exception_switch_recurse)(int depth, int left);
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();

};

void Singleton::f1();{
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
}
void Singleton::f2();{
	int depth;
	exception_t(int depth) : depth(depth) { }
/* Functions are called via pointers to prevent inlining */
static void (*p_test_exception_throw)(int depth);
static PyObject* (*p_test_exception_switch_recurse)(int depth, int left);
}
void Singleton::f3();{
static PyObject *
test_exception_switch(PyObject *self, PyObject *args)
	int depth;
	if (!PyArg_ParseTuple(args, "i", &depth))
		return NULL;
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();

};

void Singleton::f1();{
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
}
void Singleton::f2();{
	int depth;
	exception_t(int depth) : depth(depth) { }
/* Functions are called via pointers to prevent inlining */
static void (*p_test_exception_throw)(int depth);
static PyObject* (*p_test_exception_switch_recurse)(int depth, int left);
}
void Singleton::f3();{
static PyObject *
test_exception_switch(PyObject *self, PyObject *args)
	int depth;
	if (!PyArg_ParseTuple(args, "i", &depth))
		return NULL;
}
void Singleton::f4();{
 * - recurses depth times
 * - switches to parent inside try/catch block
 * - throws an exception that (expected to be caught in the same function)
 * - verifies depth matches (exceptions shouldn't be caught in other greenlets)
static PyObject *
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();

};

void Singleton::f1();{
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
}
void Singleton::f2();{
	int depth;
	exception_t(int depth) : depth(depth) { }
/* Functions are called via pointers to prevent inlining */
static void (*p_test_exception_throw)(int depth);
static PyObject* (*p_test_exception_switch_recurse)(int depth, int left);
}
void Singleton::f3();{
static PyObject *
test_exception_switch(PyObject *self, PyObject *args)
	int depth;
	if (!PyArg_ParseTuple(args, "i", &depth))
		return NULL;
}
void Singleton::f4();{
 * - recurses depth times
 * - switches to parent inside try/catch block
 * - throws an exception that (expected to be caught in the same function)
 * - verifies depth matches (exceptions shouldn't be caught in other greenlets)
static PyObject *
}
void Singleton::f5();{
	Py_DECREF(self);
	return result;
/* test_exception_switch(int depth)
 * - recurses depth times
 * - switches to parent inside try/catch block
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();

};

void Singleton::f1();{
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
}
void Singleton::f2();{
	int depth;
	exception_t(int depth) : depth(depth) { }
/* Functions are called via pointers to prevent inlining */
static void (*p_test_exception_throw)(int depth);
static PyObject* (*p_test_exception_switch_recurse)(int depth, int left);
}
void Singleton::f3();{
static PyObject *
test_exception_switch(PyObject *self, PyObject *args)
	int depth;
	if (!PyArg_ParseTuple(args, "i", &depth))
		return NULL;
}
void Singleton::f4();{
 * - recurses depth times
 * - switches to parent inside try/catch block
 * - throws an exception that (expected to be caught in the same function)
 * - verifies depth matches (exceptions shouldn't be caught in other greenlets)
static PyObject *
}
void Singleton::f5();{
	Py_DECREF(self);
	return result;
/* test_exception_switch(int depth)
 * - recurses depth times
 * - switches to parent inside try/catch block
}
void Singleton::f6();{
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
		p_test_exception_throw(depth);
		PyErr_SetString(PyExc_RuntimeError, "throwing C++ exception didn't work");
	} catch(exception_t& e) {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();

};

void Singleton::f1();{
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
}
void Singleton::f2();{
	int depth;
	exception_t(int depth) : depth(depth) { }
/* Functions are called via pointers to prevent inlining */
static void (*p_test_exception_throw)(int depth);
static PyObject* (*p_test_exception_switch_recurse)(int depth, int left);
}
void Singleton::f3();{
static PyObject *
test_exception_switch(PyObject *self, PyObject *args)
	int depth;
	if (!PyArg_ParseTuple(args, "i", &depth))
		return NULL;
}
void Singleton::f4();{
 * - recurses depth times
 * - switches to parent inside try/catch block
 * - throws an exception that (expected to be caught in the same function)
 * - verifies depth matches (exceptions shouldn't be caught in other greenlets)
static PyObject *
}
void Singleton::f5();{
	Py_DECREF(self);
	return result;
/* test_exception_switch(int depth)
 * - recurses depth times
 * - switches to parent inside try/catch block
}
void Singleton::f6();{
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
		p_test_exception_throw(depth);
		PyErr_SetString(PyExc_RuntimeError, "throwing C++ exception didn't work");
	} catch(exception_t& e) {
}
void Singleton::f7();{
	PyObject* result = NULL;
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();

};

void Singleton::f1();{
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
}
void Singleton::f2();{
	int depth;
	exception_t(int depth) : depth(depth) { }
/* Functions are called via pointers to prevent inlining */
static void (*p_test_exception_throw)(int depth);
static PyObject* (*p_test_exception_switch_recurse)(int depth, int left);
}
void Singleton::f3();{
static PyObject *
test_exception_switch(PyObject *self, PyObject *args)
	int depth;
	if (!PyArg_ParseTuple(args, "i", &depth))
		return NULL;
}
void Singleton::f4();{
 * - recurses depth times
 * - switches to parent inside try/catch block
 * - throws an exception that (expected to be caught in the same function)
 * - verifies depth matches (exceptions shouldn't be caught in other greenlets)
static PyObject *
}
void Singleton::f5();{
	Py_DECREF(self);
	return result;
/* test_exception_switch(int depth)
 * - recurses depth times
 * - switches to parent inside try/catch block
}
void Singleton::f6();{
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
		p_test_exception_throw(depth);
		PyErr_SetString(PyExc_RuntimeError, "throwing C++ exception didn't work");
	} catch(exception_t& e) {
}
void Singleton::f7();{
	PyObject* result = NULL;
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
}
void Singleton::f8();{
	if (left > 0) {
		return p_test_exception_switch_recurse(depth, left - 1);
	PyObject* result = NULL;
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
}

class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
       
    // autogenerated signatures
	void Singleton::f1();
	void Singleton::f2();
	void Singleton::f3();
	void Singleton::f4();
	void Singleton::f5();
	void Singleton::f6();
	void Singleton::f7();
	void Singleton::f8();
	void Singleton::f9();

};

void Singleton::f1();{
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
}
void Singleton::f2();{
	int depth;
	exception_t(int depth) : depth(depth) { }
/* Functions are called via pointers to prevent inlining */
static void (*p_test_exception_throw)(int depth);
static PyObject* (*p_test_exception_switch_recurse)(int depth, int left);
}
void Singleton::f3();{
static PyObject *
test_exception_switch(PyObject *self, PyObject *args)
	int depth;
	if (!PyArg_ParseTuple(args, "i", &depth))
		return NULL;
}
void Singleton::f4();{
 * - recurses depth times
 * - switches to parent inside try/catch block
 * - throws an exception that (expected to be caught in the same function)
 * - verifies depth matches (exceptions shouldn't be caught in other greenlets)
static PyObject *
}
void Singleton::f5();{
	Py_DECREF(self);
	return result;
/* test_exception_switch(int depth)
 * - recurses depth times
 * - switches to parent inside try/catch block
}
void Singleton::f6();{
	try {
		PyGreenlet_Switch(self->parent, NULL, NULL);
		p_test_exception_throw(depth);
		PyErr_SetString(PyExc_RuntimeError, "throwing C++ exception didn't work");
	} catch(exception_t& e) {
}
void Singleton::f7();{
	PyObject* result = NULL;
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
		return NULL;
	try {
}
void Singleton::f8();{
	if (left > 0) {
		return p_test_exception_switch_recurse(depth, left - 1);
	PyObject* result = NULL;
	PyGreenlet* self = PyGreenlet_GetCurrent();
	if (self == NULL)
}
void Singleton::f9();{
PyMODINIT_FUNC
PyInit__test_extension_cpp(void)
PyMODINIT_FUNC
init_test_extension_cpp(void)
	PyObject *module = NULL;
}
